{
    "docs": [
        {
            "location": "/", 
            "text": "Ractive.js\n\n\nWelcome! These pages aim to provide all the information you need to master Ractive. Let's get started!\n\n\nDownload\n\n\nRactive is available via the following channels:\n\n\n// unpkg\nhttps://unpkg.com/ractive\n\n// CDNjs\nhttps://cdnjs.com/libraries/ractive\n\n// npm\nnpm install --save-dev ractive\n\n// Bower\nbower install --save ractive\n\n\n\n\nUsage\n\n\nUsing Ractive is very simple. Create a new instance using \nnew Ractive({...})\n with the desired options.\n\n\n\n\n\nvar ractive = Ractive({\n    el: 'body',\n    template: '\np\n{{greeting}}, {{recipient}}\n/p\n',\n    data: {\n        greeting: 'Hello',\n        recipient: 'World!'\n    }\n});\n\n\n\n\nWhile there are \nno required options\n, \nel\n, \ntemplate\n and \ndata\n are the most common. They specify \nwhat element\n to attach an instance with \nthis markup\n having \nthis data\n. Check out \nInitialization Options\n to learn more about the available options.\n\n\nIf you get stuck at any point, visit the \nGet Support\n page for places to find help.\n\n\n\n\nAbout Ractive.js\n\n\nRactive was originally created at \nThe Guardian (theguardian.com)\n to produce news applications. A typical news app is heavily interactive, combines HTML and SVG, and is developed under extreme deadline pressure. It has to work reliably across browsers, and perform well even on mobile devices.\n\n\nUnlike other frameworks, \nRactive works for you\n, not the other way around. It doesn't have an opinion about the other tools you want to use with it. It also adapts to the approach you want to take. This means you're not locked-in to a framework-specific way of thinking. Should you hate one of your tools for some reason, you can easily swap it out for another and move on with life.\n\n\nThis project is the brainchild of an Englishman and has contributors from all over the world. There is an ecclectic mix of primarily the Queen's English, a fair amount of 'Murican English, and a bit of others here and there. Things like \nadaptor\n, \nbehaviour\n, and \ndependant\n may have more than one spelling but we try to stick to the Queen's English to the extent that we are able.\n\n\nFun fact: Fun fact: The name is a reference to Neal Stephenson's \nThe Diamond Age: Or, A Young Lady's Illustrated Primer\n \u2013 a book about (among other things) the future of storytelling.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#ractivejs", 
            "text": "Welcome! These pages aim to provide all the information you need to master Ractive. Let's get started!", 
            "title": "Ractive.js"
        }, 
        {
            "location": "/#download", 
            "text": "Ractive is available via the following channels:  // unpkg\nhttps://unpkg.com/ractive\n\n// CDNjs\nhttps://cdnjs.com/libraries/ractive\n\n// npm\nnpm install --save-dev ractive\n\n// Bower\nbower install --save ractive", 
            "title": "Download"
        }, 
        {
            "location": "/#usage", 
            "text": "Using Ractive is very simple. Create a new instance using  new Ractive({...})  with the desired options.   var ractive = Ractive({\n    el: 'body',\n    template: ' p {{greeting}}, {{recipient}} /p ',\n    data: {\n        greeting: 'Hello',\n        recipient: 'World!'\n    }\n});  While there are  no required options ,  el ,  template  and  data  are the most common. They specify  what element  to attach an instance with  this markup  having  this data . Check out  Initialization Options  to learn more about the available options.  If you get stuck at any point, visit the  Get Support  page for places to find help.", 
            "title": "Usage"
        }, 
        {
            "location": "/#about-ractivejs", 
            "text": "Ractive was originally created at  The Guardian (theguardian.com)  to produce news applications. A typical news app is heavily interactive, combines HTML and SVG, and is developed under extreme deadline pressure. It has to work reliably across browsers, and perform well even on mobile devices.  Unlike other frameworks,  Ractive works for you , not the other way around. It doesn't have an opinion about the other tools you want to use with it. It also adapts to the approach you want to take. This means you're not locked-in to a framework-specific way of thinking. Should you hate one of your tools for some reason, you can easily swap it out for another and move on with life.  This project is the brainchild of an Englishman and has contributors from all over the world. There is an ecclectic mix of primarily the Queen's English, a fair amount of 'Murican English, and a bit of others here and there. Things like  adaptor ,  behaviour , and  dependant  may have more than one spelling but we try to stick to the Queen's English to the extent that we are able.  Fun fact: Fun fact: The name is a reference to Neal Stephenson's  The Diamond Age: Or, A Young Lady's Illustrated Primer  \u2013 a book about (among other things) the future of storytelling.", 
            "title": "About Ractive.js"
        }, 
        {
            "location": "/get-started/60-second-setup/", 
            "text": "60-second setup\n\n\nCreate a file called \nindex.html\n and paste in the following (or just open the playground):\n\n\n\n\n\n!doctype html\n\n\nhtml\n\n\nhead\n\n  \nmeta http-equiv=\nX-UA-Compatible\n content=\nIE=edge\n\n  \nmeta charset='utf-8'\n\n  \ntitle\nHello World\n/title\n\n\n  \n!-- The latest release of Ractive can always be found at https://unpkg.com/ractive --\n\n  \nscript src='https://unpkg.com/ractive'\n/script\n\n\n/head\n\n\nbody\n\n\n  \n!-- The element to mount the instance --\n\n  \ndiv id=\napp\n/div\n\n\n  \nscript\n\n\n    // A simple component definition, complete with markup, styles and data\n    Ractive.components.HelloWorld = Ractive.extend({\n      template: `\n        \ndiv\n\n          \nh1\nHello {{ message }}\n/h1\n\n          \ninput type=\ntext\n value=\n{{ message }}\n /\n\n        \n/div\n\n      `,\n      css: `\n        h1 { color: red }\n      `,\n      data: () =\n ({\n        message: 'World!'\n      })\n    });\n\n    // Mount an instance of the component to the container\n    const app = Ractive({ template: '\nHelloWorld/\n', el: '#app' });\n\n  \n/script\n\n\n/body\n\n\n/html\n\n\n\n\n\nNow, open the page in a browser. You should see a \"Hello World!\" greeting. Updating the input values should update the greeting. If you open the console and type \napp.set('message', 'Jim')\n, the text should update to \"Hello Jim\".\n\n\nThat's it - you're in business!\n\n\nNext steps\n\n\n\n\n\n\nAs your app grows, you'll want to separate each component definition into its own file.\n\n\n\n\n\n\nRactive has many ways to \nregister\n a component, as well as \ntools\n to allow you to write components depending on your setup.\n\n\n\n\n\n\nRactive also allows for \nsingle-file components\n where you define the markup, styles and logic for a single component in a single file.\n\n\n\n\n\n\nRactive \nworks for you\n, not the other way around. There are no set rules or conventions. Be creative.", 
            "title": "60-second Setup"
        }, 
        {
            "location": "/get-started/60-second-setup/#60-second-setup", 
            "text": "Create a file called  index.html  and paste in the following (or just open the playground):   !doctype html  html  head \n   meta http-equiv= X-UA-Compatible  content= IE=edge \n   meta charset='utf-8' \n   title Hello World /title \n\n   !-- The latest release of Ractive can always be found at https://unpkg.com/ractive -- \n   script src='https://unpkg.com/ractive' /script  /head  body \n\n   !-- The element to mount the instance -- \n   div id= app /div \n\n   script \n\n    // A simple component definition, complete with markup, styles and data\n    Ractive.components.HelloWorld = Ractive.extend({\n      template: `\n         div \n           h1 Hello {{ message }} /h1 \n           input type= text  value= {{ message }}  / \n         /div \n      `,\n      css: `\n        h1 { color: red }\n      `,\n      data: () =  ({\n        message: 'World!'\n      })\n    });\n\n    // Mount an instance of the component to the container\n    const app = Ractive({ template: ' HelloWorld/ ', el: '#app' });\n\n   /script  /body  /html   Now, open the page in a browser. You should see a \"Hello World!\" greeting. Updating the input values should update the greeting. If you open the console and type  app.set('message', 'Jim') , the text should update to \"Hello Jim\".  That's it - you're in business!", 
            "title": "60-second setup"
        }, 
        {
            "location": "/get-started/60-second-setup/#next-steps", 
            "text": "As your app grows, you'll want to separate each component definition into its own file.    Ractive has many ways to  register  a component, as well as  tools  to allow you to write components depending on your setup.    Ractive also allows for  single-file components  where you define the markup, styles and logic for a single component in a single file.    Ractive  works for you , not the other way around. There are no set rules or conventions. Be creative.", 
            "title": "Next steps"
        }, 
        {
            "location": "/get-started/tutorials/hello-world/", 
            "text": "Hello, world!\n\n\nWelcome to the Ractive.js tutorials. This is a set of interactive tutorials which you can take at your own pace. Each tutorial consists of a number of steps \u2013 first up is step 1 of the 'Hello world!' tutorial.\n\n\nAt any time you can start or reset a step by clicking its Start button.\n\n\nStep 1\n\n\n\n    \nStart\n\n\n\n\nTry creating a new Ractive by executing the JavaScript in the script tab of the playground by hitting the \n button on the top right-hand corner of the playground.\n\n\n\n\nIn later steps, if you can't get it to work (or if you're just lazy!) you can click the Fix Code button, if there is one available, next to the Start button to insert working code as though you'd followed the instructions exactly.\n\n\nThroughout the tutorials, boxes like this will contain technical notes and asides, for the particularly nerdy or curious.\n\n\n\n\nStep 2\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nThat's not very exciting. Let's make our template more templatey \u2013 replace the hard-coded text in the template with some variables:\n\n\np\n{{greeting}} {{name}}!\n/p\n\n\n\n\n\nThen, add some data to it, by adding a data initialisation option to our code on the script tab so that it looks like this:\n\n\nvar ractive = new Ractive({\n  el: output,\n  template: template,\n  data: { greeting: 'Hello', name: 'world' }\n});\n\n\n\n\nExecute the code (with the \n button). It should look exactly as it did before.\n\n\nStep 3\n\n\n\n  \nStart\n\n\n\n\nHere's where Ractive differs from other templating libraries. Normally, if you wanted to change the data, you would have to re-render the entire view, which would have the effect of discarding the DOM nodes you'd already created. That's wasteful.\n\n\nInstead, we can manipulate views we've already created. Try running this code - click on it and hit Shift-Space:\n\n\n\n\n\nractive.set('greeting', 'Bonjour');\n\n\n\n\nAnd now this:\n\n\n\n\n\nractive.set('name', 'tout le monde');\n\n\n\n\nOoh la la! Even better, we could set both properties in one go. Let's do it in Mandarin this time:\n\n\n\n\n\nractive.set({\n  greeting: '\u4f60\u597d',\n  name: '\u4e16\u754c'\n});\n\n\n\n\nWhat's happening here is that the contents of the \np\n element are split into four text nodes \u2013 one for \n{{greeting}}\n, one for the comma and space characters, one for \n{{name}}\n, and one for the \n!\n. Ractive stores references to the nodes that correspond to the variables, and updates them when the data changes, leaving everything else untouched.\n\n\nSurgically updating text nodes is much faster than replacing elements, particularly when you only need to change part of your ractive.\n\n\n\n\nNote that due to the way the tutorials interact with the playground, the eval blocks above are actually running after the entire example is reloaded in the output pane. That's why running the last eval before running the next to last eval doesn't leave the Mandarin greeting intact. Under normal circumstances, the entire example wouldn't need to be re-run, which \nwould\n leave the Mandarin greeting intact.", 
            "title": "Hello, world!"
        }, 
        {
            "location": "/get-started/tutorials/hello-world/#hello-world", 
            "text": "Welcome to the Ractive.js tutorials. This is a set of interactive tutorials which you can take at your own pace. Each tutorial consists of a number of steps \u2013 first up is step 1 of the 'Hello world!' tutorial.  At any time you can start or reset a step by clicking its Start button.", 
            "title": "Hello, world!"
        }, 
        {
            "location": "/get-started/tutorials/hello-world/#step-1", 
            "text": "Start   Try creating a new Ractive by executing the JavaScript in the script tab of the playground by hitting the   button on the top right-hand corner of the playground.   In later steps, if you can't get it to work (or if you're just lazy!) you can click the Fix Code button, if there is one available, next to the Start button to insert working code as though you'd followed the instructions exactly.  Throughout the tutorials, boxes like this will contain technical notes and asides, for the particularly nerdy or curious.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/hello-world/#step-2", 
            "text": "Start \n     Fix Code   That's not very exciting. Let's make our template more templatey \u2013 replace the hard-coded text in the template with some variables:  p {{greeting}} {{name}}! /p   Then, add some data to it, by adding a data initialisation option to our code on the script tab so that it looks like this:  var ractive = new Ractive({\n  el: output,\n  template: template,\n  data: { greeting: 'Hello', name: 'world' }\n});  Execute the code (with the   button). It should look exactly as it did before.", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/hello-world/#step-3", 
            "text": "Start   Here's where Ractive differs from other templating libraries. Normally, if you wanted to change the data, you would have to re-render the entire view, which would have the effect of discarding the DOM nodes you'd already created. That's wasteful.  Instead, we can manipulate views we've already created. Try running this code - click on it and hit Shift-Space:   ractive.set('greeting', 'Bonjour');  And now this:   ractive.set('name', 'tout le monde');  Ooh la la! Even better, we could set both properties in one go. Let's do it in Mandarin this time:   ractive.set({\n  greeting: '\u4f60\u597d',\n  name: '\u4e16\u754c'\n});  What's happening here is that the contents of the  p  element are split into four text nodes \u2013 one for  {{greeting}} , one for the comma and space characters, one for  {{name}} , and one for the  ! . Ractive stores references to the nodes that correspond to the variables, and updates them when the data changes, leaving everything else untouched.  Surgically updating text nodes is much faster than replacing elements, particularly when you only need to change part of your ractive.   Note that due to the way the tutorials interact with the playground, the eval blocks above are actually running after the entire example is reloaded in the output pane. That's why running the last eval before running the next to last eval doesn't leave the Mandarin greeting intact. Under normal circumstances, the entire example wouldn't need to be re-run, which  would  leave the Mandarin greeting intact.", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/", 
            "text": "References and Context\n\n\nJust about everything you can do with Ractive revolves around data, and each bit of data is accessible by a keypath. Each particular instance of a keypath in a template is called a reference, because it references the data that lives at that keypath. A keypath in Ractive is simply a \n.\n delimited set of keys that looks something like \nfoo.bar.baz\n, which when placed in a template mustache would be a reference to the value at the \nbaz\n key on the object at the \nbar\n key on the object at the \nfoo\n key on the data object passed to Ractive. The base key in that keypath is \nfoo\n.\n\n\nKeypaths in Ractive need not be absolute, and there are a few conveniences built in to make accessing data easier. Before we get into that though, it's important to understand the concepts of context in a Ractive template and how that can affect your references.\n\n\nContext\n\n\nA context in Ractive is simply the bit of data at the current place in the template. There are five ways to introduce a new context in a Ractive template:\n\n\n\n\nThe root context is the default context at which all templates start.\n\n\nAn iterative mustache will introduce a new context for each iteration.\n\n\nA \nwith\n mustache will introduce a new context with whatever is passed to it.\n\n\nThere's a special case of \nwith\n that covers passing a context to a partial.\n\n\nA plain block mustache will introduce a new context because it acts like either a conditional \nwith\n or an iterative block, depending on the what is passed to it.\n\n\nEvery component introduces its own root context.\n\n\n\n\nContexts tend to build linearly through a template, meaning that the first context in a template may be \nblog\n, and nested within the block that created that context may be another \nposts\n, making the full keypath for the inner context \nblog.posts\n. If \nblog.posts\n is an array that is passed to an iterative block, the body of the first iteration would have a context of \nblog.posts.0\n, the second \nblog.posts.1\n, and so on. Note though, that context is \nnot required\n to build linearly like that; it's just very common because it builds naturally alongside the data structure.\n\n\nIf this section is a little confusing, don't worry too much about it because all of these concepts are closely related and tend to make sense more as a whole than individual parts.\n\n\nSpecificity and Ambiguity\n\n\nA reference is ambiguous if it does not exist in the current context. Ractive will resolve ambiguous references by looking at each context up the stack from the current point in the template to the root. If no data matching the base key and no matching alias is found, then the current context will be used as the starting point for the reference. That means that with a context of \nblog.posts.0\n, referencing \nauthor.name\n that doesn't exist anywhere in the context hierarchy will end up with a resolved keypath of \nblog.posts.0.author.name\n. References only resolve once as the template is being rendered, which means that if data appears after a conditional has rendered and the conditional later unrenders and re-renders, then the new, more specific data will be resolved in the newly rendered conditional.\n\n\n{{#with blog.posts.0}}\n  Author: {{author.name}}\n{{/with}}\n\n\n\n\n\n\n\nvar app = new Ractive({\n  target: '#target',\n  template: '#template',\n  data: {\n    blog: {\n      posts: [ {} ]\n    }\n  }\n});\n\nsetTimeout(function() {\n  app.set('blog.posts.0.author.name', 'John Q. Resolver');\n}, 1000);\n\n\n\n\nAmbiguity in Ractive is generally discouraged, since it can lead to weird scenarios like that described above in the unrendering/re-rendering of a conditional section. It's also not as fast to search up the context hierarchy as it is to simply start with the current context, which is usually what you want anyway. To that end, there is a special reference \nthis\n, that refers to the current context at the current point in the template. \nthis\n is meant to mirror the JavaScript keyword of the same name and similar concept. There's also a shorthand for \nthis\n, \n.\n e.g. \n{{this}} is the same as {{.}}\n and \n{{this.name}} is the same as {{.name}}\n. Ambiguity does have its purposes, but generally, if you can, you should use specific references.\n\n\n{{#if show}}\n  {{#with blog}}\n    {{#with posts.0}}\n      \nh2\nAmbiguity may be good or bad, depending on what you're trying to do.\n/h2\n\n      \np\n{{.name}}\n/p\n\n      \np\n{{name}}\n/p\n\n    {{/with}}\n  {{/with}}\n{{/if}}\n\n\n\n\n\n\n\nvar app = new Ractive({\n  target: '#target',\n  template: '#template',\n  data: {\n    blog: {\n      posts: [ {} ],\n      name: 'Mah Blog'\n    },\n    show: true\n  }\n});\n\nsetTimeout(function() {\n  app.set('blog.posts.0.name', 'I am foo.bar.baz');\n\n  setTimeout(function() {\n    app.toggle('show');\n    app.toggle('show');\n  }, 1000);\n}, 1000);\n\n\n\n\nNavigating Contexts and Keypaths\n\n\nSometimes the data you're after may not exist in the current context or one of it's child keypaths. Ractive offers a few ways to navigate both contexts and keypaths.\n\n\nNavigating keypaths is very similar to naviagating a filesystem, both syntactically and conceptually. If your current context is \nuser.settings.display\n and you want to access \nuser.name\n, you can pop up the keypath using the \n../\n prefix e.g. \n../../name\n. Note that this \nonly\n traverses the current keypath and not the context stack, even though those turn out to be the same in many cases. If the context stack happens to contain disjointed keypaths e.g. \nuser.settings\n with a nested context of \nblog.posts\n (also on the root data object), then you would have to pop all the way to the root keypath to access a \nuser\n keypath. That's not a terrible imposition with a shallow data structure, but it can be painful if the current context is more than a few keys deep.\n\n\nTo address that, Ractive also supports a root keypath prefix, \n~/\n that is meant to mirror the \"home\" directory prefix available to POSIX environments. From the previous example, instead of using \n../../user\n from the \nblog.posts\n context, you could simply use \n~/user\n. The root prefix refers to the root of the data in the current Ractive instance, meaning that containing instances of a component are not directly accessible using \n~/\n.\n\n\nSome contexts are not directly addessable from outside of their context children, like expression contexts e.g. \n{{#with { answer: 42, list: [ 1, 2, 3 ] } }}{{#with ~/some.key}} there's no way to get back to the outer context using ../ or ~/ {{/with}}{{/with}}\n. If you're not sure what's happening with that outer context, don't worry because that's covered more elsewhere. To address situations like that, Ractive provides a context-popping prefix, \n^^/\n that is similar to the keypath-popping prefix. In the example, \n^^/answer\n would resolve to \n42\n from the inner context because \n^^/\n steps one step up the context hierarchy and gets the key \nanswer\n, which in this case happens to be on the inline object expression \n{ answer: 42, list: [ 1, 2, 3 ] }\n. Context popping is not something you need often, but it's the only way to work around some corner-case scenarios explicitly.\n\n\nNote that aside from \n~/\n, prefixed keypaths are not accessible from non-context API methods, like \napp.set('../answer', 42)\n because there's no way to determine to which keypath that should be relative. There are context helpers that make such relative keypaths available, but they're covered elsewhere.\n\n\nIterative Contexts\n\n\nIt's worth noting that iterative mustaches introduce an implicit context that is two levels deeper than the surrounding context, which can be a little confusing at first glance. For instance:\n\n\n{{#with user.blog}}\n  {{#each posts}}\n    {{../title}}\n  {{/each}}\n{{/with}}\n\n\n\n\nIn that example, you may expect \n../title\n in the each block body to resolve to \nuser.blog.title\n, but it doesn't. Instead, it resolves to \nuser.blog.posts.title\n because each iteration has two additional keys added e.g. \nuser.blog.posts.0\n to make the current item the context of the iteration body. Popping up the keypath once only removes the index key, leaving you at the list rather than the surrounding context. Note that this is actually quite useful for things like:\n\n\n\n\n\nul\n\n{{#each list}}\n  \nli\nItem {{@index + 1}} of {{../length}} is {{.}}\n/li\n\n{{/each}}\n\n/ul\n\n\n\n\n\nAliases\n\n\nIn addition to direct references, Ractive allows you to create template aliases to other references and expressions that are accessible from nested template blocks. There are four ways to create an alias:\n\n\n\n\nWith an alias block, which looks like a context section, but with aliases instead of a context e.g. \n{{#with foo.bar as bat, (baz.bat * 22) + 14 as magicNumber}}...{{/with}}\n. Within that block, \nbat\n will resolve to \nfoo.bar\n and \nmagicNumber\n will resolve to \n(baz.bat * 22) + 14)\n.\n\n\nNaming the iteration context in an iterative mustache e.g. \n{{#each list as item}}...{{/each}}\n. Within that block, \nitem\n will resolve to the current iteration context. This is particularly useful for nested contexts within the iteration body, where \n.\n is no longer the current iteration.\n\n\nIndex and/or key aliases in an iterative mustache e.g. \n{{#each list:i}}\n. The current index alias \ni\n is available within the iteration body. The alias can be any name you like, so it doesn't have to be \ni\n. Similarly, with object iteration e.g. \n{{#each someObject:k, i}}\n, the first alias is the current key and the second alias is the current index. All of the aliases are completely optional.\n\n\nNaming aliases in a partial or yielder e.g. \n{{\nmyPartial foo.bar as bat, baz.bat as bip}}\n or \n{{yield myPartial with foo.bar as bat}}\n. If you aren't familiar with partials and yielders, don't worry because they're covered elsewhere.\n\n\n\n\nIn each of those cases, one or more references is introduced that doesn't directly relate to the data in the current context. Aliases are useful for templates that have many nested contexts to avoid large context or keypath popping prefixes, but note that they will resolve as part of the ambiguous reference resolution process, meaning that a local key with the same name in the current context with resolve before the alias.\n\n\nSpecial References\n\n\nRactive provides a number of special references that exist primarily at one particular point in a template and are not directly related to data. Special references are a sort of meta reference that starts with an \n@\n, and we've already seen one in an example above in the form of \n@index\n.\n\n\nIteration Index\n\n\nThe current index of an iteration is available as the special \n@index\n reference. If the iterated reference is an object, then the current key name is available as the special \n@key\n reference.\n\n\nRactive Instance\n\n\nThe \n@this\n special reference resolves to a special handle to the current Ractive instance. This is useful for calling methods or accessing properties on the Ractive instance that aren't part of the instance's data. If you have any helper methods that need to be accessible from both the API and the template, or you simply don't like putting helper functions in your data, you can place them on the Ractive instance and access them using \n@this\n.\n\n\nAs with \nthis\n, \n@this\n also has a special shorthand form \n@\n, so \n@this.set('answer', 42)\n is the same as \n@.set('answer', 42)\n. The \n@this\n reference is one of the few special references that is available outside of a template e.g. \napp.set('@this.answer', 42)\n, and that is handled because it's the only way to have instance properties update directly in an observable way.\n\n\nProperties on the \n@this\n reference that have a Ractive instance as a value will resolve to the equivalent \n@this\n for that value. This means that referencing a property on a foreign instance will result in a binding that updates correctly everywhere when it changes.\n\n\nIn addition to Ractive instance properties, there is a special \ndata\n property (\n@.data\n) that resolves to the root model of the instance. This means that foreign instance data can be referenced as long as there is a supported path to the instance available in the template. Tight coupling is discouraged in general for components, but some classes of component are greatly simplified by allowing them to be tightly coupled.\n\n\nKeypath\n\n\nThe keypath of the current context is available as the special \n@keypath\n reference. There are some contexts that do not have externally addressable keypaths, like expressions. The keypath resolved by the \n@keypath\n reference is relative to the immediate instance, meaning that if the current instance happens to be a component and the context is provided by a mapping, then the keypath will be relative to the local component. To get the full path, you can use the special \n@rootpath\n reference, which will traverse mappings to the root instance to return the full keypath.\n\n\nGlobal\n\n\nMost of the common JavaScript globals are available as normal references, like \nMath\n, \nObject\n, and \nJSON\n. The rest of the global scope is accessible from the special \n@global\n reference, which, like the \n@this\n model, is available to both the template and JavaScript API on any Ractive instance. Any changes made to a \n@global\n keypath through the \nset\n or other mutation method will also notify any other dependencies within Ractive that they need to update.\n\n\nIn a node.js environment, \n@global\n wraps the \nglobal\n object, and in most browsers, it wraps the \nwindow\n object.\n\n\nRactive-global Storage\n\n\nThe special \n@global\n reference is subject to interference from outside code, so Ractive also provides its own special \n@shared\n reference, which is global among all Ractive instances.\n\n\nContext\n\n\nEach block-level node in a Ractive template provides a special \n@context\n reference. This is the same object that is returned by \nRactive.getNodeInfo()\n when called with the nearest parent DOM element. Contexts provided by the template are more precise than those acquired from a DOM element, because the template has access to the surrounding block scopes.\n\n\nWhen a \n@context\n is provided for an event directive, it will be extended with additional properties relevant to the event.\n\n\nEvent Object\n\n\nThe special \n@event\n reference is available to event directives and resolves to the current DOM or instance event object. This reference provides direct access to properties like \nkey\n, \nclientX\n, and \nclientY\n.\n\n\nEvent Element\n\n\nThe special \n@node\n reference is available to event directives and resolves to the DOM element on which the event directive is installed. With the \n@node\n reference you can use properties, like \nvalue\n, and call methods, like \nselect()\n, from an event handler e.g. \ninput on-focus=\"@node.select()\" /\n, which selects the text of the input when it gains focus.\n\n\nLocal Model\n\n\nRactive provides a special \n@local\n reference that is a context-local model designed to provide out-of-model storage for plugins like decorators and parser transforms.\n\n\nReference Summary Table\n\n\n\n\n\n\n\n\nPrefix / Special\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n.\n\n\nImmediate context, and any further keys are accessed from the immediate context.\n\n\n\n\n\n\n../\n\n\nMove up one level in the keypath of the current context. This can be stacked, and any keys after the prefix are accessed from the resulting context.\n\n\n\n\n\n\n~/\n\n\nThe local root context, and any keys after the prefix are accessed starting from the root context.\n\n\n\n\n\n\n^^/\n\n\nThe immediate parent context, and keys after the prefix are accessed from the resulting context. This can also be stacked with \n../\n e.g. \n^^/^^/../name\n, which would pop the context twice, then the keypath on that context once, and finally return the \nname\n key.\n\n\n\n\n\n\n@this\n\n\nThe instance associated with the current context.\n\n\n\n\n\n\n@index\n\n\nThe index of the nearest parent iterative mustache.\n\n\n\n\n\n\n@key\n\n\nThe key of the nearest parent iterative mustache.\n\n\n\n\n\n\n@keypath\n\n\nThe keypath of the current context relative to the immediate instance.\n\n\n\n\n\n\n@rootpath\n\n\nThe keypath of the current context relative to the root instance.\n\n\n\n\n\n\n@global\n\n\nThe global object e.g. \nglobal\n in node.js and \nwindow\n in the browser.\n\n\n\n\n\n\n@shared\n\n\nRactive-private global storage.\n\n\n\n\n\n\n@context\n\n\nThe context object associated with the current context.\n\n\n\n\n\n\n@event\n\n\nThe DOM or instance event triggering an event directive. This is only accessible inside event directives.\n\n\n\n\n\n\n@node\n\n\nThe DOM element associated with a particular event directive. This is only accessible inside event directives.\n\n\n\n\n\n\n@local\n\n\nSpecial storage associated with the current context.", 
            "title": "References and Context"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#references-and-context", 
            "text": "Just about everything you can do with Ractive revolves around data, and each bit of data is accessible by a keypath. Each particular instance of a keypath in a template is called a reference, because it references the data that lives at that keypath. A keypath in Ractive is simply a  .  delimited set of keys that looks something like  foo.bar.baz , which when placed in a template mustache would be a reference to the value at the  baz  key on the object at the  bar  key on the object at the  foo  key on the data object passed to Ractive. The base key in that keypath is  foo .  Keypaths in Ractive need not be absolute, and there are a few conveniences built in to make accessing data easier. Before we get into that though, it's important to understand the concepts of context in a Ractive template and how that can affect your references.", 
            "title": "References and Context"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#context", 
            "text": "A context in Ractive is simply the bit of data at the current place in the template. There are five ways to introduce a new context in a Ractive template:   The root context is the default context at which all templates start.  An iterative mustache will introduce a new context for each iteration.  A  with  mustache will introduce a new context with whatever is passed to it.  There's a special case of  with  that covers passing a context to a partial.  A plain block mustache will introduce a new context because it acts like either a conditional  with  or an iterative block, depending on the what is passed to it.  Every component introduces its own root context.   Contexts tend to build linearly through a template, meaning that the first context in a template may be  blog , and nested within the block that created that context may be another  posts , making the full keypath for the inner context  blog.posts . If  blog.posts  is an array that is passed to an iterative block, the body of the first iteration would have a context of  blog.posts.0 , the second  blog.posts.1 , and so on. Note though, that context is  not required  to build linearly like that; it's just very common because it builds naturally alongside the data structure.  If this section is a little confusing, don't worry too much about it because all of these concepts are closely related and tend to make sense more as a whole than individual parts.", 
            "title": "Context"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#specificity-and-ambiguity", 
            "text": "A reference is ambiguous if it does not exist in the current context. Ractive will resolve ambiguous references by looking at each context up the stack from the current point in the template to the root. If no data matching the base key and no matching alias is found, then the current context will be used as the starting point for the reference. That means that with a context of  blog.posts.0 , referencing  author.name  that doesn't exist anywhere in the context hierarchy will end up with a resolved keypath of  blog.posts.0.author.name . References only resolve once as the template is being rendered, which means that if data appears after a conditional has rendered and the conditional later unrenders and re-renders, then the new, more specific data will be resolved in the newly rendered conditional.  {{#with blog.posts.0}}\n  Author: {{author.name}}\n{{/with}}   var app = new Ractive({\n  target: '#target',\n  template: '#template',\n  data: {\n    blog: {\n      posts: [ {} ]\n    }\n  }\n});\n\nsetTimeout(function() {\n  app.set('blog.posts.0.author.name', 'John Q. Resolver');\n}, 1000);  Ambiguity in Ractive is generally discouraged, since it can lead to weird scenarios like that described above in the unrendering/re-rendering of a conditional section. It's also not as fast to search up the context hierarchy as it is to simply start with the current context, which is usually what you want anyway. To that end, there is a special reference  this , that refers to the current context at the current point in the template.  this  is meant to mirror the JavaScript keyword of the same name and similar concept. There's also a shorthand for  this ,  .  e.g.  {{this}} is the same as {{.}}  and  {{this.name}} is the same as {{.name}} . Ambiguity does have its purposes, but generally, if you can, you should use specific references.  {{#if show}}\n  {{#with blog}}\n    {{#with posts.0}}\n       h2 Ambiguity may be good or bad, depending on what you're trying to do. /h2 \n       p {{.name}} /p \n       p {{name}} /p \n    {{/with}}\n  {{/with}}\n{{/if}}   var app = new Ractive({\n  target: '#target',\n  template: '#template',\n  data: {\n    blog: {\n      posts: [ {} ],\n      name: 'Mah Blog'\n    },\n    show: true\n  }\n});\n\nsetTimeout(function() {\n  app.set('blog.posts.0.name', 'I am foo.bar.baz');\n\n  setTimeout(function() {\n    app.toggle('show');\n    app.toggle('show');\n  }, 1000);\n}, 1000);", 
            "title": "Specificity and Ambiguity"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#navigating-contexts-and-keypaths", 
            "text": "Sometimes the data you're after may not exist in the current context or one of it's child keypaths. Ractive offers a few ways to navigate both contexts and keypaths.  Navigating keypaths is very similar to naviagating a filesystem, both syntactically and conceptually. If your current context is  user.settings.display  and you want to access  user.name , you can pop up the keypath using the  ../  prefix e.g.  ../../name . Note that this  only  traverses the current keypath and not the context stack, even though those turn out to be the same in many cases. If the context stack happens to contain disjointed keypaths e.g.  user.settings  with a nested context of  blog.posts  (also on the root data object), then you would have to pop all the way to the root keypath to access a  user  keypath. That's not a terrible imposition with a shallow data structure, but it can be painful if the current context is more than a few keys deep.  To address that, Ractive also supports a root keypath prefix,  ~/  that is meant to mirror the \"home\" directory prefix available to POSIX environments. From the previous example, instead of using  ../../user  from the  blog.posts  context, you could simply use  ~/user . The root prefix refers to the root of the data in the current Ractive instance, meaning that containing instances of a component are not directly accessible using  ~/ .  Some contexts are not directly addessable from outside of their context children, like expression contexts e.g.  {{#with { answer: 42, list: [ 1, 2, 3 ] } }}{{#with ~/some.key}} there's no way to get back to the outer context using ../ or ~/ {{/with}}{{/with}} . If you're not sure what's happening with that outer context, don't worry because that's covered more elsewhere. To address situations like that, Ractive provides a context-popping prefix,  ^^/  that is similar to the keypath-popping prefix. In the example,  ^^/answer  would resolve to  42  from the inner context because  ^^/  steps one step up the context hierarchy and gets the key  answer , which in this case happens to be on the inline object expression  { answer: 42, list: [ 1, 2, 3 ] } . Context popping is not something you need often, but it's the only way to work around some corner-case scenarios explicitly.  Note that aside from  ~/ , prefixed keypaths are not accessible from non-context API methods, like  app.set('../answer', 42)  because there's no way to determine to which keypath that should be relative. There are context helpers that make such relative keypaths available, but they're covered elsewhere.", 
            "title": "Navigating Contexts and Keypaths"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#iterative-contexts", 
            "text": "It's worth noting that iterative mustaches introduce an implicit context that is two levels deeper than the surrounding context, which can be a little confusing at first glance. For instance:  {{#with user.blog}}\n  {{#each posts}}\n    {{../title}}\n  {{/each}}\n{{/with}}  In that example, you may expect  ../title  in the each block body to resolve to  user.blog.title , but it doesn't. Instead, it resolves to  user.blog.posts.title  because each iteration has two additional keys added e.g.  user.blog.posts.0  to make the current item the context of the iteration body. Popping up the keypath once only removes the index key, leaving you at the list rather than the surrounding context. Note that this is actually quite useful for things like:   ul \n{{#each list}}\n   li Item {{@index + 1}} of {{../length}} is {{.}} /li \n{{/each}} /ul", 
            "title": "Iterative Contexts"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#aliases", 
            "text": "In addition to direct references, Ractive allows you to create template aliases to other references and expressions that are accessible from nested template blocks. There are four ways to create an alias:   With an alias block, which looks like a context section, but with aliases instead of a context e.g.  {{#with foo.bar as bat, (baz.bat * 22) + 14 as magicNumber}}...{{/with}} . Within that block,  bat  will resolve to  foo.bar  and  magicNumber  will resolve to  (baz.bat * 22) + 14) .  Naming the iteration context in an iterative mustache e.g.  {{#each list as item}}...{{/each}} . Within that block,  item  will resolve to the current iteration context. This is particularly useful for nested contexts within the iteration body, where  .  is no longer the current iteration.  Index and/or key aliases in an iterative mustache e.g.  {{#each list:i}} . The current index alias  i  is available within the iteration body. The alias can be any name you like, so it doesn't have to be  i . Similarly, with object iteration e.g.  {{#each someObject:k, i}} , the first alias is the current key and the second alias is the current index. All of the aliases are completely optional.  Naming aliases in a partial or yielder e.g.  {{ myPartial foo.bar as bat, baz.bat as bip}}  or  {{yield myPartial with foo.bar as bat}} . If you aren't familiar with partials and yielders, don't worry because they're covered elsewhere.   In each of those cases, one or more references is introduced that doesn't directly relate to the data in the current context. Aliases are useful for templates that have many nested contexts to avoid large context or keypath popping prefixes, but note that they will resolve as part of the ambiguous reference resolution process, meaning that a local key with the same name in the current context with resolve before the alias.", 
            "title": "Aliases"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#special-references", 
            "text": "Ractive provides a number of special references that exist primarily at one particular point in a template and are not directly related to data. Special references are a sort of meta reference that starts with an  @ , and we've already seen one in an example above in the form of  @index .", 
            "title": "Special References"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#iteration-index", 
            "text": "The current index of an iteration is available as the special  @index  reference. If the iterated reference is an object, then the current key name is available as the special  @key  reference.", 
            "title": "Iteration Index"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#ractive-instance", 
            "text": "The  @this  special reference resolves to a special handle to the current Ractive instance. This is useful for calling methods or accessing properties on the Ractive instance that aren't part of the instance's data. If you have any helper methods that need to be accessible from both the API and the template, or you simply don't like putting helper functions in your data, you can place them on the Ractive instance and access them using  @this .  As with  this ,  @this  also has a special shorthand form  @ , so  @this.set('answer', 42)  is the same as  @.set('answer', 42) . The  @this  reference is one of the few special references that is available outside of a template e.g.  app.set('@this.answer', 42) , and that is handled because it's the only way to have instance properties update directly in an observable way.  Properties on the  @this  reference that have a Ractive instance as a value will resolve to the equivalent  @this  for that value. This means that referencing a property on a foreign instance will result in a binding that updates correctly everywhere when it changes.  In addition to Ractive instance properties, there is a special  data  property ( @.data ) that resolves to the root model of the instance. This means that foreign instance data can be referenced as long as there is a supported path to the instance available in the template. Tight coupling is discouraged in general for components, but some classes of component are greatly simplified by allowing them to be tightly coupled.", 
            "title": "Ractive Instance"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#keypath", 
            "text": "The keypath of the current context is available as the special  @keypath  reference. There are some contexts that do not have externally addressable keypaths, like expressions. The keypath resolved by the  @keypath  reference is relative to the immediate instance, meaning that if the current instance happens to be a component and the context is provided by a mapping, then the keypath will be relative to the local component. To get the full path, you can use the special  @rootpath  reference, which will traverse mappings to the root instance to return the full keypath.", 
            "title": "Keypath"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#global", 
            "text": "Most of the common JavaScript globals are available as normal references, like  Math ,  Object , and  JSON . The rest of the global scope is accessible from the special  @global  reference, which, like the  @this  model, is available to both the template and JavaScript API on any Ractive instance. Any changes made to a  @global  keypath through the  set  or other mutation method will also notify any other dependencies within Ractive that they need to update.  In a node.js environment,  @global  wraps the  global  object, and in most browsers, it wraps the  window  object.", 
            "title": "Global"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#ractive-global-storage", 
            "text": "The special  @global  reference is subject to interference from outside code, so Ractive also provides its own special  @shared  reference, which is global among all Ractive instances.", 
            "title": "Ractive-global Storage"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#context_1", 
            "text": "Each block-level node in a Ractive template provides a special  @context  reference. This is the same object that is returned by  Ractive.getNodeInfo()  when called with the nearest parent DOM element. Contexts provided by the template are more precise than those acquired from a DOM element, because the template has access to the surrounding block scopes.  When a  @context  is provided for an event directive, it will be extended with additional properties relevant to the event.", 
            "title": "Context"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#event-object", 
            "text": "The special  @event  reference is available to event directives and resolves to the current DOM or instance event object. This reference provides direct access to properties like  key ,  clientX , and  clientY .", 
            "title": "Event Object"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#event-element", 
            "text": "The special  @node  reference is available to event directives and resolves to the DOM element on which the event directive is installed. With the  @node  reference you can use properties, like  value , and call methods, like  select() , from an event handler e.g.  input on-focus=\"@node.select()\" / , which selects the text of the input when it gains focus.", 
            "title": "Event Element"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#local-model", 
            "text": "Ractive provides a special  @local  reference that is a context-local model designed to provide out-of-model storage for plugins like decorators and parser transforms.", 
            "title": "Local Model"
        }, 
        {
            "location": "/get-started/tutorials/references-and-context/#reference-summary-table", 
            "text": "Prefix / Special  Description      .  Immediate context, and any further keys are accessed from the immediate context.    ../  Move up one level in the keypath of the current context. This can be stacked, and any keys after the prefix are accessed from the resulting context.    ~/  The local root context, and any keys after the prefix are accessed starting from the root context.    ^^/  The immediate parent context, and keys after the prefix are accessed from the resulting context. This can also be stacked with  ../  e.g.  ^^/^^/../name , which would pop the context twice, then the keypath on that context once, and finally return the  name  key.    @this  The instance associated with the current context.    @index  The index of the nearest parent iterative mustache.    @key  The key of the nearest parent iterative mustache.    @keypath  The keypath of the current context relative to the immediate instance.    @rootpath  The keypath of the current context relative to the root instance.    @global  The global object e.g.  global  in node.js and  window  in the browser.    @shared  Ractive-private global storage.    @context  The context object associated with the current context.    @event  The DOM or instance event triggering an event directive. This is only accessible inside event directives.    @node  The DOM element associated with a particular event directive. This is only accessible inside event directives.    @local  Special storage associated with the current context.", 
            "title": "Reference Summary Table"
        }, 
        {
            "location": "/get-started/tutorials/expressions-and-computations/", 
            "text": "Expressions and Computations\n\n\nAccessing data directly from within a template is quite useful, but there are some situations in which it is not at all convenient to have values for every possible data point computed ahead of time. To address that, Ractive supports both computed properties at the instance level and expressions within templates, both of which use a dependency tracking system that allows them to update reactively when data on which they depend changes.\n\n\nTemplate Expressions\n\n\nRactive's template parser has a fairly complete JavaScript parser inside it, so that it can read plain JS expressions with Ractive references in order to know what expressions need to be recomputed when data changes. Ractive template expressions can be just about any JavaScript (ES5) expression with a few exceptions:\n\n\n\n\nAssignments are not permitted i.e. \ni = 10\n, \na += b\n, \ni++\n, \n--a\n, etc.\n\n\nnew\n, \ndelete\n, and \nvoid\n are not available.\n\n\nFunction literals are not permitted i.e. anything involving the \nfunction\n keyword.\n\n\nAs statements (as opposed to expressions), \nfor\n, \nwith\n, \nif\n, \nreturn\n, etc are not permitted.\n\n\n\n\nBeyond those exceptions, pretty much all of JavaScript is available, including some applicable features from later versions of ECMAScript, like array, object, and argument spread operators.\n\n\nFunctions in Data\n\n\nAny functions that can be referenced within a template can also be called within the template. Functions may exist in an instance's data, among its members accessed using \n@this\n, globally via \n@global\n, and shared across Ractive instances via \n@shared\n. They can be called, as you would expect, by referencing them and using a call operator or method e.g. \nfn(arg)\n, \nfn.call(context, arg)\n, or \nfn.apply(context, [arg])\n.\n\n\nConversion to Functions\n\n\nAfter parsing, template expressions have any references extracted into a list of dependencies, and the references are replaced with numbered placeholders. If the parser is in \ncsp\n mode, then the parser will create functions for each expression in the template and attach them to the template object's expression cache by name. After reference extraction, expressions are much more generic, so different expressions can end up referencing the same function. For instance, \na + b\n and \nanswer + otherSum\n both reduce to \n_0+_1\n. When the function for that expression is created, either at parse or runtime, it will look like \nfunction(_0, _1) { return _0+_1; }\n.\n\n\nWhen the runtime encounters an expression while rendering a template, it will create a special model to stand in as a proxy for the expression. The proxy will have the list of references that expression depends upon along with the function that matches the expression. When asked for a value, the proxy will resolve all of the dependencies to values and call the function with them in the correct order. The function is called inside a \ntry\n/\ncatch\n so that any expceptions that may happen inside the expression don't blow up the render.\n\n\nUse\n\n\nTemplate expressions can be used just about anywhere in a template that would accept a regular reference, and in a few additional places, like event directives.\n\n\nCapture and Dependencies\n\n\nWhen evaluating an expression or computation, Ractive will keep track of any keypaths accessed via \nget\n and record those as dependencies of the computation. The mechanism that tracks dependencies in computations is called capture. If any dependency of a computation changes, then the computation will recompute and notify any of it's dependents that it also has a new value.\n\n\n\n\nNote: that in addition to be reactive, computations are also lazy, meaning that they will not actually compute a value until a dependent asks for the value.\n\n\n\n\nComputed Properties\n\n\nComputed properties are accessible in the same way as references that exist at the root of an instance's viewmodel. They may be read-only or read-write depending on whether or not they have both a getter and a setter. Like expressions, computations use capture to track their dependencies, so changes in a computations dependencies will cause the computation to invalidate and recompute.", 
            "title": "Expressions and Computations"
        }, 
        {
            "location": "/get-started/tutorials/expressions-and-computations/#expressions-and-computations", 
            "text": "Accessing data directly from within a template is quite useful, but there are some situations in which it is not at all convenient to have values for every possible data point computed ahead of time. To address that, Ractive supports both computed properties at the instance level and expressions within templates, both of which use a dependency tracking system that allows them to update reactively when data on which they depend changes.", 
            "title": "Expressions and Computations"
        }, 
        {
            "location": "/get-started/tutorials/expressions-and-computations/#template-expressions", 
            "text": "Ractive's template parser has a fairly complete JavaScript parser inside it, so that it can read plain JS expressions with Ractive references in order to know what expressions need to be recomputed when data changes. Ractive template expressions can be just about any JavaScript (ES5) expression with a few exceptions:   Assignments are not permitted i.e.  i = 10 ,  a += b ,  i++ ,  --a , etc.  new ,  delete , and  void  are not available.  Function literals are not permitted i.e. anything involving the  function  keyword.  As statements (as opposed to expressions),  for ,  with ,  if ,  return , etc are not permitted.   Beyond those exceptions, pretty much all of JavaScript is available, including some applicable features from later versions of ECMAScript, like array, object, and argument spread operators.", 
            "title": "Template Expressions"
        }, 
        {
            "location": "/get-started/tutorials/expressions-and-computations/#functions-in-data", 
            "text": "Any functions that can be referenced within a template can also be called within the template. Functions may exist in an instance's data, among its members accessed using  @this , globally via  @global , and shared across Ractive instances via  @shared . They can be called, as you would expect, by referencing them and using a call operator or method e.g.  fn(arg) ,  fn.call(context, arg) , or  fn.apply(context, [arg]) .", 
            "title": "Functions in Data"
        }, 
        {
            "location": "/get-started/tutorials/expressions-and-computations/#conversion-to-functions", 
            "text": "After parsing, template expressions have any references extracted into a list of dependencies, and the references are replaced with numbered placeholders. If the parser is in  csp  mode, then the parser will create functions for each expression in the template and attach them to the template object's expression cache by name. After reference extraction, expressions are much more generic, so different expressions can end up referencing the same function. For instance,  a + b  and  answer + otherSum  both reduce to  _0+_1 . When the function for that expression is created, either at parse or runtime, it will look like  function(_0, _1) { return _0+_1; } .  When the runtime encounters an expression while rendering a template, it will create a special model to stand in as a proxy for the expression. The proxy will have the list of references that expression depends upon along with the function that matches the expression. When asked for a value, the proxy will resolve all of the dependencies to values and call the function with them in the correct order. The function is called inside a  try / catch  so that any expceptions that may happen inside the expression don't blow up the render.", 
            "title": "Conversion to Functions"
        }, 
        {
            "location": "/get-started/tutorials/expressions-and-computations/#use", 
            "text": "Template expressions can be used just about anywhere in a template that would accept a regular reference, and in a few additional places, like event directives.", 
            "title": "Use"
        }, 
        {
            "location": "/get-started/tutorials/expressions-and-computations/#capture-and-dependencies", 
            "text": "When evaluating an expression or computation, Ractive will keep track of any keypaths accessed via  get  and record those as dependencies of the computation. The mechanism that tracks dependencies in computations is called capture. If any dependency of a computation changes, then the computation will recompute and notify any of it's dependents that it also has a new value.   Note: that in addition to be reactive, computations are also lazy, meaning that they will not actually compute a value until a dependent asks for the value.", 
            "title": "Capture and Dependencies"
        }, 
        {
            "location": "/get-started/tutorials/expressions-and-computations/#computed-properties", 
            "text": "Computed properties are accessible in the same way as references that exist at the root of an instance's viewmodel. They may be read-only or read-write depending on whether or not they have both a getter and a setter. Like expressions, computations use capture to track their dependencies, so changes in a computations dependencies will cause the computation to invalidate and recompute.", 
            "title": "Computed Properties"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/", 
            "text": "All Things Template\n\n\nThis tutorial covers \nevery\n template construct available to Ractive, and as such, it's pretty long. Some of these constructs are also covered in more depth in other tutorials, but the goal here is to have a single reference point for anything you might ever see in the wild.\n\n\nElements\n\n\nAttributes\n\n\nSpecial Cases\n\n\nComponents\n\n\nMappings\n\n\nDirectives\n\n\nEvents\n\n\nBindings\n\n\nDecorators\n\n\nTransitions\n\n\nClass and Style\n\n\nInterpolators\n\n\nStatic\n\n\nPartials\n\n\nContext\n\n\nAliases\n\n\nYielders\n\n\nAliases\n\n\nBlocks\n\n\nPlain Mustache Block\n\n\nIndex and Key\n\n\nNegated Mustache Block\n\n\nEach Block\n\n\nItem Alias\n\n\nIndex and Key\n\n\nWith Block\n\n\nAliases\n\n\nIf Block\n\n\nAlternate Cases\n\n\nUnless Block\n\n\nPartial Block", 
            "title": "All Things Template"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#all-things-template", 
            "text": "This tutorial covers  every  template construct available to Ractive, and as such, it's pretty long. Some of these constructs are also covered in more depth in other tutorials, but the goal here is to have a single reference point for anything you might ever see in the wild.", 
            "title": "All Things Template"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#elements", 
            "text": "", 
            "title": "Elements"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#attributes", 
            "text": "", 
            "title": "Attributes"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#special-cases", 
            "text": "", 
            "title": "Special Cases"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#mappings", 
            "text": "", 
            "title": "Mappings"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#directives", 
            "text": "", 
            "title": "Directives"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#events", 
            "text": "", 
            "title": "Events"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#bindings", 
            "text": "", 
            "title": "Bindings"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#decorators", 
            "text": "", 
            "title": "Decorators"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#transitions", 
            "text": "", 
            "title": "Transitions"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#class-and-style", 
            "text": "", 
            "title": "Class and Style"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#interpolators", 
            "text": "", 
            "title": "Interpolators"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#static", 
            "text": "", 
            "title": "Static"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#partials", 
            "text": "", 
            "title": "Partials"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#context", 
            "text": "", 
            "title": "Context"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#aliases", 
            "text": "", 
            "title": "Aliases"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#yielders", 
            "text": "", 
            "title": "Yielders"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#aliases_1", 
            "text": "", 
            "title": "Aliases"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#blocks", 
            "text": "", 
            "title": "Blocks"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#plain-mustache-block", 
            "text": "", 
            "title": "Plain Mustache Block"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#index-and-key", 
            "text": "", 
            "title": "Index and Key"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#negated-mustache-block", 
            "text": "", 
            "title": "Negated Mustache Block"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#each-block", 
            "text": "", 
            "title": "Each Block"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#item-alias", 
            "text": "", 
            "title": "Item Alias"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#index-and-key_1", 
            "text": "", 
            "title": "Index and Key"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#with-block", 
            "text": "", 
            "title": "With Block"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#aliases_2", 
            "text": "", 
            "title": "Aliases"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#if-block", 
            "text": "", 
            "title": "If Block"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#alternate-cases", 
            "text": "", 
            "title": "Alternate Cases"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#unless-block", 
            "text": "", 
            "title": "Unless Block"
        }, 
        {
            "location": "/get-started/tutorials/all-things-template/#partial-block", 
            "text": "", 
            "title": "Partial Block"
        }, 
        {
            "location": "/get-started/tutorials/context-and-helpers/", 
            "text": "Context and Helpers\n\n\nTODO", 
            "title": "Context and Helpers"
        }, 
        {
            "location": "/get-started/tutorials/context-and-helpers/#context-and-helpers", 
            "text": "TODO", 
            "title": "Context and Helpers"
        }, 
        {
            "location": "/get-started/tutorials/dom-and-instance-events/", 
            "text": "DOM and Instance Events\n\n\nTODO", 
            "title": "DOM and Instance Events"
        }, 
        {
            "location": "/get-started/tutorials/dom-and-instance-events/#dom-and-instance-events", 
            "text": "TODO", 
            "title": "DOM and Instance Events"
        }, 
        {
            "location": "/get-started/tutorials/transitions/", 
            "text": "Transitions\n\n\nTODO", 
            "title": "Transitions"
        }, 
        {
            "location": "/get-started/tutorials/transitions/#transitions", 
            "text": "TODO", 
            "title": "Transitions"
        }, 
        {
            "location": "/get-started/tutorials/components/", 
            "text": "Components\n\n\nTODO", 
            "title": "Coomponents"
        }, 
        {
            "location": "/get-started/tutorials/components/#components", 
            "text": "TODO", 
            "title": "Components"
        }, 
        {
            "location": "/get-started/tutorials/decorators/", 
            "text": "Decorators\n\n\nTODO", 
            "title": "Decorators"
        }, 
        {
            "location": "/get-started/tutorials/decorators/#decorators", 
            "text": "TODO", 
            "title": "Decorators"
        }, 
        {
            "location": "/get-started/tutorials/svg-and-animation/", 
            "text": "SVG and Animation\n\n\nTODO", 
            "title": "SVG and Animation"
        }, 
        {
            "location": "/get-started/tutorials/svg-and-animation/#svg-and-animation", 
            "text": "TODO", 
            "title": "SVG and Animation"
        }, 
        {
            "location": "/get-started/examples/analog-clock/", 
            "text": "Analog Clock\n\n\nEmbed demo here\n\n\n\n\nThis example demonstrates the use of expressions to simplify the process of turning raw data (such as the current time) into a renderable view that uses that data in many different ways.\n\n\nNormally, you'd probably have a \nrender\n function which got all the information we need to update (the day, date, month, hour, minute, second) and calculated any derived values (the rotation of the clock hands, the suffix to append to the date), then updated the view one element at a time.\n\n\nIf you wanted to minimise interactions with the DOM (which are bad for performance) then you'd have to store all these values so you could compare them between renders.\n\n\nOr perhaps you'd have a bunch of different views \u2013 one for the 'Today is...' sentence, one for the digital clock, one for the analogue clock (or possibly one for each of the analogue clock's hands) \u2013 each with their own unique render method. You'd still have to store a load of different references, but at least your code would look neater.\n\n\nWith Ractive.js, you only need to store a single reference to the ractive object, and the render function looks like this:\n\n\nractive.set( 'date', new Date() );\n\n\n\n\nAnd that's it \u2013 all the state management and dependency tracking is done for you.\n\n\nmain.js\n\n\n// create our clock...\nvar ractive = new BaseView({\n  el: demo,\n  data: {\n    datetime: new Date()\n  }\n});\n\n// ...then update it once a second\nsetInterval( function () {\n  ractive.set( 'datetime', new Date() );\n}, 1000 );\n\n\n\n\nBaseView.html\n\n\nlink rel='ractive' href='Clock.html'\n\n\n\ndiv class='clock-container'\n\n  \nClock datetime='{{datetime}}'/\n\n\n/div\n\n\n\np\n\n  Today is {{moment(datetime).format('dddd MMMM Do YYYY')}}.\n  The time is \nstrong\n{{moment(datetime).format('h:mm:ss a')}}\n/strong\n\n\n/p\n\n\n\nstyle\n\n  .clock-container {\n    width: 10em;\n    float: left;\n  }\n\n  p {\n    float: left;\n  }\n\n/style\n\n\n\nscript\n\n  component.exports = {\n    data: {\n      moment: require( 'moment' )\n    }\n  }\n\n/script\n\n\n\n\n\nClock.html\n\n\ndiv class='clock'\n \n!-- so the SVG keeps its aspect ratio --\n\n  \nsvg viewBox='0 0 100 100'\n\n\n    \n!-- first create a group and move it to 50,50 so\n         all co-ords are relative to the center --\n\n    \ng transform='translate(50,50)'\n\n      \ncircle class='clock-face' r='48'/\n\n\n      \n!-- markers every minute (major markers every 5 minutes) --\n\n      {{#each minor:i}}\n        \nline class='minor' y1='42' y2='45' transform='rotate( {{\n          360 * i / minor.length\n        }} )'/\n\n      {{/each}}\n\n      {{#each major:i}}\n        \nline class='major' y1='35' y2='45' transform='rotate( {{\n          360 * i / major.length\n        }} )'/\n\n      {{/each}}\n\n      \n!-- hour hand --\n\n      \nline class='hour' y1='2' y2='-20' transform='rotate( {{\n        30 * datetime.getHours() +\n        datetime.getMinutes() / 2\n      }} )'/\n\n\n      \n!-- minute hand --\n\n      \nline class='minute' y1='4' y2='-30' transform='rotate( {{\n        6 * datetime.getMinutes() +\n        datetime.getSeconds() / 10\n      }} )'/\n\n\n      \n!-- second hand --\n\n      \ng transform='rotate( {{\n        6 * datetime.getSeconds()\n      }} )'\n\n        \nline class='second' y1='10' y2='-38'/\n\n        \nline class='second-counterweight' y1='10' y2='2'/\n\n      \n/g\n\n\n    \n/g\n\n\n  \n/svg\n\n\n/div\n\n\n\nstyle\n\n  .clock {\n    position: relative;\n    width: 100%;\n    height: 0;\n    padding-bottom: 100%;\n  }\n\n  svg {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n  }\n\n  .clock-face {\n    stroke: #333;\n    fill: white;\n  }\n\n  .minor {\n    stroke: #999;\n    stroke-width: 0.5;\n  }\n\n  .major {\n    stroke: #333;\n    stroke-width: 1;\n  }\n\n  .hour {\n    stroke: #333;\n  }\n\n  .minute {\n    stroke: #666;\n  }\n\n  .second, .second-counterweight {\n    stroke: rgb(180,0,0);\n  }\n\n  .second-counterweight {\n    stroke-width: 3;\n  }\n\n/style\n\n\n\nscript\n\n  component.exports = {\n    data: function () {\n      return {\n        // clock face markers - major (every 5 minutes) and minor (every minute)\n        major: new Array( 12 ),\n        minor: new Array( 60 )\n      };\n    }\n  };\n\n/script", 
            "title": "Analog Clock"
        }, 
        {
            "location": "/get-started/examples/analog-clock/#analog-clock", 
            "text": "Embed demo here  This example demonstrates the use of expressions to simplify the process of turning raw data (such as the current time) into a renderable view that uses that data in many different ways.  Normally, you'd probably have a  render  function which got all the information we need to update (the day, date, month, hour, minute, second) and calculated any derived values (the rotation of the clock hands, the suffix to append to the date), then updated the view one element at a time.  If you wanted to minimise interactions with the DOM (which are bad for performance) then you'd have to store all these values so you could compare them between renders.  Or perhaps you'd have a bunch of different views \u2013 one for the 'Today is...' sentence, one for the digital clock, one for the analogue clock (or possibly one for each of the analogue clock's hands) \u2013 each with their own unique render method. You'd still have to store a load of different references, but at least your code would look neater.  With Ractive.js, you only need to store a single reference to the ractive object, and the render function looks like this:  ractive.set( 'date', new Date() );  And that's it \u2013 all the state management and dependency tracking is done for you.", 
            "title": "Analog Clock"
        }, 
        {
            "location": "/get-started/examples/analog-clock/#mainjs", 
            "text": "// create our clock...\nvar ractive = new BaseView({\n  el: demo,\n  data: {\n    datetime: new Date()\n  }\n});\n\n// ...then update it once a second\nsetInterval( function () {\n  ractive.set( 'datetime', new Date() );\n}, 1000 );", 
            "title": "main.js"
        }, 
        {
            "location": "/get-started/examples/analog-clock/#baseviewhtml", 
            "text": "link rel='ractive' href='Clock.html'  div class='clock-container' \n   Clock datetime='{{datetime}}'/  /div  p \n  Today is {{moment(datetime).format('dddd MMMM Do YYYY')}}.\n  The time is  strong {{moment(datetime).format('h:mm:ss a')}} /strong  /p  style \n  .clock-container {\n    width: 10em;\n    float: left;\n  }\n\n  p {\n    float: left;\n  } /style  script \n  component.exports = {\n    data: {\n      moment: require( 'moment' )\n    }\n  } /script", 
            "title": "BaseView.html"
        }, 
        {
            "location": "/get-started/examples/analog-clock/#clockhtml", 
            "text": "div class='clock'   !-- so the SVG keeps its aspect ratio -- \n   svg viewBox='0 0 100 100' \n\n     !-- first create a group and move it to 50,50 so\n         all co-ords are relative to the center -- \n     g transform='translate(50,50)' \n       circle class='clock-face' r='48'/ \n\n       !-- markers every minute (major markers every 5 minutes) -- \n      {{#each minor:i}}\n         line class='minor' y1='42' y2='45' transform='rotate( {{\n          360 * i / minor.length\n        }} )'/ \n      {{/each}}\n\n      {{#each major:i}}\n         line class='major' y1='35' y2='45' transform='rotate( {{\n          360 * i / major.length\n        }} )'/ \n      {{/each}}\n\n       !-- hour hand -- \n       line class='hour' y1='2' y2='-20' transform='rotate( {{\n        30 * datetime.getHours() +\n        datetime.getMinutes() / 2\n      }} )'/ \n\n       !-- minute hand -- \n       line class='minute' y1='4' y2='-30' transform='rotate( {{\n        6 * datetime.getMinutes() +\n        datetime.getSeconds() / 10\n      }} )'/ \n\n       !-- second hand -- \n       g transform='rotate( {{\n        6 * datetime.getSeconds()\n      }} )' \n         line class='second' y1='10' y2='-38'/ \n         line class='second-counterweight' y1='10' y2='2'/ \n       /g \n\n     /g \n\n   /svg  /div  style \n  .clock {\n    position: relative;\n    width: 100%;\n    height: 0;\n    padding-bottom: 100%;\n  }\n\n  svg {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n  }\n\n  .clock-face {\n    stroke: #333;\n    fill: white;\n  }\n\n  .minor {\n    stroke: #999;\n    stroke-width: 0.5;\n  }\n\n  .major {\n    stroke: #333;\n    stroke-width: 1;\n  }\n\n  .hour {\n    stroke: #333;\n  }\n\n  .minute {\n    stroke: #666;\n  }\n\n  .second, .second-counterweight {\n    stroke: rgb(180,0,0);\n  }\n\n  .second-counterweight {\n    stroke-width: 3;\n  } /style  script \n  component.exports = {\n    data: function () {\n      return {\n        // clock face markers - major (every 5 minutes) and minor (every minute)\n        major: new Array( 12 ),\n        minor: new Array( 60 )\n      };\n    }\n  }; /script", 
            "title": "Clock.html"
        }, 
        {
            "location": "/get-started/examples/animated-chart/", 
            "text": "Animated Chart\n\n\nEmbed demo here\n\n\n\n\nMaking interactive charts is hard. Charts have many components besides the data itself \u2013 controls, axes, labels, annotations \u2013 and they often don't need to update at the same time as each other. Normally, you're faced with a choice between having several different render functions, or wastefully re-rendering the entire chart when things change.\n\n\nFor this reason, dedicated charting libraries have become popular. And that's a shame, because it means you're stuck with line charts and bar charts and pie charts and scatter charts, and don't you dare have any data that's better represented using a less conventional chart type, like this plot of high and low temperatures.\n\n\nFaced with a choice between freedom and ease of use, many developers turn to \nD3\n. D3 is a terrific library, and I won't hear a bad word said about it, but it doesn't solve the problem of efficiently updating different components of a chart because it has no concept of state.\n\n\nRactive.js takes a fundamentally different approach to other libraries. Rather than programmatically building up the different components of your chart, and writing logic to update those components, you write your SVG the same way you'd write an HTML template. When it's time to update the chart, you just throw the new state at it \u2013 the dependency tracking ensures that we only re-render what's changed. This makes it trivially easy to animate the chart when the user changes city via the drop-down menu.\n\n\nNote also that we don't need to faff about with event handlers and render logic to switch between celsius and fahrenheit \u2013 when the user switches between them, Ractive.js knows what to do, because the labels' dependency on degreeType is written into the template.\n\n\nmain.js\n\n\nvar cities = [\n  { name: 'London, UK', temperatures: [{ high: 7.9, low: 2.4 }, { high: 8.2, low: 2.2 }, { high: 10.9, low: 3.8 }, { high: 13.3, low: 5.2 }, { high: 17.2, low: 8 }, { high: 20.2, low: 11.1 }, { high: 22.8, low: 13.6 }, { high: 22.6, low: 13.3 }, { high: 19.3, low: 10.9 }, { high: 15.2, low: 8 }, { high: 10.9, low: 4.8 }, { high: 8.8, low: 3.3 }] },\n  { name: 'San Francisco, CA, US', temperatures: [{ high: 13.8, low: 7.6 }, { high: 15.7, low: 8.6 }, { high: 16.6, low: 9.2 }, { high: 17.3, low: 9.6 }, { high: 17.9, low: 10.6 }, { high: 19.1, low: 11.6 }, { high: 19.2, low: 12.3 }, { high: 20.1, low: 12.8 }, { high: 21.2, low: 12.8 }, { high: 20.7, low: 12.1 }, { high: 17.3, low: 10.1 }, { high: 13.9, low: 7.8 } ] },\n  { name: 'Phoenix, AZ, US', temperatures: [{ high: 19.7, low: 7.6 }, { high: 21.6, low: 9.3 }, { high: 25.1, low: 11.9 }, { high: 29.7, low: 15.7 }, { high: 35, low: 20.7 }, { high: 40.1, low: 25.4 }, { high: 41.2, low: 28.6 }, { high: 40.3, low: 28.2 }, { high: 37.8, low: 24.9 }, { high: 31.5, low: 18.2 }, { high: 24.3, low: 11.4 }, { high: 19, low: 7.1 } ] },\n  { name: 'New York City, NY, US', temperatures: [{ high: 3.5, low: -2.8 }, { high: 5.3, low: -1.7 }, { high: 9.8, low: 1.8 }, { high: 16.2, low: 7.1 }, { high: 21.6, low: 12.2 }, { high: 26.3, low: 17.6 }, { high: 28.9, low: 20.5 }, { high: 28.1, low: 19.9 }, { high: 24, low: 16 }, { high: 17.7, low: 10 }, { high: 12.1, low: 5.3 }, { high: 6.1, low: 0 } ] },\n  { name: 'Buenos Aires, Argentina', temperatures: [{ high: 30.4, low: 20.4 }, { high: 28.7, low: 19.4 }, { high: 26.4, low: 17 }, { high: 22.7, low: 13.7 }, { high: 19, low: 10.3 }, { high: 15.6, low: 7.6 }, { high: 13.9, low: 7.4 }, { high: 17.3, low: 8.9 }, { high: 18.9, low: 9.9 }, { high: 22.5, low: 13 }, { high: 25.3, low: 15.9 }, { high: 28.1, low: 18.4 } ] },\n  { name: 'Sydney, Australia', temperatures: [{ high: 25.9, low: 18.7 }, { high: 25.8, low: 18.8 }, { high: 24.7, low: 17.5 }, { high: 22.4, low: 14.7 }, { high: 19.4, low: 11.5 }, { high: 16.9, low: 9.3 }, { high: 16.3, low: 8 }, { high: 17.8, low: 8.9 }, { high: 20, low: 11.1 }, { high: 22.1, low: 13.5 }, { high: 23.6, low: 15.6 }, { high: 25.2, low: 17.5 } ] },\n  { name: 'Moscow, Russia', temperatures: [{ high: -4, low: -9.1 }, { high: -3.7, low: -9.8 }, { high: 2.6, low: -4.4 }, { high: 11.3, low: 2.2 }, { high: 18.6, low: 7.7 }, { high: 22, low: 12.1 }, { high: 24.3, low: 14.4 }, { high: 21.9, low: 12.5 }, { high: 15.7, low: 7.4 }, { high: 8.7, low: 2.7 }, { high: 0.9, low: -3.3 }, { high: -3, low: -7.6 } ] },\n  { name: 'Berlin, Germany', temperatures: [{ high: 2.9, low: -1.5 }, { high: 4.2, low: -1.6 }, { high: 8.5, low: 1.3 }, { high: 13.2, low: 4.2 }, { high: 18.9, low: 9 }, { high: 21.8, low: 12.3 }, { high: 24, low: 14.7 }, { high: 23.6, low: 14.1 }, { high: 18.8, low: 10.6 }, { high: 13.4, low: 6.4 }, { high: 7.1, low: 2.2 }, { high: 4.4, low: -0.4 } ] },\n  { name: 'Beijing, China', temperatures: [{ high: 1.8, low: -8.4 }, { high: 5, low: -5.6 }, { high: 11.6, low: 0.4 }, { high: 20.3, low: 7.9 }, { high: 26, low: 13.6 }, { high: 30.2, low: 18.8 }, { high: 30.9, low: 22 }, { high: 29.7, low: 20.8 }, { high: 25.8, low: 14.8 }, { high: 19.1, low: 7.9 }, { high: 10.1, low: 0 }, { high: 3.7, low: -5.8 } ] },\n  { name: 'Nairobi, Kenya', temperatures: [{ high: 24.5, low: 11.5 }, { high: 25.6, low: 11.6 }, { high: 25.6, low: 13.1 }, { high: 24.1, low: 14 }, { high: 22.6, low: 13.2 }, { high: 21.5, low: 11 }, { high: 20.6, low: 10.1 }, { high: 21.4, low: 10.2 }, { high: 23.7, low: 10.5 }, { high: 24.7, low: 12.5 }, { high: 23.1, low: 13.1 }, { high: 23.4, low: 12.6 } ] }\n]\n\nvar ractive = new BaseView({\n  el: demo,\n  data: {\n  cities: cities,\n  selectedCity: cities[0]\n  }\n});\n\nractive.observe( 'selectedCity', function ( city ) {\n  ractive.animate( 'temperatures', city.temperatures, {\n  duration: 400,\n  easing: 'easeOut'\n  });\n});\n\n\n\n\nBaseView.html\n\n\nlink rel='ractive' href='TemperatureChart.html'\n\n\n\ndiv class='temperatures'\n\n  \n!-- header and options --\n\n  \ndiv class='chart-header'\n\n    \nh3\nAverage high and low temperature\n/h3\n\n\n    \n!-- switch between celsius and fahrenheit --\n\n    \ndiv class='radio-group'\n\n      \nlabel\n\u00b0C \ninput type='radio' name='{{degreeType}}' value='celsius' checked\n/label\n\n      \nlabel\n\u00b0F \ninput type='radio' name='{{degreeType}}' value='fahrenheit'\n/label\n\n    \n/div\n\n\n    \n!-- dropdown menu --\n\n    \nselect value='{{selectedCity}}'\n\n      {{#each cities}}\n        \noption value='{{this}}'\n{{name}}\n/option\n\n      {{/each}}\n    \n/select\n\n  \n/div\n\n\n  \nTemperatureChart temperatures='{{temperatures}}' degreeType='{{degreeType}}'/\n\n\n/div\n\n\n\nstyle\n\n  .temperatures {\n    position: relative;\n    width: 100%;\n    height: 20em;\n    padding: 1em 0 0 0;\n    background-color: #fafafa;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n\n  .chart-header {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 2em;\n    padding: 0.5em;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n\n  .radio-group {\n    display: inline-block;\n    float: right;\n    text-align: right;\n    padding: 0.5em 0 0 0;\n  }\n\n  .chart-header h3 {\n    font-family: 'Voltaire';\n    font-weight: normal;\n    float: left;\n    margin: 0;\n    border: none;\n  }\n\n  .chart-header select {\n    position: relative;\n    top: 0.1em;\n    float: left;\n    clear: left;\n    font-size: inherit;\n    font-family: inherit;\n    z-index: 7;\n  }\n\n  .chart-header label {\n    position: relative;\n    z-index: 7;\n    display: block;\n  }\n\n  .chart-header p {\n    float: left;\n    clear: left;\n    margin: 0;\n  }\n\n/style\n\n\n\n\n\nTemperatureChart.html\n\n\ndiv class='chart'\n\n  \ndiv class='wrapper'\n \n!-- needed to determine size of SVG element in Firefox --\n\n    \nsvg\n\n\n      \n!-- gradient - higher temperatures are redder, lower temperatures are bluer --\n\n      \ndefs\n\n        \nlinearGradient id='gradient' x2='0' y2='100%' gradientUnits='userSpaceOnUse'\n\n          \nstop offset='0%' stop-color='rgb(255,0,0)' /\n\n          \nstop offset='100%' stop-color='rgb(0,0,255)' /\n\n        \n/linearGradient\n\n      \n/defs\n\n\n      \n!-- horizontal line representing freezing --\n\n      \ng transform='translate( 0, {{ yScale(0) }} )'\n\n        \nline class='freezing' x2='{{width}}'/\n\n        \ntext class='freezing-label-bg' x='{{ xScale(6) }}' y='0.3em'\nfreezing\n/text\n\n        \ntext class='freezing-label' x='{{ xScale(6) }}' y='0.3em'\nfreezing\n/text\n\n      \n/g\n\n\n      \n!-- the band --\n\n      \npolygon fill='url(#gradient)' stroke='url(#gradient)' class='temperature-band' points='{{points}}'/\n\n\n      {{#each temperatures :i}}\n        \n!-- point markers for average highs --\n\n        \ng class='marker' transform='translate({{ xScale(i+0.5) }},{{ yScale(high) }})'\n\n          \ncircle r='2'/\n\n          \ntext y='-10'\n{{ format(high) }}\n/text\n\n        \n/g\n\n\n        \n!-- point markers for average lows --\n\n        \ng class='marker' transform='translate({{ xScale(i+0.5) }},{{ yScale(low) }})'\n\n          \ncircle r='2'/\n\n          \ntext y='15'\n{{ format(low) }}\n/text\n\n        \n/g\n\n      {{/each}}\n    \n/svg\n\n  \n/div\n\n\n  \ndiv class='month-labels'\n\n    {{#monthNames:i}}\n      \nspan style='width: {{ 100 / monthNames.length }}%;'\n{{ monthNames[i] }}\n/span\n\n    {{/monthNames}}\n  \n/div\n\n\n/div\n\n\n\nstyle\n\n  svg {\n    width: 100%;\n    height: 100%;\n  }\n\n  .wrapper {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n\n  .chart {\n    position: relative;\n    padding: 0 0 3em 0;\n    width: 100%;\n    height: 100%;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n\n  .temperature-band {\n    fill-opacity: 0.3;\n    stroke-width: 2;\n  }\n\n  .freezing {\n    stroke: #ccc;\n    stroke-width: 1;\n  }\n\n  .freezing-label-bg, .freezing-label {\n    font-family: 'Helvetica Neue', 'Arial';\n    font-size: 0.8em;\n    text-anchor: middle;\n  }\n\n  .freezing-label-bg {\n    stroke: #fafafa;\n    stroke-width: 4;\n  }\n\n  .freezing-label {\n    stroke: none;\n    fill: #aaa;\n  }\n\n  .marker circle {\n    fill: white;\n    stroke: black;\n    stroke-width: 1;\n  }\n\n  .marker text {\n    text-anchor: middle;\n    font-family: 'Helvetica Neue', 'Arial';\n    font-size: 0.6em;\n    font-weight: bold;\n    fill: #333;\n  }\n\n  .month-labels {\n    position: absolute;\n    left: 0;\n    bottom: 1em;\n    width: 100%;\n  }\n\n  .month-labels span {\n    text-align: center;\n    float: left;\n    display: block;\n    font-family: 'Helvetica Neue', 'Arial';\n    font-size: 0.6em;\n  }\n\n/style\n\n\n\nscript\n\n\n  // this returns a function that scales a value from a given domain\n  // to a given range. Hat-tip to D3\n  function linearScale ( domain, range ) {\n    var d0 = domain[0], r0 = range[0], multipler = ( range[1] - r0 ) / ( domain[1] - d0 );\n\n    return function ( num ) {\n      return r0 + ( ( num - d0 ) * multipler );\n    };\n  }\n\n  // this function takes an array of values, and returns an array of\n  // points plotted according to the given x scale and y scale\n  function plotPoints ( points, xScale, yScale ) {\n    var result = points.map( function ( point, i ) {\n      return xScale( i + 0.5 ) + ',' + yScale( point );\n    });\n\n    // add the december value in front of january, and the january value after\n    // december, to show the cyclicality\n    result.unshift( xScale( -0.5 ) + ',' + yScale( points[ points.length - 1 ] ) );\n    result.push( xScale( points.length + 0.5 ) + ',' + yScale( points[0] ) );\n\n    return result;\n  }\n\n  function getHighPoint ( month ) { return month.high; }\n  function getLowPoint ( month ) { return month.low; }\n\n  component.exports = {\n    onrender: function () {\n      var handleResize = this.resize.bind( this );\n      window.addEventListener( 'resize', handleResize, false );\n\n      this.on( 'unrender', function () {\n        window.removeEventListener( 'resize', handleResize, false );\n      });\n\n      this.wrapper = this.find( '.wrapper' );\n      this.resize();\n    },\n\n    data: function () {\n      return {\n        // dimensions will be set on render\n        width: null,\n        height: null,\n\n        // default to \u00b0c\n        degreeType: 'celsius',\n\n        format: function ( val ) {\n          if ( this.get( 'degreeType' ) === 'fahrenheit' ) {\n            // convert celsius to fahrenheit\n            val = ( val * 1.8 ) + 32;\n          }\n\n          return val.toFixed( 1 ) + '\u00b0';\n        },\n\n        monthNames: [ 'J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D' ]\n      };\n    },\n\n    // because we're using SVG, we need to manually redraw\n    // when the container resizes. You *can* use percentages\n    // instead of pixel/em lengths, but not in transforms\n    resize: function () {\n      this.set({\n        width: this.wrapper.clientWidth,\n        height: this.wrapper.clientHeight\n      });\n    },\n\n    // when the dimensions change, recompute whatever\n    // needs to be recomputed\n    computed: {\n      xScale: function () {\n        return linearScale([ 0, 12 ], [ 0, this.get( 'width' ) ]);\n      },\n\n      yScale: function () {\n        return linearScale([ -10, 42 ], [ this.get( 'height' ) - 20, 25 ]);\n      },\n\n      // this function returns the SVG string for the polygon representing the\n      // temperature band\n      points: function () {\n        var temperatures = this.get( 'temperatures' );\n        if ( !temperatures ) return '';\n\n        var xScale = this.get( 'xScale' );\n        var yScale = this.get( 'yScale' );\n\n        var high = plotPoints( temperatures.map( getHighPoint ), xScale, yScale );\n        var low = plotPoints( temperatures.map( getLowPoint ), xScale, yScale );\n\n        return high.concat( low.reverse() ).join( ' ' );\n      }\n    }\n  };\n\n/script", 
            "title": "Animated Chart"
        }, 
        {
            "location": "/get-started/examples/animated-chart/#animated-chart", 
            "text": "Embed demo here  Making interactive charts is hard. Charts have many components besides the data itself \u2013 controls, axes, labels, annotations \u2013 and they often don't need to update at the same time as each other. Normally, you're faced with a choice between having several different render functions, or wastefully re-rendering the entire chart when things change.  For this reason, dedicated charting libraries have become popular. And that's a shame, because it means you're stuck with line charts and bar charts and pie charts and scatter charts, and don't you dare have any data that's better represented using a less conventional chart type, like this plot of high and low temperatures.  Faced with a choice between freedom and ease of use, many developers turn to  D3 . D3 is a terrific library, and I won't hear a bad word said about it, but it doesn't solve the problem of efficiently updating different components of a chart because it has no concept of state.  Ractive.js takes a fundamentally different approach to other libraries. Rather than programmatically building up the different components of your chart, and writing logic to update those components, you write your SVG the same way you'd write an HTML template. When it's time to update the chart, you just throw the new state at it \u2013 the dependency tracking ensures that we only re-render what's changed. This makes it trivially easy to animate the chart when the user changes city via the drop-down menu.  Note also that we don't need to faff about with event handlers and render logic to switch between celsius and fahrenheit \u2013 when the user switches between them, Ractive.js knows what to do, because the labels' dependency on degreeType is written into the template.", 
            "title": "Animated Chart"
        }, 
        {
            "location": "/get-started/examples/animated-chart/#mainjs", 
            "text": "var cities = [\n  { name: 'London, UK', temperatures: [{ high: 7.9, low: 2.4 }, { high: 8.2, low: 2.2 }, { high: 10.9, low: 3.8 }, { high: 13.3, low: 5.2 }, { high: 17.2, low: 8 }, { high: 20.2, low: 11.1 }, { high: 22.8, low: 13.6 }, { high: 22.6, low: 13.3 }, { high: 19.3, low: 10.9 }, { high: 15.2, low: 8 }, { high: 10.9, low: 4.8 }, { high: 8.8, low: 3.3 }] },\n  { name: 'San Francisco, CA, US', temperatures: [{ high: 13.8, low: 7.6 }, { high: 15.7, low: 8.6 }, { high: 16.6, low: 9.2 }, { high: 17.3, low: 9.6 }, { high: 17.9, low: 10.6 }, { high: 19.1, low: 11.6 }, { high: 19.2, low: 12.3 }, { high: 20.1, low: 12.8 }, { high: 21.2, low: 12.8 }, { high: 20.7, low: 12.1 }, { high: 17.3, low: 10.1 }, { high: 13.9, low: 7.8 } ] },\n  { name: 'Phoenix, AZ, US', temperatures: [{ high: 19.7, low: 7.6 }, { high: 21.6, low: 9.3 }, { high: 25.1, low: 11.9 }, { high: 29.7, low: 15.7 }, { high: 35, low: 20.7 }, { high: 40.1, low: 25.4 }, { high: 41.2, low: 28.6 }, { high: 40.3, low: 28.2 }, { high: 37.8, low: 24.9 }, { high: 31.5, low: 18.2 }, { high: 24.3, low: 11.4 }, { high: 19, low: 7.1 } ] },\n  { name: 'New York City, NY, US', temperatures: [{ high: 3.5, low: -2.8 }, { high: 5.3, low: -1.7 }, { high: 9.8, low: 1.8 }, { high: 16.2, low: 7.1 }, { high: 21.6, low: 12.2 }, { high: 26.3, low: 17.6 }, { high: 28.9, low: 20.5 }, { high: 28.1, low: 19.9 }, { high: 24, low: 16 }, { high: 17.7, low: 10 }, { high: 12.1, low: 5.3 }, { high: 6.1, low: 0 } ] },\n  { name: 'Buenos Aires, Argentina', temperatures: [{ high: 30.4, low: 20.4 }, { high: 28.7, low: 19.4 }, { high: 26.4, low: 17 }, { high: 22.7, low: 13.7 }, { high: 19, low: 10.3 }, { high: 15.6, low: 7.6 }, { high: 13.9, low: 7.4 }, { high: 17.3, low: 8.9 }, { high: 18.9, low: 9.9 }, { high: 22.5, low: 13 }, { high: 25.3, low: 15.9 }, { high: 28.1, low: 18.4 } ] },\n  { name: 'Sydney, Australia', temperatures: [{ high: 25.9, low: 18.7 }, { high: 25.8, low: 18.8 }, { high: 24.7, low: 17.5 }, { high: 22.4, low: 14.7 }, { high: 19.4, low: 11.5 }, { high: 16.9, low: 9.3 }, { high: 16.3, low: 8 }, { high: 17.8, low: 8.9 }, { high: 20, low: 11.1 }, { high: 22.1, low: 13.5 }, { high: 23.6, low: 15.6 }, { high: 25.2, low: 17.5 } ] },\n  { name: 'Moscow, Russia', temperatures: [{ high: -4, low: -9.1 }, { high: -3.7, low: -9.8 }, { high: 2.6, low: -4.4 }, { high: 11.3, low: 2.2 }, { high: 18.6, low: 7.7 }, { high: 22, low: 12.1 }, { high: 24.3, low: 14.4 }, { high: 21.9, low: 12.5 }, { high: 15.7, low: 7.4 }, { high: 8.7, low: 2.7 }, { high: 0.9, low: -3.3 }, { high: -3, low: -7.6 } ] },\n  { name: 'Berlin, Germany', temperatures: [{ high: 2.9, low: -1.5 }, { high: 4.2, low: -1.6 }, { high: 8.5, low: 1.3 }, { high: 13.2, low: 4.2 }, { high: 18.9, low: 9 }, { high: 21.8, low: 12.3 }, { high: 24, low: 14.7 }, { high: 23.6, low: 14.1 }, { high: 18.8, low: 10.6 }, { high: 13.4, low: 6.4 }, { high: 7.1, low: 2.2 }, { high: 4.4, low: -0.4 } ] },\n  { name: 'Beijing, China', temperatures: [{ high: 1.8, low: -8.4 }, { high: 5, low: -5.6 }, { high: 11.6, low: 0.4 }, { high: 20.3, low: 7.9 }, { high: 26, low: 13.6 }, { high: 30.2, low: 18.8 }, { high: 30.9, low: 22 }, { high: 29.7, low: 20.8 }, { high: 25.8, low: 14.8 }, { high: 19.1, low: 7.9 }, { high: 10.1, low: 0 }, { high: 3.7, low: -5.8 } ] },\n  { name: 'Nairobi, Kenya', temperatures: [{ high: 24.5, low: 11.5 }, { high: 25.6, low: 11.6 }, { high: 25.6, low: 13.1 }, { high: 24.1, low: 14 }, { high: 22.6, low: 13.2 }, { high: 21.5, low: 11 }, { high: 20.6, low: 10.1 }, { high: 21.4, low: 10.2 }, { high: 23.7, low: 10.5 }, { high: 24.7, low: 12.5 }, { high: 23.1, low: 13.1 }, { high: 23.4, low: 12.6 } ] }\n]\n\nvar ractive = new BaseView({\n  el: demo,\n  data: {\n  cities: cities,\n  selectedCity: cities[0]\n  }\n});\n\nractive.observe( 'selectedCity', function ( city ) {\n  ractive.animate( 'temperatures', city.temperatures, {\n  duration: 400,\n  easing: 'easeOut'\n  });\n});", 
            "title": "main.js"
        }, 
        {
            "location": "/get-started/examples/animated-chart/#baseviewhtml", 
            "text": "link rel='ractive' href='TemperatureChart.html'  div class='temperatures' \n   !-- header and options -- \n   div class='chart-header' \n     h3 Average high and low temperature /h3 \n\n     !-- switch between celsius and fahrenheit -- \n     div class='radio-group' \n       label \u00b0C  input type='radio' name='{{degreeType}}' value='celsius' checked /label \n       label \u00b0F  input type='radio' name='{{degreeType}}' value='fahrenheit' /label \n     /div \n\n     !-- dropdown menu -- \n     select value='{{selectedCity}}' \n      {{#each cities}}\n         option value='{{this}}' {{name}} /option \n      {{/each}}\n     /select \n   /div \n\n   TemperatureChart temperatures='{{temperatures}}' degreeType='{{degreeType}}'/  /div  style \n  .temperatures {\n    position: relative;\n    width: 100%;\n    height: 20em;\n    padding: 1em 0 0 0;\n    background-color: #fafafa;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n\n  .chart-header {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 2em;\n    padding: 0.5em;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n\n  .radio-group {\n    display: inline-block;\n    float: right;\n    text-align: right;\n    padding: 0.5em 0 0 0;\n  }\n\n  .chart-header h3 {\n    font-family: 'Voltaire';\n    font-weight: normal;\n    float: left;\n    margin: 0;\n    border: none;\n  }\n\n  .chart-header select {\n    position: relative;\n    top: 0.1em;\n    float: left;\n    clear: left;\n    font-size: inherit;\n    font-family: inherit;\n    z-index: 7;\n  }\n\n  .chart-header label {\n    position: relative;\n    z-index: 7;\n    display: block;\n  }\n\n  .chart-header p {\n    float: left;\n    clear: left;\n    margin: 0;\n  } /style", 
            "title": "BaseView.html"
        }, 
        {
            "location": "/get-started/examples/animated-chart/#temperaturecharthtml", 
            "text": "div class='chart' \n   div class='wrapper'   !-- needed to determine size of SVG element in Firefox -- \n     svg \n\n       !-- gradient - higher temperatures are redder, lower temperatures are bluer -- \n       defs \n         linearGradient id='gradient' x2='0' y2='100%' gradientUnits='userSpaceOnUse' \n           stop offset='0%' stop-color='rgb(255,0,0)' / \n           stop offset='100%' stop-color='rgb(0,0,255)' / \n         /linearGradient \n       /defs \n\n       !-- horizontal line representing freezing -- \n       g transform='translate( 0, {{ yScale(0) }} )' \n         line class='freezing' x2='{{width}}'/ \n         text class='freezing-label-bg' x='{{ xScale(6) }}' y='0.3em' freezing /text \n         text class='freezing-label' x='{{ xScale(6) }}' y='0.3em' freezing /text \n       /g \n\n       !-- the band -- \n       polygon fill='url(#gradient)' stroke='url(#gradient)' class='temperature-band' points='{{points}}'/ \n\n      {{#each temperatures :i}}\n         !-- point markers for average highs -- \n         g class='marker' transform='translate({{ xScale(i+0.5) }},{{ yScale(high) }})' \n           circle r='2'/ \n           text y='-10' {{ format(high) }} /text \n         /g \n\n         !-- point markers for average lows -- \n         g class='marker' transform='translate({{ xScale(i+0.5) }},{{ yScale(low) }})' \n           circle r='2'/ \n           text y='15' {{ format(low) }} /text \n         /g \n      {{/each}}\n     /svg \n   /div \n\n   div class='month-labels' \n    {{#monthNames:i}}\n       span style='width: {{ 100 / monthNames.length }}%;' {{ monthNames[i] }} /span \n    {{/monthNames}}\n   /div  /div  style \n  svg {\n    width: 100%;\n    height: 100%;\n  }\n\n  .wrapper {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n\n  .chart {\n    position: relative;\n    padding: 0 0 3em 0;\n    width: 100%;\n    height: 100%;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n\n  .temperature-band {\n    fill-opacity: 0.3;\n    stroke-width: 2;\n  }\n\n  .freezing {\n    stroke: #ccc;\n    stroke-width: 1;\n  }\n\n  .freezing-label-bg, .freezing-label {\n    font-family: 'Helvetica Neue', 'Arial';\n    font-size: 0.8em;\n    text-anchor: middle;\n  }\n\n  .freezing-label-bg {\n    stroke: #fafafa;\n    stroke-width: 4;\n  }\n\n  .freezing-label {\n    stroke: none;\n    fill: #aaa;\n  }\n\n  .marker circle {\n    fill: white;\n    stroke: black;\n    stroke-width: 1;\n  }\n\n  .marker text {\n    text-anchor: middle;\n    font-family: 'Helvetica Neue', 'Arial';\n    font-size: 0.6em;\n    font-weight: bold;\n    fill: #333;\n  }\n\n  .month-labels {\n    position: absolute;\n    left: 0;\n    bottom: 1em;\n    width: 100%;\n  }\n\n  .month-labels span {\n    text-align: center;\n    float: left;\n    display: block;\n    font-family: 'Helvetica Neue', 'Arial';\n    font-size: 0.6em;\n  } /style  script \n\n  // this returns a function that scales a value from a given domain\n  // to a given range. Hat-tip to D3\n  function linearScale ( domain, range ) {\n    var d0 = domain[0], r0 = range[0], multipler = ( range[1] - r0 ) / ( domain[1] - d0 );\n\n    return function ( num ) {\n      return r0 + ( ( num - d0 ) * multipler );\n    };\n  }\n\n  // this function takes an array of values, and returns an array of\n  // points plotted according to the given x scale and y scale\n  function plotPoints ( points, xScale, yScale ) {\n    var result = points.map( function ( point, i ) {\n      return xScale( i + 0.5 ) + ',' + yScale( point );\n    });\n\n    // add the december value in front of january, and the january value after\n    // december, to show the cyclicality\n    result.unshift( xScale( -0.5 ) + ',' + yScale( points[ points.length - 1 ] ) );\n    result.push( xScale( points.length + 0.5 ) + ',' + yScale( points[0] ) );\n\n    return result;\n  }\n\n  function getHighPoint ( month ) { return month.high; }\n  function getLowPoint ( month ) { return month.low; }\n\n  component.exports = {\n    onrender: function () {\n      var handleResize = this.resize.bind( this );\n      window.addEventListener( 'resize', handleResize, false );\n\n      this.on( 'unrender', function () {\n        window.removeEventListener( 'resize', handleResize, false );\n      });\n\n      this.wrapper = this.find( '.wrapper' );\n      this.resize();\n    },\n\n    data: function () {\n      return {\n        // dimensions will be set on render\n        width: null,\n        height: null,\n\n        // default to \u00b0c\n        degreeType: 'celsius',\n\n        format: function ( val ) {\n          if ( this.get( 'degreeType' ) === 'fahrenheit' ) {\n            // convert celsius to fahrenheit\n            val = ( val * 1.8 ) + 32;\n          }\n\n          return val.toFixed( 1 ) + '\u00b0';\n        },\n\n        monthNames: [ 'J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D' ]\n      };\n    },\n\n    // because we're using SVG, we need to manually redraw\n    // when the container resizes. You *can* use percentages\n    // instead of pixel/em lengths, but not in transforms\n    resize: function () {\n      this.set({\n        width: this.wrapper.clientWidth,\n        height: this.wrapper.clientHeight\n      });\n    },\n\n    // when the dimensions change, recompute whatever\n    // needs to be recomputed\n    computed: {\n      xScale: function () {\n        return linearScale([ 0, 12 ], [ 0, this.get( 'width' ) ]);\n      },\n\n      yScale: function () {\n        return linearScale([ -10, 42 ], [ this.get( 'height' ) - 20, 25 ]);\n      },\n\n      // this function returns the SVG string for the polygon representing the\n      // temperature band\n      points: function () {\n        var temperatures = this.get( 'temperatures' );\n        if ( !temperatures ) return '';\n\n        var xScale = this.get( 'xScale' );\n        var yScale = this.get( 'yScale' );\n\n        var high = plotPoints( temperatures.map( getHighPoint ), xScale, yScale );\n        var low = plotPoints( temperatures.map( getLowPoint ), xScale, yScale );\n\n        return high.concat( low.reverse() ).join( ' ' );\n      }\n    }\n  }; /script", 
            "title": "TemperatureChart.html"
        }, 
        {
            "location": "/get-started/examples/comments/", 
            "text": "Comments\n\n\nThis example uses the \nmarked\n library to convert markdown to HTML, before rendering it with a 'triple-stache'. (Note that Ractive.js doesn't sanitize HTML before inserting it \u2013 that's the app's responsibility.)\n\n\nAfter the comment is created, a newComment event is fired. This would allow us to, for example, save the new comment to a server.\n\n\nmain.js\n\n\n// populate our app with some sample comments\nvar sampleComments = [\n  { author: 'Rich', text: 'FIRST!!!' },\n  { author: 'anonymous', text: 'I disagree with the previous commenter' },\n  { author: 'Samuel L. Ipsum', text: \nIf they don't know, that means we never told anyone. And if we never told anyone it means we never made it back. Hence we die down here. Just as a matter of deductive logic.\\n\\nYou think water moves fast? You should see ice. It moves like it has a mind. Like it knows it killed the world once and got a taste for murder.\n },\n  { author: 'Jon Grubber', text: '**Hey you guys!** I can use [markdown](http://daringfireball.net/projects/markdown/) in my posts' }\n];\n\nvar ractive = new CommentWidget({\n  el: demo,\n  data: {\n    comments: sampleComments\n  }\n});\n\nractive.on( 'newComment', function ( comment ) {\n  console.log( 'saving to server...', comment );\n});\n\n\n\n\nComment.html\n\n\ndiv class='comment-block' intro='slide'\n\n  \nh4 class='comment-author'\n{{author}}\n/h4\n\n\n  \n!-- we're using a triple-stache to render the comment body. There\n    is a theoretical security risk in that triples insert HTML\n    without sanitizing it, so a user could submit a comment with an\n    XSS attack hidden in it, which would affect other users.\n\n    In a real-life app, make sure you sanitize on the server\n    before sending data to clients! --\n\n  \ndiv class='comment-text'\n{{{ marked(text) }}}\n/div\n\n\n/div\n\n\n\nstyle\n\n  h3, h4 {\n    font-family: 'Voltaire';\n  }\n\n  h4 {\n    margin: 0;\n  }\n\n  .comment-block {\n    position: relative;\n    padding: 0 0 0 10em;\n    margin: 0 0 1em 0;\n  }\n\n  .comment-author {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 9em;\n    background-color: #eee;\n    padding: 0.5em;\n  }\n\n  .comment-text {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    border-top: 1px solid #eee;\n    padding: 0.5em 0.5em 0.5em 1em;\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n  }\n\n  .comment-text p:last-child {\n    margin: 0;\n  }\n\n/style\n\n\n\nscript\n\n  component.exports = {\n    data: {\n      marked: require( 'marked' )\n    },\n\n    transitions: {\n      slide: require( 'ractive-transitions-slide' )\n    }\n  };\n\n/script\n\n\n\n\n\nCommentWidget.html\n\n\nlink rel='ractive' href='Comment.html'\n\n\n{{#each comments}}\n  \nComment author='{{author}}' text='{{text}}'/\n\n{{/each}}\n\n\nform on-submit='post(event, { author: author, text: text })'\n\n  \n!-- author name --\n\n  \ninput class='author-name' value='{{author}}' placeholder='Your name' required\n\n\n  \n!-- comment body --\n\n  \ntextarea value='{{text}}' placeholder='Say something...' required\n/textarea\n\n\n  \n!-- 'submit comment' button --\n\n  \ninput type='submit' value='Submit comment'\n\n\n/form\n\n\n\nstyle\n\n  form {\n    position: relative;\n    padding: 0 0 0 10.5em;\n  }\n\n  .author-name {\n    position: absolute;\n    left: 0;\n    top: 0;\n    font-size: inherit;\n    font-family: inherit;\n    width: 10em;\n    padding: 0.5em;\n    margin: 0;\n    border: 1px solid #eee;\n    box-shadow: inset 1px 1px 3px rgba(0,0,0,0.1);\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n  }\n\n  textarea {\n    font-size: inherit;\n    font-family: inherit;\n    width: 100%;\n    height: 5em;\n    padding: 0.5em;\n    border: 1px solid #eee;\n    box-shadow: inset 1px 1px 3px rgba(0,0,0,0.1);\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n  }\n\n  input[type=\nsubmit\n] {\n    background-color: #729d34;\n    border: none;\n    padding: 0.5em;\n    font-size: inherit;\n    font-family: 'Voltaire';\n    color: white;\n    opacity: 0.5;\n    cursor: pointer;\n  }\n\n  input[type=\nsubmit\n]:hover, input[type=\nsubmit\n]:focus {\n    opacity: 1;\n    outline: none;\n  }\n\n/style\n\n\n\nscript\n\n  component.exports = {\n    post: function ( event, comment ) {\n      // prevent the page from reloading\n      event.original.preventDefault();\n\n      // add to the list of comments\n      this.push( 'comments', comment );\n\n      // fire an event, so we can (for example)\n      // save the comment to our server\n      this.fire( 'newComment', comment );\n\n      // reset the form\n      document.activeElement.blur();\n      this.set({ author: '', text: '' });\n    }\n  };\n\n/script", 
            "title": "Comments"
        }, 
        {
            "location": "/get-started/examples/comments/#comments", 
            "text": "This example uses the  marked  library to convert markdown to HTML, before rendering it with a 'triple-stache'. (Note that Ractive.js doesn't sanitize HTML before inserting it \u2013 that's the app's responsibility.)  After the comment is created, a newComment event is fired. This would allow us to, for example, save the new comment to a server.", 
            "title": "Comments"
        }, 
        {
            "location": "/get-started/examples/comments/#mainjs", 
            "text": "// populate our app with some sample comments\nvar sampleComments = [\n  { author: 'Rich', text: 'FIRST!!!' },\n  { author: 'anonymous', text: 'I disagree with the previous commenter' },\n  { author: 'Samuel L. Ipsum', text:  If they don't know, that means we never told anyone. And if we never told anyone it means we never made it back. Hence we die down here. Just as a matter of deductive logic.\\n\\nYou think water moves fast? You should see ice. It moves like it has a mind. Like it knows it killed the world once and got a taste for murder.  },\n  { author: 'Jon Grubber', text: '**Hey you guys!** I can use [markdown](http://daringfireball.net/projects/markdown/) in my posts' }\n];\n\nvar ractive = new CommentWidget({\n  el: demo,\n  data: {\n    comments: sampleComments\n  }\n});\n\nractive.on( 'newComment', function ( comment ) {\n  console.log( 'saving to server...', comment );\n});", 
            "title": "main.js"
        }, 
        {
            "location": "/get-started/examples/comments/#commenthtml", 
            "text": "div class='comment-block' intro='slide' \n   h4 class='comment-author' {{author}} /h4 \n\n   !-- we're using a triple-stache to render the comment body. There\n    is a theoretical security risk in that triples insert HTML\n    without sanitizing it, so a user could submit a comment with an\n    XSS attack hidden in it, which would affect other users.\n\n    In a real-life app, make sure you sanitize on the server\n    before sending data to clients! -- \n   div class='comment-text' {{{ marked(text) }}} /div  /div  style \n  h3, h4 {\n    font-family: 'Voltaire';\n  }\n\n  h4 {\n    margin: 0;\n  }\n\n  .comment-block {\n    position: relative;\n    padding: 0 0 0 10em;\n    margin: 0 0 1em 0;\n  }\n\n  .comment-author {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 9em;\n    background-color: #eee;\n    padding: 0.5em;\n  }\n\n  .comment-text {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    border-top: 1px solid #eee;\n    padding: 0.5em 0.5em 0.5em 1em;\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n  }\n\n  .comment-text p:last-child {\n    margin: 0;\n  } /style  script \n  component.exports = {\n    data: {\n      marked: require( 'marked' )\n    },\n\n    transitions: {\n      slide: require( 'ractive-transitions-slide' )\n    }\n  }; /script", 
            "title": "Comment.html"
        }, 
        {
            "location": "/get-started/examples/comments/#commentwidgethtml", 
            "text": "link rel='ractive' href='Comment.html' \n\n{{#each comments}}\n   Comment author='{{author}}' text='{{text}}'/ \n{{/each}} form on-submit='post(event, { author: author, text: text })' \n   !-- author name -- \n   input class='author-name' value='{{author}}' placeholder='Your name' required \n\n   !-- comment body -- \n   textarea value='{{text}}' placeholder='Say something...' required /textarea \n\n   !-- 'submit comment' button -- \n   input type='submit' value='Submit comment'  /form  style \n  form {\n    position: relative;\n    padding: 0 0 0 10.5em;\n  }\n\n  .author-name {\n    position: absolute;\n    left: 0;\n    top: 0;\n    font-size: inherit;\n    font-family: inherit;\n    width: 10em;\n    padding: 0.5em;\n    margin: 0;\n    border: 1px solid #eee;\n    box-shadow: inset 1px 1px 3px rgba(0,0,0,0.1);\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n  }\n\n  textarea {\n    font-size: inherit;\n    font-family: inherit;\n    width: 100%;\n    height: 5em;\n    padding: 0.5em;\n    border: 1px solid #eee;\n    box-shadow: inset 1px 1px 3px rgba(0,0,0,0.1);\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n  }\n\n  input[type= submit ] {\n    background-color: #729d34;\n    border: none;\n    padding: 0.5em;\n    font-size: inherit;\n    font-family: 'Voltaire';\n    color: white;\n    opacity: 0.5;\n    cursor: pointer;\n  }\n\n  input[type= submit ]:hover, input[type= submit ]:focus {\n    opacity: 1;\n    outline: none;\n  } /style  script \n  component.exports = {\n    post: function ( event, comment ) {\n      // prevent the page from reloading\n      event.original.preventDefault();\n\n      // add to the list of comments\n      this.push( 'comments', comment );\n\n      // fire an event, so we can (for example)\n      // save the comment to our server\n      this.fire( 'newComment', comment );\n\n      // reset the form\n      document.activeElement.blur();\n      this.set({ author: '', text: '' });\n    }\n  }; /script", 
            "title": "CommentWidget.html"
        }, 
        {
            "location": "/get-started/examples/donut-chart/", 
            "text": "Donut Chart\n\n\nEmbed demo here\n\n\n\n\nmain.js\n\n\nvar ractive = new BaseView({\n  el: demo,\n  data: getData()\n});\n\nfunction getData () {\n  return {\n    months: [\n      { name: 'January',   points: { dogs: 4, cats: 3, rabbits: 7 } },\n      { name: 'February',  points: { dogs: 2, cats: 7, rabbits: 3 } },\n      { name: 'March',     points: { dogs: 5, cats: 4, rabbits: 6 } },\n      { name: 'April',     points: { dogs: 6, cats: 8, rabbits: 4 } },\n      { name: 'May',       points: { dogs: 8, cats: 9, rabbits: 5 } },\n      { name: 'June',      points: { dogs: 3, cats: 2, rabbits: 2 } },\n      { name: 'July',      points: { dogs: 4, cats: 4, rabbits: 8 } },\n      { name: 'August',    points: { dogs: 2, cats: 5, rabbits: 9 } },\n      { name: 'September', points: { dogs: 3, cats: 6, rabbits: 4 } },\n      { name: 'October',   points: { dogs: 7, cats: 2, rabbits: 7 } },\n      { name: 'November',  points: { dogs: 5, cats: 8, rabbits: 5 } },\n      { name: 'December',  points: { dogs: 1, cats: 0, rabbits: 7 } }\n    ]\n  };\n}\n\n\n\n\nBaseView.html\n\n\nlink rel='ractive' href='DonutChart.html'\n\n\n\n!-- legend --\n\n\nul\n\n  {{#each colors}}\n    \nli\n\n      \nspan class='block' style='background-color: {{this}}'\n/span\n\n      \nspan\n{{@key}}\n/span\n\n    \n/li\n\n  {{/each}}\n\n/ul\n\n\n{{#each months:i}}\n  \nDonutChart style='width: 16.666%;' points='{{points}}' selected='{{id}}' delay='{{i*50}}'\n\n    \np\n{{name}}\n/p\n\n  \n/DonutChart\n\n{{/each}}\n\n\nstyle\n\n  p {\n    text-align: center;\n  }\n\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  li {\n    display: inline-block;\n    margin: 0 0 0 1em;\n  }\n\n  .block {\n    position: relative;\n    top: 0.1em;\n    display: inline-block;\n    width: 1em;\n    height: 1em;\n    margin: 0 0.1em 0 0;\n    border-radius: 50%;\n  }\n\n/style\n\n\n\nscript\n\n  component.exports = {\n    data: function () {\n      return {\n        id: null,\n        colors: {\n          dogs: '#000064',\n          cats: '#729d34',\n          rabbits: '#5050b4'\n        }\n      };\n    }\n  };\n\n/script\n\n\n\n\n\nDonutChart.html\n\n\ndiv class='donut-chart' style='{{style}}'\n\n  \ndiv class='square'\n\n    \nsvg viewBox='0 0 100 100'\n\n      \ng transform='translate(50,50)'\n\n        {{#each segments :i}}\n          \npolygon\n            on-mouseover='set(\nselected\n,id)'\n            on-mouseout='set(\nselected\n,null)'\n            class='donut-segment'\n            fill='{{colors[id]}}'\n            opacity='{{selected ? ( selected === id ? 1 : 0.2 ) :1}}'\n            points='{{plot(this)}}'\n          \n\n        {{/each}}\n\n        {{#if selected}}\n          \ntext intro-outro='fade' y='6'\n{{points[selected]}}\n/text\n\n        {{/if}}\n      \n/g\n\n    \n/svg\n\n  \n/div\n\n\n  {{yield}}\n\n/div\n\n\n\nscript\n\n  component.exports = {\n    oninit: function () {\n      var self = this, delay = this.get( 'delay' );\n\n      // wait a bit, then animate in\n      setTimeout( function () {\n        self.animate( 'c', Math.PI * 2, {\n          duration: 800,\n          easing: 'easeOut'\n        });\n      }, delay );\n    },\n\n    data: {\n      c: 0, // we animate from zero to Math.PI * 2 (the number of radians in a circle)\n      innerRadius: 20,\n      outerRadius: 45,\n\n      plot: function ( segment ) {\n        var innerRadius = this.get( 'innerRadius' );\n        var outerRadius = this.get( 'outerRadius' );\n        var c = this.get( 'c' ); // allows us to animate intro\n\n        var start = segment.start * c;\n        var end = segment.end * c;\n\n        function getPoint ( angle, radius ) {\n          return ( ( radius * Math.sin( angle ) ).toFixed( 2 ) + ',' + ( radius * -Math.cos( angle ) ).toFixed( 2 ) );\n        }\n\n        var points = [];\n        var angle;\n\n        // get points along the outer edge of the segment\n        for ( angle = start; angle \n end; angle += 0.05 ) {\n          points.push( getPoint( angle, outerRadius ) );\n        }\n\n        points.push( getPoint( end, outerRadius ) );\n\n        // get points along the inner edge of the segment\n        for ( angle = end; angle \n start; angle -= 0.05 ) {\n          points.push( getPoint( angle, innerRadius ) );\n        }\n\n        points.push( getPoint( start, innerRadius ) );\n\n        // join them up as an SVG points list\n        return points.join( ' ' );\n      }\n    },\n\n    computed: {\n      segments: function () {\n        var points = this.get( 'points' );\n\n        var keys = Object.keys( points ).sort( function ( a, b ) {\n          return points[b] - points[a];\n        });\n\n        // tally up the total value\n        var total = keys.reduce( function ( total, id ) {\n          return total + points[id];\n        }, 0 );\n\n        // find the start and end point of each segment\n        var start = 0;\n\n        return keys.map( function ( id ) {\n          var size = points[id] / total, end = start + size, segment;\n\n          segment = {\n            id: id,\n            start: start,\n            end: end\n          };\n\n          start = end;\n          return segment;\n        });\n      }\n    },\n\n    transitions: {\n      fade: require( 'ractive-transitions-fade' )\n    }\n  };\n\n/script\n\n\n\nstyle\n\n  .donut-chart {\n    float: left;\n  }\n\n  .square {\n    position: relative;\n    width: 100%;\n    height: 0;\n    padding: 0 0 100% 0;\n  }\n\n  svg {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n  }\n\n  polygon {\n    stroke: white;\n    stroke-width: 1;\n    -webkit-transition: opacity 0.2s;\n    transition: opacity 0.2s;\n  }\n\n  text {\n    text-anchor: middle;\n    font-size: 1.2em;\n    font-weight: 900;\n    fill: #999;\n  }\n\n/style", 
            "title": "Donut Chart"
        }, 
        {
            "location": "/get-started/examples/donut-chart/#donut-chart", 
            "text": "Embed demo here", 
            "title": "Donut Chart"
        }, 
        {
            "location": "/get-started/examples/donut-chart/#mainjs", 
            "text": "var ractive = new BaseView({\n  el: demo,\n  data: getData()\n});\n\nfunction getData () {\n  return {\n    months: [\n      { name: 'January',   points: { dogs: 4, cats: 3, rabbits: 7 } },\n      { name: 'February',  points: { dogs: 2, cats: 7, rabbits: 3 } },\n      { name: 'March',     points: { dogs: 5, cats: 4, rabbits: 6 } },\n      { name: 'April',     points: { dogs: 6, cats: 8, rabbits: 4 } },\n      { name: 'May',       points: { dogs: 8, cats: 9, rabbits: 5 } },\n      { name: 'June',      points: { dogs: 3, cats: 2, rabbits: 2 } },\n      { name: 'July',      points: { dogs: 4, cats: 4, rabbits: 8 } },\n      { name: 'August',    points: { dogs: 2, cats: 5, rabbits: 9 } },\n      { name: 'September', points: { dogs: 3, cats: 6, rabbits: 4 } },\n      { name: 'October',   points: { dogs: 7, cats: 2, rabbits: 7 } },\n      { name: 'November',  points: { dogs: 5, cats: 8, rabbits: 5 } },\n      { name: 'December',  points: { dogs: 1, cats: 0, rabbits: 7 } }\n    ]\n  };\n}", 
            "title": "main.js"
        }, 
        {
            "location": "/get-started/examples/donut-chart/#baseviewhtml", 
            "text": "link rel='ractive' href='DonutChart.html'  !-- legend --  ul \n  {{#each colors}}\n     li \n       span class='block' style='background-color: {{this}}' /span \n       span {{@key}} /span \n     /li \n  {{/each}} /ul \n\n{{#each months:i}}\n   DonutChart style='width: 16.666%;' points='{{points}}' selected='{{id}}' delay='{{i*50}}' \n     p {{name}} /p \n   /DonutChart \n{{/each}} style \n  p {\n    text-align: center;\n  }\n\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  li {\n    display: inline-block;\n    margin: 0 0 0 1em;\n  }\n\n  .block {\n    position: relative;\n    top: 0.1em;\n    display: inline-block;\n    width: 1em;\n    height: 1em;\n    margin: 0 0.1em 0 0;\n    border-radius: 50%;\n  } /style  script \n  component.exports = {\n    data: function () {\n      return {\n        id: null,\n        colors: {\n          dogs: '#000064',\n          cats: '#729d34',\n          rabbits: '#5050b4'\n        }\n      };\n    }\n  }; /script", 
            "title": "BaseView.html"
        }, 
        {
            "location": "/get-started/examples/donut-chart/#donutcharthtml", 
            "text": "div class='donut-chart' style='{{style}}' \n   div class='square' \n     svg viewBox='0 0 100 100' \n       g transform='translate(50,50)' \n        {{#each segments :i}}\n           polygon\n            on-mouseover='set( selected ,id)'\n            on-mouseout='set( selected ,null)'\n            class='donut-segment'\n            fill='{{colors[id]}}'\n            opacity='{{selected ? ( selected === id ? 1 : 0.2 ) :1}}'\n            points='{{plot(this)}}'\n           \n        {{/each}}\n\n        {{#if selected}}\n           text intro-outro='fade' y='6' {{points[selected]}} /text \n        {{/if}}\n       /g \n     /svg \n   /div \n\n  {{yield}} /div  script \n  component.exports = {\n    oninit: function () {\n      var self = this, delay = this.get( 'delay' );\n\n      // wait a bit, then animate in\n      setTimeout( function () {\n        self.animate( 'c', Math.PI * 2, {\n          duration: 800,\n          easing: 'easeOut'\n        });\n      }, delay );\n    },\n\n    data: {\n      c: 0, // we animate from zero to Math.PI * 2 (the number of radians in a circle)\n      innerRadius: 20,\n      outerRadius: 45,\n\n      plot: function ( segment ) {\n        var innerRadius = this.get( 'innerRadius' );\n        var outerRadius = this.get( 'outerRadius' );\n        var c = this.get( 'c' ); // allows us to animate intro\n\n        var start = segment.start * c;\n        var end = segment.end * c;\n\n        function getPoint ( angle, radius ) {\n          return ( ( radius * Math.sin( angle ) ).toFixed( 2 ) + ',' + ( radius * -Math.cos( angle ) ).toFixed( 2 ) );\n        }\n\n        var points = [];\n        var angle;\n\n        // get points along the outer edge of the segment\n        for ( angle = start; angle   end; angle += 0.05 ) {\n          points.push( getPoint( angle, outerRadius ) );\n        }\n\n        points.push( getPoint( end, outerRadius ) );\n\n        // get points along the inner edge of the segment\n        for ( angle = end; angle   start; angle -= 0.05 ) {\n          points.push( getPoint( angle, innerRadius ) );\n        }\n\n        points.push( getPoint( start, innerRadius ) );\n\n        // join them up as an SVG points list\n        return points.join( ' ' );\n      }\n    },\n\n    computed: {\n      segments: function () {\n        var points = this.get( 'points' );\n\n        var keys = Object.keys( points ).sort( function ( a, b ) {\n          return points[b] - points[a];\n        });\n\n        // tally up the total value\n        var total = keys.reduce( function ( total, id ) {\n          return total + points[id];\n        }, 0 );\n\n        // find the start and end point of each segment\n        var start = 0;\n\n        return keys.map( function ( id ) {\n          var size = points[id] / total, end = start + size, segment;\n\n          segment = {\n            id: id,\n            start: start,\n            end: end\n          };\n\n          start = end;\n          return segment;\n        });\n      }\n    },\n\n    transitions: {\n      fade: require( 'ractive-transitions-fade' )\n    }\n  }; /script  style \n  .donut-chart {\n    float: left;\n  }\n\n  .square {\n    position: relative;\n    width: 100%;\n    height: 0;\n    padding: 0 0 100% 0;\n  }\n\n  svg {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n  }\n\n  polygon {\n    stroke: white;\n    stroke-width: 1;\n    -webkit-transition: opacity 0.2s;\n    transition: opacity 0.2s;\n  }\n\n  text {\n    text-anchor: middle;\n    font-size: 1.2em;\n    font-weight: 900;\n    fill: #999;\n  } /style", 
            "title": "DonutChart.html"
        }, 
        {
            "location": "/get-started/examples/illustration/", 
            "text": "Illustration\n\n\nTODO: Simplify. MkDocs indexer appears to index the heavy SVG.", 
            "title": "Illustration"
        }, 
        {
            "location": "/get-started/examples/illustration/#illustration", 
            "text": "TODO: Simplify. MkDocs indexer appears to index the heavy SVG.", 
            "title": "Illustration"
        }, 
        {
            "location": "/get-started/examples/rating-stars/", 
            "text": "Rating Stars\n\n\nEmbed demo here\n\n\n\n\nCreating a simple star rating widget is the kind of thing that quickly turns to spaghetti if you try and build it by hand, or even with jQuery \u2013 lots of manually adding and removing classes, probably using tricks like \n$.index()\n or \nthis.getAttribute('data-index')\n and other such horrors.\n\n\nBecause Ractive.js uses dependency tracking to keep the view in sync - with the minimum DOM manipulation possible - there are no such headaches.\n\n\nmain.js\n\n\nvar ractive = new BaseView({\n  el: demo,\n  data: {\n    rating: 5\n  }\n});\n\n// if you wanted to save the rating...\nractive.observe( 'rating', function ( rating ) {\n  console.log( 'saving to server: ', rating );\n}, { init: false }); // init: false so it doesn't save until it changes\n\n\n\n\nBaseView.html\n\n\nlink rel='ractive' href='Rating.html'\n\n\n\np class='current-rating'\ncurrent rating: \nstrong\n{{rating}}\n/strong\n/p\n\n\n\ndiv class='ratings'\n\n  \nh3\nClickable Rating\n/h3\n\n  \nRating max='10' rating='{{rating}}'/\n\n\n  \nh3\nReadonly rating\n/h3\n\n  \nRating max='10' rating='{{rating}}' readonly/\n\n\n/div\n\n\n\nstyle\n\n  h3 {\n    font-family: 'Voltaire';\n  }\n\n  .current-rating {\n    float: left;\n    margin-right: 2em;\n    padding-top: 2em;\n    text-align: center;\n  }\n\n  .current-rating strong {\n    display: block;\n    clear: both;\n    font-size: 6em;\n    font-family: 'Voltaire';\n  }\n\n  .ratings {\n    float: left;\n    border-left: 1px solid #eee;\n    padding-left: 1em;\n  }\n\n/style\n\n\n\n\n\nRating.html\n\n\ndiv class='rating {{readonly ? \nreadonly\n : \n}}' on-mouseout='highlight(0)'\n\n  {{#each stars:i}}\n    \nspan class='star {{ rating \n i ? \nselected\n : \n }} {{ highlighted \n i ? \nhighlighted\n : \n }}'\n          on-tap='select(i+1)'\n          on-mouseover='highlight(i+1)'\n    \n#9733;\n/span\n\n  {{/each}}\n\n/div\n\n\n\nscript\n\n  component.exports = {\n    computed: {\n      // we generate an array of length `max`, so that\n      // we can iterate over it in the template\n      stars: function () {\n        var max = this.get( 'max' );\n        return new Array( max );\n      }\n    },\n\n    select: function ( rating ) {\n      if ( !this.get( 'readonly' ) ) {\n        this.set( 'rating', rating );\n      }\n    },\n\n    highlight: function ( rating ) {\n      if ( !this.get( 'readonly' ) ) {\n        this.set( 'highlighted', rating );\n      }\n    },\n\n    events: {\n      // use the mobile-friendly tap plugin\n      tap: require( 'ractive-events-tap' )\n    }\n  }\n\n/script\n\n\n\nstyle\n\n  .rating {\n    margin: 0 0 1em 0;\n  }\n\n  .rating:after {\n    content: '';\n    display: table;\n    clear: both;\n  }\n\n  .star {\n    font-size: 2em;\n    color: #eee;\n    cursor: pointer;\n    display: block;\n    float: left;\n  }\n\n  .readonly .star {\n    cursor: default;\n  }\n\n  .highlighted {\n    color: #ccc;\n  }\n\n  .selected {\n    color: #729d34;\n  }\n\n/style", 
            "title": "Rating Sars"
        }, 
        {
            "location": "/get-started/examples/rating-stars/#rating-stars", 
            "text": "Embed demo here  Creating a simple star rating widget is the kind of thing that quickly turns to spaghetti if you try and build it by hand, or even with jQuery \u2013 lots of manually adding and removing classes, probably using tricks like  $.index()  or  this.getAttribute('data-index')  and other such horrors.  Because Ractive.js uses dependency tracking to keep the view in sync - with the minimum DOM manipulation possible - there are no such headaches.", 
            "title": "Rating Stars"
        }, 
        {
            "location": "/get-started/examples/rating-stars/#mainjs", 
            "text": "var ractive = new BaseView({\n  el: demo,\n  data: {\n    rating: 5\n  }\n});\n\n// if you wanted to save the rating...\nractive.observe( 'rating', function ( rating ) {\n  console.log( 'saving to server: ', rating );\n}, { init: false }); // init: false so it doesn't save until it changes", 
            "title": "main.js"
        }, 
        {
            "location": "/get-started/examples/rating-stars/#baseviewhtml", 
            "text": "link rel='ractive' href='Rating.html'  p class='current-rating' current rating:  strong {{rating}} /strong /p  div class='ratings' \n   h3 Clickable Rating /h3 \n   Rating max='10' rating='{{rating}}'/ \n\n   h3 Readonly rating /h3 \n   Rating max='10' rating='{{rating}}' readonly/  /div  style \n  h3 {\n    font-family: 'Voltaire';\n  }\n\n  .current-rating {\n    float: left;\n    margin-right: 2em;\n    padding-top: 2em;\n    text-align: center;\n  }\n\n  .current-rating strong {\n    display: block;\n    clear: both;\n    font-size: 6em;\n    font-family: 'Voltaire';\n  }\n\n  .ratings {\n    float: left;\n    border-left: 1px solid #eee;\n    padding-left: 1em;\n  } /style", 
            "title": "BaseView.html"
        }, 
        {
            "location": "/get-started/examples/rating-stars/#ratinghtml", 
            "text": "div class='rating {{readonly ?  readonly  :  }}' on-mouseout='highlight(0)' \n  {{#each stars:i}}\n     span class='star {{ rating   i ?  selected  :   }} {{ highlighted   i ?  highlighted  :   }}'\n          on-tap='select(i+1)'\n          on-mouseover='highlight(i+1)'\n     #9733; /span \n  {{/each}} /div  script \n  component.exports = {\n    computed: {\n      // we generate an array of length `max`, so that\n      // we can iterate over it in the template\n      stars: function () {\n        var max = this.get( 'max' );\n        return new Array( max );\n      }\n    },\n\n    select: function ( rating ) {\n      if ( !this.get( 'readonly' ) ) {\n        this.set( 'rating', rating );\n      }\n    },\n\n    highlight: function ( rating ) {\n      if ( !this.get( 'readonly' ) ) {\n        this.set( 'highlighted', rating );\n      }\n    },\n\n    events: {\n      // use the mobile-friendly tap plugin\n      tap: require( 'ractive-events-tap' )\n    }\n  } /script  style \n  .rating {\n    margin: 0 0 1em 0;\n  }\n\n  .rating:after {\n    content: '';\n    display: table;\n    clear: both;\n  }\n\n  .star {\n    font-size: 2em;\n    color: #eee;\n    cursor: pointer;\n    display: block;\n    float: left;\n  }\n\n  .readonly .star {\n    cursor: default;\n  }\n\n  .highlighted {\n    color: #ccc;\n  }\n\n  .selected {\n    color: #729d34;\n  } /style", 
            "title": "Rating.html"
        }, 
        {
            "location": "/get-started/examples/todo-list/", 
            "text": "Todo List\n\n\nEmbed demo here\n\n\n\n\nThis is an adaptation of the \nTodoMVC\n application. Ractive.js doesn't take a side in the MVC wars \u2013 it aims to be architecturally agnostic \u2013 so whereas other TodoMVC implementations have a strict separation between models, views and controllers, Ractive.js encourages you to structure your app around \ncomponents\n, but ultimately lets you do things however you want.\n\n\nWith MVC frameworks, you'll typically do something like \nmodel.set(key, value)\n or \ncollection.add(model)\n to manipulate your data in a way that keeps the view in sync. Ractive flips this script on its head - you call methods on your Ractive instance instead. That means your data can consist of plain old JavaScript objects and arrays - no framework lock-in or interoperability woes.\n\n\nmain.js\n\n\nvar items;\n\n// try to load from localStorage\ntry {\n  items = JSON.parse( localStorage.todoItems );\n} catch ( err ) {}\n\nif ( !items ) {\n  items = [\n    { completed: true,  description: 'Add a todo' },\n    { completed: false, description: 'Add some more todos' },\n    { completed: false, description: 'Build something with Ractive.js' }\n  ]\n}\n\nvar ractive = new TodoList({\n  el: demo,\n  data: {\n    items: items\n  }\n});\n\n// persist changes to localStorage if possible\nractive.observe( 'items', function ( items ) {\n  try {\n    localStorage.todoItems = JSON.stringify( items );\n  } catch ( err ) {}\n});\n\n\n\n\nTodoList.html\n\n\ndiv class='todo-app'\n\n  \nheader\n\n    \ninput\n      class='new-todo'\n      on-change='createTodo(event)'\n      placeholder='What needs to be done?'\n      autofocus\n    \n\n  \n/header\n\n\n  {{#if items.length}} \n!-- only show when there are one or more items --\n\n    \nsection class='main'\n\n\n      \n!-- 'toggle all' button --\n\n      \ndiv class='toggle-all-container'\n\n        \nlabel for='toggle-all'\nMark all as complete\n/label\n\n        \ninput\n          name='toggle-all'\n          class='toggle toggle-all'\n          type='checkbox'\n          on-change='toggleAll(event)'\n          twoway='false'\n          checked='{{ items.length === completedTodos.length }}'\n        \n\n      \n/div\n\n\n      \n!-- the actual list --\n\n      \nul class='todo-list'\n\n        {{#each items:i}}\n          {{#if filter(this)}}\n            \nli\n              intro-outro='slide:fast'\n              class='item {{ completed ? \ncompleted\n : \n }} {{ currentlyEditing === i ? \nediting\n : \n }}'\n            \n\n              \ndiv class='view'\n\n                \ninput class='toggle' type='checkbox' checked='{{completed}}'\n\n                \nlabel on-dblclick='set(\ncurrentlyEditing\n,i)'\n{{description}}\n/label\n\n                \nbutton on-tap='splice(\nitems\n, i, 1)' class='destroy'\n/button\n\n              \n/div\n\n\n              {{#if currentlyEditing === i}}\n                \ndiv class='edit-container'\n\n                  \ninput\n                    decorator='select'\n                    class='edit'\n                    value='{{description}}'\n                    on-blur-change='submitEdit(event, i)'\n                  \n\n                \n/div\n\n              {{/if}}\n            \n/li\n\n          {{/if}}\n        {{/each}}\n      \n/ul\n\n    \n/section\n\n\n    \nsection class='footer' intro='fade' outro='slide'\n\n      \nspan class='todo-count'\n\n        \nstrong\n{{ activeTodos.length }}\n/strong\n {{ activeTodos.length === 1 ? 'item' : 'items' }} left\n      \n/span\n\n\n      \n!-- switch filters --\n\n      \nul class='filters'\n\n        \nli\n          class='{{ currentFilter === \nall\n ? \nselected\n : \n }}'\n          on-tap='set(\ncurrentFilter\n,\nall\n)'\n        \nAll\n/li\n\n\n        \nli\n          class='{{ currentFilter === \nactive\n ? \nselected\n : \n }}'\n          on-tap='set(\ncurrentFilter\n,\nactive\n)'\n        \nActive\n/li\n\n\n        \nli\n          class='{{ currentFilter === \ncompleted\n ? \nselected\n : \n }}'\n          on-tap='set(\ncurrentFilter\n,\ncompleted\n)'\n        \nCompleted\n/li\n\n      \n/ul\n\n\n      \n!-- hidden if no completed items are left --\n\n      {{#if completedTodos.length }}\n        \nbutton class='clear-completed' on-tap='clearCompleted()'\n\n          Clear completed ({{ completedTodos.length }})\n        \n/button\n\n      {{/if}}\n    \n/section\n\n  {{/if}}\n\n/div\n\n\n\n\nscript\n\n  // set up some filters\n  var filters = {\n    completed: function ( item ) { return item.completed; },\n    active: function ( item ) { return !item.completed; },\n    all: function () { return true; }\n  };\n\n  component.exports = {\n    data: function () {\n      return {\n        filters: filters,\n        currentFilter: 'all'\n      };\n    },\n\n    computed: {\n      completedTodos: function () {\n        return this.get( 'items' ).filter( filters.completed );\n      },\n\n      activeTodos: function () {\n        return this.get( 'items' ).filter( filters.active );\n      },\n\n      filter: function () {\n        return filters[ this.get( 'currentFilter' ) ];\n      }\n    },\n\n    // Methods for interacting with the list\n    createTodo: function ( event ) {\n      this.push( 'items', {\n        description: event.node.value,\n        completed: false\n      });\n\n      event.node.value = ''; // reset\n    },\n\n    submitEdit: function ( event, index ) {\n      this.set( 'items[' + index + '].description', event.node.value );\n      this.set( 'currentlyEditing', null );\n    },\n\n    clearCompleted: function () {\n      var items = this.get( 'items' );\n      var i = items.length;\n\n      while ( i-- ) {\n        if ( items[i].completed ) {\n          this.splice( 'items', i, 1 );\n        }\n      }\n    },\n\n    toggleAll: function ( event ) {\n      this.set( 'items[*].completed', event.node.checked );\n    },\n\n    // Event and transition plugins\n    events: {\n      tap: require( 'ractive-events-tap' )\n    },\n\n    transitions: {\n      slide: require( 'ractive-transitions-slide' )\n    },\n\n    // Decorators allow you to interact with DOM nodes\n    // when they are created or destroyed. In this case,\n    // we want to select the contents of the edit \ninput\n\n    // as soon as it's created\n    decorators: {\n      select: function ( node ) {\n        setTimeout( function () {\n          node.select();\n        });\n\n        return {\n          // teardown is a noop\n          teardown: function () {}\n        };\n      }\n    },\n\n    // disable slide transitions during initial render\n    noIntro: true\n  };\n\n/script\n\n\n\nstyle\n\n  button, button:hover, button:active, button:focus {\n    border: none;\n    background: none;\n    margin: 0;\n  }\n\n  header {\n    padding: 0;\n    margin: 0;\n  }\n\n  .new-todo,\n  .edit {\n    margin: 0;\n    width: 100%;\n    font-size: 24px;\n    font-family: inherit;\n    outline: none;\n    color: inherit;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n\n  .new-todo {\n    padding: 16px 16px 16px 60px;\n    border: 1px dotted #ddd;\n  }\n\n  .edit {\n    padding: 6px;\n    border: 1px solid #999;\n    box-shadow: inset 1px 1px 5px 0 rgba(0, 0, 0, 0.2);\n  }\n\n  label[for='toggle-all'] {\n    display: none;\n  }\n\n  .toggle-all-container {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 40px;\n    height: 4em;\n  }\n\n  .toggle-all {\n    position: absolute;\n    top: -42px;\n    left: -4px;\n    width: 40px;\n    text-align: center;\n    border: none; /* Mobile Safari */\n  }\n\n  .todo-list {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n\n  .item {\n    position: relative;\n    font-size: 24px;\n    border-bottom: 1px dotted #ccc;\n    margin: 0;\n  }\n\n  .view {\n    padding: 0 40px;\n  }\n\n  .item:last-child {\n    border-bottom: none;\n  }\n\n  .item.editing {\n    border-bottom: none;\n    padding: 0;\n  }\n\n  .item.editing .edit {\n    display: block;\n    width: 100%;\n    padding: 13px 17px 12px 61px;\n    margin: 0;\n  }\n\n  .item.editing .view {\n    display: none;\n  }\n\n  .toggle {\n    text-align: center;\n    width: 40px;\n    /* auto, since non-WebKit browsers doesn't support input styling */\n    height: auto;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    margin: auto 0;\n    outline: none;\n    border: none; /* Mobile Safari */\n    -webkit-appearance: none;\n    /*-moz-appearance: none;*/\n    -ms-appearance: none;\n    -o-appearance: none;\n    appearance: none;\n  }\n\n  .toggle:after {\n    content: '\\2713';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%,-50%);\n    font-size: 20px;\n    color: #d9d9d9;\n    text-shadow: 0 -1px 0 #bfbfbf;\n  }\n\n  .toggle:checked:after {\n    color: #729d34;\n    text-shadow: 0 1px 0 #669991;\n  }\n\n  .toggle-all::after {\n    font-size: 28px;\n  }\n\n  .item label {\n    word-break: break-word;\n    padding: 15px;\n    margin-left: 5px;\n    display: block;\n    line-height: 1.2;\n    -webkit-transition: color 0.4s;\n    -moz-transition: color 0.4s;\n    -ms-transition: color 0.4s;\n    -o-transition: color 0.4s;\n    transition: color 0.4s;\n  }\n\n  .item.completed label {\n    color: #a9a9a9;\n    text-decoration: line-through;\n  }\n\n  .item .destroy {\n    display: none;\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 40px;\n    height: 100%;\n    font-size: 22px;\n    color: rgb(180,0,0);\n    opacity: 0.3;\n    cursor: pointer;\n    -webkit-transition: all 0.2s;\n    transition: all 0.2s;\n  }\n\n  .item .destroy:hover {\n    opacity: 1;\n  }\n\n  .item .destroy:after {\n    position: absolute;\n    top: 55%;\n    left: 50%;\n    transform: translate(-50%,-50%);\n    content: '\\274C';\n    line-height: 1;\n  }\n\n  .item:hover .destroy {\n    display: block;\n  }\n\n  .item.editing:last-child {\n    margin-bottom: -1px;\n  }\n\n  .footer {\n    position: relative;\n    height: 1.3em;\n    color: #777;\n    z-index: 1;\n    text-align: center;\n    background: #f9f9f9;\n    padding: 0.5em;\n    border-top: 1px dotted #adadad;\n  }\n\n  .todo-count {\n    float: left;\n    text-align: left;\n  }\n\n  .filters {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n    position: absolute;\n    right: 0;\n    left: 0;\n  }\n\n  .filters li {\n    display: inline;\n    color: #83756f;\n    margin: 2px;\n    text-decoration: none;\n    cursor: pointer;\n  }\n\n  li.selected {\n    font-weight: bold;\n  }\n\n  .clear-completed {\n    float: right;\n    position: relative;\n    line-height: 20px;\n    text-decoration: none;\n    background: rgba(0, 0, 0, 0.1);\n    font-size: 11px;\n    padding: 0 10px;\n    border-radius: 3px;\n    box-shadow: 0 -1px 0 0 rgba(0, 0, 0, 0.2);\n  }\n\n  .clear-completed:hover {\n    background: rgba(0, 0, 0, 0.15);\n    box-shadow: 0 -1px 0 0 rgba(0, 0, 0, 0.3);\n  }\n\n/style", 
            "title": "ToDo List"
        }, 
        {
            "location": "/get-started/examples/todo-list/#todo-list", 
            "text": "Embed demo here  This is an adaptation of the  TodoMVC  application. Ractive.js doesn't take a side in the MVC wars \u2013 it aims to be architecturally agnostic \u2013 so whereas other TodoMVC implementations have a strict separation between models, views and controllers, Ractive.js encourages you to structure your app around  components , but ultimately lets you do things however you want.  With MVC frameworks, you'll typically do something like  model.set(key, value)  or  collection.add(model)  to manipulate your data in a way that keeps the view in sync. Ractive flips this script on its head - you call methods on your Ractive instance instead. That means your data can consist of plain old JavaScript objects and arrays - no framework lock-in or interoperability woes.", 
            "title": "Todo List"
        }, 
        {
            "location": "/get-started/examples/todo-list/#mainjs", 
            "text": "var items;\n\n// try to load from localStorage\ntry {\n  items = JSON.parse( localStorage.todoItems );\n} catch ( err ) {}\n\nif ( !items ) {\n  items = [\n    { completed: true,  description: 'Add a todo' },\n    { completed: false, description: 'Add some more todos' },\n    { completed: false, description: 'Build something with Ractive.js' }\n  ]\n}\n\nvar ractive = new TodoList({\n  el: demo,\n  data: {\n    items: items\n  }\n});\n\n// persist changes to localStorage if possible\nractive.observe( 'items', function ( items ) {\n  try {\n    localStorage.todoItems = JSON.stringify( items );\n  } catch ( err ) {}\n});", 
            "title": "main.js"
        }, 
        {
            "location": "/get-started/examples/todo-list/#todolisthtml", 
            "text": "div class='todo-app' \n   header \n     input\n      class='new-todo'\n      on-change='createTodo(event)'\n      placeholder='What needs to be done?'\n      autofocus\n     \n   /header \n\n  {{#if items.length}}  !-- only show when there are one or more items -- \n     section class='main' \n\n       !-- 'toggle all' button -- \n       div class='toggle-all-container' \n         label for='toggle-all' Mark all as complete /label \n         input\n          name='toggle-all'\n          class='toggle toggle-all'\n          type='checkbox'\n          on-change='toggleAll(event)'\n          twoway='false'\n          checked='{{ items.length === completedTodos.length }}'\n         \n       /div \n\n       !-- the actual list -- \n       ul class='todo-list' \n        {{#each items:i}}\n          {{#if filter(this)}}\n             li\n              intro-outro='slide:fast'\n              class='item {{ completed ?  completed  :   }} {{ currentlyEditing === i ?  editing  :   }}'\n             \n               div class='view' \n                 input class='toggle' type='checkbox' checked='{{completed}}' \n                 label on-dblclick='set( currentlyEditing ,i)' {{description}} /label \n                 button on-tap='splice( items , i, 1)' class='destroy' /button \n               /div \n\n              {{#if currentlyEditing === i}}\n                 div class='edit-container' \n                   input\n                    decorator='select'\n                    class='edit'\n                    value='{{description}}'\n                    on-blur-change='submitEdit(event, i)'\n                   \n                 /div \n              {{/if}}\n             /li \n          {{/if}}\n        {{/each}}\n       /ul \n     /section \n\n     section class='footer' intro='fade' outro='slide' \n       span class='todo-count' \n         strong {{ activeTodos.length }} /strong  {{ activeTodos.length === 1 ? 'item' : 'items' }} left\n       /span \n\n       !-- switch filters -- \n       ul class='filters' \n         li\n          class='{{ currentFilter ===  all  ?  selected  :   }}'\n          on-tap='set( currentFilter , all )'\n         All /li \n\n         li\n          class='{{ currentFilter ===  active  ?  selected  :   }}'\n          on-tap='set( currentFilter , active )'\n         Active /li \n\n         li\n          class='{{ currentFilter ===  completed  ?  selected  :   }}'\n          on-tap='set( currentFilter , completed )'\n         Completed /li \n       /ul \n\n       !-- hidden if no completed items are left -- \n      {{#if completedTodos.length }}\n         button class='clear-completed' on-tap='clearCompleted()' \n          Clear completed ({{ completedTodos.length }})\n         /button \n      {{/if}}\n     /section \n  {{/if}} /div  script \n  // set up some filters\n  var filters = {\n    completed: function ( item ) { return item.completed; },\n    active: function ( item ) { return !item.completed; },\n    all: function () { return true; }\n  };\n\n  component.exports = {\n    data: function () {\n      return {\n        filters: filters,\n        currentFilter: 'all'\n      };\n    },\n\n    computed: {\n      completedTodos: function () {\n        return this.get( 'items' ).filter( filters.completed );\n      },\n\n      activeTodos: function () {\n        return this.get( 'items' ).filter( filters.active );\n      },\n\n      filter: function () {\n        return filters[ this.get( 'currentFilter' ) ];\n      }\n    },\n\n    // Methods for interacting with the list\n    createTodo: function ( event ) {\n      this.push( 'items', {\n        description: event.node.value,\n        completed: false\n      });\n\n      event.node.value = ''; // reset\n    },\n\n    submitEdit: function ( event, index ) {\n      this.set( 'items[' + index + '].description', event.node.value );\n      this.set( 'currentlyEditing', null );\n    },\n\n    clearCompleted: function () {\n      var items = this.get( 'items' );\n      var i = items.length;\n\n      while ( i-- ) {\n        if ( items[i].completed ) {\n          this.splice( 'items', i, 1 );\n        }\n      }\n    },\n\n    toggleAll: function ( event ) {\n      this.set( 'items[*].completed', event.node.checked );\n    },\n\n    // Event and transition plugins\n    events: {\n      tap: require( 'ractive-events-tap' )\n    },\n\n    transitions: {\n      slide: require( 'ractive-transitions-slide' )\n    },\n\n    // Decorators allow you to interact with DOM nodes\n    // when they are created or destroyed. In this case,\n    // we want to select the contents of the edit  input \n    // as soon as it's created\n    decorators: {\n      select: function ( node ) {\n        setTimeout( function () {\n          node.select();\n        });\n\n        return {\n          // teardown is a noop\n          teardown: function () {}\n        };\n      }\n    },\n\n    // disable slide transitions during initial render\n    noIntro: true\n  }; /script  style \n  button, button:hover, button:active, button:focus {\n    border: none;\n    background: none;\n    margin: 0;\n  }\n\n  header {\n    padding: 0;\n    margin: 0;\n  }\n\n  .new-todo,\n  .edit {\n    margin: 0;\n    width: 100%;\n    font-size: 24px;\n    font-family: inherit;\n    outline: none;\n    color: inherit;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n\n  .new-todo {\n    padding: 16px 16px 16px 60px;\n    border: 1px dotted #ddd;\n  }\n\n  .edit {\n    padding: 6px;\n    border: 1px solid #999;\n    box-shadow: inset 1px 1px 5px 0 rgba(0, 0, 0, 0.2);\n  }\n\n  label[for='toggle-all'] {\n    display: none;\n  }\n\n  .toggle-all-container {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 40px;\n    height: 4em;\n  }\n\n  .toggle-all {\n    position: absolute;\n    top: -42px;\n    left: -4px;\n    width: 40px;\n    text-align: center;\n    border: none; /* Mobile Safari */\n  }\n\n  .todo-list {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n\n  .item {\n    position: relative;\n    font-size: 24px;\n    border-bottom: 1px dotted #ccc;\n    margin: 0;\n  }\n\n  .view {\n    padding: 0 40px;\n  }\n\n  .item:last-child {\n    border-bottom: none;\n  }\n\n  .item.editing {\n    border-bottom: none;\n    padding: 0;\n  }\n\n  .item.editing .edit {\n    display: block;\n    width: 100%;\n    padding: 13px 17px 12px 61px;\n    margin: 0;\n  }\n\n  .item.editing .view {\n    display: none;\n  }\n\n  .toggle {\n    text-align: center;\n    width: 40px;\n    /* auto, since non-WebKit browsers doesn't support input styling */\n    height: auto;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    margin: auto 0;\n    outline: none;\n    border: none; /* Mobile Safari */\n    -webkit-appearance: none;\n    /*-moz-appearance: none;*/\n    -ms-appearance: none;\n    -o-appearance: none;\n    appearance: none;\n  }\n\n  .toggle:after {\n    content: '\\2713';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%,-50%);\n    font-size: 20px;\n    color: #d9d9d9;\n    text-shadow: 0 -1px 0 #bfbfbf;\n  }\n\n  .toggle:checked:after {\n    color: #729d34;\n    text-shadow: 0 1px 0 #669991;\n  }\n\n  .toggle-all::after {\n    font-size: 28px;\n  }\n\n  .item label {\n    word-break: break-word;\n    padding: 15px;\n    margin-left: 5px;\n    display: block;\n    line-height: 1.2;\n    -webkit-transition: color 0.4s;\n    -moz-transition: color 0.4s;\n    -ms-transition: color 0.4s;\n    -o-transition: color 0.4s;\n    transition: color 0.4s;\n  }\n\n  .item.completed label {\n    color: #a9a9a9;\n    text-decoration: line-through;\n  }\n\n  .item .destroy {\n    display: none;\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 40px;\n    height: 100%;\n    font-size: 22px;\n    color: rgb(180,0,0);\n    opacity: 0.3;\n    cursor: pointer;\n    -webkit-transition: all 0.2s;\n    transition: all 0.2s;\n  }\n\n  .item .destroy:hover {\n    opacity: 1;\n  }\n\n  .item .destroy:after {\n    position: absolute;\n    top: 55%;\n    left: 50%;\n    transform: translate(-50%,-50%);\n    content: '\\274C';\n    line-height: 1;\n  }\n\n  .item:hover .destroy {\n    display: block;\n  }\n\n  .item.editing:last-child {\n    margin-bottom: -1px;\n  }\n\n  .footer {\n    position: relative;\n    height: 1.3em;\n    color: #777;\n    z-index: 1;\n    text-align: center;\n    background: #f9f9f9;\n    padding: 0.5em;\n    border-top: 1px dotted #adadad;\n  }\n\n  .todo-count {\n    float: left;\n    text-align: left;\n  }\n\n  .filters {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n    position: absolute;\n    right: 0;\n    left: 0;\n  }\n\n  .filters li {\n    display: inline;\n    color: #83756f;\n    margin: 2px;\n    text-decoration: none;\n    cursor: pointer;\n  }\n\n  li.selected {\n    font-weight: bold;\n  }\n\n  .clear-completed {\n    float: right;\n    position: relative;\n    line-height: 20px;\n    text-decoration: none;\n    background: rgba(0, 0, 0, 0.1);\n    font-size: 11px;\n    padding: 0 10px;\n    border-radius: 3px;\n    box-shadow: 0 -1px 0 0 rgba(0, 0, 0, 0.2);\n  }\n\n  .clear-completed:hover {\n    background: rgba(0, 0, 0, 0.15);\n    box-shadow: 0 -1px 0 0 rgba(0, 0, 0, 0.3);\n  } /style", 
            "title": "TodoList.html"
        }, 
        {
            "location": "/get-started/debugging/", 
            "text": "Debugging\n\n\nUsing \nRactive.getNodeInfo()\n for debugging\n\n\nRactive.getNodeInfo()\n is a function that allows you to grab the Ractive instance that holds a specific node. This is especially helpful together with Chrome Dev Tools' \n$0\n global which references the last selected element in the Element Inspector. You can simply select the element in the Element Inspector and call \nRactive.getNodeInfo($0)\n in the console to inspect the Ractive instance.\n\n\nUsing the \ndebugger\n statement\n\n\nSome loaders transform component files into Ractive components on the fly using \nnew Function\n. As such, you cannot simply look for the file and put breakpoints. In situations like this, you will have to use the \ndebugger\n statement to put breakpoints on dynamically generated code.", 
            "title": "Debugging"
        }, 
        {
            "location": "/get-started/debugging/#debugging", 
            "text": "", 
            "title": "Debugging"
        }, 
        {
            "location": "/get-started/debugging/#using-ractivegetnodeinfo-for-debugging", 
            "text": "Ractive.getNodeInfo()  is a function that allows you to grab the Ractive instance that holds a specific node. This is especially helpful together with Chrome Dev Tools'  $0  global which references the last selected element in the Element Inspector. You can simply select the element in the Element Inspector and call  Ractive.getNodeInfo($0)  in the console to inspect the Ractive instance.", 
            "title": "Using Ractive.getNodeInfo() for debugging"
        }, 
        {
            "location": "/get-started/debugging/#using-the-debugger-statement", 
            "text": "Some loaders transform component files into Ractive components on the fly using  new Function . As such, you cannot simply look for the file and put breakpoints. In situations like this, you will have to use the  debugger  statement to put breakpoints on dynamically generated code.", 
            "title": "Using the debugger statement"
        }, 
        {
            "location": "/get-started/support/", 
            "text": "Support\n\n\nGetting in touch\n\n\nThere are a lot of places to find help if you get stuck with Ractive:\n\n\n\n\nStackOverflow\n\n\nGoogle Groups\n\n\nGitHub\n\n\nTwitter\n\n\nGitter\n\n\n\n\nLegacy versions\n\n\nThe current site only documents the latest version of Ractive. Legacy versions are \ncurrently stored in Github\n.\n\n\nLegacy browsers\n\n\nThe core Ractive library requires the following APIs need to be present:\n\n\n\n\nArray.isArray\n\n\nArray.prototype.every\n\n\nArray.prototype.filter\n\n\nArray.prototype.forEach\n\n\nArray.prototype.indexOf\n\n\nArray.prototype.map\n\n\nArray.prototype.reduce\n\n\nDate.now\n\n\nFunction.prototype.bind\n\n\nNode.prototype.contains\n\n\nObject.create\n\n\nObject.defineProperty\n\n\nObject.freeze\n\n\nObject.keys\n\n\nPromise\n\n\nrequestAnimationFrame\n\n\nString.prototype.trim\n\n\nwindow.addEventListener\n\n\nwindow.getComputedStyle\n\n\n\n\nMost \nmodern\n browsers already support these APIs\n. Should you want to serve your app on older browsers, Ractive comes with an optional file called \npolyfills.js\n containing these specific polyfills. That way, you can still enjoy the full Ractive experience without lugging in a huge polyfill library. Simply load it up before Ractive.\n\n\nSVGs\n\n\nRactive doesn't mind whether you're rendering HTML or SVG - it treats both the same way. Unfortunately, some browsers (notably IE8 and below, and Android 2.3 and below) \ndo\n care.\n\n\n\n\nThis browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See https://github.com/RactiveJS/Ractive/wiki/SVG-and-older-browsers for more information\n\n\n\n\nIf your template includes SVG and these browsers throw an error along those lines, \nthe only winning move is not to play\n. You will need to provide an alternate fallback when SVG isn't supported. Ractive provides \nRactive.svg\n to indicate if the browser handles SVGs properly.\n\n\nnew Ractive({\n  el: 'container',\n  template: Ractive.svg ? awesomeVectorGraphicsContent : highResolutionImageContent\n});", 
            "title": "Support"
        }, 
        {
            "location": "/get-started/support/#support", 
            "text": "", 
            "title": "Support"
        }, 
        {
            "location": "/get-started/support/#getting-in-touch", 
            "text": "There are a lot of places to find help if you get stuck with Ractive:   StackOverflow  Google Groups  GitHub  Twitter  Gitter", 
            "title": "Getting in touch"
        }, 
        {
            "location": "/get-started/support/#legacy-versions", 
            "text": "The current site only documents the latest version of Ractive. Legacy versions are  currently stored in Github .", 
            "title": "Legacy versions"
        }, 
        {
            "location": "/get-started/support/#legacy-browsers", 
            "text": "The core Ractive library requires the following APIs need to be present:   Array.isArray  Array.prototype.every  Array.prototype.filter  Array.prototype.forEach  Array.prototype.indexOf  Array.prototype.map  Array.prototype.reduce  Date.now  Function.prototype.bind  Node.prototype.contains  Object.create  Object.defineProperty  Object.freeze  Object.keys  Promise  requestAnimationFrame  String.prototype.trim  window.addEventListener  window.getComputedStyle   Most  modern  browsers already support these APIs . Should you want to serve your app on older browsers, Ractive comes with an optional file called  polyfills.js  containing these specific polyfills. That way, you can still enjoy the full Ractive experience without lugging in a huge polyfill library. Simply load it up before Ractive.", 
            "title": "Legacy browsers"
        }, 
        {
            "location": "/get-started/support/#svgs", 
            "text": "Ractive doesn't mind whether you're rendering HTML or SVG - it treats both the same way. Unfortunately, some browsers (notably IE8 and below, and Android 2.3 and below)  do  care.   This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See https://github.com/RactiveJS/Ractive/wiki/SVG-and-older-browsers for more information   If your template includes SVG and these browsers throw an error along those lines,  the only winning move is not to play . You will need to provide an alternate fallback when SVG isn't supported. Ractive provides  Ractive.svg  to indicate if the browser handles SVGs properly.  new Ractive({\n  el: 'container',\n  template: Ractive.svg ? awesomeVectorGraphicsContent : highResolutionImageContent\n});", 
            "title": "SVGs"
        }, 
        {
            "location": "/get-started/contributing/", 
            "text": "Contributing\n\n\nRactive is a community-driven project. Most of its best features were \nsuggested by users like you\n. There are a lot of ways you can contribute to the project. Here are a few examples:\n\n\nContribute code\n\n\nRaising issues, reporting bugs, feature requests, enhancements, optimizations, all forms of contributions welcome! . Just go over the \nCONTRIBUTING.md\n and select your course of action.\n\n\nWrite documentation\n\n\nIf you've spotted a typo, a section you can explain better, or if you're just better in The Queen's English than we are, your help is greatly appreciated. Each page in the documentation is just \na file written in markdown\n. All you need is a text editor to get started.\n\n\nWrite plugins\n\n\nExtend Ractive in ways you've never seen before. Interface with other libraries, create effects, widgets, interactions, custom elements, and so much more with Ractive's very extensible core.\n\n\nRefer to \nPlugins\n for details on how to start writing Ractive plugins.\n\n\nHelp other developers\n\n\nSubscribe to \nStack Overflow questions tagged with \nractivejs\n, and you'll get alerts when someone asks a question that you might be able to answer.\n\n\nSpread the word\n\n\nTweet\n, write blog posts, recommend it to your friends, submit talks (here are some \ntips on speaking at tech meetups\n). These are just a few ways to spread the word about Ractive. The larger the community, the better it becomes.\n\n\nBuild stuff\n\n\nBut above all, build stuff! If you make something with Ractive, we'd love to hear about it.", 
            "title": "Contributing"
        }, 
        {
            "location": "/get-started/contributing/#contributing", 
            "text": "Ractive is a community-driven project. Most of its best features were  suggested by users like you . There are a lot of ways you can contribute to the project. Here are a few examples:", 
            "title": "Contributing"
        }, 
        {
            "location": "/get-started/contributing/#contribute-code", 
            "text": "Raising issues, reporting bugs, feature requests, enhancements, optimizations, all forms of contributions welcome! . Just go over the  CONTRIBUTING.md  and select your course of action.", 
            "title": "Contribute code"
        }, 
        {
            "location": "/get-started/contributing/#write-documentation", 
            "text": "If you've spotted a typo, a section you can explain better, or if you're just better in The Queen's English than we are, your help is greatly appreciated. Each page in the documentation is just  a file written in markdown . All you need is a text editor to get started.", 
            "title": "Write documentation"
        }, 
        {
            "location": "/get-started/contributing/#write-plugins", 
            "text": "Extend Ractive in ways you've never seen before. Interface with other libraries, create effects, widgets, interactions, custom elements, and so much more with Ractive's very extensible core.  Refer to  Plugins  for details on how to start writing Ractive plugins.", 
            "title": "Write plugins"
        }, 
        {
            "location": "/get-started/contributing/#help-other-developers", 
            "text": "Subscribe to  Stack Overflow questions tagged with  ractivejs , and you'll get alerts when someone asks a question that you might be able to answer.", 
            "title": "Help other developers"
        }, 
        {
            "location": "/get-started/contributing/#spread-the-word", 
            "text": "Tweet , write blog posts, recommend it to your friends, submit talks (here are some  tips on speaking at tech meetups ). These are just a few ways to spread the word about Ractive. The larger the community, the better it becomes.", 
            "title": "Spread the word"
        }, 
        {
            "location": "/get-started/contributing/#build-stuff", 
            "text": "But above all, build stuff! If you make something with Ractive, we'd love to hear about it.", 
            "title": "Build stuff"
        }, 
        {
            "location": "/api/initialization-options/", 
            "text": "Initialization Options\n\n\nThe following is an exhaustive list of initialisation options that you can pass to \nnew Ractive()\n and \nRactive.extend()\n. Extra properties passed as options that are not initialization options are added as properties or methods of the instance.\n\n\nvar ractive = new Ractive({\n  myMethod: function () {\n    alert( 'my method was called' );\n  }\n});\n\nractive.myMethod(); // triggers the alert\n\n\n\n\n\n\nadapt\n\n\n(Array\nstring|Object\n)\n\n\nAn array of \nadaptors\n to use. Values can either be names of registered adaptors or an adaptor definition.\n\n\nadapt: [ 'MyAdaptor', AdaptorDefinition ]\n\n\n\n\nadapt\n is not required if you registered adaptors via the \nadaptors\n initialization property. The adaptors registered via \nadaptors\n initialization property are automatically used as if they were set with \nadapt\n.\n\n\nconst instance = new Ractive({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n});\n\nconst Component = Ractive.extend({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n});\n\nnew Component({\n  // No need to use adapt\n});\n\n\n\n\n\n\nadaptors\n\n\n(Object\nstring, Object\n)\n\n\nA map of \nadaptors\n where the key is the adaptor name and the value is an adaptor definition.\n\n\nadaptors: {\n  MyAdaptor: AdaptorDefinition\n}\n\n\n\n\nRegistering an adaptor via \nadaptors\n is not required if you directly specified the adaptor definition via \nadapt\n.\n\n\nconst Adaptor = { ... };\n\nconst instance = new Ractive({\n  adapt: [ AdaptorDefinition ]\n  // No need to use adaptors\n});\n\n\n\n\n\n\nappend\n\n\n(boolean|string|HTMLElement|array-like)\n\n\nControls how the instance is attached to \nel\n. Defaults to \nfalse\n.\n\n\nfalse\n replaces the contents of \nel\n.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: false,\ntemplate: '\np\nnew content\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nnew content\n/p\n\n\n/div\n\n\n\n\n\ntrue\n appends the instance to \nel\n.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: true,\ntemplate: '\np\nnew content\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n  \np\nnew content\n/p\n\n\n/div\n\n\n\n\n\nAn \nid\n of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element, which is a child of \nel\n will render the instance before that element.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nred\n/p\n\n  \np\norange\n/p\n\n  \np\nyellow\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: document.querySelector('p:nth-child(2)'),\ntemplate: '\np\ngrey\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nred\n/p\n\n  \np\ngrey\n/p\n\n  \np\norange\n/p\n\n  \np\nyellow\n/p\n\n\n/div\n\n\n\n\n\n\n\ncomponents\n\n\n(Object\nstring, Function\n)\n\n\nA map of \ncomponents\n where the key is the component name the value is either a component definition or a function that returns either a name of a registered component or a component definition. The function form receives processed \ndata\n as first argument.\n\n\ncomponents: {\n  StaticComponent: ComponentDefinition,\n  DynamicComponent: function(data){\n    return data.foo ? 'MyGlobalComponent' : ComponentDefinition;\n  }\n}\n\n\n\n\nDuring a \nractive.reset()\n, components registered using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\n\n\ncomputed\n\n\n(Object\nstring, function|Object\n)\n\n\nA map of \ncomputed properties\n where the key is the name of the computed property and the value is either a computed property expression, a function that returns a value, or an object that has \nget\n and \nset\n functions.\n\n\n// Imagine a square...\ncomputed: {\n  // Computed property expression\n  diagonal: '${side} * Math.sqrt(2)',\n\n  // A function\n  perimeter: function(){\n    return 4 * this.get('side');\n  },\n\n  // An object with get and set functions\n  area: {\n    get: function(){\n      return Math.pow(this.get('side'), 2);\n    },\n    set: function(value){\n      this.set('side', Math.sqrt(value));\n    }\n  },\n}\n\n\n\n\n\n\ncsp\n\n\n(boolean)\n\n\nWhether or not to add inline functions for expressions after parsing. Defaults to \nfalse\n.\n\n\nThis can effectively eliminate \neval\n caused by expressions in templates. It also makes the resulting template no longer JSON compatible, so the template will have to be served via \nscript\n tag.\n\n\n\n\ncss\n\n\n(string)\n\n\nScoped CSS for a component and its descendants.\n\n\ncss: `\n  .bold { font-weight: bold }\n`\n\n\n\n\nAt the moment, only applies to components.\n\n\n// This works\nconst Component = Ractive.extend({\n  css: '...'\n});\n\n// This will not work\nnew Ractive({\n  css: '...'\n});\n\n\n\n\n\n\ndata\n\n\n(Object\nstring, any\n|Function)\n\n\nThe data for an instance, or default data for a component. Can either be an object or a function that returns an object.\n\n\n// Object form\ndata: {\n  foo: 'bar'\n}\n\n// Function form\ndata: function() {\n  return { foo: 'bar' };\n}\n\n// Function form using arrow function for less verbosity\ndata: () =\n ({\n  foo: 'bar'\n})\n\n\n\n\nWhen using the object form, the data is attached to the component's prototype. Standard prototype rules apply.\n\n\nconst Component = Ractive.extend({\n  data: {\n    foo: { bar: 42 }\n  }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 12\n\n\n\n\nWhen using the function form, the function is executed to give each instance a copy of the data. Standard prototype rules apply.\n\n\nconst Component = Ractive.extend({\n  data: function () {\n    return {\n      foo: { bar: 42 }\n    };\n  }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 42\n\n\n\n\nWhen extending from a constructor, data from the parent constructor will be shallow-copied over to the child data. Child data takes precedence in the event of collisions.\n\n\nconst Parent = Ractive.extend({\n  data: {\n    foo: 'Hello',\n    bar: 'World'\n  }\n});\n\nconst Child = Parent.extend({\n  data: {\n    foo: 'Goodbye'\n  }\n});\n\nParent().get(); // { foo: 'Hello', bar: 'World' }\nChild().get();  // { foo: 'Goodbye', bar: 'World' }\n\n\n\n\n\n\ndecorators\n\n\n(Object\nstring, Function\n)\n\n\nA map of \ndecorators\n where the key is the decorator name and the value is a decorator definition.\n\n\ndecorators: {\n  MyDecorator: DecoratorDefinition\n}\n\n\n\n\n\n\ndelimiters\n\n\n(Array[string])\n\n\nSets the template delimiters. Defaults to \n[ '{{', '}}' ]\n.\n\n\ndelimiters: [ '\n%=', '%\n' ],\ntemplate: 'hello \n%= world %\n',\ndata: { world: 'earth' }\n\n// result:\n// hello earth\n\n\n\n\n\n\neasing\n\n\n(Object\nstring, Function\n)\n\n\nA map of \neasing functions\n where the key is the easing function name and the value is the easing function.\n\n\neasing: {\n  MyEasing: EasingDefinition\n}\n\n\n\n\n\n\nel\n\n\n(string|HTMLElement|array-like)\n\n\nThe element to render an instance to. Can either be an \nid\n of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element.\n\n\nel: 'container'\nel: '#container'\nel: document.getElementById('container')\nel: jQuery('#container')\n\n\n\n\n\n\nenhance\n\n\n(boolean)\n\n\nWhether or not to apply progressive enhancement by inspecting the contents of \nel\n and try to reuse as much of the existing tree as possible. Defaults to \nfalse\n.\n\n\nThere are a few limitations to this feature:\n\n\n\n\n\n\nThis option cannot be used with \nappend\n.\n\n\n\n\n\n\nUnescaped HTML mustaches (triples) don't play nicely with enhance because there's no easy way to match up the string content to the target DOM nodes.\n\n\n\n\n\n\nAll matching elements will be reused, except for a few cases regarding text nodes.\n\n\ndiv\nleft text {{#if foo}} middle text {{/if}} right text\n/div\n\n\nHTML does not have markup representation for adjacent text nodes. Rendering the snippet above from the server, regardless of \nfoo\n's value, the browser creates one contiguous text node. However, Ractive will need \nthree\n adjacent text nodes to represent it: One for \nouter text\n, another for \nright text\n and another for \nmiddle text\n when \nfoo\n becomes truthy.\n\n\nIt has been suggested that Ractive could deal with merged text nodes, but that would lead to extra complexity as there are certain scenarios where the text node would have to split and rejoin. When \nfoo\n is falsey, \nleft text\n and \nright text\n could be merged. But when \nfoo\n becomes truthy, that text node would have to split in order to accomodate \nmiddle text\n.\n\n\n\n\n\n\n\n\nevents\n\n\n(Object\nstring, Function\n)\n\n\nA map of \nevents\n where the key is the event name and value is an event definition.\n\n\nevents: {\n  MyEvent: EventDefinition\n}\n\n\n\n\n\n\ninterpolators\n\n\n(Object\nstring, Function\n)\n\n\nA map of \ninterpolators\n where the key is the interpolator name and the value is an interpolator definition.\n\n\ninterpolators: {\n  MyInterpolator: InterpolatorDefinition\n}\n\n\n\n\n\n\nisolated\n\n\n(boolean)\n\n\nControls whether the component will try to \nresolve data and plugins on its ancestors\n. Defaults to \ntrue\n.\n\n\nRelevant only to \nComponents\n.\n\n\n\n\nlazy\n\n\n(boolean)\n\n\nWhether or not to update data using late-firing DOM events (i.e. \nchange\n, \nblur\n) instead of events that fire immediately on interaction (i.e. \nkeyup\n, \nkeydown\n). Defaults to \nfalse\n.\n\n\nOnly applicable if \ntwoway\n is \ntrue\n.\n\n\nvar ractive = new Ractive({\n  template: '\ninput value=\n{{foo}}\n',\n  data: { foo: 'bar' },\n  lazy: true\n});\n\n// Only fires when input loses focus.\nractive.on('change', function(){\n  console.log('changed!')\n})\n\n\n\n\n\n\nnoCSSTransform\n\n\n(boolean)\n\n\nPrevents component CSS from being transformed with scoping guids. Defaults to \nfalse\n.\n\n\n\n\nnoIntro\n\n\n(boolean)\n\n\nWhether or not to skip intro transitions on initial render. Defaults to \nfalse\n.\n\n\nvar ractive = new Ractive({\n  template: '\nul\n{{#items}}\nli intro=\nfade\n{{.}}\n/li\n{{/items}}\n/ul\n',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: { fade: function ( t, params ) {...} },\n  noIntro: true\n});\n// 'red' and 'blue' list items do not fade in on intro\n\nractive.get('items').push( 'green' );\n// 'green' list item will fade in\n\n\n\n\n\n\noncomplete\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is rendered and all the transitions have completed.\n\n\n\n\nonconfig\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed and all initialization options have been processed.\n\n\n\n\nonconstruct\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed but before any initialization option has been processed.\n\n\nAccepts the instance's initialization options as argument.\n\n\n\n\nondetach\n\n\n(Function)\n\n\nA lifecycle event that is called whenever \nractive.detach()\n is called.\n\n\nNote that \nractive.insert()\n implicitly calls \nractive.detach()\n if needed.\n\n\n\n\noninit\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed and is ready to be rendered.\n\n\n\n\noninsert\n\n\n(Function)\n\n\nA lifecycle event that is called when \nractive.insert()\n is called.\n\n\n\n\nonrender\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is rendered but \nbefore\n transitions start.\n\n\n\n\nonteardown\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is being torn down.\n\n\n\n\nonunrender\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is being undrendered.\n\n\n\n\nonupdate\n\n\n(Function)\n\n\nA lifecycle event that is called when \nractive.update()\n is called.\n\n\n\n\npartials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nA map of \npartials\n where the key is the partial name and the value is either a template string, a parsed template object or a function that returns any of the previous options. The function form accepts processed \ndata\n and  \nParse Object\n as arguments.\n\n\npartials: {\n  stringPartial: '\np\n{{greeting}} world!\n/p\n',\n  parsedPartial: {\nv\n:3,\nt\n:[{\nt\n:7,\ne\n:\np\n,\nf\n:[{\nt\n:2,\nr\n:\ngreeting\n},\n world!\n]}]},\n  functionPartial: function(data, p){\n    return data.condition ? '\np\nhello world\n/p\n' : '\ndiv\nyes, we have no foo\n/div\n';\n  }\n}\n\n\n\n\nDuring a \nractive.reset()\n, function partials are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\n\n\npreserveWhitespace\n\n\n(boolean)\n\n\nWhether or not to preserve whitespace in templates when parsing. Defaults to \nfalse\n.\n\n\nWhitespace in \npre\n elements are always preserved. The browser will still deal with whitespace in the normal fashion.\n\n\nvar ractive = new Ractive({\n  template: '\np\nhello\\n\\n  \\tworld   \n/p\n',\n  preserveWhitespace: false //default\n});\n\nconsole.log( ractive.toHTML() );\n// \np\nhello world\n/p\n\n\nvar ractive = new Ractive({\n  template: '\np\nhello\\n\\n  \\tworld   \n/p\n',\n  preserveWhitespace: true\n});\n\nconsole.log( ractive.toHTML() );\n//\np\nhello\n//\n//  world   \n/p\n\n\n\n\n\n\n\nsanitize\n\n\n(boolean|Object)\n\n\nWhether or not certain elements will be stripped from the template during parsing.  Defaults to \nfalse\n.\n\n\ntrue\n strips out blacklisted elements and event attributes. See \nRactive.parse()\n for the default list of blacklisted elements.\n\n\ntemplate: `\n  \np\nsome content\n/p\n\n  \nframe\nAm I a bad element or just misunderstood?\n/frame\n\n`,\nsanitize: true\n\n// result:\n// \np\nsome content\n/p\n\n\n\n\n\nThe object form should have \nelements\n which is an array of blacklisted elements and \neventAttributes\n boolean which, when \ntrue\n, also strips out event attributes.\n\n\ntemplate: `\n  \np\nsome content\n/p\n\n  \ndiv onclick=\ndoEvil()\nthe good stuff\n/div\n\n`,\nsanitize: {\n  elements: [ 'p' ],\n  eventAttributes: true\n}\n\n// result:\n// \ndiv\nthe good stuff\n/div\n\n\n\n\n\n\n\nstaticDelimiters\n\n\n(Array[string])\n\n\nSets the static (one-time binding) delimiters. Defaults to \n[ '[[', ']]' ]\n.\n\n\nvar ractive = new Ractive({\n  template: 'hello [[foo]]',\n  staticDelimiters: [ '[[', ']]' ], //default\n  data: { foo: 'world' }\n});\n// result: \nhello world\n\n\nractive.set( 'foo', 'mars' );\n// still is: \nhello world\n\n\n\n\n\n\n\nstaticTripleDelimiters\n\n\n(Array\nstring\n)\n\n\nSets the static (one-time binding) triple delimiters. Defaults to \n[ '[[[', ']]]' ]\n.\n\n\nvar ractive = new Ractive({\n  template: 'hello [[[html]]]',\n  staticTripleDelimiters: [ '[[[', ']]]' ], //default\n  data: { html: '\nspan\nworld\n/span\n' }\n});\n// result: \nhello \nspan\nworld\n/span\n\n\nractive.set( 'html', '\nspan\nmars\n/span\n' );\n// still is: \nhello world\n\n\n\n\n\n\n\nstripComments\n\n\n(boolean)\n\n\nWhether or not to remove comments in templates when parsing. Defaults to \ntrue\n.\n\n\ntemplate: '\n!-- html comment --\nhello world',\nstripComments: false\n\n// result:\n// \n!-- html comment --\nhello world\n\n\n\n\n\n\ntarget\n\n\n(string|HTMLElement|array-like)\n\n\nAlias for \nel\n.\n\n\n\n\ntemplate\n\n\n(string|array|object|function)\n\n\nThe \ntemplate\n to use. Must either be a CSS selector string pointing to an element on the page containing the template, an HTML string, an object resulting from \nRactive.parse()\n or a function that returns any of the previous options. The function form accepts processed \ndata\n and a \nParse Object\n.\n\n\n// Selector\ntemplate: '#my-template',\n\n// HTML\ntemplate: '\np\n{{greeting}} world!\n/p\n',\n\n// Template AST\ntemplate: {\nv\n:3,\nt\n:[{\nt\n:7,\ne\n:\np\n,\nf\n:[{\nt\n:2,\nr\n:\ngreeting\n},\n world!\n]}]},\n\n// Function\ntemplate: function(data, p){\n  return '\np\n{{greeting}} world!\n/p\n';\n},\n\n\n\n\nDuring a \nractive.reset()\n, templates provided using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\n\n\ntransitions\n\n\n(Object\nstring, Function\n)\n\n\nA map of \ntransitions\n where the key is the name of the transition and the value is a transition definition.\n\n\n\n\ntransitionsEnabled\n\n\n(boolean)\n\n\nWhether or not transitions are enabled. Defaults to \ntrue\n.\n\n\n\n\ntripleDelimiters\n\n\n(Array[string])\n\n\nSets the triple delimiters. Defaults to \n[ '{{{', '}}}' ]\n.\n\n\ntemplate: 'hello @html@',\ntripleDelimiters: [ '@', '@' ],\ndata: { html: '\nspan\nworld\n/span\n' }\n\n// result:\n// hello \nspan\nworld\n/span\n\n\n\n\n\n\n\ntwoway\n\n\n(boolean)\n\n\nWhether or not \ntwo-way binding\n is enabled. Defaults to \ntrue\n.\n\n\nvar ractive = new Ractive({\n  template: '\ninput value=\n{{foo}}\n',\n  data: { foo: 'bar' },\n  twoway: false\n});\n\n// user types \nfizz\n into \ninput\n, but data value is not changed:\n\nconsole.log( ractive.get( 'foo' ) ); //logs \nbar\n\n\n// updates from the model are still pushed to the view\n\nractive.set( 'foo', 'fizz' );\n\n// input now displays \nfizz", 
            "title": "Initialization Options"
        }, 
        {
            "location": "/api/initialization-options/#initialization-options", 
            "text": "The following is an exhaustive list of initialisation options that you can pass to  new Ractive()  and  Ractive.extend() . Extra properties passed as options that are not initialization options are added as properties or methods of the instance.  var ractive = new Ractive({\n  myMethod: function () {\n    alert( 'my method was called' );\n  }\n});\n\nractive.myMethod(); // triggers the alert", 
            "title": "Initialization Options"
        }, 
        {
            "location": "/api/initialization-options/#adapt", 
            "text": "(Array string|Object )  An array of  adaptors  to use. Values can either be names of registered adaptors or an adaptor definition.  adapt: [ 'MyAdaptor', AdaptorDefinition ]  adapt  is not required if you registered adaptors via the  adaptors  initialization property. The adaptors registered via  adaptors  initialization property are automatically used as if they were set with  adapt .  const instance = new Ractive({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n});\n\nconst Component = Ractive.extend({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n});\n\nnew Component({\n  // No need to use adapt\n});", 
            "title": "adapt"
        }, 
        {
            "location": "/api/initialization-options/#adaptors", 
            "text": "(Object string, Object )  A map of  adaptors  where the key is the adaptor name and the value is an adaptor definition.  adaptors: {\n  MyAdaptor: AdaptorDefinition\n}  Registering an adaptor via  adaptors  is not required if you directly specified the adaptor definition via  adapt .  const Adaptor = { ... };\n\nconst instance = new Ractive({\n  adapt: [ AdaptorDefinition ]\n  // No need to use adaptors\n});", 
            "title": "adaptors"
        }, 
        {
            "location": "/api/initialization-options/#append", 
            "text": "(boolean|string|HTMLElement|array-like)  Controls how the instance is attached to  el . Defaults to  false .  false  replaces the contents of  el .  !-- before --  div id='container' \n   p existing content /p  /div   el: '#container',\nappend: false,\ntemplate: ' p new content /p '  !-- after --  div id='container' \n   p new content /p  /div   true  appends the instance to  el .  !-- before --  div id='container' \n   p existing content /p  /div   el: '#container',\nappend: true,\ntemplate: ' p new content /p '  !-- after --  div id='container' \n   p existing content /p \n   p new content /p  /div   An  id  of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element, which is a child of  el  will render the instance before that element.  !-- before --  div id='container' \n   p red /p \n   p orange /p \n   p yellow /p  /div   el: '#container',\nappend: document.querySelector('p:nth-child(2)'),\ntemplate: ' p grey /p '  !-- after --  div id='container' \n   p red /p \n   p grey /p \n   p orange /p \n   p yellow /p  /div", 
            "title": "append"
        }, 
        {
            "location": "/api/initialization-options/#components", 
            "text": "(Object string, Function )  A map of  components  where the key is the component name the value is either a component definition or a function that returns either a name of a registered component or a component definition. The function form receives processed  data  as first argument.  components: {\n  StaticComponent: ComponentDefinition,\n  DynamicComponent: function(data){\n    return data.foo ? 'MyGlobalComponent' : ComponentDefinition;\n  }\n}  During a  ractive.reset() , components registered using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "components"
        }, 
        {
            "location": "/api/initialization-options/#computed", 
            "text": "(Object string, function|Object )  A map of  computed properties  where the key is the name of the computed property and the value is either a computed property expression, a function that returns a value, or an object that has  get  and  set  functions.  // Imagine a square...\ncomputed: {\n  // Computed property expression\n  diagonal: '${side} * Math.sqrt(2)',\n\n  // A function\n  perimeter: function(){\n    return 4 * this.get('side');\n  },\n\n  // An object with get and set functions\n  area: {\n    get: function(){\n      return Math.pow(this.get('side'), 2);\n    },\n    set: function(value){\n      this.set('side', Math.sqrt(value));\n    }\n  },\n}", 
            "title": "computed"
        }, 
        {
            "location": "/api/initialization-options/#csp", 
            "text": "(boolean)  Whether or not to add inline functions for expressions after parsing. Defaults to  false .  This can effectively eliminate  eval  caused by expressions in templates. It also makes the resulting template no longer JSON compatible, so the template will have to be served via  script  tag.", 
            "title": "csp"
        }, 
        {
            "location": "/api/initialization-options/#css", 
            "text": "(string)  Scoped CSS for a component and its descendants.  css: `\n  .bold { font-weight: bold }\n`  At the moment, only applies to components.  // This works\nconst Component = Ractive.extend({\n  css: '...'\n});\n\n// This will not work\nnew Ractive({\n  css: '...'\n});", 
            "title": "css"
        }, 
        {
            "location": "/api/initialization-options/#data", 
            "text": "(Object string, any |Function)  The data for an instance, or default data for a component. Can either be an object or a function that returns an object.  // Object form\ndata: {\n  foo: 'bar'\n}\n\n// Function form\ndata: function() {\n  return { foo: 'bar' };\n}\n\n// Function form using arrow function for less verbosity\ndata: () =  ({\n  foo: 'bar'\n})  When using the object form, the data is attached to the component's prototype. Standard prototype rules apply.  const Component = Ractive.extend({\n  data: {\n    foo: { bar: 42 }\n  }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 12  When using the function form, the function is executed to give each instance a copy of the data. Standard prototype rules apply.  const Component = Ractive.extend({\n  data: function () {\n    return {\n      foo: { bar: 42 }\n    };\n  }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 42  When extending from a constructor, data from the parent constructor will be shallow-copied over to the child data. Child data takes precedence in the event of collisions.  const Parent = Ractive.extend({\n  data: {\n    foo: 'Hello',\n    bar: 'World'\n  }\n});\n\nconst Child = Parent.extend({\n  data: {\n    foo: 'Goodbye'\n  }\n});\n\nParent().get(); // { foo: 'Hello', bar: 'World' }\nChild().get();  // { foo: 'Goodbye', bar: 'World' }", 
            "title": "data"
        }, 
        {
            "location": "/api/initialization-options/#decorators", 
            "text": "(Object string, Function )  A map of  decorators  where the key is the decorator name and the value is a decorator definition.  decorators: {\n  MyDecorator: DecoratorDefinition\n}", 
            "title": "decorators"
        }, 
        {
            "location": "/api/initialization-options/#delimiters", 
            "text": "(Array[string])  Sets the template delimiters. Defaults to  [ '{{', '}}' ] .  delimiters: [ ' %=', '% ' ],\ntemplate: 'hello  %= world % ',\ndata: { world: 'earth' }\n\n// result:\n// hello earth", 
            "title": "delimiters"
        }, 
        {
            "location": "/api/initialization-options/#easing", 
            "text": "(Object string, Function )  A map of  easing functions  where the key is the easing function name and the value is the easing function.  easing: {\n  MyEasing: EasingDefinition\n}", 
            "title": "easing"
        }, 
        {
            "location": "/api/initialization-options/#el", 
            "text": "(string|HTMLElement|array-like)  The element to render an instance to. Can either be an  id  of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element.  el: 'container'\nel: '#container'\nel: document.getElementById('container')\nel: jQuery('#container')", 
            "title": "el"
        }, 
        {
            "location": "/api/initialization-options/#enhance", 
            "text": "(boolean)  Whether or not to apply progressive enhancement by inspecting the contents of  el  and try to reuse as much of the existing tree as possible. Defaults to  false .  There are a few limitations to this feature:    This option cannot be used with  append .    Unescaped HTML mustaches (triples) don't play nicely with enhance because there's no easy way to match up the string content to the target DOM nodes.    All matching elements will be reused, except for a few cases regarding text nodes.  div left text {{#if foo}} middle text {{/if}} right text /div  HTML does not have markup representation for adjacent text nodes. Rendering the snippet above from the server, regardless of  foo 's value, the browser creates one contiguous text node. However, Ractive will need  three  adjacent text nodes to represent it: One for  outer text , another for  right text  and another for  middle text  when  foo  becomes truthy.  It has been suggested that Ractive could deal with merged text nodes, but that would lead to extra complexity as there are certain scenarios where the text node would have to split and rejoin. When  foo  is falsey,  left text  and  right text  could be merged. But when  foo  becomes truthy, that text node would have to split in order to accomodate  middle text .", 
            "title": "enhance"
        }, 
        {
            "location": "/api/initialization-options/#events", 
            "text": "(Object string, Function )  A map of  events  where the key is the event name and value is an event definition.  events: {\n  MyEvent: EventDefinition\n}", 
            "title": "events"
        }, 
        {
            "location": "/api/initialization-options/#interpolators", 
            "text": "(Object string, Function )  A map of  interpolators  where the key is the interpolator name and the value is an interpolator definition.  interpolators: {\n  MyInterpolator: InterpolatorDefinition\n}", 
            "title": "interpolators"
        }, 
        {
            "location": "/api/initialization-options/#isolated", 
            "text": "(boolean)  Controls whether the component will try to  resolve data and plugins on its ancestors . Defaults to  true .  Relevant only to  Components .", 
            "title": "isolated"
        }, 
        {
            "location": "/api/initialization-options/#lazy", 
            "text": "(boolean)  Whether or not to update data using late-firing DOM events (i.e.  change ,  blur ) instead of events that fire immediately on interaction (i.e.  keyup ,  keydown ). Defaults to  false .  Only applicable if  twoway  is  true .  var ractive = new Ractive({\n  template: ' input value= {{foo}} ',\n  data: { foo: 'bar' },\n  lazy: true\n});\n\n// Only fires when input loses focus.\nractive.on('change', function(){\n  console.log('changed!')\n})", 
            "title": "lazy"
        }, 
        {
            "location": "/api/initialization-options/#nocsstransform", 
            "text": "(boolean)  Prevents component CSS from being transformed with scoping guids. Defaults to  false .", 
            "title": "noCSSTransform"
        }, 
        {
            "location": "/api/initialization-options/#nointro", 
            "text": "(boolean)  Whether or not to skip intro transitions on initial render. Defaults to  false .  var ractive = new Ractive({\n  template: ' ul {{#items}} li intro= fade {{.}} /li {{/items}} /ul ',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: { fade: function ( t, params ) {...} },\n  noIntro: true\n});\n// 'red' and 'blue' list items do not fade in on intro\n\nractive.get('items').push( 'green' );\n// 'green' list item will fade in", 
            "title": "noIntro"
        }, 
        {
            "location": "/api/initialization-options/#oncomplete", 
            "text": "(Function)  A lifecycle event that is called when the instance is rendered and all the transitions have completed.", 
            "title": "oncomplete"
        }, 
        {
            "location": "/api/initialization-options/#onconfig", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed and all initialization options have been processed.", 
            "title": "onconfig"
        }, 
        {
            "location": "/api/initialization-options/#onconstruct", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed but before any initialization option has been processed.  Accepts the instance's initialization options as argument.", 
            "title": "onconstruct"
        }, 
        {
            "location": "/api/initialization-options/#ondetach", 
            "text": "(Function)  A lifecycle event that is called whenever  ractive.detach()  is called.  Note that  ractive.insert()  implicitly calls  ractive.detach()  if needed.", 
            "title": "ondetach"
        }, 
        {
            "location": "/api/initialization-options/#oninit", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed and is ready to be rendered.", 
            "title": "oninit"
        }, 
        {
            "location": "/api/initialization-options/#oninsert", 
            "text": "(Function)  A lifecycle event that is called when  ractive.insert()  is called.", 
            "title": "oninsert"
        }, 
        {
            "location": "/api/initialization-options/#onrender", 
            "text": "(Function)  A lifecycle event that is called when the instance is rendered but  before  transitions start.", 
            "title": "onrender"
        }, 
        {
            "location": "/api/initialization-options/#onteardown", 
            "text": "(Function)  A lifecycle event that is called when the instance is being torn down.", 
            "title": "onteardown"
        }, 
        {
            "location": "/api/initialization-options/#onunrender", 
            "text": "(Function)  A lifecycle event that is called when the instance is being undrendered.", 
            "title": "onunrender"
        }, 
        {
            "location": "/api/initialization-options/#onupdate", 
            "text": "(Function)  A lifecycle event that is called when  ractive.update()  is called.", 
            "title": "onupdate"
        }, 
        {
            "location": "/api/initialization-options/#partials", 
            "text": "(Object string, string|Object|Function )  A map of  partials  where the key is the partial name and the value is either a template string, a parsed template object or a function that returns any of the previous options. The function form accepts processed  data  and   Parse Object  as arguments.  partials: {\n  stringPartial: ' p {{greeting}} world! /p ',\n  parsedPartial: { v :3, t :[{ t :7, e : p , f :[{ t :2, r : greeting },  world! ]}]},\n  functionPartial: function(data, p){\n    return data.condition ? ' p hello world /p ' : ' div yes, we have no foo /div ';\n  }\n}  During a  ractive.reset() , function partials are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "partials"
        }, 
        {
            "location": "/api/initialization-options/#preservewhitespace", 
            "text": "(boolean)  Whether or not to preserve whitespace in templates when parsing. Defaults to  false .  Whitespace in  pre  elements are always preserved. The browser will still deal with whitespace in the normal fashion.  var ractive = new Ractive({\n  template: ' p hello\\n\\n  \\tworld    /p ',\n  preserveWhitespace: false //default\n});\n\nconsole.log( ractive.toHTML() );\n//  p hello world /p \n\nvar ractive = new Ractive({\n  template: ' p hello\\n\\n  \\tworld    /p ',\n  preserveWhitespace: true\n});\n\nconsole.log( ractive.toHTML() );\n// p hello\n//\n//  world    /p", 
            "title": "preserveWhitespace"
        }, 
        {
            "location": "/api/initialization-options/#sanitize", 
            "text": "(boolean|Object)  Whether or not certain elements will be stripped from the template during parsing.  Defaults to  false .  true  strips out blacklisted elements and event attributes. See  Ractive.parse()  for the default list of blacklisted elements.  template: `\n   p some content /p \n   frame Am I a bad element or just misunderstood? /frame \n`,\nsanitize: true\n\n// result:\n//  p some content /p   The object form should have  elements  which is an array of blacklisted elements and  eventAttributes  boolean which, when  true , also strips out event attributes.  template: `\n   p some content /p \n   div onclick= doEvil() the good stuff /div \n`,\nsanitize: {\n  elements: [ 'p' ],\n  eventAttributes: true\n}\n\n// result:\n//  div the good stuff /div", 
            "title": "sanitize"
        }, 
        {
            "location": "/api/initialization-options/#staticdelimiters", 
            "text": "(Array[string])  Sets the static (one-time binding) delimiters. Defaults to  [ '[[', ']]' ] .  var ractive = new Ractive({\n  template: 'hello [[foo]]',\n  staticDelimiters: [ '[[', ']]' ], //default\n  data: { foo: 'world' }\n});\n// result:  hello world \n\nractive.set( 'foo', 'mars' );\n// still is:  hello world", 
            "title": "staticDelimiters"
        }, 
        {
            "location": "/api/initialization-options/#statictripledelimiters", 
            "text": "(Array string )  Sets the static (one-time binding) triple delimiters. Defaults to  [ '[[[', ']]]' ] .  var ractive = new Ractive({\n  template: 'hello [[[html]]]',\n  staticTripleDelimiters: [ '[[[', ']]]' ], //default\n  data: { html: ' span world /span ' }\n});\n// result:  hello  span world /span \n\nractive.set( 'html', ' span mars /span ' );\n// still is:  hello world", 
            "title": "staticTripleDelimiters"
        }, 
        {
            "location": "/api/initialization-options/#stripcomments", 
            "text": "(boolean)  Whether or not to remove comments in templates when parsing. Defaults to  true .  template: ' !-- html comment -- hello world',\nstripComments: false\n\n// result:\n//  !-- html comment -- hello world", 
            "title": "stripComments"
        }, 
        {
            "location": "/api/initialization-options/#target", 
            "text": "(string|HTMLElement|array-like)  Alias for  el .", 
            "title": "target"
        }, 
        {
            "location": "/api/initialization-options/#template", 
            "text": "(string|array|object|function)  The  template  to use. Must either be a CSS selector string pointing to an element on the page containing the template, an HTML string, an object resulting from  Ractive.parse()  or a function that returns any of the previous options. The function form accepts processed  data  and a  Parse Object .  // Selector\ntemplate: '#my-template',\n\n// HTML\ntemplate: ' p {{greeting}} world! /p ',\n\n// Template AST\ntemplate: { v :3, t :[{ t :7, e : p , f :[{ t :2, r : greeting },  world! ]}]},\n\n// Function\ntemplate: function(data, p){\n  return ' p {{greeting}} world! /p ';\n},  During a  ractive.reset() , templates provided using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "template"
        }, 
        {
            "location": "/api/initialization-options/#transitions", 
            "text": "(Object string, Function )  A map of  transitions  where the key is the name of the transition and the value is a transition definition.", 
            "title": "transitions"
        }, 
        {
            "location": "/api/initialization-options/#transitionsenabled", 
            "text": "(boolean)  Whether or not transitions are enabled. Defaults to  true .", 
            "title": "transitionsEnabled"
        }, 
        {
            "location": "/api/initialization-options/#tripledelimiters", 
            "text": "(Array[string])  Sets the triple delimiters. Defaults to  [ '{{{', '}}}' ] .  template: 'hello @html@',\ntripleDelimiters: [ '@', '@' ],\ndata: { html: ' span world /span ' }\n\n// result:\n// hello  span world /span", 
            "title": "tripleDelimiters"
        }, 
        {
            "location": "/api/initialization-options/#twoway", 
            "text": "(boolean)  Whether or not  two-way binding  is enabled. Defaults to  true .  var ractive = new Ractive({\n  template: ' input value= {{foo}} ',\n  data: { foo: 'bar' },\n  twoway: false\n});\n\n// user types  fizz  into  input , but data value is not changed:\n\nconsole.log( ractive.get( 'foo' ) ); //logs  bar \n\n// updates from the model are still pushed to the view\n\nractive.set( 'foo', 'fizz' );\n\n// input now displays  fizz", 
            "title": "twoway"
        }, 
        {
            "location": "/api/static-properties/", 
            "text": "Static Properties\n\n\nRactive.adaptors\n\n\n(Object\nstring, Object\n)\n\n\nThe registry of globally available \nadaptors\n.\n\n\n\n\nRactive.components\n\n\n(Object\nstring, Function\n)\n\n\nThe registry of globally available \ncomponent definitions\n.\n\n\n\n\nRactive.DEBUG\n\n\n(boolean)\n\n\nTells Ractive if it's in debug mode or not. When set to \ntrue\n, non-fatal errors are logged. When set to \nfalse\n, non-fatal errors are suppressed. By default, this is set to \ntrue\n.\n\n\n\n\nRactive.DEBUG_PROMISES\n\n\n(boolean)\n\n\nTells Ractive to log errors thrown inside promises. When set to \ntrue\n, errors thrown in promises are logged. When set to \nfalse\n, errors inside promises are suppressed. By default, this is set to \ntrue\n.\n\n\n\n\nRactive.decorators\n\n\n(Object\nstring, Function\n)\n\n\nThe registry of globally available \ndecorators\n.\n\n\n\n\nRactive.defaults\n\n\n(Object\nstring, any\n)\n\n\nGlobal defaults for \ninitialisation options\n with the exception of \nplugin registries\n.\n\n\n// Change the default mustache delimiters to [[ ]] globally\nRactive.defaults.delimiters = [ '[[', ']]' ];\n\n// Future instances now use [[ ]]\nractive1 = new Ractive({\n    template: 'hello [[world]]'\n});\n\n\n\n\nDefaults can be specified for a subclass of Ractive, overriding global defaults.\n\n\nvar MyRactive = Ractive.extend();\n\nMyRactive.defaults.el = document.body;\n\n\n\n\nConfiguration on the instance overrides subclass and global defaults.\n\n\nRactive.defaults.delimiters = [ '[[', ']]' ];\n\n// Uses the delimiters specified above\nnew Ractive({\n    template: 'hello [[world]]'\n});\n\n// Uses the delimiters specified in the init options\nnew Ractive({\n    template: 'hello //world\\\\',\n    delimiters: [ '//', '\\\\' ]\n});\n\n\n\n\n\n\nRactive.easing\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of \neasing functions\n.\n\n\nThe easing functions are used by the \nractive.animate\n method and by \ntransitions\n. Four are included by default: \nlinear\n, \neaseIn\n, \neaseOut\n and \neaseInOut\n.\n\n\n\n\nRactive.events\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of \nevents\n.\n\n\n\n\nRactive.interpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n.\n\n\n\n\nRactive.partials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nThe global registry of \npartial templates\n.\n\n\nLike \ntemplates\n, partials are \nparsed\n at the point of use. The parsed output is cached and utilized for future use.\n\n\n\n\nRactive.svg\n\n\n(boolean)\n\n\nIndicates whether or not the browser supports SVG.\n\n\n\n\nRactive.transitions\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of \ntransition functions\n.\n\n\n\n\nRactive.VERSION\n\n\n(string)\n\n\nThe version of the currently loaded Ractive.", 
            "title": "Static Properties"
        }, 
        {
            "location": "/api/static-properties/#static-properties", 
            "text": "", 
            "title": "Static Properties"
        }, 
        {
            "location": "/api/static-properties/#ractiveadaptors", 
            "text": "(Object string, Object )  The registry of globally available  adaptors .", 
            "title": "Ractive.adaptors"
        }, 
        {
            "location": "/api/static-properties/#ractivecomponents", 
            "text": "(Object string, Function )  The registry of globally available  component definitions .", 
            "title": "Ractive.components"
        }, 
        {
            "location": "/api/static-properties/#ractivedebug", 
            "text": "(boolean)  Tells Ractive if it's in debug mode or not. When set to  true , non-fatal errors are logged. When set to  false , non-fatal errors are suppressed. By default, this is set to  true .", 
            "title": "Ractive.DEBUG"
        }, 
        {
            "location": "/api/static-properties/#ractivedebug_promises", 
            "text": "(boolean)  Tells Ractive to log errors thrown inside promises. When set to  true , errors thrown in promises are logged. When set to  false , errors inside promises are suppressed. By default, this is set to  true .", 
            "title": "Ractive.DEBUG_PROMISES"
        }, 
        {
            "location": "/api/static-properties/#ractivedecorators", 
            "text": "(Object string, Function )  The registry of globally available  decorators .", 
            "title": "Ractive.decorators"
        }, 
        {
            "location": "/api/static-properties/#ractivedefaults", 
            "text": "(Object string, any )  Global defaults for  initialisation options  with the exception of  plugin registries .  // Change the default mustache delimiters to [[ ]] globally\nRactive.defaults.delimiters = [ '[[', ']]' ];\n\n// Future instances now use [[ ]]\nractive1 = new Ractive({\n    template: 'hello [[world]]'\n});  Defaults can be specified for a subclass of Ractive, overriding global defaults.  var MyRactive = Ractive.extend();\n\nMyRactive.defaults.el = document.body;  Configuration on the instance overrides subclass and global defaults.  Ractive.defaults.delimiters = [ '[[', ']]' ];\n\n// Uses the delimiters specified above\nnew Ractive({\n    template: 'hello [[world]]'\n});\n\n// Uses the delimiters specified in the init options\nnew Ractive({\n    template: 'hello //world\\\\',\n    delimiters: [ '//', '\\\\' ]\n});", 
            "title": "Ractive.defaults"
        }, 
        {
            "location": "/api/static-properties/#ractiveeasing", 
            "text": "(Object string, Function )  The global registry of  easing functions .  The easing functions are used by the  ractive.animate  method and by  transitions . Four are included by default:  linear ,  easeIn ,  easeOut  and  easeInOut .", 
            "title": "Ractive.easing"
        }, 
        {
            "location": "/api/static-properties/#ractiveevents", 
            "text": "(Object string, Function )  The global registry of  events .", 
            "title": "Ractive.events"
        }, 
        {
            "location": "/api/static-properties/#ractiveinterpolators", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate() .", 
            "title": "Ractive.interpolators"
        }, 
        {
            "location": "/api/static-properties/#ractivepartials", 
            "text": "(Object string, string|Object|Function )  The global registry of  partial templates .  Like  templates , partials are  parsed  at the point of use. The parsed output is cached and utilized for future use.", 
            "title": "Ractive.partials"
        }, 
        {
            "location": "/api/static-properties/#ractivesvg", 
            "text": "(boolean)  Indicates whether or not the browser supports SVG.", 
            "title": "Ractive.svg"
        }, 
        {
            "location": "/api/static-properties/#ractivetransitions", 
            "text": "(Object string, Function )  The global registry of  transition functions .", 
            "title": "Ractive.transitions"
        }, 
        {
            "location": "/api/static-properties/#ractiveversion", 
            "text": "(string)  The version of the currently loaded Ractive.", 
            "title": "Ractive.VERSION"
        }, 
        {
            "location": "/api/static-methods/", 
            "text": "Static Methods\n\n\nRactive.escapeKey()\n\n\nEscapes the given key so that it can be concatenated with a \nkeypath\n string.\n\n\nSyntax\n\n\n\n\nRactive.escapeKey(key)\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: The key to escape.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The escaped key.\n\n\n\n\nExamples\n\n\nRactive.escapeKey('foo.bar'); // foo\\.bar\n\n\n\n\n\n\nRactive.extend()\n\n\nCreates a \"subclass\" of the Ractive constructor or a subclass constructor. See \nComponents\n for an in-depth discussion on the use of \nRactive.extend\n.\n\n\nSyntax\n\n\n\n\nRactive.extend([options[, ...optionsN]])\n\n\n\n\nArguments\n\n\n\n\n[options] (Object)\n: One or more objects that represent the defaults for instances of the subclass, with the latter objects' properties taking precedence over the former. See \nInitialization Options\n for a list of possible options.\n\n\n\n\nReturns\n\n\n\n\n(Function)\n: The subclass constructor function.\n\n\n\n\nExamples\n\n\nconst SubClass = Ractive.extend({\n    template: '\ndiv\n{{message}}\n/div\n',\n    data: {\n        message: 'Hello World!'\n    }\n});\n\n// \ndiv\nHello World!\n/div\n\nconst instance1 = new SubClass({\n    el: '.div1'\n});\n\n// \ndiv\nLorem Ipsum\n/div\n\nconst instance2 = new SubClass({\n    el: '.div2',\n    data: {\n        message: 'Lorem Ipsum'\n    }\n});\n\n\n\n\n\n\nRactive.getCSS()\n\n\nReturns the scoped CSS from Ractive subclasses defined at the time of the call.\n\n\nIf used without arguments, it will return the scoped CSS of all subclasses. If provided an array of scoping IDs, it will return the scoped CSS of all subclasses whose scoping ID is included in the array.\n\n\nSyntax\n\n\n\n\nRactive.getCSS([key])\n\n\n\n\nArguments\n\n\n\n\n[key] (Array\nstring\n)\n: Subclass CSS scoping ID.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The scoped CSS.\n\n\n\n\nExamples\n\n\n// Assuming the generated ID for this subclass is 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.\nconst Subclass1 = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\n// Assuming the generated ID for this subclass is 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy'.\nconst Subclass2 = Ractive.extend({\n    ...\n    css: 'div{ color: green }'\n    ...\n});\n\n// CSS contains the scoped versions of div{ color: red } and div{ color: green }.\nconst css = Ractive.getCSS();\n\n// css contains the scoped version of div{ color: red } only.\nconst css = Ractive.getCSS([ 'xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' ]);\n\n\n\n\n\n\n\nRactive.getNodeInfo()\n\n\nAccepts a node and returns an \nNode Info\n object containing details of the Ractive instance the node is associated to.\n\n\nSyntax\n\n\n\n\nRactive.getNodeInfo(node)\n\n\n\n\nArguments\n\n\n\n\nnode (string|Node)\n: The DOM node or a CSS selector of the DOM node for which you wish to retrieve the Ractive instance or view details.\n\n\n\n\nReturns\n\n\n\n\n(NodeInfo)\n: An \nNodeInfo\n object.\n\n\n\n\nExamples\n\n\nconst info = Ractive.getNodeInfo(document.getElementById('some-node'));\n\nconst info = Ractive.getNodeInfo('#some-node');\n\n\n\n\n\n\nRactive.joinKeys()\n\n\nJoins the given keys into a properly escaped \nkeypath\n e.g. `\n\n\nSyntax\n\n\n\n\nRactive.joinKeys(key1 [, ...keyN])\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: One or more strings to join.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: A properly joined and escaped keypath.\n\n\n\n\nExamples\n\n\nRactive.joinKeys( 'foo', 'bar.baz' ); // foo.bar\\.baz\n\n\n\n\n\n\nRactive.parse()\n\n\nParses the template into an abstract syntax tree that Ractive can work on.\n\n\nSyntax\n\n\n\n\nRactive.parse(template[, options])\n\n\n\n\nArguments\n\n\n\n\ntemplate (string)\n: A Ractive-compliant HTML template.\n\n\n[options] (Object)\n: Parser options.\n\n\n[preserveWhitespace] (boolean)\n: When \ntrue\n, preserves whitespace in templates. Whitespace inside the \npre\n element is preserved regardless of the value of this option. Defaults to \nfalse\n.\n\n\n[sanitize] (boolean|Object)\n: When \ntrue\n, strips inline event attributes and certain elements from the markup. Defaults to \nfalse\n.\n\n\n[elements] (Array\nstring\n)\n: An array of element names to blacklist.\n\n\n[eventAttributes] (boolean)\n: When \ntrue\n, strips off inline event attributes.\n\n\n\n\n\n\n\n\n\n\n\n\nWhen \nsanitize\n is \ntrue\n, the following elements are stripped:\n\n\n\n\napplet\n\n\nbase\n\n\nbasefont\n\n\nbody\n\n\nframe\n\n\nframeset\n\n\nhead\n\n\nhtml\n\n\nisindex\n\n\nlink\n\n\nmeta\n\n\nnoframes\n\n\nnoscript\n\n\nobject\n\n\nparam\n\n\nscript\n\n\nstyle\n\n\ntitle\n\n\n\n\nReturns\n\n\n\n\n(Object)\n - The object representation of the provided markup.\n\n\n\n\nExamples\n\n\nAssume the following markup.\n\n\ndiv class='gallery'\n\n  {{#items}}\n    \n!-- comments get stripped out of the template --\n\n    \nfigure proxy-tap='select' intro='staggered'\n\n      \nimg class='thumbnail' src='assets/images/{{id}}.jpg'\n\n      \nfigcaption\n{{( i+1 )}}: {{description}}\n/figcaption\n\n    \n/figure\n\n  {{/items}}\n\n/div\n\n\n\n\n\nRactive.parse( template );\n will yield the following output:\n\n\n[{\nt\n:7,\ne\n:\ndiv\n,\na\n:{\nclass\n:\ngallery\n},\nf\n:[{\nt\n:4,\nr\n:\nitems\n,\ni\n:\ni\n,\nf\n:[\n \n,{\nt\n:7,\ne\n:\nfigure\n,\na\n:{\nintro\n:\nstaggered\n},\nf\n:[{\nt\n:7,\ne\n:\nimg\n,\na\n:{\nclass\n:\nthumbnail\n,\nsrc\n:[\nassets/images/\n,{\nt\n:2,\nr\n:\nid\n,\np\n:4},\n.jpg\n]}},\n \n,{\nt\n:7,\ne\n:\nfigcaption\n,\nf\n:[{\nt\n:2,\nx\n:{\nr\n:[\ni\n],\ns\n:\n\u27560+1\n},\np\n:4},\n: \n,{\nt\n:2,\nr\n:\ndescription\n,\np\n:4}]}],\nv\n:{\ntap\n:\nselect\n}},\n \n],\np\n:1}]}]\n\n\n\n\nTODO: \nRactive.parse\n has more options. Document them.\n\n\n\n\nRactive.splitKeypath()\n\n\nSplits the given \nkeypath\n into an array of unescaped keys.\n\n\nSyntax\n\n\n\n\nRactive.splitKeypath(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n to split into keys.\n\n\n\n\nReturns\n\n\n\n\n(Array)\n: Returns an array of unescaped keys.\n\n\n\n\nExamples\n\n\nRactive.splitKeypath( 'foo.bar\\.baz' ); // [ 'foo', 'bar.baz' ]\n\n\n\n\n\n\nRactive.unescapeKey()\n\n\nUnescapes the given key e.g. \nfoo\\.bar\n =\n \nfoo.bar\n.\n\n\nSyntax\n\n\n\n\nRactive.unescapeKey(key)\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: The key to unescape.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The unescaped key.\n\n\n\n\nExamples\n\n\nRactive.unescapeKey('foo\\.bar'); // foo.bar", 
            "title": "Static Methods"
        }, 
        {
            "location": "/api/static-methods/#static-methods", 
            "text": "", 
            "title": "Static Methods"
        }, 
        {
            "location": "/api/static-methods/#ractiveescapekey", 
            "text": "Escapes the given key so that it can be concatenated with a  keypath  string.  Syntax   Ractive.escapeKey(key)   Arguments   key (string) : The key to escape.   Returns   (string) : The escaped key.   Examples  Ractive.escapeKey('foo.bar'); // foo\\.bar", 
            "title": "Ractive.escapeKey()"
        }, 
        {
            "location": "/api/static-methods/#ractiveextend", 
            "text": "Creates a \"subclass\" of the Ractive constructor or a subclass constructor. See  Components  for an in-depth discussion on the use of  Ractive.extend .  Syntax   Ractive.extend([options[, ...optionsN]])   Arguments   [options] (Object) : One or more objects that represent the defaults for instances of the subclass, with the latter objects' properties taking precedence over the former. See  Initialization Options  for a list of possible options.   Returns   (Function) : The subclass constructor function.   Examples  const SubClass = Ractive.extend({\n    template: ' div {{message}} /div ',\n    data: {\n        message: 'Hello World!'\n    }\n});\n\n//  div Hello World! /div \nconst instance1 = new SubClass({\n    el: '.div1'\n});\n\n//  div Lorem Ipsum /div \nconst instance2 = new SubClass({\n    el: '.div2',\n    data: {\n        message: 'Lorem Ipsum'\n    }\n});", 
            "title": "Ractive.extend()"
        }, 
        {
            "location": "/api/static-methods/#ractivegetcss", 
            "text": "Returns the scoped CSS from Ractive subclasses defined at the time of the call.  If used without arguments, it will return the scoped CSS of all subclasses. If provided an array of scoping IDs, it will return the scoped CSS of all subclasses whose scoping ID is included in the array.  Syntax   Ractive.getCSS([key])   Arguments   [key] (Array string ) : Subclass CSS scoping ID.   Returns   (string) : The scoped CSS.   Examples  // Assuming the generated ID for this subclass is 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.\nconst Subclass1 = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\n// Assuming the generated ID for this subclass is 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy'.\nconst Subclass2 = Ractive.extend({\n    ...\n    css: 'div{ color: green }'\n    ...\n});\n\n// CSS contains the scoped versions of div{ color: red } and div{ color: green }.\nconst css = Ractive.getCSS();\n\n// css contains the scoped version of div{ color: red } only.\nconst css = Ractive.getCSS([ 'xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' ]);", 
            "title": "Ractive.getCSS()"
        }, 
        {
            "location": "/api/static-methods/#ractivegetnodeinfo", 
            "text": "Accepts a node and returns an  Node Info  object containing details of the Ractive instance the node is associated to.  Syntax   Ractive.getNodeInfo(node)   Arguments   node (string|Node) : The DOM node or a CSS selector of the DOM node for which you wish to retrieve the Ractive instance or view details.   Returns   (NodeInfo) : An  NodeInfo  object.   Examples  const info = Ractive.getNodeInfo(document.getElementById('some-node'));\n\nconst info = Ractive.getNodeInfo('#some-node');", 
            "title": "Ractive.getNodeInfo()"
        }, 
        {
            "location": "/api/static-methods/#ractivejoinkeys", 
            "text": "Joins the given keys into a properly escaped  keypath  e.g. `  Syntax   Ractive.joinKeys(key1 [, ...keyN])   Arguments   key (string) : One or more strings to join.   Returns   (string) : A properly joined and escaped keypath.   Examples  Ractive.joinKeys( 'foo', 'bar.baz' ); // foo.bar\\.baz", 
            "title": "Ractive.joinKeys()"
        }, 
        {
            "location": "/api/static-methods/#ractiveparse", 
            "text": "Parses the template into an abstract syntax tree that Ractive can work on.  Syntax   Ractive.parse(template[, options])   Arguments   template (string) : A Ractive-compliant HTML template.  [options] (Object) : Parser options.  [preserveWhitespace] (boolean) : When  true , preserves whitespace in templates. Whitespace inside the  pre  element is preserved regardless of the value of this option. Defaults to  false .  [sanitize] (boolean|Object) : When  true , strips inline event attributes and certain elements from the markup. Defaults to  false .  [elements] (Array string ) : An array of element names to blacklist.  [eventAttributes] (boolean) : When  true , strips off inline event attributes.       When  sanitize  is  true , the following elements are stripped:   applet  base  basefont  body  frame  frameset  head  html  isindex  link  meta  noframes  noscript  object  param  script  style  title   Returns   (Object)  - The object representation of the provided markup.   Examples  Assume the following markup.  div class='gallery' \n  {{#items}}\n     !-- comments get stripped out of the template -- \n     figure proxy-tap='select' intro='staggered' \n       img class='thumbnail' src='assets/images/{{id}}.jpg' \n       figcaption {{( i+1 )}}: {{description}} /figcaption \n     /figure \n  {{/items}} /div   Ractive.parse( template );  will yield the following output:  [{ t :7, e : div , a :{ class : gallery }, f :[{ t :4, r : items , i : i , f :[   ,{ t :7, e : figure , a :{ intro : staggered }, f :[{ t :7, e : img , a :{ class : thumbnail , src :[ assets/images/ ,{ t :2, r : id , p :4}, .jpg ]}},   ,{ t :7, e : figcaption , f :[{ t :2, x :{ r :[ i ], s : \u27560+1 }, p :4}, :  ,{ t :2, r : description , p :4}]}], v :{ tap : select }},   ], p :1}]}]  TODO:  Ractive.parse  has more options. Document them.", 
            "title": "Ractive.parse()"
        }, 
        {
            "location": "/api/static-methods/#ractivesplitkeypath", 
            "text": "Splits the given  keypath  into an array of unescaped keys.  Syntax   Ractive.splitKeypath(keypath)   Arguments   keypath (string) : The  keypath  to split into keys.   Returns   (Array) : Returns an array of unescaped keys.   Examples  Ractive.splitKeypath( 'foo.bar\\.baz' ); // [ 'foo', 'bar.baz' ]", 
            "title": "Ractive.splitKeypath()"
        }, 
        {
            "location": "/api/static-methods/#ractiveunescapekey", 
            "text": "Unescapes the given key e.g.  foo\\.bar  =   foo.bar .  Syntax   Ractive.unescapeKey(key)   Arguments   key (string) : The key to unescape.   Returns   (string) : The unescaped key.   Examples  Ractive.unescapeKey('foo\\.bar'); // foo.bar", 
            "title": "Ractive.unescapeKey()"
        }, 
        {
            "location": "/api/instance-properties/", 
            "text": "Instance Properties\n\n\nractive.adaptors\n\n\n(Object\nstring, Object\n)\n\n\nThe instance-only registry of \nadaptors\n.\n\n\n\n\nractive.components\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \ncomponents\n.\n\n\n\n\nractive.container\n\n\n(Ractive)\n\n\nEach component instance that is in a yielded fragment has a container instance that is accessible using \nthis.container\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nIf \nbar\n \n{{yield}}\ns, then \nbaz\n's container will be the \nfoo\n instance.\n\n\n\n\nractive.decorators\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \ndecorators\n.\n\n\n\n\nractive.easing\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \neasing functions\n.\n\n\n\n\nractive.events\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \nevents\n.\n\n\n\n\nractive.interpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n.\n\n\n\n\nractive.nodes\n\n\n(Object\nstring, HTMLElement\n)\n\n\nAn object containing all of the elements inside the instance that have an \nid\n attribute.\n\n\nconst ractive = new Ractive({\n  el: body,\n  template: '\ndiv id=\nmyDiv\nAn unimaginatively named div.\n/div\n'\n});\n\nractive.nodes.myDiv === document.getElementById( 'myDiv' ); // true\n\n\n\n\nThis will also reference dynamically created elements.\n\n\nconst ractive = new Ractive({\n  el: myContainer,\n  template: `\n    \nul\n\n        {{#items:i}}\n            \nli id='item_{{i}}'\n{{content}}\n/li\n\n        {{/items}}\n    \n/ul\n\n  `,\n  data: { items: myListOfItems }\n});\n\n// Get a reference to an arbitrary li element.\nractive.nodes[ 'item_' + num ];\n\n\n\n\n\n\nractive.parent\n\n\n(Ractive)\n\n\nEach component instance can access its parent using \nthis.parent\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nbaz\n's parent is the \nbar\n instance, and \nbar\n's parent is the \nfoo\n instance.\n\n\n\n\nractive.partials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nThe instance-only registry of \npartials\n.\n\n\n\n\nractive.root\n\n\n(Ractive)\n\n\nEach component instance can access its root Ractive instance using \nthis.root\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nfoo\n, \nbar\n, and \nbaz\n will all have the Ractive instance with this template as their \nroot\n.\n\n\n\n\nractive.transitions\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \ntransitions\n.", 
            "title": "Instance Properties"
        }, 
        {
            "location": "/api/instance-properties/#instance-properties", 
            "text": "", 
            "title": "Instance Properties"
        }, 
        {
            "location": "/api/instance-properties/#ractiveadaptors", 
            "text": "(Object string, Object )  The instance-only registry of  adaptors .", 
            "title": "ractive.adaptors"
        }, 
        {
            "location": "/api/instance-properties/#ractivecomponents", 
            "text": "(Object string, Function )  The instance-only registry of  components .", 
            "title": "ractive.components"
        }, 
        {
            "location": "/api/instance-properties/#ractivecontainer", 
            "text": "(Ractive)  Each component instance that is in a yielded fragment has a container instance that is accessible using  this.container .  foo \n   bar \n     baz / \n   /bar  /foo   If  bar   {{yield}} s, then  baz 's container will be the  foo  instance.", 
            "title": "ractive.container"
        }, 
        {
            "location": "/api/instance-properties/#ractivedecorators", 
            "text": "(Object string, Function )  The instance-only registry of  decorators .", 
            "title": "ractive.decorators"
        }, 
        {
            "location": "/api/instance-properties/#ractiveeasing", 
            "text": "(Object string, Function )  The instance-only registry of  easing functions .", 
            "title": "ractive.easing"
        }, 
        {
            "location": "/api/instance-properties/#ractiveevents", 
            "text": "(Object string, Function )  The instance-only registry of  events .", 
            "title": "ractive.events"
        }, 
        {
            "location": "/api/instance-properties/#ractiveinterpolators", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate() .", 
            "title": "ractive.interpolators"
        }, 
        {
            "location": "/api/instance-properties/#ractivenodes", 
            "text": "(Object string, HTMLElement )  An object containing all of the elements inside the instance that have an  id  attribute.  const ractive = new Ractive({\n  el: body,\n  template: ' div id= myDiv An unimaginatively named div. /div '\n});\n\nractive.nodes.myDiv === document.getElementById( 'myDiv' ); // true  This will also reference dynamically created elements.  const ractive = new Ractive({\n  el: myContainer,\n  template: `\n     ul \n        {{#items:i}}\n             li id='item_{{i}}' {{content}} /li \n        {{/items}}\n     /ul \n  `,\n  data: { items: myListOfItems }\n});\n\n// Get a reference to an arbitrary li element.\nractive.nodes[ 'item_' + num ];", 
            "title": "ractive.nodes"
        }, 
        {
            "location": "/api/instance-properties/#ractiveparent", 
            "text": "(Ractive)  Each component instance can access its parent using  this.parent .  foo \n   bar \n     baz / \n   /bar  /foo   baz 's parent is the  bar  instance, and  bar 's parent is the  foo  instance.", 
            "title": "ractive.parent"
        }, 
        {
            "location": "/api/instance-properties/#ractivepartials", 
            "text": "(Object string, string|Object|Function )  The instance-only registry of  partials .", 
            "title": "ractive.partials"
        }, 
        {
            "location": "/api/instance-properties/#ractiveroot", 
            "text": "(Ractive)  Each component instance can access its root Ractive instance using  this.root .  foo \n   bar \n     baz / \n   /bar  /foo   foo ,  bar , and  baz  will all have the Ractive instance with this template as their  root .", 
            "title": "ractive.root"
        }, 
        {
            "location": "/api/instance-properties/#ractivetransitions", 
            "text": "(Object string, Function )  The instance-only registry of  transitions .", 
            "title": "ractive.transitions"
        }, 
        {
            "location": "/api/instance-methods/", 
            "text": "Instance Methods\n\n\nractive._super()\n\n\nCalls the parent method from a child method of the same name.\n\n\nractive._super()\n is not always available. Only when Ractive detects its use does it make this reference to the parent method.\n\n\nSyntax\n\n\n\n\nractive._super([arg[, ...argN]])\n\n\n\n\nArguments\n\n\n\n\n[arg] (any)\n: One or more arguments to pass to the function.\n\n\n\n\nReturns\n\n\n\n\n(any)\n: Depends on the method called.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n    oninit: function() {\n        console.log('super init')\n    }\n});\n\nvar SubComponent = Component.extend({\n    oninit: function() {\n        this._super();\n        console.log('sub init');\n    }\n})\n\nnew SubComponent();\n\n\n\n\n\n\nractive.add()\n\n\nIncrements the selected keypath.\n\n\nSyntax\n\n\n\n\nractive.add(keypath[, number])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the number we're incrementing.\n\n\n[number] (number)\n: The number to increment by. Defaults to \n1\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the operation completes.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    r.add('counter');\n    console.log(r.get('counter'));\n}, 1000);\n\nsetTimeout(function() {\n    r.add('counter', 10);\n    console.log(r.get('counter'));\n}, 2000);\n\n\n\n\n\n\nractive.animate()\n\n\nSimilar to \nractive.set()\n, this will update the data and re-render any affected mustaches and notify \nobservers\n.\n\n\nAll animations are handled by a global timer that is shared between Ractive instances (and which only runs if there are one or more animations still in progress), so you can trigger as many separate animations as you like without worrying about timer congestion. Where possible, \nrequestAnimationFrame\n is used rather than \nsetTimeout\n.\n\n\nNumeric values and strings that can be parsed as numeric values can be interpolated. Objects and arrays containing numeric values (or other objects and arrays which themselves contain numeric values, and so on recursively) are also interpolated.\n\n\nNote that there is currently no mechanism for detecting cyclical structures! Animating to a value that indirectly references itself will cause an infinite loop.\n\n\nFuture versions of Ractive may include string interpolators - e.g. for SVG paths, colours, transformations and so on, a la D3 - and the ability to pass in your own interpolator.\n\n\nIf an animation is started on a \nkeypath\n which is \nalready\n being animated, the first animation is cancelled. (Currently, there is no mechanism in place to prevent collisions between e.g. \nractive.animate('foo', { bar: 1 })\n and \nractive.animate('foo.bar', 0)\n.)\n\n\nSyntax\n\n\n\n\nractive.animate(keypath, value[, options])\n\n\nractive.animate(map[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n to animate.\n\n\nvalue (number|string|Object|Array)\n: The value to animate to.\n\n\nmap (Object)\n: A key-value hash of \nkeypath\n and value.\n\n\n[options] (Object)\n:\n\n\n[duration] (number)\n: How many milliseconds the animation should run for. Defaults to \n400\n.\n\n\n[easing] (string|Function)\n: The name of an easing function or the easing function itself. Defaults to \nlinear\n.\n\n\n[step] (Function)\n: A function to be called on each step of the animation. Receives \nt\n and \nvalue\n as arguments, where \nt\n is the animation progress (between \n0\n and \n1\n, as determined by the easing function) and \nvalue\n is the intermediate value at \nt\n.\n\n\n[complete] (Function)\n: A function to be called when the animation completes, with the same argument signature as \nstep\n (i.e. \nt\n is \n1\n, and \nvalue\n is the destination value)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a Promise with an additional \nstop\n method, which cancels the animation.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    r.animate('counter', 20, { duration: 2000 });\n}, 1000);\n\n\n\n\n\n\nractive.attachChild()\n\n\nCreates a parent-child relationship between two Ractive instances. The child may be an instance of a component defined by \nractive.extend()\n, but that is not a requirement, as children may be a plain Ractive instance created with \nnew Ractive()\n.\n\n\nSyntax\n\n\nractive.attachChild( child );\nractive.attachChild( child, options );\n\n\n\n\nArguments\n\n\n\n\nchild (Ractive instance)\n: The child instance to attach.\n\n\n[options] (Object)\n:\n\n\n[target] (string)\n: An anchor name at which to render the instance. See \nComponents\n. If the instance is already rendered, it will be unrendered and re-rendered at an appropriate anchor.\n\n\n[append] (boolean)\n: Default \ntrue\n - add the instance to the end of the list for the targeted anchor.\n\n\n[prepend] (boolean)\n: Add the instance to the beginning of the list for the targeted anchor.\n\n\n[insertAt] (number)\n: Index at which to add the instance in the list for the targeted anchor.\n\n\n\n\n\n\n\n\nWhen a child is attached to a parent, the child's \nparent\n property is updated in an observable way, so any references to \n@this.parent\n in the child will be notified of the change.\n\n\nA child may be targeted to a \nComponents\n when it is attached. If a child has no specified target, then it is responsible for managing its own render cycle. If a child does have a specified target, then the parent will manage rendering and unrendering the child as appropriate in the same way that a regular component has a managed render cycle.\n\n\nWhen a child is attached targeting an anchor, only anchors that belong directly to the parent are considered as hosts. However, any element or component queries on the parent instance, including live queries, will consider the child when trying to match both elements and components. There is also an option on the query methods that allows querying remote, unmanaged instances, so that non-anchored children can also be queried for elements and components.\n\n\nReturns\n\n\n\n\n(Promise)\n: A \nPromise\n that resolves with the child instance when any transitions are complete.\n\n\n\n\nChildren can be detached using \nractive.detachChild()\n.\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.detach()\n\n\nDetaches the instance from the DOM, returning a document fragment. You can reinsert it, possibly in a different place, with \nractive.insert()\n (note that if you are reinserting it immediately you don't need to detach it first - it will happen automatically).\n\n\nSyntax\n\n\n\n\nractive.detach()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(DocumentFragment)\n: A document fragment.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    var div = document.createElement('div');\n    div.appendChild(r.detach());\n    console.log(div.innerHTML);\n}, 1000);\n\n\n\n\n\n\nractive.detachChild()\n\n\nDetaches a child from an instance when it was previously attached with \nractive.attachChild()\n.\n\n\nWhen a child instance that was attached targeting an anchor is detached, its instance is spliced out of the \n@this.children.byName.anchorName\n array so that subsequent children move forward to fill the void.\n\n\nSyntax\n\n\n\n\nractive.detachChild( child )\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A \nPromise\n that resolves with the child instance when any transitions are complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.find()\n\n\nReturns the first element inside a given Ractive instance matching a CSS selector. This is similar to doing \nthis.el.querySelector(selector)\n (though it doesn't actually use \nquerySelector()\n).\n\n\nSyntax\n\n\n\n\nractive.find(selector[, options])\n\n\n\n\nArguments\n\n\n\n\nselector (string)\n: A CSS selector representing the element to find.\n\n\n[options] (Object)\n:\n\n\n\n\nReturns\n\n\n\n\n(Node)\n: A Node.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl'\n});\n\nsetTimeout(function() {\n    var p = r.find('p.target');\n    console.log(p.outerHTML);\n}, 1000);\n\n\n\n\n\n\nractive.findAll()\n\n\nThis method is similar to [\nractive.find()\n]ractivefind), with two important differences. Firstly, it returns a list of elements matching the selector, rather than a single node. Secondly, it can return a \nlive\n list, which will stay in sync with the DOM as it continues to update.\n\n\nSyntax\n\n\n\n\nractive.findAll(selector[, options])\n\n\n\n\nArguments\n\n\n\n\nselector (string)\n: A CSS selector representing the elements to find.\n\n\n[options] (Object)\n\n\n[live] (boolean)\n: Whether to return a live list or a static one. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Array\nNode\n)\n: An array of nodes.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl'\n});\n\nsetTimeout(function() {\n    var ps = r.findAll('p');\n    ps.forEach(function(p) {\n        console.log(p.outerHTML);\n    })\n}, 1000);\n\n\n\n\n\n\nractive.findAllComponents()\n\n\nReturns all components inside a given Ractive instance with the given \nname\n (or all components of any kind if no name is given).\n\n\nSyntax\n\n\n\n\nractive.findAllComponents([name[, options]])\n\n\n\n\nArguments\n\n\n\n\n[name] (string)\n: The name of the component to find.\n\n\n[options] (Object)\n\n\n[live] (boolean)\n: Whether to return a live list or a static one. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Array\nractive\n)\n: An array of ractive instances.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n    template: 'Component {{number}}'\n});\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    components: {\n        Component: Component\n    }\n});\n\nsetTimeout(function() {\n    var cs = r.findAllComponents('Component');\n    cs.forEach(function(c) {\n        console.log(c.toHTML());\n    })\n}, 1000);\n\n\n\n\n\n\nractive.findComponent()\n\n\nReturns the first component inside a given Ractive instance with the given \nname\n (or the first component of any kind if no name is given).\n\n\nSyntax\n\n\n\n\nractive.findComponent([name[, options]])\n\n\n\n\nArguments\n\n\n\n\n[name] (string)\n: The name of the component to find.\n\n\n[options] (Object)\n:\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: A ractive instance.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n    template: 'Component {{number}}'\n});\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    components: {\n        Component: Component\n    }\n});\n\nsetTimeout(function() {\n    var c = r.findComponent('Component');\n    console.log(c.toHTML());\n}, 1000);\n\n\n\n\n\n\nractive.findContainer()\n\n\nReturns the first container of this component instance with the given \nname\n.\n\n\nSyntax\n\n\n\n\nractive.findContainer(name)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the container to find.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the first container of this component with the given \nname\n.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.findParent()\n\n\nReturns the first parent of this component instance with the given \nname\n.\n\n\nSyntax\n\n\n\n\nractive.findParent(name)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the parent to find.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the first parent of this component with the given \nname\n.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.fire()\n\n\nFires an event, which will be received by handlers that were bound using \nractive.on\n. In practical terms, you would mostly likely use this with \nRactive.extend()\n, to allow applications to hook into your subclass.\n\n\nSyntax\n\n\n\n\nractive.fire(eventName[, arg1[, ...argN])\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the event.\n\n\n[arg] (any)\n: The arguments that event handlers will be called with.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive();\n\nr.on('foo', function() {\n  console.log('foo fired');\n});\n\nr.fire('foo');\n\n\n\n\n\n\nractive.get()\n\n\nReturns the value at \nkeypath\n. If the \nkeypath\n is omitted, returns a shallow copy of all the data in the instance. This data includes mappings introduced by enclosing components, but excludes computed properties.\n\n\nSyntax\n\n\n\n\nractive.get([keypath])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The \nkeypath\n of the data to retrieve.\n\n\n\n\nReturns\n\n\n\n\n(any)\n: Returns whatever data was on the keypath, or all if no \nkeypath\n was provided.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    data: {\n        foo: {\n            bar: [ 'baz' ]\n        }\n    }\n});\n\nconsole.log(r.get('foo.bar.0'));\n\n\n\n\n\n\nractive.getNodeInfo()\n\n\nThis is an instance specific version of \nRactive.getNodeInfo()\n that will only search the local instance DOM for a matching node when a selector is given. If the given value is not a string, then it is passed directly through to the static version of this method.\n\n\nSyntax\n\n\n\n\nractive.getNodeInfo(node)\n\n\n\n\nArguments\n\n\n\n\nnode (string|Node)\n: The DOM node or a CSS selector of a target node for which you wish to retrieve the Ractive instance or view details.\n\n\n\n\nReturns\n\n\n\n\n(NodeInfo)\n: Returns an \nNodeInfo\n object with helper methods to interact with the Ractive instance and context associated with the given node.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.insert()\n\n\nInserts the instance to a different location. If the instance is currently in the DOM, it will be detached first. See also \nractive.detach()\n.\n\n\nSyntax\n\n\n\n\nractive.insert(target[, anchor])\n\n\n\n\nArguments\n\n\n\n\ntarget (string|Node|array-like)\n: The new parent element.\n\n\n[anchor] (string|Node|array-like)\n: The sibling element to insert the instance before. If omitted, the instance will be inserted as the last child of the parent.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.link()\n\n\nCreates a link between two \nkeypaths\n that keeps them in sync. Since Ractive can't always watch the contents of objects, copying an object to two different \nkeypaths\n in your data usually leads to one or both of them getting out of sync. \nlink\n creates a sort of symlink between the two paths so that Ractive knows they are actually the same object. This is particularly useful for master/detail scenarios where you have a complex list of data and you want to be able to select an item to edit in a detail form.\n\n\nSyntax\n\n\n\n\nractive.link(source, destination)\n\n\n\n\nArguments\n\n\n\n\nsource (string)\n: The \nkeypath\n of the source item.\n\n\ndestination (string)\n: The \nkeypath\n to use as the destination - or where you'd like the data 'copied'.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise.\n\n\n\n\nExamples\n\n\nractive.link( 'some.nested.0.list.25.item', 'current' );\nractive.set( 'current.name', 'Rich' ); // some.nested.0.list.25.item.name is also updated to be 'Rich'\n\n\n\n\nThis can be used to great effect with method events and the \n@keypath\n special ref:\n\n\n{{#each some.nested}}\n  {{#each list}}\n    {{#with item}}\n      {{.name}}\n      \nbutton on-click=\nevent.link('.', 'current')\nSelect\n/button\n\n    {{/with}}\n  {{/each}}\n{{/each}}\n\nName: \ninput value=\n{{~/current.name}}\n /\n\n\n\n\n\nLinks can be removed using \nractive.unlink()\n.\n\n\n\n\nractive.merge()\n\n\nSets the indicated \nkeypath\n to the new array value, but \"merges\" the existing rendered nodes representing the data into the newly rendered array, inserting and removing nodes from the DOM as necessary. Where necessary, items are moved from their current location in the array (and, therefore, in the DOM) to their new location.\n\n\nThis is an efficient way to (for example) handle data from a server. It also helps to control \nintro\n and \noutro\n \ntransitions\n which might not otherwise happen with a basic \nractive.set()\n operation.\n\n\nTo determine whether the first item of \n['foo', 'bar', 'baz']\n is the same as the last item of \n['bar', 'baz', 'foo']\n, by default we do a strict equality (\n===\n) check.\n\n\nIn some situations that won't work, because the arrays contain objects, which may \nlook\n the same but not be identical. To deal with these, we use the \ncompare\n option detailed below.\n\n\nMerge can also be used to created a context block that uses transitions when the context changes.\n\n\nSyntax\n\n\n\n\nractive.merge(keypath, value[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array we're updating.\n\n\nvalue (Array)\n: The new data to merge in.\n\n\n[options] (Object)\n\n\n[compare] (boolean)\n: If \ntrue\n, values will be stringified (with \nJSON.stringify\n) before comparison.\n\n\n[compare] (string)\n: A property name that will be used to compare the array elements.\n\n\n[compare] (Function)\n: A function that returns a value with which to compare array members.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - Returns a promise.\n\n\n\n\nExamples\n\n\n{{#user}}\n\ndiv intro='fade'\n{{first}} {{last}}\n/div\n\n{{/}}\n\n\n\n\nvar r = new Ractive({\n    el: document.body,\n    template: '#template',\n    data: {\n        user: [{\n            first: 'sam',\n            last: 'smith'\n        }]\n    },\n    complete: function(){\n        this.merge('user', [{\n            first: 'jane',\n            last: 'johnson'\n        }])\n    }\n})\n\n\n\n\n\n\nractive.observe()\n\n\nObserves the data at a particular \nkeypath\n. Unless specified otherwise, the callback will be fired immediately, with \nundefined\n as \noldValue\n. Thereafter it will be called whenever the \nobserved keypath\n changes.\n\n\nSyntax\n\n\n\n\nractive.observe(keypath, callback[, options])\n\n\nractive.observe(map[, options])\n\n\n\n\nArguments\n\n\n\n\n\n\nkeypath (String)\n: The \nkeypath\n to observe, or a group of space-separated keypaths. Any of the keys can be a \n*\n character, which is treated as a wildcard. A \n**\n means recursive.\n\n\nThe difference between \n*\n and \n**\n is that \n*\n provides your callback function \nvalue\n and \nkeypath\n arguments containing the path of the what actually changed, at any level of the keypath. So instead of getting the same parent value on every change, you get the changed value from whatever arbitrarily deep keypath changed.\n\n\n\n\n\n\ncallback (Function)\n: The function that will be called, with \nnewValue\n, \noldValue\n and \nkeypath\n as arguments (see \nObservers\n for more nuance regarding these arguments), whenever the observed \nkeypath\n changes value. By default the function will be called with \nractive\n as \nthis\n. Any wildcards in the \nkeypath\n will have their matches passed to the callback at the end of the arguments list as well.\n\n\n\n\nmap (Object)\n: A map of keypath-observer pairs.\n\n\n[options] (Object)\n:\n\n\n[init] (boolean)\n: Defaults to \ntrue\n. Whether or not to initialise the observer, i.e. call the function with the current value of \nkeypath\n as the first argument and \nundefined\n as the second.\n\n\n[defer] (boolean)\n: Defaults to \nfalse\n, in which case \nobservers\n will fire before any DOM changes take place. If \ntrue\n, the \nobserver\n will fire once the DOM has been updated.\n\n\n[links] (boolean)\n: Defaults to \nfalse\n.  Whether or not the observer should \"follow through\" any links created with \nractive.link()\n.\n\n\n[strict] (boolean)\n: Defaults to \nfalse\n. \nstrict\n uses object identity to determine if there was a change, meaning that unless the primary object changed, it won't trigger the observer. For example with \n{ data: { foo: { bar: 'baz' } } }\n, \nractive.observe('foo', ..., { strict: true })\n will not fire on \nractive.set('foo.bar', 'bat')\n but will on \nractive.set('foo', { bar: 'bip' })\n.\n\n\n[context] (any)\n: Defaults to \nractive\n. The context the \nobserver\n is called in (i.e. the value of \nthis\n)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: An object with a \ncancel\n method, for cancelling all observers\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nNote that you can observe \nkeypath\n \npatterns\n...\n\n\nractive.observe( 'items.*.status', function ( newValue, oldValue, keypath) {\n    var index = /items.(\\d+).status/.exec( keypath )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\n...or multiple space-separated \nkeypaths\n simultaneously:\n\n\nractive.observe( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n    alert( keypath ) + ' changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\nSee \nObservers\n for more detail.\n\n\n\n\nractive.observeOnce()\n\n\nObserves the data at a particular \nkeypath\n until the first change. After the handler has been called, it will be unsubscribed from any future changes.\n\n\nSyntax\n\n\n\n\nractive.observeOnce(keypath, callback[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n to observe, or a group of space-separated keypaths. Any of the keys can be a `` character, which is treated as a wildcard.\n\n\ncallback (Function)\n: The function that will be called, with \nnewValue\n, \noldValue\n and \nkeypath\n as arguments (see \nObservers\n for more nuance regarding these arguments), whenever the observed \nkeypath\n changes value. By default the function will be called with \nractive\n as \nthis\n. Any wildcards in the \nkeypath\n will have their matches passed to the callback at the end of the arguments list as well.\n\n\n[options] (Object)\n:\n\n\n[defer] (boolean)\n: Defaults to \nfalse\n, in which case \nobservers\n will fire before any DOM changes take place. If \ntrue\n, the \nobserver\n will fire once the DOM has been updated.\n\n\n[context] (any)\n: Defaults to \nractive\n. The context the \nobserver\n is called in (i.e. the value of \nthis\n)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: An object with a \ncancel\n method, for cancelling the observer.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nNote that you can observe \nkeypath\n \npatterns\n...\n\n\nractive.observeOnce( 'items.*.status', function ( newValue, oldValue, keypath ) {\n    var index = /items.(\\d+).status/.exec( keypath )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\n...or multiple space-separated \nkeypaths\n simultaneously:\n\n\nractive.observeOnce( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n    alert( keypath + ' changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\nSee \nObservers\n for more detail.\n\n\n\n\nractive.off()\n\n\nRemoves an event handler, several event handlers, or all event handlers.\n\n\nTo remove a single handler, you must specify both the event name and the handler. If you only specify the event name, all handlers bound to that event name will be removed. If you specify neither event name nor handler, \nall\n event handlers will be removed.\n\n\nAn alternative way to remove event handlers is to use the \ncancel\n method of the return value of a call to \nractive.on()\n.\n\n\nSyntax\n\n\n\n\nractive.off([eventName[, handler]])\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The event name to which this handler is currently bound.\n\n\nhandler (Function)\n: The handler to remove.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the \nractive\n instance to allow this call to be chainable.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.on()\n\n\nSubscribe to \nevents\n.\n\n\nSyntax\n\n\n\n\nractive.on(eventName, handler)\n\n\nractive.on(obj)\n\n\n\n\nArguments\n\n\n\n\neventName (String)\n: The name of the event to subscribe to\n\n\nhandler (Function)\n: The function that will be called, with \nractive\n as \nthis\n. The arguments depend on the event. Returning \nfalse\n from the handler will stop propagation and prevent default of DOM events and cancel \nevent bubbling\n.\n\n\nobj (Object)\n: An object with keys named for each event to subscribe to. The value at each key is the handler function for that event.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n - An \nObject\n with a \ncancel\n method, which removes the handler.\n\n\n(Object)\n - An \nObject\n with a \ncancel\n method, which removes all handlers in the passed-in \nobj\n.\n\n\n\n\nExamples\n\n\n// single handler to function\nractive.on( 'activate', function () {...});\n\n// wildcard pattern matching\nractive.on( 'foo.*', function () {...} );\n\n// multiple handlers to one function\nractive.on( 'activate select', function () {...} );\n\n// map of handler/function pairs\nractive.on({\n    activate: function () {...},\n    select: function () {...}\n});\n\n// knock yourself out:\nractive.on({\n    activate: function () {...},\n    'bip bop boop': function () {...},\n    'select foo.* bar': function () {...}\n});\n\n\n\n\n\n\nractive.once()\n\n\nSubscribe to an event for a single firing. This is a convenience function on top of \nractive.on()\n.\n\n\nSyntax\n\n\n\n\nractive.once(eventName, handler)\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The name of the event to subscribe to.\n\n\nhandler (Function)\n: The function that will be called, with \nractive\n as \nthis\n. The arguments depend on the event. Returning \nfalse\n from the handler will stop propagation and prevent default of DOM events and cancel \nevent bubbling\n.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: Returns an \nObject\n with a \ncancel\n method, which removes the handler.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.pop()\n\n\nThe Ractive equivalent to \nArray.pop\n that removes an element from the end of the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.pop(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve with the removed element after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.push()\n\n\nThe Ractive equivalent to \nArray.push\n that appends one or more elements to the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.push(keypath, value[, ...valueN])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nvalue (any)\n: The value to append to the end of the array. One or more values may be supplied.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - Returns a Promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.render()\n\n\nRenders the component into a DOM element.\n\n\nSyntax\n\n\n\n\nractive.render(target)\n\n\n\n\nArguments\n\n\n\n\ntarget (Node|String|array-like)\n: The DOM element to render to.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when rendering completes or when the instance is already rendered.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.reset()\n\n\nResets the entire \nractive.data\n object and updates the DOM.\n\n\nSyntax\n\n\n\n\nractive.reset(data)\n\n\n\n\nArguments\n\n\n\n\ndata (Object)\n: The data to reset with. Defaults to \n{}\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\nThis differs from \nractive.set()\n in the following way:\n\n\nractive = new Ractive({\n  // ...,\n  data: { foo: 1 }\n});\n\nractive.set({ bar: 2 });\nconsole.log( ractive.get() ); // { foo: 1, bar: 2 }\n\nractive.reset({ bar: 2 });\nconsole.log( ractive.get() ); // { bar: 2 }\n\n\n\n\n\n\nractive.resetPartial()\n\n\nResets a partial and re-renders all of its use-sites, including in any components that have inherited it. If a component has a partial with a same name that is its own, that partial will not be affected.\n\n\nInline partials that don't belong directly to a Ractive instance aren't affected by \nresetPartial\n.\n\n\nSyntax\n\n\n\n\nractive.resetPartial(name, partial)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The partial to reset.\n\n\npartial (string|Object|Function)\n: A template string, pre-parsed template or a function that returns either.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\nractive = new Ractive({\n  // ...,\n  partials: { foo: 'foo' }\n});\n\n// {{\nfoo}} will be replaced with 'foo'\n\nractive.resetPartial('foo', 'bar');\n\n// {{\nfoo}} will be replaced with 'bar'\n\n\n\n\n\n\nractive.reverse()\n\n\nThe Ractive equivalent to \nArray.reverse\n reverses the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.reverse(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (String)\n: The \nkeypath\n of the array to reverse, e.g. \nlist\n or \norder.items\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - A promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.set()\n\n\nUpdates data and triggers a re-render of any mustaches that are affected (directly or indirectly) by the change. Any \nobservers\n of affected \nkeypaths\n will be notified.\n\n\nWhen setting an array value, ractive will reuse the existing DOM nodes for the new array, adding or removing nodes as necessary. This can impact nodes with \ntransitions\n. See \nractive.merge()\n for setting a new array value while retaining existing nodes corresponding to individual array item values.\n\n\nSyntax\n\n\n\n\nractive.set(keypath, value)\n\n\nractive.set(map)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the data we're changing, e.g. \nuser\n or \nuser.name\n or \nuser.friends[1]\n or \nusers.*.status\n.\n\n\nvalue (any)\n: The value we're changing it to. Can be a primitive or an object (or array), in which case dependants of \ndownstream keypaths\n will also be re-rendered (if they have changed).\n\n\nmap (Object)\n: A map of \nkeypath: value\n pairs, as above.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will be called after the set operation and any transitions are complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nThe \nkeypath\n can also contain wildcards \npattern-observers\n. All matching \nkeypaths\n will be set with the supplied values:\n\n\nractive.on('selectAll', function(){\n    ractive.set('items.*.selected', true);\n})\n\n\n\n\n\n\nractive.shift()\n\n\nThe Ractive equivalent to \nArray.shift\n that removes an element from the beginning of the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.shift(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that will resolve with the removed element after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.sort()\n\n\nThe Ractive equivalent to \nArray.sort\n sorts the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.sort(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to sort, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.splice()\n\n\nThe Ractive equivalent to \nArray.splice\n that can add new elements to the array while removing existing elements.\n\n\nIf the given \nkeypath\n does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.splice(keypath, index, [removeCount[, add]])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nindex (number)\n: The index at which to start the operation.\n\n\n[removeCount] (number)\n: The number of elements to remove starting with the element at *\nindex\n. This may be 0 if you don't want to remove any elements.\n\n\n[add] (any)\n: Any elements to insert into the array starting at *\nindex\n. There can be 0 or more elements passed to add to the array.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve with the removed elements after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.subtract()\n\n\nDecrements the selected \nkeypath\n.\n\n\nSyntax\n\n\n\n\nractive.subtract(keypath[, number])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the number we're decrementing.\n\n\n[number] (number)\n: Defaults to \n1\n. The number to decrement by.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.teardown()\n\n\nUnrenders this Ractive instance, removing any event handlers that were bound automatically by Ractive.\n\n\nCalling \nractive.teardown()\n causes a \nteardown\n \nevent\n to be fired - this is most useful with \nRactive.extend()\n as it allows you to clean up anything else (event listeners and other bindings) that are part of the subclass.\n\n\nSyntax\n\n\n\n\nractive.teardown()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.toCSS()\n\n\nReturns the scoped CSS of the current instance and its descendants.\n\n\nAt the moment, this will not work on a direct instance of Ractive and will log a warning. You can only use this method on an instance of a subclass.\n\n\nSyntax\n\n\n\n\nractive.toCSS()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The scoped CSS of the instance.\n\n\n\n\nExamples\n\n\nconst Subclass = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\nconst subclassInstance = new Subclass({...});\n\n// Contains the scoped version of div{ color: red }\nsubclassInstance.toCSS();\n\n\n\n\n\n\nractive.toHTML()\n\n\nReturns a chunk of HTML representing the current state of the instance. This is most useful when you're using Ractive in node.js, as it allows you to serve fully-rendered pages (good for SEO and initial pageload performance) to the client.\n\n\nSyntax\n\n\n\n\nractive.toHTML()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The instance HTML.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.toggle()\n\n\nToggles the selected \nkeypath\n. In other words, if \nfoo\n is \ntruthy\n, then \nractive.toggle('foo')\n will make it \nfalse\n, and vice-versa.\n\n\nSyntax\n\n\n\n\nractive.toggle(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n to toggle the value of. If \nkeypath\n is a pattern, then all matching \nkeypaths\n will be toggled.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.transition()\n\n\nTriggers a transition on a node managed by this Ractive instance.\n\n\nSyntax\n\n\n\n\nractive.transition(transition, node, options)\n\n\n\n\nArguments\n\n\n\n\ntransition (string|Function)\n: A transition function or a name of a transition function.\n\n\nnode (HTMLElement)\n: The node on which to start the transition - optional if called from within a Ractive event handler, as it will be retrieved from the event if not supplied.\n\n\noptions (Object)\n: Options supplied to the transition.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the transition completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.unlink()\n\n\nRemoves a link set up by \nractive.link()\n.\n\n\nSyntax\n\n\n\n\nractive.unlink(destination)\n\n\n\n\nArguments\n\n\n\n\ndestination (string)\n: The destination supplied to [\nractive.link()\n].\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.unrender()\n\n\n\n\nUnrenders this Ractive instance, throwing away any DOM nodes associated with this instance. This is the counterpart to \nractive.render()\n. The rest of the ractive instance is left intact, unlike \nractive.teardown()\n.\n\n\nSyntax\n\n\n\n\nractive.unrender()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.unshift()\n\n\nThe Ractive equivalent to \nArray.unshift\n that prepends one or more elements to the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.unshift(keypath, value)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nvalue (any)\n: The value to prepend to the beginning of the array. One or more values may be supplied.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.update()\n\n\n\"Dirty checks\" everything that depends directly or indirectly on the specified \nkeypath\n. If no \nkeypath\n is specified, all keypaths will be checked. Keypaths that involve special references (i.e. \n@global\n) require the keypath to be supplied.\n\n\nThis is useful when manipulating the instance's data without using the built in setter methods (i.e. \nractive.set()\n, \nractive.animate()\n).\n\n\nSyntax\n\n\n\n\nractive.update([keypath])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The keypath to treat as 'dirty'.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the operation completes.\n\n\n\n\nExamples\n\n\nractive.observe( 'foo', function ( foo ) {\n  alert( foo );\n});\n\nmodel.foo = 'changed';   // Does not cause the instance to update.\nractive.update( 'foo' ); // Informs the instance that foo was changed externally.\n\n\n\n\n\n\nractive.updateModel()\n\n\nIf you programmatically manipulate inputs and other elements that have \ntwo\u2010way binding\n set up, your model can get out of sync. In these cases, we need to force a resync with \nractive.updateModel()\n:\n\n\nSyntax\n\n\n\n\nractive.updateModel([keypath[, cascade]])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n to treat as 'dirty'. Any two-way bindings linked to this \nkeypath\n will be checked to see if the model is out of date\n\n\ncascade (boolean)\n: If true, bindings that are \ndownstream\n of \nkeypath\n will also be checked - e.g. \nractive.updateModel( 'items', true )\n would check \nitems.0.foo\n and \nitems.1.foo\n and so on. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise. If a \nkeypath\n is not specified, all two-way bindings will be checked.\n\n\n\n\nExamples\n\n\nractive = new Ractive({\n  el: 'container',\n  template: '\ninput value=\n{{name}}\n'\n  data: { name: 'Bob' }\n});\n\nractive.find( 'input' ).value = 'Jim';\nalert( ractive.get( 'name' ) ); // alerts 'Bob', not 'Jim'\n\nractive.updateModel();\nalert( ractive.get( 'name' ) ); // alerts 'Jim'", 
            "title": "Instance Methods"
        }, 
        {
            "location": "/api/instance-methods/#instance-methods", 
            "text": "", 
            "title": "Instance Methods"
        }, 
        {
            "location": "/api/instance-methods/#ractive_super", 
            "text": "Calls the parent method from a child method of the same name.  ractive._super()  is not always available. Only when Ractive detects its use does it make this reference to the parent method.  Syntax   ractive._super([arg[, ...argN]])   Arguments   [arg] (any) : One or more arguments to pass to the function.   Returns   (any) : Depends on the method called.   Examples   var Component = Ractive.extend({\n    oninit: function() {\n        console.log('super init')\n    }\n});\n\nvar SubComponent = Component.extend({\n    oninit: function() {\n        this._super();\n        console.log('sub init');\n    }\n})\n\nnew SubComponent();", 
            "title": "ractive._super()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveadd", 
            "text": "Increments the selected keypath.  Syntax   ractive.add(keypath[, number])   Arguments   keypath (string) : The  keypath  of the number we're incrementing.  [number] (number) : The number to increment by. Defaults to  1 .   Returns   (Promise) : A promise that resolves when the operation completes.   Examples   var r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    r.add('counter');\n    console.log(r.get('counter'));\n}, 1000);\n\nsetTimeout(function() {\n    r.add('counter', 10);\n    console.log(r.get('counter'));\n}, 2000);", 
            "title": "ractive.add()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveanimate", 
            "text": "Similar to  ractive.set() , this will update the data and re-render any affected mustaches and notify  observers .  All animations are handled by a global timer that is shared between Ractive instances (and which only runs if there are one or more animations still in progress), so you can trigger as many separate animations as you like without worrying about timer congestion. Where possible,  requestAnimationFrame  is used rather than  setTimeout .  Numeric values and strings that can be parsed as numeric values can be interpolated. Objects and arrays containing numeric values (or other objects and arrays which themselves contain numeric values, and so on recursively) are also interpolated.  Note that there is currently no mechanism for detecting cyclical structures! Animating to a value that indirectly references itself will cause an infinite loop.  Future versions of Ractive may include string interpolators - e.g. for SVG paths, colours, transformations and so on, a la D3 - and the ability to pass in your own interpolator.  If an animation is started on a  keypath  which is  already  being animated, the first animation is cancelled. (Currently, there is no mechanism in place to prevent collisions between e.g.  ractive.animate('foo', { bar: 1 })  and  ractive.animate('foo.bar', 0) .)  Syntax   ractive.animate(keypath, value[, options])  ractive.animate(map[, options])   Arguments   keypath (string) : The  keypath  to animate.  value (number|string|Object|Array) : The value to animate to.  map (Object) : A key-value hash of  keypath  and value.  [options] (Object) :  [duration] (number) : How many milliseconds the animation should run for. Defaults to  400 .  [easing] (string|Function) : The name of an easing function or the easing function itself. Defaults to  linear .  [step] (Function) : A function to be called on each step of the animation. Receives  t  and  value  as arguments, where  t  is the animation progress (between  0  and  1 , as determined by the easing function) and  value  is the intermediate value at  t .  [complete] (Function) : A function to be called when the animation completes, with the same argument signature as  step  (i.e.  t  is  1 , and  value  is the destination value)     Returns   (Promise) : Returns a Promise with an additional  stop  method, which cancels the animation.   Examples   var r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    r.animate('counter', 20, { duration: 2000 });\n}, 1000);", 
            "title": "ractive.animate()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveattachchild", 
            "text": "Creates a parent-child relationship between two Ractive instances. The child may be an instance of a component defined by  ractive.extend() , but that is not a requirement, as children may be a plain Ractive instance created with  new Ractive() .  Syntax  ractive.attachChild( child );\nractive.attachChild( child, options );  Arguments   child (Ractive instance) : The child instance to attach.  [options] (Object) :  [target] (string) : An anchor name at which to render the instance. See  Components . If the instance is already rendered, it will be unrendered and re-rendered at an appropriate anchor.  [append] (boolean) : Default  true  - add the instance to the end of the list for the targeted anchor.  [prepend] (boolean) : Add the instance to the beginning of the list for the targeted anchor.  [insertAt] (number) : Index at which to add the instance in the list for the targeted anchor.     When a child is attached to a parent, the child's  parent  property is updated in an observable way, so any references to  @this.parent  in the child will be notified of the change.  A child may be targeted to a  Components  when it is attached. If a child has no specified target, then it is responsible for managing its own render cycle. If a child does have a specified target, then the parent will manage rendering and unrendering the child as appropriate in the same way that a regular component has a managed render cycle.  When a child is attached targeting an anchor, only anchors that belong directly to the parent are considered as hosts. However, any element or component queries on the parent instance, including live queries, will consider the child when trying to match both elements and components. There is also an option on the query methods that allows querying remote, unmanaged instances, so that non-anchored children can also be queried for elements and components.  Returns   (Promise) : A  Promise  that resolves with the child instance when any transitions are complete.   Children can be detached using  ractive.detachChild() .  Examples  // TODO", 
            "title": "ractive.attachChild()"
        }, 
        {
            "location": "/api/instance-methods/#ractivedetach", 
            "text": "Detaches the instance from the DOM, returning a document fragment. You can reinsert it, possibly in a different place, with  ractive.insert()  (note that if you are reinserting it immediately you don't need to detach it first - it will happen automatically).  Syntax   ractive.detach()   Arguments   None   Returns   (DocumentFragment) : A document fragment.   Examples   var r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    var div = document.createElement('div');\n    div.appendChild(r.detach());\n    console.log(div.innerHTML);\n}, 1000);", 
            "title": "ractive.detach()"
        }, 
        {
            "location": "/api/instance-methods/#ractivedetachchild", 
            "text": "Detaches a child from an instance when it was previously attached with  ractive.attachChild() .  When a child instance that was attached targeting an anchor is detached, its instance is spliced out of the  @this.children.byName.anchorName  array so that subsequent children move forward to fill the void.  Syntax   ractive.detachChild( child )   Returns   (Promise) : A  Promise  that resolves with the child instance when any transitions are complete.   Examples  // TODO", 
            "title": "ractive.detachChild()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefind", 
            "text": "Returns the first element inside a given Ractive instance matching a CSS selector. This is similar to doing  this.el.querySelector(selector)  (though it doesn't actually use  querySelector() ).  Syntax   ractive.find(selector[, options])   Arguments   selector (string) : A CSS selector representing the element to find.  [options] (Object) :   Returns   (Node) : A Node.   Examples   var r = new Ractive({\n    el: '#main',\n    template: '#tpl'\n});\n\nsetTimeout(function() {\n    var p = r.find('p.target');\n    console.log(p.outerHTML);\n}, 1000);", 
            "title": "ractive.find()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefindall", 
            "text": "This method is similar to [ ractive.find() ]ractivefind), with two important differences. Firstly, it returns a list of elements matching the selector, rather than a single node. Secondly, it can return a  live  list, which will stay in sync with the DOM as it continues to update.  Syntax   ractive.findAll(selector[, options])   Arguments   selector (string) : A CSS selector representing the elements to find.  [options] (Object)  [live] (boolean) : Whether to return a live list or a static one. Defaults to  false .     Returns   (Array Node ) : An array of nodes.   Examples   var r = new Ractive({\n    el: '#main',\n    template: '#tpl'\n});\n\nsetTimeout(function() {\n    var ps = r.findAll('p');\n    ps.forEach(function(p) {\n        console.log(p.outerHTML);\n    })\n}, 1000);", 
            "title": "ractive.findAll()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefindallcomponents", 
            "text": "Returns all components inside a given Ractive instance with the given  name  (or all components of any kind if no name is given).  Syntax   ractive.findAllComponents([name[, options]])   Arguments   [name] (string) : The name of the component to find.  [options] (Object)  [live] (boolean) : Whether to return a live list or a static one. Defaults to  false .     Returns   (Array ractive ) : An array of ractive instances.   Examples   var Component = Ractive.extend({\n    template: 'Component {{number}}'\n});\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    components: {\n        Component: Component\n    }\n});\n\nsetTimeout(function() {\n    var cs = r.findAllComponents('Component');\n    cs.forEach(function(c) {\n        console.log(c.toHTML());\n    })\n}, 1000);", 
            "title": "ractive.findAllComponents()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefindcomponent", 
            "text": "Returns the first component inside a given Ractive instance with the given  name  (or the first component of any kind if no name is given).  Syntax   ractive.findComponent([name[, options]])   Arguments   [name] (string) : The name of the component to find.  [options] (Object) :   Returns   (Ractive) : A ractive instance.   Examples   var Component = Ractive.extend({\n    template: 'Component {{number}}'\n});\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    components: {\n        Component: Component\n    }\n});\n\nsetTimeout(function() {\n    var c = r.findComponent('Component');\n    console.log(c.toHTML());\n}, 1000);", 
            "title": "ractive.findComponent()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefindcontainer", 
            "text": "Returns the first container of this component instance with the given  name .  Syntax   ractive.findContainer(name)   Arguments   name (string) : The name of the container to find.   Returns   (Ractive) : Returns the first container of this component with the given  name .   Examples  // TODO", 
            "title": "ractive.findContainer()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefindparent", 
            "text": "Returns the first parent of this component instance with the given  name .  Syntax   ractive.findParent(name)   Arguments   name (string) : The name of the parent to find.   Returns   (Ractive) : Returns the first parent of this component with the given  name .   Examples  // TODO", 
            "title": "ractive.findParent()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefire", 
            "text": "Fires an event, which will be received by handlers that were bound using  ractive.on . In practical terms, you would mostly likely use this with  Ractive.extend() , to allow applications to hook into your subclass.  Syntax   ractive.fire(eventName[, arg1[, ...argN])   Arguments   name (string) : The name of the event.  [arg] (any) : The arguments that event handlers will be called with.   Returns   (boolean)   Examples   var r = new Ractive();\n\nr.on('foo', function() {\n  console.log('foo fired');\n});\n\nr.fire('foo');", 
            "title": "ractive.fire()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveget", 
            "text": "Returns the value at  keypath . If the  keypath  is omitted, returns a shallow copy of all the data in the instance. This data includes mappings introduced by enclosing components, but excludes computed properties.  Syntax   ractive.get([keypath])   Arguments   [keypath] (string) : The  keypath  of the data to retrieve.   Returns   (any) : Returns whatever data was on the keypath, or all if no  keypath  was provided.   Examples   var r = new Ractive({\n    data: {\n        foo: {\n            bar: [ 'baz' ]\n        }\n    }\n});\n\nconsole.log(r.get('foo.bar.0'));", 
            "title": "ractive.get()"
        }, 
        {
            "location": "/api/instance-methods/#ractivegetnodeinfo", 
            "text": "This is an instance specific version of  Ractive.getNodeInfo()  that will only search the local instance DOM for a matching node when a selector is given. If the given value is not a string, then it is passed directly through to the static version of this method.  Syntax   ractive.getNodeInfo(node)   Arguments   node (string|Node) : The DOM node or a CSS selector of a target node for which you wish to retrieve the Ractive instance or view details.   Returns   (NodeInfo) : Returns an  NodeInfo  object with helper methods to interact with the Ractive instance and context associated with the given node.   Examples  // TODO", 
            "title": "ractive.getNodeInfo()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveinsert", 
            "text": "Inserts the instance to a different location. If the instance is currently in the DOM, it will be detached first. See also  ractive.detach() .  Syntax   ractive.insert(target[, anchor])   Arguments   target (string|Node|array-like) : The new parent element.  [anchor] (string|Node|array-like) : The sibling element to insert the instance before. If omitted, the instance will be inserted as the last child of the parent.   Returns   (undefined)   Examples  // TODO", 
            "title": "ractive.insert()"
        }, 
        {
            "location": "/api/instance-methods/#ractivelink", 
            "text": "Creates a link between two  keypaths  that keeps them in sync. Since Ractive can't always watch the contents of objects, copying an object to two different  keypaths  in your data usually leads to one or both of them getting out of sync.  link  creates a sort of symlink between the two paths so that Ractive knows they are actually the same object. This is particularly useful for master/detail scenarios where you have a complex list of data and you want to be able to select an item to edit in a detail form.  Syntax   ractive.link(source, destination)   Arguments   source (string) : The  keypath  of the source item.  destination (string) : The  keypath  to use as the destination - or where you'd like the data 'copied'.   Returns   (Promise) : Returns a promise.   Examples  ractive.link( 'some.nested.0.list.25.item', 'current' );\nractive.set( 'current.name', 'Rich' ); // some.nested.0.list.25.item.name is also updated to be 'Rich'  This can be used to great effect with method events and the  @keypath  special ref:  {{#each some.nested}}\n  {{#each list}}\n    {{#with item}}\n      {{.name}}\n       button on-click= event.link('.', 'current') Select /button \n    {{/with}}\n  {{/each}}\n{{/each}}\n\nName:  input value= {{~/current.name}}  /   Links can be removed using  ractive.unlink() .", 
            "title": "ractive.link()"
        }, 
        {
            "location": "/api/instance-methods/#ractivemerge", 
            "text": "Sets the indicated  keypath  to the new array value, but \"merges\" the existing rendered nodes representing the data into the newly rendered array, inserting and removing nodes from the DOM as necessary. Where necessary, items are moved from their current location in the array (and, therefore, in the DOM) to their new location.  This is an efficient way to (for example) handle data from a server. It also helps to control  intro  and  outro   transitions  which might not otherwise happen with a basic  ractive.set()  operation.  To determine whether the first item of  ['foo', 'bar', 'baz']  is the same as the last item of  ['bar', 'baz', 'foo'] , by default we do a strict equality ( === ) check.  In some situations that won't work, because the arrays contain objects, which may  look  the same but not be identical. To deal with these, we use the  compare  option detailed below.  Merge can also be used to created a context block that uses transitions when the context changes.  Syntax   ractive.merge(keypath, value[, options])   Arguments   keypath (string) : The  keypath  of the array we're updating.  value (Array) : The new data to merge in.  [options] (Object)  [compare] (boolean) : If  true , values will be stringified (with  JSON.stringify ) before comparison.  [compare] (string) : A property name that will be used to compare the array elements.  [compare] (Function) : A function that returns a value with which to compare array members.     Returns   (Promise)  - Returns a promise.   Examples  {{#user}} div intro='fade' {{first}} {{last}} /div \n{{/}}  var r = new Ractive({\n    el: document.body,\n    template: '#template',\n    data: {\n        user: [{\n            first: 'sam',\n            last: 'smith'\n        }]\n    },\n    complete: function(){\n        this.merge('user', [{\n            first: 'jane',\n            last: 'johnson'\n        }])\n    }\n})", 
            "title": "ractive.merge()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveobserve", 
            "text": "Observes the data at a particular  keypath . Unless specified otherwise, the callback will be fired immediately, with  undefined  as  oldValue . Thereafter it will be called whenever the  observed keypath  changes.  Syntax   ractive.observe(keypath, callback[, options])  ractive.observe(map[, options])   Arguments    keypath (String) : The  keypath  to observe, or a group of space-separated keypaths. Any of the keys can be a  *  character, which is treated as a wildcard. A  **  means recursive.  The difference between  *  and  **  is that  *  provides your callback function  value  and  keypath  arguments containing the path of the what actually changed, at any level of the keypath. So instead of getting the same parent value on every change, you get the changed value from whatever arbitrarily deep keypath changed.    callback (Function) : The function that will be called, with  newValue ,  oldValue  and  keypath  as arguments (see  Observers  for more nuance regarding these arguments), whenever the observed  keypath  changes value. By default the function will be called with  ractive  as  this . Any wildcards in the  keypath  will have their matches passed to the callback at the end of the arguments list as well.   map (Object) : A map of keypath-observer pairs.  [options] (Object) :  [init] (boolean) : Defaults to  true . Whether or not to initialise the observer, i.e. call the function with the current value of  keypath  as the first argument and  undefined  as the second.  [defer] (boolean) : Defaults to  false , in which case  observers  will fire before any DOM changes take place. If  true , the  observer  will fire once the DOM has been updated.  [links] (boolean) : Defaults to  false .  Whether or not the observer should \"follow through\" any links created with  ractive.link() .  [strict] (boolean) : Defaults to  false .  strict  uses object identity to determine if there was a change, meaning that unless the primary object changed, it won't trigger the observer. For example with  { data: { foo: { bar: 'baz' } } } ,  ractive.observe('foo', ..., { strict: true })  will not fire on  ractive.set('foo.bar', 'bat')  but will on  ractive.set('foo', { bar: 'bip' }) .  [context] (any) : Defaults to  ractive . The context the  observer  is called in (i.e. the value of  this )     Returns   (Object) : An object with a  cancel  method, for cancelling all observers   Examples  // TODO  Note that you can observe  keypath   patterns ...  ractive.observe( 'items.*.status', function ( newValue, oldValue, keypath) {\n    var index = /items.(\\d+).status/.exec( keypath )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});  ...or multiple space-separated  keypaths  simultaneously:  ractive.observe( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n    alert( keypath ) + ' changed from ' + oldValue + ' to ' + newValue );\n});  See  Observers  for more detail.", 
            "title": "ractive.observe()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveobserveonce", 
            "text": "Observes the data at a particular  keypath  until the first change. After the handler has been called, it will be unsubscribed from any future changes.  Syntax   ractive.observeOnce(keypath, callback[, options])   Arguments   keypath (string) : The  keypath  to observe, or a group of space-separated keypaths. Any of the keys can be a `` character, which is treated as a wildcard.  callback (Function) : The function that will be called, with  newValue ,  oldValue  and  keypath  as arguments (see  Observers  for more nuance regarding these arguments), whenever the observed  keypath  changes value. By default the function will be called with  ractive  as  this . Any wildcards in the  keypath  will have their matches passed to the callback at the end of the arguments list as well.  [options] (Object) :  [defer] (boolean) : Defaults to  false , in which case  observers  will fire before any DOM changes take place. If  true , the  observer  will fire once the DOM has been updated.  [context] (any) : Defaults to  ractive . The context the  observer  is called in (i.e. the value of  this )     Returns   (Object) : An object with a  cancel  method, for cancelling the observer.   Examples  // TODO  Note that you can observe  keypath   patterns ...  ractive.observeOnce( 'items.*.status', function ( newValue, oldValue, keypath ) {\n    var index = /items.(\\d+).status/.exec( keypath )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});  ...or multiple space-separated  keypaths  simultaneously:  ractive.observeOnce( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n    alert( keypath + ' changed from ' + oldValue + ' to ' + newValue );\n});  See  Observers  for more detail.", 
            "title": "ractive.observeOnce()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveoff", 
            "text": "Removes an event handler, several event handlers, or all event handlers.  To remove a single handler, you must specify both the event name and the handler. If you only specify the event name, all handlers bound to that event name will be removed. If you specify neither event name nor handler,  all  event handlers will be removed.  An alternative way to remove event handlers is to use the  cancel  method of the return value of a call to  ractive.on() .  Syntax   ractive.off([eventName[, handler]])   Arguments   eventName (string) : The event name to which this handler is currently bound.  handler (Function) : The handler to remove.   Returns   (Ractive) : Returns the  ractive  instance to allow this call to be chainable.   Examples  // TODO", 
            "title": "ractive.off()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveon", 
            "text": "Subscribe to  events .  Syntax   ractive.on(eventName, handler)  ractive.on(obj)   Arguments   eventName (String) : The name of the event to subscribe to  handler (Function) : The function that will be called, with  ractive  as  this . The arguments depend on the event. Returning  false  from the handler will stop propagation and prevent default of DOM events and cancel  event bubbling .  obj (Object) : An object with keys named for each event to subscribe to. The value at each key is the handler function for that event.   Returns   (Object)  - An  Object  with a  cancel  method, which removes the handler.  (Object)  - An  Object  with a  cancel  method, which removes all handlers in the passed-in  obj .   Examples  // single handler to function\nractive.on( 'activate', function () {...});\n\n// wildcard pattern matching\nractive.on( 'foo.*', function () {...} );\n\n// multiple handlers to one function\nractive.on( 'activate select', function () {...} );\n\n// map of handler/function pairs\nractive.on({\n    activate: function () {...},\n    select: function () {...}\n});\n\n// knock yourself out:\nractive.on({\n    activate: function () {...},\n    'bip bop boop': function () {...},\n    'select foo.* bar': function () {...}\n});", 
            "title": "ractive.on()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveonce", 
            "text": "Subscribe to an event for a single firing. This is a convenience function on top of  ractive.on() .  Syntax   ractive.once(eventName, handler)   Arguments   eventName (string) : The name of the event to subscribe to.  handler (Function) : The function that will be called, with  ractive  as  this . The arguments depend on the event. Returning  false  from the handler will stop propagation and prevent default of DOM events and cancel  event bubbling .   Returns   (Object) : Returns an  Object  with a  cancel  method, which removes the handler.   Examples  // TODO", 
            "title": "ractive.once()"
        }, 
        {
            "location": "/api/instance-methods/#ractivepop", 
            "text": "The Ractive equivalent to  Array.pop  that removes an element from the end of the array at the given  keypath  and triggers an update event.  If the given  keypath  does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.pop(keypath)   Arguments   keypath (string) : The  keypath  of the array to change, e.g.  list  or  order.items .   Returns   (Promise) : Returns a promise that will resolve with the removed element after the update is complete.   Examples  // TODO", 
            "title": "ractive.pop()"
        }, 
        {
            "location": "/api/instance-methods/#ractivepush", 
            "text": "The Ractive equivalent to  Array.push  that appends one or more elements to the array at the given  keypath  and triggers an update event.  If the given  keypath  does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.push(keypath, value[, ...valueN])   Arguments   keypath (string) : The  keypath  of the array to change, e.g.  list  or  order.items .  value (any) : The value to append to the end of the array. One or more values may be supplied.   Returns   (Promise)  - Returns a Promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.push()"
        }, 
        {
            "location": "/api/instance-methods/#ractiverender", 
            "text": "Renders the component into a DOM element.  Syntax   ractive.render(target)   Arguments   target (Node|String|array-like) : The DOM element to render to.   Returns   (Promise) : A promise that resolves when rendering completes or when the instance is already rendered.   Examples  // TODO", 
            "title": "ractive.render()"
        }, 
        {
            "location": "/api/instance-methods/#ractivereset", 
            "text": "Resets the entire  ractive.data  object and updates the DOM.  Syntax   ractive.reset(data)   Arguments   data (Object) : The data to reset with. Defaults to  {} .   Returns   (Promise) : A promise.   Examples  This differs from  ractive.set()  in the following way:  ractive = new Ractive({\n  // ...,\n  data: { foo: 1 }\n});\n\nractive.set({ bar: 2 });\nconsole.log( ractive.get() ); // { foo: 1, bar: 2 }\n\nractive.reset({ bar: 2 });\nconsole.log( ractive.get() ); // { bar: 2 }", 
            "title": "ractive.reset()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveresetpartial", 
            "text": "Resets a partial and re-renders all of its use-sites, including in any components that have inherited it. If a component has a partial with a same name that is its own, that partial will not be affected.  Inline partials that don't belong directly to a Ractive instance aren't affected by  resetPartial .  Syntax   ractive.resetPartial(name, partial)   Arguments   name (string) : The partial to reset.  partial (string|Object|Function) : A template string, pre-parsed template or a function that returns either.   Returns   (Promise) : A promise.   Examples  ractive = new Ractive({\n  // ...,\n  partials: { foo: 'foo' }\n});\n\n// {{ foo}} will be replaced with 'foo'\n\nractive.resetPartial('foo', 'bar');\n\n// {{ foo}} will be replaced with 'bar'", 
            "title": "ractive.resetPartial()"
        }, 
        {
            "location": "/api/instance-methods/#ractivereverse", 
            "text": "The Ractive equivalent to  Array.reverse  reverses the array at the given  keypath  and triggers an update event.  If the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.reverse(keypath)   Arguments   keypath (String) : The  keypath  of the array to reverse, e.g.  list  or  order.items   Returns   (Promise)  - A promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.reverse()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveset", 
            "text": "Updates data and triggers a re-render of any mustaches that are affected (directly or indirectly) by the change. Any  observers  of affected  keypaths  will be notified.  When setting an array value, ractive will reuse the existing DOM nodes for the new array, adding or removing nodes as necessary. This can impact nodes with  transitions . See  ractive.merge()  for setting a new array value while retaining existing nodes corresponding to individual array item values.  Syntax   ractive.set(keypath, value)  ractive.set(map)   Arguments   keypath (string) : The  keypath  of the data we're changing, e.g.  user  or  user.name  or  user.friends[1]  or  users.*.status .  value (any) : The value we're changing it to. Can be a primitive or an object (or array), in which case dependants of  downstream keypaths  will also be re-rendered (if they have changed).  map (Object) : A map of  keypath: value  pairs, as above.   Returns   (Promise) : Returns a promise that will be called after the set operation and any transitions are complete.   Examples  // TODO  The  keypath  can also contain wildcards  pattern-observers . All matching  keypaths  will be set with the supplied values:  ractive.on('selectAll', function(){\n    ractive.set('items.*.selected', true);\n})", 
            "title": "ractive.set()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveshift", 
            "text": "The Ractive equivalent to  Array.shift  that removes an element from the beginning of the array at the given  keypath  and triggers an update event.  If the given  keypath  does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.shift(keypath)   Arguments   keypath (string) : The  keypath  of the array to change, e.g.  list  or  order.items .   Returns   (Promise) : A promise that will resolve with the removed element after the update is complete.   Examples  // TODO", 
            "title": "ractive.shift()"
        }, 
        {
            "location": "/api/instance-methods/#ractivesort", 
            "text": "The Ractive equivalent to  Array.sort  sorts the array at the given  keypath  and triggers an update event.  If the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.sort(keypath)   Arguments   keypath (string) : The  keypath  of the array to sort, e.g.  list  or  order.items .   Returns   (Promise) : Returns a promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.sort()"
        }, 
        {
            "location": "/api/instance-methods/#ractivesplice", 
            "text": "The Ractive equivalent to  Array.splice  that can add new elements to the array while removing existing elements.  If the given  keypath  does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.splice(keypath, index, [removeCount[, add]])   Arguments   keypath (string) : The  keypath  of the array to change, e.g.  list  or  order.items .  index (number) : The index at which to start the operation.  [removeCount] (number) : The number of elements to remove starting with the element at * index . This may be 0 if you don't want to remove any elements.  [add] (any) : Any elements to insert into the array starting at * index . There can be 0 or more elements passed to add to the array.   Returns   (Promise) : Returns a promise that will resolve with the removed elements after the update is complete.   Examples  // TODO", 
            "title": "ractive.splice()"
        }, 
        {
            "location": "/api/instance-methods/#ractivesubtract", 
            "text": "Decrements the selected  keypath .  Syntax   ractive.subtract(keypath[, number])   Arguments   keypath (string) : The  keypath  of the number we're decrementing.  [number] (number) : Defaults to  1 . The number to decrement by.   Returns   (Promise) : Returns a promise.   Examples  // TODO", 
            "title": "ractive.subtract()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveteardown", 
            "text": "Unrenders this Ractive instance, removing any event handlers that were bound automatically by Ractive.  Calling  ractive.teardown()  causes a  teardown   event  to be fired - this is most useful with  Ractive.extend()  as it allows you to clean up anything else (event listeners and other bindings) that are part of the subclass.  Syntax   ractive.teardown()   Arguments   None   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.teardown()"
        }, 
        {
            "location": "/api/instance-methods/#ractivetocss", 
            "text": "Returns the scoped CSS of the current instance and its descendants.  At the moment, this will not work on a direct instance of Ractive and will log a warning. You can only use this method on an instance of a subclass.  Syntax   ractive.toCSS()   Arguments   None   Returns   (string) : The scoped CSS of the instance.   Examples  const Subclass = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\nconst subclassInstance = new Subclass({...});\n\n// Contains the scoped version of div{ color: red }\nsubclassInstance.toCSS();", 
            "title": "ractive.toCSS()"
        }, 
        {
            "location": "/api/instance-methods/#ractivetohtml", 
            "text": "Returns a chunk of HTML representing the current state of the instance. This is most useful when you're using Ractive in node.js, as it allows you to serve fully-rendered pages (good for SEO and initial pageload performance) to the client.  Syntax   ractive.toHTML()   Arguments   None   Returns   (string) : The instance HTML.   Examples  // TODO", 
            "title": "ractive.toHTML()"
        }, 
        {
            "location": "/api/instance-methods/#ractivetoggle", 
            "text": "Toggles the selected  keypath . In other words, if  foo  is  truthy , then  ractive.toggle('foo')  will make it  false , and vice-versa.  Syntax   ractive.toggle(keypath)   Arguments   keypath (string) : The  keypath  to toggle the value of. If  keypath  is a pattern, then all matching  keypaths  will be toggled.   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.toggle()"
        }, 
        {
            "location": "/api/instance-methods/#ractivetransition", 
            "text": "Triggers a transition on a node managed by this Ractive instance.  Syntax   ractive.transition(transition, node, options)   Arguments   transition (string|Function) : A transition function or a name of a transition function.  node (HTMLElement) : The node on which to start the transition - optional if called from within a Ractive event handler, as it will be retrieved from the event if not supplied.  options (Object) : Options supplied to the transition.   Returns   (Promise) : A promise that resolves when the transition completes.   Examples  // TODO", 
            "title": "ractive.transition()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveunlink", 
            "text": "Removes a link set up by  ractive.link() .  Syntax   ractive.unlink(destination)   Arguments   destination (string) : The destination supplied to [ ractive.link() ].   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.unlink()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveunrender", 
            "text": "Unrenders this Ractive instance, throwing away any DOM nodes associated with this instance. This is the counterpart to  ractive.render() . The rest of the ractive instance is left intact, unlike  ractive.teardown() .  Syntax   ractive.unrender()   Arguments   None   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.unrender()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveunshift", 
            "text": "The Ractive equivalent to  Array.unshift  that prepends one or more elements to the array at the given  keypath  and triggers an update event.  If the given  keypath  does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.unshift(keypath, value)   Arguments   keypath (string) : The  keypath  of the array to change, e.g.  list  or  order.items .  value (any) : The value to prepend to the beginning of the array. One or more values may be supplied.   Returns   (Promise) : Returns a promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.unshift()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveupdate", 
            "text": "\"Dirty checks\" everything that depends directly or indirectly on the specified  keypath . If no  keypath  is specified, all keypaths will be checked. Keypaths that involve special references (i.e.  @global ) require the keypath to be supplied.  This is useful when manipulating the instance's data without using the built in setter methods (i.e.  ractive.set() ,  ractive.animate() ).  Syntax   ractive.update([keypath])   Arguments   [keypath] (string) : The keypath to treat as 'dirty'.   Returns   (Promise) : A promise that resolves when the operation completes.   Examples  ractive.observe( 'foo', function ( foo ) {\n  alert( foo );\n});\n\nmodel.foo = 'changed';   // Does not cause the instance to update.\nractive.update( 'foo' ); // Informs the instance that foo was changed externally.", 
            "title": "ractive.update()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveupdatemodel", 
            "text": "If you programmatically manipulate inputs and other elements that have  two\u2010way binding  set up, your model can get out of sync. In these cases, we need to force a resync with  ractive.updateModel() :  Syntax   ractive.updateModel([keypath[, cascade]])   Arguments   keypath (string) : The  keypath  to treat as 'dirty'. Any two-way bindings linked to this  keypath  will be checked to see if the model is out of date  cascade (boolean) : If true, bindings that are  downstream  of  keypath  will also be checked - e.g.  ractive.updateModel( 'items', true )  would check  items.0.foo  and  items.1.foo  and so on. Defaults to  false .   Returns   (Promise) : A promise. If a  keypath  is not specified, all two-way bindings will be checked.   Examples  ractive = new Ractive({\n  el: 'container',\n  template: ' input value= {{name}} '\n  data: { name: 'Bob' }\n});\n\nractive.find( 'input' ).value = 'Jim';\nalert( ractive.get( 'name' ) ); // alerts 'Bob', not 'Jim'\n\nractive.updateModel();\nalert( ractive.get( 'name' ) ); // alerts 'Jim'", 
            "title": "ractive.updateModel()"
        }, 
        {
            "location": "/api/helper-objects/node-info/", 
            "text": "Node Info\n\n\nThe nodeinfo object is the type of object you receive when calling \nNode Info\n. This object contains various properties and methods that allow you to obtain information about the Ractive instance, the node associated with it and the context surrounding it.\n\n\nHelper methods that take a \nkeypath\n will resolve relative to that node's context. Special references, template aliases, and key and index aliases are supported.\n\n\n\n\nnodeinfo.add()\n\n\nSee \nractive.add()\n.\n\n\n\n\nnodeinfo.animate()\n\n\nSee \nractive.animate()\n.\n\n\n\n\nnodeinfo.context\n\n\n(any)\n\n\nThe data context of the node.\n\n\n\n\nnodeinfo.get()\n\n\nSee \nractive.get()\n.\n\n\n\n\nnodeinfo.getBinding()\n\n\nReturns the value of the binding if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\nnodeinfo.getBinding()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(any)\n: The value of the binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\ninput id=\nfindMe\n value=\n{{.baz}}\n /\n{{/with}}\n\n\n\n\nRactive.getNodeInfo('#findMe').getBinding(); // returns value of foo.bar.baz\n\n\n\n\nnodeinfo.getBindingPath()\n\n\nReturns the \nkeypath\n of the binding if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\nnodeinfo.getBindingPath([ractive])\n\n\n\n\nArguments\n\n\n\n\n[ractive] (Ractive)\n: The instance to resolve the \nkeypath\n against.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The \nkeypath\n of the node binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\ninput id=\nfindMe\n value=\n{{.baz}}\n /\n{{/with}}\n\n\n\n\nRactive.getNodeInfo('#findMe').getBindingPath(); // Returns \nfoo.bar.baz\n\n\n\n\n\n\n\nnodeinfo.index\n\n\n(number|undefined)\n\n\nThe index of \ncontext\n if it's in an array. If not in an array, the value is \nundefined\n.\n\n\n\n\nnodeinfo.isBound()\n\n\nReturns \ntrue\n if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\nnodeinfo.isBound()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: \ntrue\n if the node represented has a two-way binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\n  \ninput id=\nfoo\n value=\n{{.baz}}\n /\n\n  \ninput id=\nbar\n value=\n /\n\n{{/with}}\n\n\n\n\nRactive.getNodeInfo('#foo').isBound(); // Returns true\nRactive.getNodeInfo('#bar').isBound(); // Returns false\n\n\n\n\n\n\nnodeinfo.keypath\n\n\n(string)\n\n\nThe \nkeypath\n to \ncontext\n.\n\n\n\n\nnodeinfo.link()\n\n\nSee \nractive.link()\n.\n\n\n\n\nnodeinfo.merge()\n\n\nSee \nractive.merge()\n.\n\n\n\n\nnodeinfo.node\n\n\n(Node|undefined)\n\n\nThe node the event originated from. Normally present when the event is a Ractive DOM. May be \nundefined\n on custom events or events from event plugins.\n\n\n\n\nnodeinfo.original\n\n\n(Event|undefined)\n\n\nThe original DOM event object. Normally present when the event is a Ractive DOM event. May be \nundefined\n on custom events or events from event plugins.\n\n\n\n\nnodeinfo.pop()\n\n\nSee \nractive.pop()\n.\n\n\n\n\nnodeinfo.push()\n\n\nSee \nractive.push()\n.\n\n\n\n\nnodeinfo.ractive\n\n\n(Ractive)\n\n\nThis property holds a reference to the Ractive instance that controls the node represented by this info object.\n\n\n\n\nnodeinfo.resolve()\n\n\nResolves the given \nkeypath\n to a full keypath. If a Ractive instance is supplied, the resolved path will also account for any mappings defined for the instance.\n\n\nSyntax\n\n\n\n\nnodeinfo.resolve([keypath[, ractive]])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The \nkeypath\n to resolve.\n\n\n[ractive] (Ractive)\n: The instance to resolve the \nkeypath\n against.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The resolved keypath.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nnodeinfo.reverse()\n\n\nSee \nractive.reverse()\n.\n\n\n\n\nnodeinfo.set()\n\n\nSee \nractive.set()\n.\n\n\n\n\nnodeinfo.setBinding()\n\n\nSets the binding of the node represented by this info object to the specified value.\n\n\nSyntax\n\n\n\n\nnodeinfo.setBinding(value)\n\n\n\n\nArguments\n\n\n\n\nvalue (any)\n. The value to set.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nnodeinfo.shift()\n\n\nSee \nractive.shift()\n.\n\n\n\n\nnodeinfo.splice()\n\n\nSee \nractive.splice()\n.\n\n\n\n\nnodeinfo.sort()\n\n\nSee \nractive.sort()\n.\n\n\n\n\nnodeinfo.subtract()\n\n\nSee \nractive.subtract()\n.\n\n\n\n\nnodeinfo.toggle()\n\n\nSee \nractive.toggle()\n.\n\n\n\n\nnodeinfo.unlink()\n\n\nSee \nractive.unlink()\n.\n\n\n\n\nnodeinfo.unshift()\n\n\nSee \nractive.unshift()\n.\n\n\n\n\nnodeinfo.update()\n\n\nSee \nractive.update()\n.\n\n\n\n\nnodeinfo.updateModel()\n\n\nSee \nractive.updateModel()\n.", 
            "title": "Node Info"
        }, 
        {
            "location": "/api/helper-objects/node-info/#node-info", 
            "text": "The nodeinfo object is the type of object you receive when calling  Node Info . This object contains various properties and methods that allow you to obtain information about the Ractive instance, the node associated with it and the context surrounding it.  Helper methods that take a  keypath  will resolve relative to that node's context. Special references, template aliases, and key and index aliases are supported.", 
            "title": "Node Info"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfoadd", 
            "text": "See  ractive.add() .", 
            "title": "nodeinfo.add()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfoanimate", 
            "text": "See  ractive.animate() .", 
            "title": "nodeinfo.animate()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfocontext", 
            "text": "(any)  The data context of the node.", 
            "title": "nodeinfo.context"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfoget", 
            "text": "See  ractive.get() .", 
            "title": "nodeinfo.get()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfogetbinding", 
            "text": "Returns the value of the binding if the node represented by this info object has a two-way binding.  Syntax   nodeinfo.getBinding()   Arguments   None   Returns   (any) : The value of the binding.   Examples  {{#with foo.bar}} input id= findMe  value= {{.baz}}  / {{/with}}  Ractive.getNodeInfo('#findMe').getBinding(); // returns value of foo.bar.baz", 
            "title": "nodeinfo.getBinding()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfogetbindingpath", 
            "text": "Returns the  keypath  of the binding if the node represented by this info object has a two-way binding.  Syntax   nodeinfo.getBindingPath([ractive])   Arguments   [ractive] (Ractive) : The instance to resolve the  keypath  against.   Returns   (string) : The  keypath  of the node binding.   Examples  {{#with foo.bar}} input id= findMe  value= {{.baz}}  / {{/with}}  Ractive.getNodeInfo('#findMe').getBindingPath(); // Returns  foo.bar.baz", 
            "title": "nodeinfo.getBindingPath()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfoindex", 
            "text": "(number|undefined)  The index of  context  if it's in an array. If not in an array, the value is  undefined .", 
            "title": "nodeinfo.index"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfoisbound", 
            "text": "Returns  true  if the node represented by this info object has a two-way binding.  Syntax   nodeinfo.isBound()   Arguments   None   Returns   (boolean) :  true  if the node represented has a two-way binding.   Examples  {{#with foo.bar}}\n   input id= foo  value= {{.baz}}  / \n   input id= bar  value=  / \n{{/with}}  Ractive.getNodeInfo('#foo').isBound(); // Returns true\nRactive.getNodeInfo('#bar').isBound(); // Returns false", 
            "title": "nodeinfo.isBound()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfokeypath", 
            "text": "(string)  The  keypath  to  context .", 
            "title": "nodeinfo.keypath"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfolink", 
            "text": "See  ractive.link() .", 
            "title": "nodeinfo.link()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfomerge", 
            "text": "See  ractive.merge() .", 
            "title": "nodeinfo.merge()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfonode", 
            "text": "(Node|undefined)  The node the event originated from. Normally present when the event is a Ractive DOM. May be  undefined  on custom events or events from event plugins.", 
            "title": "nodeinfo.node"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfooriginal", 
            "text": "(Event|undefined)  The original DOM event object. Normally present when the event is a Ractive DOM event. May be  undefined  on custom events or events from event plugins.", 
            "title": "nodeinfo.original"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfopop", 
            "text": "See  ractive.pop() .", 
            "title": "nodeinfo.pop()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfopush", 
            "text": "See  ractive.push() .", 
            "title": "nodeinfo.push()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinforactive", 
            "text": "(Ractive)  This property holds a reference to the Ractive instance that controls the node represented by this info object.", 
            "title": "nodeinfo.ractive"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinforesolve", 
            "text": "Resolves the given  keypath  to a full keypath. If a Ractive instance is supplied, the resolved path will also account for any mappings defined for the instance.  Syntax   nodeinfo.resolve([keypath[, ractive]])   Arguments   [keypath] (string) : The  keypath  to resolve.  [ractive] (Ractive) : The instance to resolve the  keypath  against.   Returns   (string) : The resolved keypath.   Examples  // TODO", 
            "title": "nodeinfo.resolve()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinforeverse", 
            "text": "See  ractive.reverse() .", 
            "title": "nodeinfo.reverse()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfoset", 
            "text": "See  ractive.set() .", 
            "title": "nodeinfo.set()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfosetbinding", 
            "text": "Sets the binding of the node represented by this info object to the specified value.  Syntax   nodeinfo.setBinding(value)   Arguments   value (any) . The value to set.   Returns   (Promise)   Examples  // TODO", 
            "title": "nodeinfo.setBinding()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfoshift", 
            "text": "See  ractive.shift() .", 
            "title": "nodeinfo.shift()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfosplice", 
            "text": "See  ractive.splice() .", 
            "title": "nodeinfo.splice()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfosort", 
            "text": "See  ractive.sort() .", 
            "title": "nodeinfo.sort()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfosubtract", 
            "text": "See  ractive.subtract() .", 
            "title": "nodeinfo.subtract()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfotoggle", 
            "text": "See  ractive.toggle() .", 
            "title": "nodeinfo.toggle()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfounlink", 
            "text": "See  ractive.unlink() .", 
            "title": "nodeinfo.unlink()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfounshift", 
            "text": "See  ractive.unshift() .", 
            "title": "nodeinfo.unshift()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfoupdate", 
            "text": "See  ractive.update() .", 
            "title": "nodeinfo.update()"
        }, 
        {
            "location": "/api/helper-objects/node-info/#nodeinfoupdatemodel", 
            "text": "See  ractive.updateModel() .", 
            "title": "nodeinfo.updateModel()"
        }, 
        {
            "location": "/api/helper-objects/parse/", 
            "text": "Parse\n\n\nThe parse object is an object you receive as the second argument in \nfunction templates\n. This helper object provides you with essential functions to dissect markup before turning over the template for use.\n\n\n\n\np.fromId()\n\n\nRetrieves the template from the DOM \nscript\n tag specified by \nid\n. Make sure to set \ntype='text/ractive'\n on the \nscript\n tag to prevent the browser from running the template as a script.\n\n\nSyntax\n\n\n\n\np.fromId(id)\n\n\n\n\nArguments\n\n\n\n\nid (string)\n: The id of the \nscript\n tag containing the template. The leading \n#\n is optional.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The template inside the specified element.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\np.isParsed()\n\n\nTest whether the supplied template is already parsed and is in its object form.\n\n\nSyntax\n\n\n\n\np.isParsed(template)\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The template, either in its string form or object form.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: Returns \ntrue\n if the template is already parsed, \nfalse\n if otherwise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\np.parse()\n\n\nParses the template using \nRactive.parse()\n. Full Ractive runtime must be loaded.\n\n\nSyntax\n\n\n\n\np.parse(template[, parseOptions])\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The template in its string form or object form.\n\n\n[parseOptions] (Object)\n: Template parser options. See \nRactive.parse()\n for all available options. If \nparseOptions\n is not specified, it defaults to those of the current instance.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: The parsed template.\n\n\n\n\nExamples\n\n\n// TODO", 
            "title": "Parse"
        }, 
        {
            "location": "/api/helper-objects/parse/#parse", 
            "text": "The parse object is an object you receive as the second argument in  function templates . This helper object provides you with essential functions to dissect markup before turning over the template for use.", 
            "title": "Parse"
        }, 
        {
            "location": "/api/helper-objects/parse/#pfromid", 
            "text": "Retrieves the template from the DOM  script  tag specified by  id . Make sure to set  type='text/ractive'  on the  script  tag to prevent the browser from running the template as a script.  Syntax   p.fromId(id)   Arguments   id (string) : The id of the  script  tag containing the template. The leading  #  is optional.   Returns   (string) : The template inside the specified element.   Examples  // TODO", 
            "title": "p.fromId()"
        }, 
        {
            "location": "/api/helper-objects/parse/#pisparsed", 
            "text": "Test whether the supplied template is already parsed and is in its object form.  Syntax   p.isParsed(template)   Arguments   template (string|Object) : The template, either in its string form or object form.   Returns   (boolean) : Returns  true  if the template is already parsed,  false  if otherwise.   Examples  // TODO", 
            "title": "p.isParsed()"
        }, 
        {
            "location": "/api/helper-objects/parse/#pparse", 
            "text": "Parses the template using  Ractive.parse() . Full Ractive runtime must be loaded.  Syntax   p.parse(template[, parseOptions])   Arguments   template (string|Object) : The template in its string form or object form.  [parseOptions] (Object) : Template parser options. See  Ractive.parse()  for all available options. If  parseOptions  is not specified, it defaults to those of the current instance.   Returns   (Object) : The parsed template.   Examples  // TODO", 
            "title": "p.parse()"
        }, 
        {
            "location": "/api/helper-objects/transition/", 
            "text": "Transition\n\n\nThe transition object is an object you receive when writing transitions. It has a few properties and methods designed to make creating transitions easier.\n\n\n\n\nt.animateStyle()\n\n\nAnimates CSS properties to a certain value.\n\n\nSyntax\n\n\n\n\nt.animateStyle(prop, value, options[, complete])\n\n\nt.animateStyle(props, options[, complete])\n\n\n\n\nArguments\n\n\n\n\nprops (Object)\n: A map of animation properties and values.\n\n\nprop (string)\n: The style to animate.\n\n\nvalue (any)\n: The value to animate it to.\n\n\noptions (Object)\n: Animation options.\n\n\nduration (number)\n: The duration of the animation.\n\n\neasing (string)\n: The easing function of the animation.\n\n\ndelay (number)\n: The number of milliseconds before the animation starts.\n\n\n[complete] (Function)\n: A function that is executed when the animation completes, or immediately if no changes were made.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the animation completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.complete()\n\n\nSignals Ractive that the transition is complete.\n\n\nSyntax\n\n\n\n\nt.complete[noReset])\n\n\n\n\nArguments\n\n\n\n\n[noReset] (boolean)\n: If \ntrue\n, \nt.resetStyle()\n is not called. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.getStyle()\n\n\nRetrieve a CSS property value from \nt.node\n.\n\n\nSyntax\n\n\n\n\nt.getStyle(prop)\n\n\n\n\nArguments\n\n\n\n\nprop (string)\n: An unprefixed CSS property either in camelCase or kebab-case.\n\n\nprop (Array)\n: An array of CSS properties.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The value of the specified style property.\n\n\n(Object)\n: A key-value pair of properties and their respective values.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.isIntro\n\n\n(boolean)\n\n\nShould be self-explanatory...\n\n\n\n\nt.name\n\n\n(string)\n\n\nThe name of the transition.\n\n\n\n\nt.node\n\n\n(Node)\n\n\nThe node that's entering or leaving the DOM\n\n\n\n\nt.processParams()\n\n\nBuilds a map of parameters whose values are taken from the provided arguments. When used with a single number or string argument, serves as a shorthand for creating a map with a \nduration\n property.\n\n\nSyntax\n\n\n\n\nt.processParams(params[, defaults])\n\n\n\n\nArguments\n\n\n\n\nparams (number)\n: Numeric shorthand for the \nduration\n parameter. Expressed in milliseconds.\n\n\nparams (string)\n: String shorthand for the \nduration\n parameter. Valid values are:\n\n\n\"fast\" - 200ms\n\n\n\"slow\" - 600ms\n\n\nAny other string - 400ms\n\n\n\n\n\n\nparams (Object)\n: A map of parameters and their values.\n\n\n[defaults] (Object)\n: A map of parameters and their default values.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: A map of parameters and their values.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.setStyle()\n\n\nSets a CSS property on \nt.node\n to a value.\n\n\nSyntax\n\n\n\n\nt.setStyle(prop, value)\n\n\nt.setStyle(props)\n\n\n\n\nArguments\n\n\n\n\nprop (string)\n: An unprefixed CSS property either in camelCase or kebab-case.\n\n\nprops (Object)\n: A key-value pair of CSS properties and their respective values.\n\n\nvalue (string)\n: A valid value for the specified CSS property.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO", 
            "title": "Transition"
        }, 
        {
            "location": "/api/helper-objects/transition/#transition", 
            "text": "The transition object is an object you receive when writing transitions. It has a few properties and methods designed to make creating transitions easier.", 
            "title": "Transition"
        }, 
        {
            "location": "/api/helper-objects/transition/#tanimatestyle", 
            "text": "Animates CSS properties to a certain value.  Syntax   t.animateStyle(prop, value, options[, complete])  t.animateStyle(props, options[, complete])   Arguments   props (Object) : A map of animation properties and values.  prop (string) : The style to animate.  value (any) : The value to animate it to.  options (Object) : Animation options.  duration (number) : The duration of the animation.  easing (string) : The easing function of the animation.  delay (number) : The number of milliseconds before the animation starts.  [complete] (Function) : A function that is executed when the animation completes, or immediately if no changes were made.   Returns   (Promise) : A promise that resolves when the animation completes.   Examples  // TODO", 
            "title": "t.animateStyle()"
        }, 
        {
            "location": "/api/helper-objects/transition/#tcomplete", 
            "text": "Signals Ractive that the transition is complete.  Syntax   t.complete[noReset])   Arguments   [noReset] (boolean) : If  true ,  t.resetStyle()  is not called. Defaults to  false .   Returns   (undefined)   Examples  // TODO", 
            "title": "t.complete()"
        }, 
        {
            "location": "/api/helper-objects/transition/#tgetstyle", 
            "text": "Retrieve a CSS property value from  t.node .  Syntax   t.getStyle(prop)   Arguments   prop (string) : An unprefixed CSS property either in camelCase or kebab-case.  prop (Array) : An array of CSS properties.   Returns   (string) : The value of the specified style property.  (Object) : A key-value pair of properties and their respective values.   Examples  // TODO", 
            "title": "t.getStyle()"
        }, 
        {
            "location": "/api/helper-objects/transition/#tisintro", 
            "text": "(boolean)  Should be self-explanatory...", 
            "title": "t.isIntro"
        }, 
        {
            "location": "/api/helper-objects/transition/#tname", 
            "text": "(string)  The name of the transition.", 
            "title": "t.name"
        }, 
        {
            "location": "/api/helper-objects/transition/#tnode", 
            "text": "(Node)  The node that's entering or leaving the DOM", 
            "title": "t.node"
        }, 
        {
            "location": "/api/helper-objects/transition/#tprocessparams", 
            "text": "Builds a map of parameters whose values are taken from the provided arguments. When used with a single number or string argument, serves as a shorthand for creating a map with a  duration  property.  Syntax   t.processParams(params[, defaults])   Arguments   params (number) : Numeric shorthand for the  duration  parameter. Expressed in milliseconds.  params (string) : String shorthand for the  duration  parameter. Valid values are:  \"fast\" - 200ms  \"slow\" - 600ms  Any other string - 400ms    params (Object) : A map of parameters and their values.  [defaults] (Object) : A map of parameters and their default values.   Returns   (Object) : A map of parameters and their values.   Examples  // TODO", 
            "title": "t.processParams()"
        }, 
        {
            "location": "/api/helper-objects/transition/#tsetstyle", 
            "text": "Sets a CSS property on  t.node  to a value.  Syntax   t.setStyle(prop, value)  t.setStyle(props)   Arguments   prop (string) : An unprefixed CSS property either in camelCase or kebab-case.  props (Object) : A key-value pair of CSS properties and their respective values.  value (string) : A valid value for the specified CSS property.   Returns   (undefined)   Examples  // TODO", 
            "title": "t.setStyle()"
        }, 
        {
            "location": "/api/attributes/", 
            "text": "Attributes\n\n\nas-*\n\n\nas-*\n attributes augment the element with \ndecorators\n. It accepts an optional, comma-separated list of expressions which are handed over as arguments to the decorator function.\n\n\ndiv as-modal\nDiv appearing as modal\n/div\n\n\ndiv as-modal=\ntrue, true, true, false\nDiv appearing as modal\n/div\n\n\n\n\n\nclass-*\n\n\nclass-*\n attributes toggle individual class names based on the truthiness of its value. The part of the attribute name following \nclass-\n will be used as the class name. \nclass-*\n attribute values are processed as expressions.\n\n\ndiv class-foo=\nisFoo\nAdds \nfoo\n if isFoo is truthy\n/div\n\n\ndiv class-foo-bar=\nisFooBar\nAdds \nfoo-bar\n if isFooBar is truthy\n/div\n\n\ndiv class-fooBar=\nisFooBar\nAdds \nfooBar\n if isFooBar is truthy\n/div\n\n\n\n\n\non-*\n\n\non-*\n attributes attach event handlers for both native and \ncustom events\n. They are designed to look similar to regular \non*\n attributes for familiarity, the only difference being the hyphen. \non-*\n can be used in two ways: proxy event syntax and expression syntax.\n\n\nUsing the proxy event syntax, \non-*\n accepts an event name as value. Events are handled by registering a function with \nractive.on\n using the assigned event name.\n\n\nRactive({\n  template: `\n    \nbutton type=\nbutton\n on-click=\nclicked\nPush me!\n/button\n\n  `,\n  oninit(){\n    this.on('clicked', event =\n {\n      console.log('clicked!');\n    });\n  }\n});\n\n\n\n\nUsing the expression syntax, \non-*\n accepts expressions as value. This allows it to appear like regular inline scripts, similar to how it's done in inline event handlers.\n\n\nRactive({\n  template: `\n    \nbutton type=\nbutton\n on-click=\n@this.someMethod()\nPush me!\n/button\n\n  `,\n  someMethod(){\n    console.log('clicked!');\n  }\n});\n\n\n\n\nMultiple events can also be tied to the same handler by separating them with a hyphen:\n\n\nRactive({\n  template: `\n    \nbutton type=\nbutton\n on-hover-click=\n@this.someMethod()\nPush me!\n/button\n\n  `,\n  someMethod(){\n    console.log('Fires on hover and on click!');\n  }\n});\n\n\n\n\n*-in\n, \n*-out\n, \n*-in-out\n\n\n*-in\n, \n*-out\n, and \n*-in-out\n attributes apply \ntransitions\n to the element. \n*-in\n specifies intro-only, \n*-out\n specifies outro-only, and \n*-in-out\n for both intro and outro. All three accept an optional value, an expression in the form of an object which is handed over as arguments to the transition function.\n\n\ndiv fade-in\nFades on render\n/div\n\n\ndiv fade-out\nFades before removal\n/div\n\n\ndiv fade-in-out\nFades on render and before removal\n/div\n\n\ndiv fade-in-out=\n{ duration: 500 }\nFades with 500ms duration\n/div\n\n\n\n\n\nstyle-*\n\n\nstyle-*\n attributes update individual \nstyle\n properties of the element. The part of the attribute following \nstyle-\n will be used as the style property name. There are two forms of the syntax: \nstyle-property-name\n (CSS style) and \nstyle-propertyName\n (JS style). Style property names will be normalized.\n\n\ndiv style-vertical-align=\nmiddle\nApplies style.verticalAlign\n/div\n\n\ndiv style-textAlign=\ncenter\nApplies style.textAlign\n/div\n\n\n\n\n\nstyle-*\n attribute values are processed as strings. Mustaches can also be used to supply the values. When the values are updated, the appropriate style property on the element will update to the new value.\n\n\ndiv style-vertical-align=\n{{ vAlign }}\n style-textAlign=\n{{ tAlign }}\n...\n/div", 
            "title": "Attributes"
        }, 
        {
            "location": "/api/attributes/#attributes", 
            "text": "", 
            "title": "Attributes"
        }, 
        {
            "location": "/api/attributes/#as-", 
            "text": "as-*  attributes augment the element with  decorators . It accepts an optional, comma-separated list of expressions which are handed over as arguments to the decorator function.  div as-modal Div appearing as modal /div  div as-modal= true, true, true, false Div appearing as modal /div", 
            "title": "as-*"
        }, 
        {
            "location": "/api/attributes/#class-", 
            "text": "class-*  attributes toggle individual class names based on the truthiness of its value. The part of the attribute name following  class-  will be used as the class name.  class-*  attribute values are processed as expressions.  div class-foo= isFoo Adds  foo  if isFoo is truthy /div  div class-foo-bar= isFooBar Adds  foo-bar  if isFooBar is truthy /div  div class-fooBar= isFooBar Adds  fooBar  if isFooBar is truthy /div", 
            "title": "class-*"
        }, 
        {
            "location": "/api/attributes/#on-", 
            "text": "on-*  attributes attach event handlers for both native and  custom events . They are designed to look similar to regular  on*  attributes for familiarity, the only difference being the hyphen.  on-*  can be used in two ways: proxy event syntax and expression syntax.  Using the proxy event syntax,  on-*  accepts an event name as value. Events are handled by registering a function with  ractive.on  using the assigned event name.  Ractive({\n  template: `\n     button type= button  on-click= clicked Push me! /button \n  `,\n  oninit(){\n    this.on('clicked', event =  {\n      console.log('clicked!');\n    });\n  }\n});  Using the expression syntax,  on-*  accepts expressions as value. This allows it to appear like regular inline scripts, similar to how it's done in inline event handlers.  Ractive({\n  template: `\n     button type= button  on-click= @this.someMethod() Push me! /button \n  `,\n  someMethod(){\n    console.log('clicked!');\n  }\n});  Multiple events can also be tied to the same handler by separating them with a hyphen:  Ractive({\n  template: `\n     button type= button  on-hover-click= @this.someMethod() Push me! /button \n  `,\n  someMethod(){\n    console.log('Fires on hover and on click!');\n  }\n});", 
            "title": "on-*"
        }, 
        {
            "location": "/api/attributes/#-in-out-in-out", 
            "text": "*-in ,  *-out , and  *-in-out  attributes apply  transitions  to the element.  *-in  specifies intro-only,  *-out  specifies outro-only, and  *-in-out  for both intro and outro. All three accept an optional value, an expression in the form of an object which is handed over as arguments to the transition function.  div fade-in Fades on render /div  div fade-out Fades before removal /div  div fade-in-out Fades on render and before removal /div  div fade-in-out= { duration: 500 } Fades with 500ms duration /div", 
            "title": "*-in, *-out, *-in-out"
        }, 
        {
            "location": "/api/attributes/#style-", 
            "text": "style-*  attributes update individual  style  properties of the element. The part of the attribute following  style-  will be used as the style property name. There are two forms of the syntax:  style-property-name  (CSS style) and  style-propertyName  (JS style). Style property names will be normalized.  div style-vertical-align= middle Applies style.verticalAlign /div  div style-textAlign= center Applies style.textAlign /div   style-*  attribute values are processed as strings. Mustaches can also be used to supply the values. When the values are updated, the appropriate style property on the element will update to the new value.  div style-vertical-align= {{ vAlign }}  style-textAlign= {{ tAlign }} ... /div", 
            "title": "style-*"
        }, 
        {
            "location": "/api/keypath-prefixes/", 
            "text": "Keypath prefixes\n\n\nNormally, keypaths are resolved following a \ndefined routine\n. But there are times where you want to skip the normal resolution routine and resolve a keypath relative to a specific data context. Keypath prefixes allow you to specify which data context a keypath resolves to, regardless if it resolves to something or not.\n\n\nCurrent context (\n.\n)\n\n\nResolves the keypath relative to the current data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    spoon: 'SPOON',\n    matrix: {\n        agent: 'Smith'\n      // There is no spoon\n    }\n  },\n  template: `\n    \ndiv\nOutside the matrix, you have {{ spoon }}\n/div\n\n    {{# matrix }}\n      \ndiv\nInside the matrix, you think you have {{ spoon }}.\n/div\n\n      \ndiv\nIn reality, there is no {{ ./spoon }}\n/div\n\n    {{/}}\n  `\n});\n\n// Outside the matrix, you have SPOON\n// Inside the matrix, you think you have SPOON.\n// In reality, there is no\n\n\n\n\nParent context (\n../\n)\n\n\nResolves the keypath relative to the parent data context. This prefix can be used more than once to reference ancestors.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    id: 'reality',\n    dream: {\n        id: 'dream1',\n        dream: {\n            id: 'dream2',\n            dream: {\n                id: 'dream3',\n            }\n        }\n    }\n  },\n  template: `\n    \ndiv\nYou are in {{ id }}\n/div\n\n    {{# dream }}\n      \ndiv\nYou are in {{ id }}\n/div\n\n      {{# dream }}\n        \ndiv\nYou are in {{ id }}\n/div\n\n        {{# dream }}\n          \ndiv\nYou are in {{ id }}\n/div\n\n\n          \ndiv\nEscaping...\n/div\n\n          \ndiv\nYou are in {{ ../id }}\n/div\n\n          \ndiv\nYou are in {{ ../../id }}\n/div\n\n          \ndiv\nYou are in {{ ../../../id }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// You are in reality\n// You are in dream1\n// You are in dream2\n// You are in dream3\n// Escaping...\n// You are in dream2\n// You are in dream1\n// You are in reality\n\n\n\n\nInstance root context (\n~/\n)\n\n\nResolves the keypath relative to the instance's root data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    room: '1',\n    portal: {\n        room: '2',\n        portal: {\n            room: '3',\n            portal: {\n                room: '4',\n            }\n        }\n    }\n  },\n  template: `\n    {{# portal }}\n        {{# portal }}\n        {{# portal }}\n                \ndiv\nEntering...\n/div\n\n                \ndiv\nYou are in room {{ ~/room }}\n/div\n\n                \ndiv\nYou are in room {{ ~/portal.room }}\n/div\n\n                \ndiv\nYou are in room {{ ~/portal.portal.room }}\n/div\n\n                \ndiv\nYou are in room {{ ~/portal.portal.portal.room }}\n/div\n\n            {{/}}\n        {{/}}\n    {{/}}\n  `\n});\n\n// Entering...\n// You are in room 1\n// You are in room 2\n// You are in room 3\n// You are in room 4", 
            "title": "Keypath Prefixes"
        }, 
        {
            "location": "/api/keypath-prefixes/#keypath-prefixes", 
            "text": "Normally, keypaths are resolved following a  defined routine . But there are times where you want to skip the normal resolution routine and resolve a keypath relative to a specific data context. Keypath prefixes allow you to specify which data context a keypath resolves to, regardless if it resolves to something or not.", 
            "title": "Keypath prefixes"
        }, 
        {
            "location": "/api/keypath-prefixes/#current-context", 
            "text": "Resolves the keypath relative to the current data context.   Ractive({\n  el: 'body',\n  data: {\n    spoon: 'SPOON',\n    matrix: {\n        agent: 'Smith'\n      // There is no spoon\n    }\n  },\n  template: `\n     div Outside the matrix, you have {{ spoon }} /div \n    {{# matrix }}\n       div Inside the matrix, you think you have {{ spoon }}. /div \n       div In reality, there is no {{ ./spoon }} /div \n    {{/}}\n  `\n});\n\n// Outside the matrix, you have SPOON\n// Inside the matrix, you think you have SPOON.\n// In reality, there is no", 
            "title": "Current context (.)"
        }, 
        {
            "location": "/api/keypath-prefixes/#parent-context", 
            "text": "Resolves the keypath relative to the parent data context. This prefix can be used more than once to reference ancestors.   Ractive({\n  el: 'body',\n  data: {\n    id: 'reality',\n    dream: {\n        id: 'dream1',\n        dream: {\n            id: 'dream2',\n            dream: {\n                id: 'dream3',\n            }\n        }\n    }\n  },\n  template: `\n     div You are in {{ id }} /div \n    {{# dream }}\n       div You are in {{ id }} /div \n      {{# dream }}\n         div You are in {{ id }} /div \n        {{# dream }}\n           div You are in {{ id }} /div \n\n           div Escaping... /div \n           div You are in {{ ../id }} /div \n           div You are in {{ ../../id }} /div \n           div You are in {{ ../../../id }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// You are in reality\n// You are in dream1\n// You are in dream2\n// You are in dream3\n// Escaping...\n// You are in dream2\n// You are in dream1\n// You are in reality", 
            "title": "Parent context (../)"
        }, 
        {
            "location": "/api/keypath-prefixes/#instance-root-context", 
            "text": "Resolves the keypath relative to the instance's root data context.   Ractive({\n  el: 'body',\n  data: {\n    room: '1',\n    portal: {\n        room: '2',\n        portal: {\n            room: '3',\n            portal: {\n                room: '4',\n            }\n        }\n    }\n  },\n  template: `\n    {{# portal }}\n        {{# portal }}\n        {{# portal }}\n                 div Entering... /div \n                 div You are in room {{ ~/room }} /div \n                 div You are in room {{ ~/portal.room }} /div \n                 div You are in room {{ ~/portal.portal.room }} /div \n                 div You are in room {{ ~/portal.portal.portal.room }} /div \n            {{/}}\n        {{/}}\n    {{/}}\n  `\n});\n\n// Entering...\n// You are in room 1\n// You are in room 2\n// You are in room 3\n// You are in room 4", 
            "title": "Instance root context (~/)"
        }, 
        {
            "location": "/api/special-references/", 
            "text": "Special references\n\n\nSpecial references are template keywords that act like data references but do not actually exist in your data. These references provide metadata regarding the current instance, context, environment, operation and more.\n\n\nthis\n\n\nThe current data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    info: {\n      message: 'Hello World!',\n      info: {\n        message: 'The quick brown fox',\n        info: {\n          message: 'jumps over the lazy dog',\n          info: {\n            message: 'Thats all folks'\n          }\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nroot: {{ JSON.stringify(this) }}\n/div\n\n    {{# info }}\n      \ndiv\ninfo 1: {{ JSON.stringify(this) }}\n/div\n\n      {{# info }}\n        \ndiv\ninfo 2: {{ JSON.stringify(this) }}\n/div\n\n        {{# info }}\n          \ndiv\ninfo 3: {{ JSON.stringify(this) }}\n/div\n\n          {{# info }}\n            \ndiv\ninfo 4: {{ JSON.stringify(this) }}\n/div\n\n          {{/}}\n        {{/}}\n      {{/}}\n    {{/}}\n  `,\n});\n\n// info 1: {\ninfo\n:{\nmessage\n:\nHello World!\n,\ninfo\n:{\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}}}\n// info 2: {\nmessage\n:\nHello World!\n,\ninfo\n:{\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}}\n// info 3: {\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}\n// info 4: {\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}\n// info 5: {\nmessage\n:\nThats all folks\n}\n\n\n\n\n@this\n\n\nThe current Ractive instance.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n    \ndiv\nCount: {{ count }}\n/div\n\n    \nbutton type=\nbutton\n on-click=\n@this.add('count')\nIncrement\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.myMethod()\nLog count\n/button\n\n  `,\n  myMethod(){\n    console.log(`current count is ${this.get('count')}`);\n  }\n});\n\n\n\n\n@index\n\n\nThe current iteration index of the containing repeated section.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @index }} says: Hi! I'm {{ name }}!\n/div\n\n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!\n\n\n\n\nFor objects, \n@index\n is still the iteration index.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @index }} says: {{ this }}\n/div\n\n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I am bob!\n// User #1 says: Hi! I am alice!\n// User #2 says: Hi! I am eve!\n\n\n\n\n@key\n\n\nThe current key name of the containing object iteration section.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser {{ @key }} says: {{ this }}\n/div\n\n    {{/each}}\n  `\n});\n\n// User bob says: Hi! I am bob!\n// User alice says: Hi! I am alice!\n// User eve says: Hi! I am eve!\n\n\n\n\nFor arrays, \n@key\n's value will be the iteration index.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @key }} says: Hi! I'm {{ name }}!\n/div\n\n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!\n\n\n\n\n@keypath\n\n\nThe keypath to the current data context relative to the instance's root data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nKeypath: {{ @keypath }}\n/div\n\n    {{# foo }}\n      \ndiv\nKeypath: {{ @keypath }}\n/div\n\n      {{# bar }}\n        \ndiv\nKeypath: {{ @keypath }}\n/div\n\n        {{# baz }}\n          \ndiv\nKeypath: {{ @keypath }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz\n\n\n\n\nIf the keypath is a mapping, the keypath will remain relative to the instance.\n\n\n\n\n\nRactive.components.Message = Ractive.extend({\n  data: () =\n ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n      \ndiv\nSender: {{ name }}\n/div\n\n      \ndiv\nMessage: {{ message }}\n/div\n\n      \ndiv\nKeypath: {{ @keypath }}\n/div\n\n    {{/}}\n  `\n});\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n      \nMessage info=\n{{ this }}\n /\n\n    {{/}}\n  `\n});\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: info\n// Sender: bob\n// Message: Hi eve!\n// Keypath: info\n\n\n\n\n@rootpath\n\n\nThe keypath to the current data context relative to the originating instance's root data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n    {{# foo }}\n      \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n      {{# bar }}\n        \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n        {{# baz }}\n          \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz\n\n\n\n\nIf the keypath is a mapping, it will be adjusted relative to the originating instance's root data context. This is what primarily sets \n@rootpath\n apart from \n@keypath\n.\n\n\n\n\n\nRactive.components.Message = Ractive.extend({\n  data: () =\n ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n      \ndiv\nSender: {{ name }}\n/div\n\n      \ndiv\nMessage: {{ message }}\n/div\n\n      \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n    {{/}}\n  `\n});\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n      \nMessage info=\n{{ this }}\n /\n\n    {{/}}\n  `\n});\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: mail.inbox.messages.0\n// Sender: bob\n// Message: Hi eve!\n// Keypath: mail.inbox.messages.1\n\n\n\n\n@global\n\n\nThe global object of the current environment. For browsers, it references the \nwindow\n object. For Node.js, it references the \nglobal\n object.\n\n\n\n\n\nwindow.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n  `\n});\n\n// Hello World!\n\n\n\n\nRactive can automatically update properties on \n@global\n via two-way binding. However, for changes caused externally, \nractive.update()\n must be called to re-render the UI.\n\n\n\n\n\nwindow.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n    \ninput type=\ntext\n value=\n{{ @global.message }}\n\n    \nbutton type=\nbutton\n on-click=\n@this.logReference()\nLog reference value\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.logGlobal()\nLog global value\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.setFooBarBaz()\nChange to \nfoo bar baz\n directly\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.update('@global.message')\nClick to update\n/button\n\n\n    \nol\n\n      \nli\nClick \nLog reference value\n and look at the console\n/li\n\n      \nli\nClick \nLog global value\n and look at the console\n/li\n\n      \nli\nChange the input value and repeat steps 1 and 2\n/li\n\n      \nli\nClick \nChange to 'foo bar baz' directly\n/li\n\n      \nli\nRepeat steps 1 and 2 and notice that step 1 was not aware of the direct change\n/li\n\n      \nli\nClick \nClick to update\n/li\n\n      \nli\nRepeat steps 1 and 2 and notice that both steps are now aware\n/li\n\n    \n/ol\n\n  `,\n  logReference(){\n    console.log(this.get('@global.message'))\n  },\n  logGlobal(){\n    console.log(window.message);\n  },\n  setFooBarBaz(){\n    window.message = \nfoo bar baz\n\n  }\n});", 
            "title": "Special References"
        }, 
        {
            "location": "/api/special-references/#special-references", 
            "text": "Special references are template keywords that act like data references but do not actually exist in your data. These references provide metadata regarding the current instance, context, environment, operation and more.", 
            "title": "Special references"
        }, 
        {
            "location": "/api/special-references/#this", 
            "text": "The current data context.   Ractive({\n  el: 'body',\n  data: {\n    info: {\n      message: 'Hello World!',\n      info: {\n        message: 'The quick brown fox',\n        info: {\n          message: 'jumps over the lazy dog',\n          info: {\n            message: 'Thats all folks'\n          }\n        }\n      }\n    }\n  },\n  template: `\n     div root: {{ JSON.stringify(this) }} /div \n    {{# info }}\n       div info 1: {{ JSON.stringify(this) }} /div \n      {{# info }}\n         div info 2: {{ JSON.stringify(this) }} /div \n        {{# info }}\n           div info 3: {{ JSON.stringify(this) }} /div \n          {{# info }}\n             div info 4: {{ JSON.stringify(this) }} /div \n          {{/}}\n        {{/}}\n      {{/}}\n    {{/}}\n  `,\n});\n\n// info 1: { info :{ message : Hello World! , info :{ message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}}}\n// info 2: { message : Hello World! , info :{ message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}}\n// info 3: { message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}\n// info 4: { message : jumps over the lazy dog , info :{ message : Thats all folks }}\n// info 5: { message : Thats all folks }", 
            "title": "this"
        }, 
        {
            "location": "/api/special-references/#this_1", 
            "text": "The current Ractive instance.   Ractive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n     div Count: {{ count }} /div \n     button type= button  on-click= @this.add('count') Increment /button \n     button type= button  on-click= @this.myMethod() Log count /button \n  `,\n  myMethod(){\n    console.log(`current count is ${this.get('count')}`);\n  }\n});", 
            "title": "@this"
        }, 
        {
            "location": "/api/special-references/#index", 
            "text": "The current iteration index of the containing repeated section.   Ractive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @index }} says: Hi! I'm {{ name }}! /div \n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!  For objects,  @index  is still the iteration index.   Ractive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @index }} says: {{ this }} /div \n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I am bob!\n// User #1 says: Hi! I am alice!\n// User #2 says: Hi! I am eve!", 
            "title": "@index"
        }, 
        {
            "location": "/api/special-references/#key", 
            "text": "The current key name of the containing object iteration section.   Ractive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n       div User {{ @key }} says: {{ this }} /div \n    {{/each}}\n  `\n});\n\n// User bob says: Hi! I am bob!\n// User alice says: Hi! I am alice!\n// User eve says: Hi! I am eve!  For arrays,  @key 's value will be the iteration index.   Ractive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @key }} says: Hi! I'm {{ name }}! /div \n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!", 
            "title": "@key"
        }, 
        {
            "location": "/api/special-references/#keypath", 
            "text": "The keypath to the current data context relative to the instance's root data context.   Ractive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n     div Keypath: {{ @keypath }} /div \n    {{# foo }}\n       div Keypath: {{ @keypath }} /div \n      {{# bar }}\n         div Keypath: {{ @keypath }} /div \n        {{# baz }}\n           div Keypath: {{ @keypath }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz  If the keypath is a mapping, the keypath will remain relative to the instance.   Ractive.components.Message = Ractive.extend({\n  data: () =  ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n       div Sender: {{ name }} /div \n       div Message: {{ message }} /div \n       div Keypath: {{ @keypath }} /div \n    {{/}}\n  `\n});\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n       Message info= {{ this }}  / \n    {{/}}\n  `\n});\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: info\n// Sender: bob\n// Message: Hi eve!\n// Keypath: info", 
            "title": "@keypath"
        }, 
        {
            "location": "/api/special-references/#rootpath", 
            "text": "The keypath to the current data context relative to the originating instance's root data context.   Ractive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n     div Keypath: {{ @rootpath }} /div \n    {{# foo }}\n       div Keypath: {{ @rootpath }} /div \n      {{# bar }}\n         div Keypath: {{ @rootpath }} /div \n        {{# baz }}\n           div Keypath: {{ @rootpath }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz  If the keypath is a mapping, it will be adjusted relative to the originating instance's root data context. This is what primarily sets  @rootpath  apart from  @keypath .   Ractive.components.Message = Ractive.extend({\n  data: () =  ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n       div Sender: {{ name }} /div \n       div Message: {{ message }} /div \n       div Keypath: {{ @rootpath }} /div \n    {{/}}\n  `\n});\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n       Message info= {{ this }}  / \n    {{/}}\n  `\n});\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: mail.inbox.messages.0\n// Sender: bob\n// Message: Hi eve!\n// Keypath: mail.inbox.messages.1", 
            "title": "@rootpath"
        }, 
        {
            "location": "/api/special-references/#global", 
            "text": "The global object of the current environment. For browsers, it references the  window  object. For Node.js, it references the  global  object.   window.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n  `\n});\n\n// Hello World!  Ractive can automatically update properties on  @global  via two-way binding. However, for changes caused externally,  ractive.update()  must be called to re-render the UI.   window.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n     input type= text  value= {{ @global.message }} \n     button type= button  on-click= @this.logReference() Log reference value /button \n     button type= button  on-click= @this.logGlobal() Log global value /button \n     button type= button  on-click= @this.setFooBarBaz() Change to  foo bar baz  directly /button \n     button type= button  on-click= @this.update('@global.message') Click to update /button \n\n     ol \n       li Click  Log reference value  and look at the console /li \n       li Click  Log global value  and look at the console /li \n       li Change the input value and repeat steps 1 and 2 /li \n       li Click  Change to 'foo bar baz' directly /li \n       li Repeat steps 1 and 2 and notice that step 1 was not aware of the direct change /li \n       li Click  Click to update /li \n       li Repeat steps 1 and 2 and notice that both steps are now aware /li \n     /ol \n  `,\n  logReference(){\n    console.log(this.get('@global.message'))\n  },\n  logGlobal(){\n    console.log(window.message);\n  },\n  setFooBarBaz(){\n    window.message =  foo bar baz \n  }\n});", 
            "title": "@global"
        }, 
        {
            "location": "/api/component-files/", 
            "text": "Component files\n\n\nRemember the good old days? When all CSS went in \nstyle\n elements in \nhead\n? When all JS went in \nscript\n elements just before \n/body\n? When all HTML was written in Mustache inside inert \nscript\n elements? When it felt good when everything just worked after a page refresh? Ractive remembers, and it's bringing those good times back with component files.\n\n\nRactive component files are simply self-contained HTML files that define a component and contains all the markup, data, styles and logic it needs. It's also designed with dependency management in mind, allowing it to declare library and component dependencies. Best of all, component files are written in the same way regardless of the development process involved, build step or none.\n\n\nExample component file\n\n\n!-- Example component file --\n\n\n\n!-- Import a component named Foo from the file foo.html. --\n\n\nlink rel='ractive' href='foo.html' name='foo'\n\n\n\n!-- Define the markup for this component. --\n\n\nh1\n{{ title }}\n/h1\n\n\n\n!-- Use imported foo component --\n\n\np\nThis is an imported 'foo' component: \nfoo/\n/p\n\n\n\n!-- Define the styles for this component. --\n\n\nstyle\n\n  p { color: red; }\n\n/style\n\n\n\n!-- Define the behavior for this component. --\n\n\nscript\n\nconst $ = require( 'jquery' );\n\ncomponent.exports = {\n  onrender: function () {\n    $('\np /\n').text('component rendered').insertAfter($this.find('p'));\n  },\n  data: {\n    title: 'Hello World!'\n  }\n};\n\n/script\n\n\n\n\n\nThe above component file roughly translates to the following in vanilla JS:\n\n\nimport Ractive from 'ractive';\nimport $ from 'jquery';\nimport foo from './foo.html';\n\nexport default Ractive.extend({\n  components: { foo },\n  onrender: function () {\n    $('\np /\n').text('component rendered').insertAfter($this.find('p'));\n  },\n  data: {\n    title: 'Hello World!'\n  },\n  template: `\n    \nh1\n{{ title }}\n/h1\n\n    \np\nThis is an imported 'foo' component: \nfoo/\n/p\n\n  `,\n  css: `\n    p { color: red; }\n  `\n});\n\n\n\n\nWriting\n\n\nlink rel=\"ractive\"\n\n\nTop-level \nlink rel=\"ractive\"\n elements define dependencies on other components. It accepts two attributes:\n\n\n\n\n\n\nhref\n - The path to the required component file. Paths that start with \n./\n or \n../\n are resolved relative to the importing component file. Otherwise, resolution is loader-specific.\n\n\n\n\n\n\nname\n (optional) - The registered name of the component. This corresponds to the key used in the \ncomponents\n initialization option. When not defined, the filename of the dependency will be used as the name.\n\n\n\n\n\n\nThe names and the loaded dependency will be assigned to the component's \ncomponents\n initialization option.\n\n\nstyle\n\n\nTop-level \nstyle\n elements define the styles for the component. If more than one \nstyle\n element is found on the component file, their contents are concatenated in the order of appearance of the \nstyle\n elements. Contents of these elements will be concatenated and assigned to the component's \ncss\n initialization option.\n\n\nscript\n\n\nA top-level \nscript\n defines the component's initialization. The script's scope has a \ncomponent\n object that is similar to Node's \nmodule\n object. Initialization options for the component is expected via \ncomponent.exports\n. It also has a special \nrequire\n function that fetches script dependencies. \nrequire\n's behavior depends on the loader used. Refer to the specific loader's documentation to know more.\n\n\nThere can only ever be one \nscript\n in a component file. Defining more than one will result in the loader throwing an error.\n\n\nTemplate\n\n\nAfter yanking out top-level \nlink rel=\"ractive\"\n, \nstyle\n or \nscript\n from the component file, anything that's left becomes a part of the template. The remaining markup will be assigned to the component's \ntemplate\n initialization option.\n\n\nUsing\n\n\nIn order to use component files, you will have to use \nloaders\n, Head over to the \nloaders\n page to learn more about loaders and help you choose a loader that suits your needs.", 
            "title": "Component Files"
        }, 
        {
            "location": "/api/component-files/#component-files", 
            "text": "Remember the good old days? When all CSS went in  style  elements in  head ? When all JS went in  script  elements just before  /body ? When all HTML was written in Mustache inside inert  script  elements? When it felt good when everything just worked after a page refresh? Ractive remembers, and it's bringing those good times back with component files.  Ractive component files are simply self-contained HTML files that define a component and contains all the markup, data, styles and logic it needs. It's also designed with dependency management in mind, allowing it to declare library and component dependencies. Best of all, component files are written in the same way regardless of the development process involved, build step or none.", 
            "title": "Component files"
        }, 
        {
            "location": "/api/component-files/#example-component-file", 
            "text": "!-- Example component file --  !-- Import a component named Foo from the file foo.html. --  link rel='ractive' href='foo.html' name='foo'  !-- Define the markup for this component. --  h1 {{ title }} /h1  !-- Use imported foo component --  p This is an imported 'foo' component:  foo/ /p  !-- Define the styles for this component. --  style \n  p { color: red; } /style  !-- Define the behavior for this component. --  script \nconst $ = require( 'jquery' );\n\ncomponent.exports = {\n  onrender: function () {\n    $(' p / ').text('component rendered').insertAfter($this.find('p'));\n  },\n  data: {\n    title: 'Hello World!'\n  }\n}; /script   The above component file roughly translates to the following in vanilla JS:  import Ractive from 'ractive';\nimport $ from 'jquery';\nimport foo from './foo.html';\n\nexport default Ractive.extend({\n  components: { foo },\n  onrender: function () {\n    $(' p / ').text('component rendered').insertAfter($this.find('p'));\n  },\n  data: {\n    title: 'Hello World!'\n  },\n  template: `\n     h1 {{ title }} /h1 \n     p This is an imported 'foo' component:  foo/ /p \n  `,\n  css: `\n    p { color: red; }\n  `\n});", 
            "title": "Example component file"
        }, 
        {
            "location": "/api/component-files/#writing", 
            "text": "", 
            "title": "Writing"
        }, 
        {
            "location": "/api/component-files/#link-relractive", 
            "text": "Top-level  link rel=\"ractive\"  elements define dependencies on other components. It accepts two attributes:    href  - The path to the required component file. Paths that start with  ./  or  ../  are resolved relative to the importing component file. Otherwise, resolution is loader-specific.    name  (optional) - The registered name of the component. This corresponds to the key used in the  components  initialization option. When not defined, the filename of the dependency will be used as the name.    The names and the loaded dependency will be assigned to the component's  components  initialization option.", 
            "title": "&lt;link rel=\"ractive\"&gt;"
        }, 
        {
            "location": "/api/component-files/#style", 
            "text": "Top-level  style  elements define the styles for the component. If more than one  style  element is found on the component file, their contents are concatenated in the order of appearance of the  style  elements. Contents of these elements will be concatenated and assigned to the component's  css  initialization option.", 
            "title": "&lt;style&gt;"
        }, 
        {
            "location": "/api/component-files/#script", 
            "text": "A top-level  script  defines the component's initialization. The script's scope has a  component  object that is similar to Node's  module  object. Initialization options for the component is expected via  component.exports . It also has a special  require  function that fetches script dependencies.  require 's behavior depends on the loader used. Refer to the specific loader's documentation to know more.  There can only ever be one  script  in a component file. Defining more than one will result in the loader throwing an error.", 
            "title": "&lt;script&gt;"
        }, 
        {
            "location": "/api/component-files/#template", 
            "text": "After yanking out top-level  link rel=\"ractive\" ,  style  or  script  from the component file, anything that's left becomes a part of the template. The remaining markup will be assigned to the component's  template  initialization option.", 
            "title": "Template"
        }, 
        {
            "location": "/api/component-files/#using", 
            "text": "In order to use component files, you will have to use  loaders , Head over to the  loaders  page to learn more about loaders and help you choose a loader that suits your needs.", 
            "title": "Using"
        }, 
        {
            "location": "/extend/adaptors/", 
            "text": "Adaptors\n\n\nIn some cases you want to write your UI in Ractive but have a custom back-end manage the data. \nAdaptors\n allow you to teach Ractive how to talk to those custom data sources without having to change the way you write Ractive or having to write a lot of connector code up front.\n\n\nWriting\n\n\nconst myAdaptor = {\n  filter: function ( object, keypath, ractive ) {\n    // return `true` if a particular object is of the type we want to adapt.\n  },\n  wrap: function ( ractive, object, keypath, prefixer ) {\n    // Setup\n    return {\n      teardown: function(){\n        // Code executed on teardown.\n      },\n      get: function(){\n        // Returns POJO version of your data backend.\n      },\n      set: function(property, value){\n        // Data setter for POJO property keypaths.\n      },\n      reset: function(value){\n        // Data setter for POJO keypath.\n      }\n    }\n  }\n};\n\n\n\n\nAdaptors are simply the translation and sync layers between your custom data source and Ractive instances. The basic principle of an \nadaptor\n is as follows:\n\n\n\n\nProvides an POJO version of your data source to Ractive.\n\n\nCaptures data changes on your data source and mirror them to the data in Ractive.\n\n\nCaptures data changes on the data in Ractive and mirror them to the data source.\n\n\n\n\nWhether it's a third-party data modelling library, a RESTful service, a socket server, browser storage, or whatever, as long as all of the three can be done, it can be adapted.\n\n\nfilter\n is a function that gets called to check if \nobject\n needs to use an adaptor.\n\n\nobject\n is the data source to adapt.\n\n\nkeypath\n is the \nkeypath\n to \nobject\n.\n\n\nractive\n is the ractive instance that is currently using the adaptor.\n\n\nwrap\n is a function that gets called to set up the \nadaptor\n on \nobject\n.\n\n\nprefixer\n is a helper function that accepts an object and automatically prefixes \nkeypath\n to the object's keys.\n\n\nget\n is a function that gets called when Ractive needs the adapted representation of the \nobject\n.\n\n\nset\n is a function that is called when \nractive.set()\n updates a \nkeypath\n to a property of the adapted data. This function allows you to update the same property on \nobject\n.\n\n\nproperty\n is the \nkeypath\n to the property being updated, relative to \nkeypath\n.\n\n\nvalue\n is the value being passed into \nractive.set()\n.\n\n\nreset\n is a function that is called when \nractive.set()\n updates a \nkeypath\n to the adapted data. This function allows you to either update \nobject\n or tear down the adaptor.\n\n\nteardown\n is a function called when the \nadaptor\n is being removed. This function allows you to do cleanup work on anything that was done during the \nadaptor\n setup.\n\n\nAdaptors\n only adapt one level\n\n\nAn \nadaptor\n only adapts an object's immediate properties. Updating nested data via Ractive or via the data source will not update the other.\n\n\nNo built-in infinite loop detection\n\n\nThere is no built-in mechanism for avoiding infinite loops. If your \nadaptor\n calls \nractive.set()\n on adapted data, which in turn will call the adaptor's \nset()\n method, which may directly or indirectly trigger another \nractive.set()\n on the same adapted data, a stack overflow error might occur.\n\n\nThis isn't a problem with primitive values since Ractive doesn't bother calling \nset()\n if a value hasn't changed. But with objects and arrays, there's no easy and performant way to tell if the contents have changed. So \nset()\n gets called \nin case something changed\n rather than \nbecause something changed\n.\n\n\nDifferent for every back-end\n\n\nThe \nadaptor\n structure only provides you with the means to talk to and listen from a custom back-end. It does not impose any rules on how to write an \nadaptor\n for a certain back-end. For instance, an \nadaptor\n for a constructor-based object may be written differently from an \nadaptor\n meant to interact with a socket server.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register adaptors:\n\n\nGlobally, via the \nRactive.adaptors\n static property.\n\n\nRactive.adaptors.myAdaptor = myAdaptor;\n\n\n\n\nPer component, via the component's \nadaptors\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  adaptors: { myAdaptor }\n});\n\n\n\n\nPer instance, via the instance's \nadaptors\n initialization property.\n\n\nconst ractive = new Ractive({\n  adaptors: { myAdaptor }\n});\n\n\n\n\nUsing\n\n\nIn order to use an adaptor, you must tell the component or an instance to use it using the \nadapt\n \ninitialization option\n.\n\n\nconst ractive = new Ractive({\n  adapt: [ 'myAdaptor' ]\n})\n\n\n\n\nExamples\n\n\nIn the following example, we have a \nBox\n constructor that uses accessors to get and set its \nwidth\n and \nheight\n properties. Since an instance of \nBox\n will have no publicly visible properties, Ractive cannot bind to them directly.\n\n\nfunction Box(width, height){\n  var _width = width;\n  var _height = height;\n\n  this.getWidth = function(){ return _width; };\n  this.setWidth = function(width){ _width = width; };\n  this.getHeight = function(){ return _height; };\n  this.setHeight = function(height){ _height = height };\n}\n\n\n\n\nIn order for Ractive to properly use a \nBox\n instance, we build an \nadaptor\n for \nBox\n.\n\n\nRactive.adaptors.boxAdaptor = {\n  filter: function ( object ) {\n    // Checks if the piece of data is an instance of Box.\n    return object instanceof Box;\n  },\n  wrap: function ( ractive, box, keypath, prefixer ) {\n\n    // We keep a reference to the original functions before monkey-patching.\n    const setWidth = box.setWidth;\n    const setHeight = box.setHeight;\n\n    // Use ractive.set on the the adapted data whenever the setters are used.\n    box.setWidth = function(width){\n      ractive.set(prefixer({\n        width: width\n      }));\n    };\n\n    box.setHeight = function(height){\n      ractive.set(prefixer({\n        height: height\n      }));\n    };\n\n    return {\n      // Return a POJO representation of an instance of Box.\n      get: function(){\n        return {\n          width: box.getWidth(),\n          height: box.getHeight();\n        };\n      },\n      // Update the adapted object's properties\n      set: function(property, value){\n        if(property === 'width') setWidth.call(box, value);\n        if(property === 'height') setHeight.call(box, value);\n      },\n      // Update the adapted object.\n      reset: function(data){\n        // We don't adapt non-objects. And if the new data is an instance of Box\n        // there's a high chance that its a new instance. In either case, we\n        // need to tear down this adapter and have Ractive set it up again if\n        // necessary.\n        if(typeof data !== 'object' || data instanceof Box) return false;\n\n        // Otherwise, we just parse through the data and update the existing box\n        // instance.\n        if(data.width !== undefined) setWidth.call(box, data.width);\n        if(data.height !== undefined) setHeight.call(box, data.height);\n      },\n      // Delete the monkey-patched methods.\n      teardown: function(){\n        delete box.setWidth;\n        delete box.setHeight;\n      }\n    };\n  }\n};\n\n\n\n\nThen we use \nboxAdaptor\n on an instance. The data can now be treated like regular Ractive data. Updates done directly on \nbox\n will reflect on Ractive. Any changes via Ractive will reflect on \nbox\n.\n\n\nconst ractive = new Ractive({\n  el: 'body',\n  // Tell the instance we'll be using boxAdaptor\n  adapt: [ 'boxAdaptor' ],\n  // We write Ractive like normal.\n  template: `\n    \ndiv\nBox is {{ box.width }}x{{ box.height }}\n/div\n,\n    \ndiv\ninput type=\ntext\n value=\n{{ box.width }}\n/div\n\n    \ndiv\ninput type=\ntext\n value=\n{{ box.height }}\n/div\n\n  `\n});\n\nconst box = new Box(3, 4);\n\n// Set the Box instance as if it were a POJO.\nractive.set('box', box);\n\n// Both box instance and box object will have 7 width and 11 height and will\n// be rendered in the UI accordingly.\nbox.setWidth(7);\nractive.set('box.height', 11);", 
            "title": "Adaptors"
        }, 
        {
            "location": "/extend/adaptors/#adaptors", 
            "text": "In some cases you want to write your UI in Ractive but have a custom back-end manage the data.  Adaptors  allow you to teach Ractive how to talk to those custom data sources without having to change the way you write Ractive or having to write a lot of connector code up front.", 
            "title": "Adaptors"
        }, 
        {
            "location": "/extend/adaptors/#writing", 
            "text": "const myAdaptor = {\n  filter: function ( object, keypath, ractive ) {\n    // return `true` if a particular object is of the type we want to adapt.\n  },\n  wrap: function ( ractive, object, keypath, prefixer ) {\n    // Setup\n    return {\n      teardown: function(){\n        // Code executed on teardown.\n      },\n      get: function(){\n        // Returns POJO version of your data backend.\n      },\n      set: function(property, value){\n        // Data setter for POJO property keypaths.\n      },\n      reset: function(value){\n        // Data setter for POJO keypath.\n      }\n    }\n  }\n};  Adaptors are simply the translation and sync layers between your custom data source and Ractive instances. The basic principle of an  adaptor  is as follows:   Provides an POJO version of your data source to Ractive.  Captures data changes on your data source and mirror them to the data in Ractive.  Captures data changes on the data in Ractive and mirror them to the data source.   Whether it's a third-party data modelling library, a RESTful service, a socket server, browser storage, or whatever, as long as all of the three can be done, it can be adapted.  filter  is a function that gets called to check if  object  needs to use an adaptor.  object  is the data source to adapt.  keypath  is the  keypath  to  object .  ractive  is the ractive instance that is currently using the adaptor.  wrap  is a function that gets called to set up the  adaptor  on  object .  prefixer  is a helper function that accepts an object and automatically prefixes  keypath  to the object's keys.  get  is a function that gets called when Ractive needs the adapted representation of the  object .  set  is a function that is called when  ractive.set()  updates a  keypath  to a property of the adapted data. This function allows you to update the same property on  object .  property  is the  keypath  to the property being updated, relative to  keypath .  value  is the value being passed into  ractive.set() .  reset  is a function that is called when  ractive.set()  updates a  keypath  to the adapted data. This function allows you to either update  object  or tear down the adaptor.  teardown  is a function called when the  adaptor  is being removed. This function allows you to do cleanup work on anything that was done during the  adaptor  setup.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/adaptors/#adaptors-only-adapt-one-level", 
            "text": "An  adaptor  only adapts an object's immediate properties. Updating nested data via Ractive or via the data source will not update the other.", 
            "title": "Adaptors only adapt one level"
        }, 
        {
            "location": "/extend/adaptors/#no-built-in-infinite-loop-detection", 
            "text": "There is no built-in mechanism for avoiding infinite loops. If your  adaptor  calls  ractive.set()  on adapted data, which in turn will call the adaptor's  set()  method, which may directly or indirectly trigger another  ractive.set()  on the same adapted data, a stack overflow error might occur.  This isn't a problem with primitive values since Ractive doesn't bother calling  set()  if a value hasn't changed. But with objects and arrays, there's no easy and performant way to tell if the contents have changed. So  set()  gets called  in case something changed  rather than  because something changed .", 
            "title": "No built-in infinite loop detection"
        }, 
        {
            "location": "/extend/adaptors/#different-for-every-back-end", 
            "text": "The  adaptor  structure only provides you with the means to talk to and listen from a custom back-end. It does not impose any rules on how to write an  adaptor  for a certain back-end. For instance, an  adaptor  for a constructor-based object may be written differently from an  adaptor  meant to interact with a socket server.", 
            "title": "Different for every back-end"
        }, 
        {
            "location": "/extend/adaptors/#registering", 
            "text": "Like other plugins, there's 3 ways you can register adaptors:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/adaptors/#globally-via-the-ractiveadaptors-static-property", 
            "text": "Ractive.adaptors.myAdaptor = myAdaptor;", 
            "title": "Globally, via the Ractive.adaptors static property."
        }, 
        {
            "location": "/extend/adaptors/#per-component-via-the-components-adaptors-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  adaptors: { myAdaptor }\n});", 
            "title": "Per component, via the component's adaptors initialization property."
        }, 
        {
            "location": "/extend/adaptors/#per-instance-via-the-instances-adaptors-initialization-property", 
            "text": "const ractive = new Ractive({\n  adaptors: { myAdaptor }\n});", 
            "title": "Per instance, via the instance's adaptors initialization property."
        }, 
        {
            "location": "/extend/adaptors/#using", 
            "text": "In order to use an adaptor, you must tell the component or an instance to use it using the  adapt   initialization option .  const ractive = new Ractive({\n  adapt: [ 'myAdaptor' ]\n})", 
            "title": "Using"
        }, 
        {
            "location": "/extend/adaptors/#examples", 
            "text": "In the following example, we have a  Box  constructor that uses accessors to get and set its  width  and  height  properties. Since an instance of  Box  will have no publicly visible properties, Ractive cannot bind to them directly.  function Box(width, height){\n  var _width = width;\n  var _height = height;\n\n  this.getWidth = function(){ return _width; };\n  this.setWidth = function(width){ _width = width; };\n  this.getHeight = function(){ return _height; };\n  this.setHeight = function(height){ _height = height };\n}  In order for Ractive to properly use a  Box  instance, we build an  adaptor  for  Box .  Ractive.adaptors.boxAdaptor = {\n  filter: function ( object ) {\n    // Checks if the piece of data is an instance of Box.\n    return object instanceof Box;\n  },\n  wrap: function ( ractive, box, keypath, prefixer ) {\n\n    // We keep a reference to the original functions before monkey-patching.\n    const setWidth = box.setWidth;\n    const setHeight = box.setHeight;\n\n    // Use ractive.set on the the adapted data whenever the setters are used.\n    box.setWidth = function(width){\n      ractive.set(prefixer({\n        width: width\n      }));\n    };\n\n    box.setHeight = function(height){\n      ractive.set(prefixer({\n        height: height\n      }));\n    };\n\n    return {\n      // Return a POJO representation of an instance of Box.\n      get: function(){\n        return {\n          width: box.getWidth(),\n          height: box.getHeight();\n        };\n      },\n      // Update the adapted object's properties\n      set: function(property, value){\n        if(property === 'width') setWidth.call(box, value);\n        if(property === 'height') setHeight.call(box, value);\n      },\n      // Update the adapted object.\n      reset: function(data){\n        // We don't adapt non-objects. And if the new data is an instance of Box\n        // there's a high chance that its a new instance. In either case, we\n        // need to tear down this adapter and have Ractive set it up again if\n        // necessary.\n        if(typeof data !== 'object' || data instanceof Box) return false;\n\n        // Otherwise, we just parse through the data and update the existing box\n        // instance.\n        if(data.width !== undefined) setWidth.call(box, data.width);\n        if(data.height !== undefined) setHeight.call(box, data.height);\n      },\n      // Delete the monkey-patched methods.\n      teardown: function(){\n        delete box.setWidth;\n        delete box.setHeight;\n      }\n    };\n  }\n};  Then we use  boxAdaptor  on an instance. The data can now be treated like regular Ractive data. Updates done directly on  box  will reflect on Ractive. Any changes via Ractive will reflect on  box .  const ractive = new Ractive({\n  el: 'body',\n  // Tell the instance we'll be using boxAdaptor\n  adapt: [ 'boxAdaptor' ],\n  // We write Ractive like normal.\n  template: `\n     div Box is {{ box.width }}x{{ box.height }} /div ,\n     div input type= text  value= {{ box.width }} /div \n     div input type= text  value= {{ box.height }} /div \n  `\n});\n\nconst box = new Box(3, 4);\n\n// Set the Box instance as if it were a POJO.\nractive.set('box', box);\n\n// Both box instance and box object will have 7 width and 11 height and will\n// be rendered in the UI accordingly.\nbox.setWidth(7);\nractive.set('box.height', 11);", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/components/", 
            "text": "Components\n\n\nIn many situations, you want to encapsulate behaviour and markup into a single reusable \ncomponent\n, which can be dropped into Ractive applications. Components are simply custom-configured \"subclasses\" of Ractive (analogous, but technically incorrect).\n\n\nWriting\n\n\nThere are several ways to write Ractive components. Standard \ninitialization options\n apply for configuration unless where changes are explicitly mentioned.\n\n\nThe most common way to define a component is by using \nRactive.extend()\n.\n\n\n// A subclass of Ractive\nconst MyComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nmy-component\n\n      \nspan class=\nmy-component__message\n{{ message }}\n/span\n\n    \n/div\n\n  `,\n  css: `\n    .my-component__message { color: red }\n  `,\n  data: { message: 'Hello World' }\n});\n\n\n\n\nAnother way to define a component is by using \ncomponent files\n and \nloaders\n.\n\n\ndiv class=\nmy-component\n\n  \nspan class=\nmy-component__message\n{{ message }}\n/span\n\n\n/div\n\n\n\nstyle\n\n  .my-component__message { color: red }\n\n/style\n\n\n\nscript\n\ncomponent.exports = {\n  data: { message: 'Hello World' }\n};\n\n/script\n\n\n\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register components:\n\n\nGlobally, via the \nRactive.components\n static property:\n\n\n// Available to all instances of Ractive.\nRactive.components.MyComponent = Ractive.extend({ ... });\n\n\n\n\nPer component, via the component's \ncomponents\n initialization property.\n\n\n// Only available for instances of AnotherComponent.\nconst AnotherComponent = Ractive.extend({\n  components: { MyComponent }\n});\n\n\n\n\nPer instance, via the instance's \ncomponents\n initialization property.\n\n\n// Only available to this specific instance.\nconst ractive = new Ractive({\n  components: { MyComponent }\n});\n\n\n\n\nUsing\n\n\nComponents are simply subclasses of Ractive, which means the are instatiable via the \nnew\n keyword.\n\n\nconst ractive = new MyComponent({ ... });\n\n\n\n\nBut where components really shine is when they're used on templates. They are written like \ncustom elements\n. Each custom element notation represents one instance of the component.\n\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n    \ndiv\n\n      \nMyComponent /\n \n!-- One instance of MyComponent --\n\n      \nMyComponent /\n \n!-- Another instance of MyComponent --\n\n      \nMyComponent /\n \n!-- Yet another instance of MyComponent --\n\n    \n/div\n\n  `\n});\n\n\n\n\nThe component's tag name depends on the name used upon registration. The same component can be registered more than once using different names.\n\n\nconst MyComponent = Ractive.extend({...});\nRactive.components.MyComponent = MyComponent;\nRactive.components.MyComponentOtherName = MyComponent;\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n    \ndiv\n\n      \nMyComponent /\n          \n!-- Using MyComponent --\n\n      \nMyComponentOtherName /\n \n!-- Using MyComponent's other name --\n\n    \n/div\n\n  `\n});\n\n\n\n\nIsolation\n\n\nBy default, components are \"isolated\". This means it can only bind data explicitely provided to it.\nIn the following example, the instance of \nChildComponent\n will not print anything.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: 'Message missing {{ message }}'\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: '\nChildComponent /\n',\n  data: {\n    message: 'The ChildComponent will not know anything about this message'\n  }\n});\n\n\n\n\nYou have to pass data explicitely:\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: 'My message: {{ message }}'\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nChildComponent message=\nSome static message\n /\n\n    \nChildComponent message=\n{{myMessage}}\n /\n\n  `,\n  data: {\n    myMessage: 'Hello World!'\n  }\n});\n\n\n\n\nThis ensures the reusability of components in any context and avoids accidentally binding to wrong data.\n\n\n\n\nThere is also a possibility to make components aware of the outer context by specifying \nisolated: false\n \ninitialization option\n.\nIn that case, it climbs to the parent component's data context if it does not resolve on the child data context.\n\n\nIn the following example, the instance of \nChildComponent\n prints \"Hello World!\" even when the data is set on the outer-most instance.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  isolated: false,\n  template: 'Child: {{ message }}'\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  isolated: false,\n  template: 'Nested \nChildComponent /\n'\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: '\nParentComponent /\n',\n  data: {\n    message: 'The nested component will find me!'\n  }\n});\n\n\n\n\nBinding\n\n\nBindings connect a piece of data on the parent instance to data on the child instance. Changes on one side will reflect on the other. The syntax is similar to how one would write HTML element attributes.\n\n\nThe following example binds \ntext\n on the instance to \nMyComponent\n's \nmessage\n. Updates on the value of \ntext\n will update \nmessage\n. Typing on the \ninput\n bound to \nmessage\n will update \ntext\n.\n\n\nRactive.components.MyComponent = Ractive.extend({\n  template: `\n    \ninput type=\ntext\n value=\n{{ message }}\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: '\nMyComponent message=\n{{ text }} /\n'\n});\n\nractive.set('text', 'Hello World!');\n\n\n\n\nData context\n\n\nEach component instance comes with its own data context so that parameters don't pollute the primary data. Bindings will still update across both contexts.\n\n\nIn the following example, we have an instance that has \nname\n and \ncolors\n. We bind bind \ncolors\n and set an \noption1\n to \nMyComponent\n. Upon inspection, the data context is just as described. \nname\n doesn't cross over to \nMyComponent\n nor does \noption1\n cross over to the instance. However, since we bound \ncolors\n to \nshades\n, updating one updates the other.\n\n\nRactive.components.MyComponent = Ractive.extend({});\n\nconst ractive = new Ractive({\n  template: `\n    \nMyComponent shades='{{colors}}' option1='A' /\n\n  `,\n  data: {\n    name: 'Colors',\n    colors: ['red', 'blue', 'yellow']\n  }\n});\n\nconst widget = ractive.findComponent('MyComponent')\n\nractive.get(); // {\ncolors\n:[\nred\n,\nblue\n,\nyellow\n], \nname\n:\nColors\n}\nwidget.get();  // {\nshades\n:[\nred\n,\nblue\n,\nyellow\n], \noption1\n:\nA\n}\n\nractive.set('colors.1', 'green');\n\nractive.get(); // {\ncolors\n:[\nred\n,\ngreen\n,\nyellow\n], \nname\n:\nColors\n}\nwidget.get();  // {\nshades\n:[\nred\n,\ngreen\n,\nyellow\n], \noption1\n:\nA\n}\n\nwidget.set('colors.2', 'blue');\n\nractive.get(); // {\ncolors\n:[\nred\n,\ngreen\n,\nblue\n], \nname\n:\nColors\n}\nwidget.get();  // {\nshades\n:[\nred\n,\ngreen\n,\nblue\n], \noption1\n:\nA\n}\n\n\n\n\nEvents\n\n\nComponents can fire events like regular elements using \nractive.fire()\n. Enclosing instances can listen for events using the same \non-*\n event notation. There are two ways to handle component events.\n\n\nThe first is using the method call syntax which is similar to how you would write inline JavaScript.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent on-boringeventname=\n@this.greetz()\n /\n\n  `,\n  greetz: function(){\n    console.log('Hello World');\n  }\n});\n\n\n\n\nThe other is using the proxy event syntax. It's called \"proxy\" in the sense that the component event is assigned another name which is actually listened to by the enclosing instance.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent on-boringeventname=\ngreetz\n /\n\n  `,\n  oninit: function(){\n    this.on('greetz', function(){\n      console.log('Hello World')\n    });\n  }\n});\n\n\n\n\nBubbling\n\n\nEvents fired from within components will also \"bubble\" up the component hierarchy with their component name attached as a namespace. This can be used to avoid having to re-fire events at each level in a deeply nested component hierarchy.\n\n\nIn the following example, the event from the \nChildComponent\n instance can be listened to from the outer Ractive instance.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('Hello World!');\n});\n\n\n\n\nTo listen to the same event name regardless of the component that's firing the event, an \n*\n can be used as the namespace.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('*.sameevent', function(){\n  console.log('This will fire two times, one for each component.');\n});\n\n\n\n\nThe namespace is not bound to the component definition but rather to the name of the component.\n\n\nIn the following example, \nChildComponent\n is registered onto the \nParentComponent\n as \nChildComponent1\n and \nChildComponent2\n. Even with the same definition, there will be two namespaces, one for \nChildComponent1\n and \nChildComponent2\n.\n\n\nconst ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent1 /\n\n    \nChildComponent2 /\n\n  `,\n  components: {\n    ChildComponent1: ChildComponent,\n    ChildComponent2: ChildComponent\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent1.sameevent', function(){\n  console.log('Same component definition, instance with name 1.');\n});\n\nractive.on('ChildComponent2.sameevent', function(){\n  console.log('Same component definition, instance with name 2.');\n});\n\n\n\n\nStopping propagation\n\n\nIn order to stop bubbling, simply return \nfalse\n from an event handler. Should the event come from a DOM event, it will call \nstopPropagation()\n and \npreventDefault()\n automatically.\n\n\nIn the following example, \nParentComponent\n listens to \nchildevent\n and returns false to in its handler. This prevents the outer instance from receiving the event.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `,\n  oninit: function(){\n    this.on('ChildComponent.childevent', function(){\n      return false;\n    });\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('This will not fire');\n});\n\n\n\n\nEvents that have been assigned a handler using \non-*\n will also prevent the bubbling of the original event. A proxy event is assigned, will bubble in its place.\n\n\nIn the following example, \nchildevent1\n is prevented by not assigning a handle. \nchildevent2\n is prevented by having a proxy event \nchildevent2proxy\n assigned to it, which will also bubble in its place. \nchildevent3\n is prevented by a method call.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function() {\n    this.fire('childevent1');\n    this.fire('childevent2');\n    this.fire('childevent3');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent on-childevent1=\n on-childevent2=\nchildevent2proxy\n on-childevent3=\n@this.parentMethod()\n /\n\n  `,\n  oninit: function() {\n    this.on('childevent2proxy', function() {\n      console.log('childevent2 handled and will no longer bubble.');\n      console.log('childevent2proxy will take its place.');\n    });\n  },\n  parentMethod: function(){\n    console.log('childevent3 handled by a method')\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent.childevent1', function() {\n  console.log('childevent1 stopped');\n});\n\nractive.on('ChildComponent.childevent2', function() {\n  console.log('childevent2 stopped');\n});\n\nractive.on('ParentComponent.childevent2proxy', function() {\n  console.log('childevent2proxy fired');\n});\n\nractive.on('ChildComponent.childevent3', function() {\n  console.log('childevent3 fired');\n});\n\n\n\n\n{{\ncontent}}\n\n\n{{\ncontent}}\n renders the inner HTML in the context of the component. Partials, components, and any other valid template items can be used as inner HTML. \n{{\ncontent}}\n can be thought of as a special partial.\n\n\nIn the following example, the result will print \"Lorem Ipsum\" because the inner HTML's context is the component, whose \nmessage\n is set to \"Lorem Ipsum\".\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n{{\ncontent}}\n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        \ndiv class=\ninner-content\n{{ message }}\n/div\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\nPartials defined in the inner HTML can be used to override partials defined on the component. This can be used to allow easy customization of each instance using partials.\n\n\nIn the following example, \nChildComponent\n's default template for the \nmessageWrapper\n partial is a \nstrong\n. Upon use of \nChildComponent\n in the instance, it overrides the partial to use an \nem\n instead.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  partials: {\n    messageWrapper: '\nstrong\n{{message}}\n/strong\n'\n  },\n  template: `\n    \ndiv class=\nchild-component\n{{\ncontent}}\n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n\n        {{#partial messageWrapper}}\nem\n{{message}}\n/em\n{{/}}\n\n        \ndiv class=\ninner-content\n\n          {{\n messageWrapper }}\n        \n/div\n\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\n{{yield}}\n\n\n{{yield}}\n renders the inner HTML in the context of the parent component. Partials, components, and any other valid template items can be used as inner HTML. A common use case of \n{{yield}}\n is to provide wrapper markup transparently.\n\n\nIn the following example, the result will print \"Hello World!\" because the inner HTML's context is the parent component's, whose \nmessage\n is \"Hello World!\".\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n{{ yield }}\n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        \ndiv class=\ninner-content\n{{ message }}\n/div\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\nYields can also be customized using named yields. Instead of rendering with the component's inner HTML, a named yield will look for a partial in the inner HTML with the same name and use that to render the yielded content.\n\n\nIn the following example, \nChildComponent\n renders the yield content 3 times. However, the last two yields will look for \nitalicYield\n and \nboldYield\n partials in the inner HTML and use that to render. What's rendered is three \"Hello World!\"s in regular, italic and bold.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n\n      {{ yield }}\n      {{ yield italicYield }}\n      {{ yield boldYield }}\n    \n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        {{#partial italicYield }}\nem\n{{message}}\n/em\n{{/}}\n        {{#partial boldYield }}\nstrong\n{{message}}\n/strong\n{{/}}\n        {{message}}\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\nExamples", 
            "title": "Components"
        }, 
        {
            "location": "/extend/components/#components", 
            "text": "In many situations, you want to encapsulate behaviour and markup into a single reusable  component , which can be dropped into Ractive applications. Components are simply custom-configured \"subclasses\" of Ractive (analogous, but technically incorrect).", 
            "title": "Components"
        }, 
        {
            "location": "/extend/components/#writing", 
            "text": "There are several ways to write Ractive components. Standard  initialization options  apply for configuration unless where changes are explicitly mentioned.  The most common way to define a component is by using  Ractive.extend() .  // A subclass of Ractive\nconst MyComponent = Ractive.extend({\n  template: `\n     div class= my-component \n       span class= my-component__message {{ message }} /span \n     /div \n  `,\n  css: `\n    .my-component__message { color: red }\n  `,\n  data: { message: 'Hello World' }\n});  Another way to define a component is by using  component files  and  loaders .  div class= my-component \n   span class= my-component__message {{ message }} /span  /div  style \n  .my-component__message { color: red } /style  script \ncomponent.exports = {\n  data: { message: 'Hello World' }\n}; /script", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/components/#registering", 
            "text": "Like other plugins, there's 3 ways you can register components:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/components/#globally-via-the-ractivecomponents-static-property", 
            "text": "// Available to all instances of Ractive.\nRactive.components.MyComponent = Ractive.extend({ ... });", 
            "title": "Globally, via the Ractive.components static property:"
        }, 
        {
            "location": "/extend/components/#per-component-via-the-components-components-initialization-property", 
            "text": "// Only available for instances of AnotherComponent.\nconst AnotherComponent = Ractive.extend({\n  components: { MyComponent }\n});", 
            "title": "Per component, via the component's components initialization property."
        }, 
        {
            "location": "/extend/components/#per-instance-via-the-instances-components-initialization-property", 
            "text": "// Only available to this specific instance.\nconst ractive = new Ractive({\n  components: { MyComponent }\n});", 
            "title": "Per instance, via the instance's components initialization property."
        }, 
        {
            "location": "/extend/components/#using", 
            "text": "Components are simply subclasses of Ractive, which means the are instatiable via the  new  keyword.  const ractive = new MyComponent({ ... });  But where components really shine is when they're used on templates. They are written like  custom elements . Each custom element notation represents one instance of the component.  const AnotherComponent = Ractive.extend({\n  template: `\n     div \n       MyComponent /   !-- One instance of MyComponent -- \n       MyComponent /   !-- Another instance of MyComponent -- \n       MyComponent /   !-- Yet another instance of MyComponent -- \n     /div \n  `\n});  The component's tag name depends on the name used upon registration. The same component can be registered more than once using different names.  const MyComponent = Ractive.extend({...});\nRactive.components.MyComponent = MyComponent;\nRactive.components.MyComponentOtherName = MyComponent;\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n     div \n       MyComponent /            !-- Using MyComponent -- \n       MyComponentOtherName /   !-- Using MyComponent's other name -- \n     /div \n  `\n});", 
            "title": "Using"
        }, 
        {
            "location": "/extend/components/#isolation", 
            "text": "By default, components are \"isolated\". This means it can only bind data explicitely provided to it.\nIn the following example, the instance of  ChildComponent  will not print anything.  Ractive.components.ChildComponent = Ractive.extend({\n  template: 'Message missing {{ message }}'\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: ' ChildComponent / ',\n  data: {\n    message: 'The ChildComponent will not know anything about this message'\n  }\n});  You have to pass data explicitely:  Ractive.components.ChildComponent = Ractive.extend({\n  template: 'My message: {{ message }}'\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ChildComponent message= Some static message  / \n     ChildComponent message= {{myMessage}}  / \n  `,\n  data: {\n    myMessage: 'Hello World!'\n  }\n});  This ensures the reusability of components in any context and avoids accidentally binding to wrong data.   There is also a possibility to make components aware of the outer context by specifying  isolated: false   initialization option .\nIn that case, it climbs to the parent component's data context if it does not resolve on the child data context.  In the following example, the instance of  ChildComponent  prints \"Hello World!\" even when the data is set on the outer-most instance.  Ractive.components.ChildComponent = Ractive.extend({\n  isolated: false,\n  template: 'Child: {{ message }}'\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  isolated: false,\n  template: 'Nested  ChildComponent / '\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: ' ParentComponent / ',\n  data: {\n    message: 'The nested component will find me!'\n  }\n});", 
            "title": "Isolation"
        }, 
        {
            "location": "/extend/components/#binding", 
            "text": "Bindings connect a piece of data on the parent instance to data on the child instance. Changes on one side will reflect on the other. The syntax is similar to how one would write HTML element attributes.  The following example binds  text  on the instance to  MyComponent 's  message . Updates on the value of  text  will update  message . Typing on the  input  bound to  message  will update  text .  Ractive.components.MyComponent = Ractive.extend({\n  template: `\n     input type= text  value= {{ message }} \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: ' MyComponent message= {{ text }} / '\n});\n\nractive.set('text', 'Hello World!');", 
            "title": "Binding"
        }, 
        {
            "location": "/extend/components/#data-context", 
            "text": "Each component instance comes with its own data context so that parameters don't pollute the primary data. Bindings will still update across both contexts.  In the following example, we have an instance that has  name  and  colors . We bind bind  colors  and set an  option1  to  MyComponent . Upon inspection, the data context is just as described.  name  doesn't cross over to  MyComponent  nor does  option1  cross over to the instance. However, since we bound  colors  to  shades , updating one updates the other.  Ractive.components.MyComponent = Ractive.extend({});\n\nconst ractive = new Ractive({\n  template: `\n     MyComponent shades='{{colors}}' option1='A' / \n  `,\n  data: {\n    name: 'Colors',\n    colors: ['red', 'blue', 'yellow']\n  }\n});\n\nconst widget = ractive.findComponent('MyComponent')\n\nractive.get(); // { colors :[ red , blue , yellow ],  name : Colors }\nwidget.get();  // { shades :[ red , blue , yellow ],  option1 : A }\n\nractive.set('colors.1', 'green');\n\nractive.get(); // { colors :[ red , green , yellow ],  name : Colors }\nwidget.get();  // { shades :[ red , green , yellow ],  option1 : A }\n\nwidget.set('colors.2', 'blue');\n\nractive.get(); // { colors :[ red , green , blue ],  name : Colors }\nwidget.get();  // { shades :[ red , green , blue ],  option1 : A }", 
            "title": "Data context"
        }, 
        {
            "location": "/extend/components/#events", 
            "text": "Components can fire events like regular elements using  ractive.fire() . Enclosing instances can listen for events using the same  on-*  event notation. There are two ways to handle component events.  The first is using the method call syntax which is similar to how you would write inline JavaScript.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent on-boringeventname= @this.greetz()  / \n  `,\n  greetz: function(){\n    console.log('Hello World');\n  }\n});  The other is using the proxy event syntax. It's called \"proxy\" in the sense that the component event is assigned another name which is actually listened to by the enclosing instance.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent on-boringeventname= greetz  / \n  `,\n  oninit: function(){\n    this.on('greetz', function(){\n      console.log('Hello World')\n    });\n  }\n});", 
            "title": "Events"
        }, 
        {
            "location": "/extend/components/#bubbling", 
            "text": "Events fired from within components will also \"bubble\" up the component hierarchy with their component name attached as a namespace. This can be used to avoid having to re-fire events at each level in a deeply nested component hierarchy.  In the following example, the event from the  ChildComponent  instance can be listened to from the outer Ractive instance.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('Hello World!');\n});  To listen to the same event name regardless of the component that's firing the event, an  *  can be used as the namespace.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('*.sameevent', function(){\n  console.log('This will fire two times, one for each component.');\n});  The namespace is not bound to the component definition but rather to the name of the component.  In the following example,  ChildComponent  is registered onto the  ParentComponent  as  ChildComponent1  and  ChildComponent2 . Even with the same definition, there will be two namespaces, one for  ChildComponent1  and  ChildComponent2 .  const ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent1 / \n     ChildComponent2 / \n  `,\n  components: {\n    ChildComponent1: ChildComponent,\n    ChildComponent2: ChildComponent\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent1.sameevent', function(){\n  console.log('Same component definition, instance with name 1.');\n});\n\nractive.on('ChildComponent2.sameevent', function(){\n  console.log('Same component definition, instance with name 2.');\n});", 
            "title": "Bubbling"
        }, 
        {
            "location": "/extend/components/#stopping-propagation", 
            "text": "In order to stop bubbling, simply return  false  from an event handler. Should the event come from a DOM event, it will call  stopPropagation()  and  preventDefault()  automatically.  In the following example,  ParentComponent  listens to  childevent  and returns false to in its handler. This prevents the outer instance from receiving the event.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `,\n  oninit: function(){\n    this.on('ChildComponent.childevent', function(){\n      return false;\n    });\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('This will not fire');\n});  Events that have been assigned a handler using  on-*  will also prevent the bubbling of the original event. A proxy event is assigned, will bubble in its place.  In the following example,  childevent1  is prevented by not assigning a handle.  childevent2  is prevented by having a proxy event  childevent2proxy  assigned to it, which will also bubble in its place.  childevent3  is prevented by a method call.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function() {\n    this.fire('childevent1');\n    this.fire('childevent2');\n    this.fire('childevent3');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent on-childevent1=  on-childevent2= childevent2proxy  on-childevent3= @this.parentMethod()  / \n  `,\n  oninit: function() {\n    this.on('childevent2proxy', function() {\n      console.log('childevent2 handled and will no longer bubble.');\n      console.log('childevent2proxy will take its place.');\n    });\n  },\n  parentMethod: function(){\n    console.log('childevent3 handled by a method')\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent.childevent1', function() {\n  console.log('childevent1 stopped');\n});\n\nractive.on('ChildComponent.childevent2', function() {\n  console.log('childevent2 stopped');\n});\n\nractive.on('ParentComponent.childevent2proxy', function() {\n  console.log('childevent2proxy fired');\n});\n\nractive.on('ChildComponent.childevent3', function() {\n  console.log('childevent3 fired');\n});", 
            "title": "Stopping propagation"
        }, 
        {
            "location": "/extend/components/#content", 
            "text": "{{ content}}  renders the inner HTML in the context of the component. Partials, components, and any other valid template items can be used as inner HTML.  {{ content}}  can be thought of as a special partial.  In the following example, the result will print \"Lorem Ipsum\" because the inner HTML's context is the component, whose  message  is set to \"Lorem Ipsum\".  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component {{ content}} /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n         div class= inner-content {{ message }} /div \n       /ChildComponent \n     /div \n  `\n});  Partials defined in the inner HTML can be used to override partials defined on the component. This can be used to allow easy customization of each instance using partials.  In the following example,  ChildComponent 's default template for the  messageWrapper  partial is a  strong . Upon use of  ChildComponent  in the instance, it overrides the partial to use an  em  instead.  Ractive.components.ChildComponent = Ractive.extend({\n  partials: {\n    messageWrapper: ' strong {{message}} /strong '\n  },\n  template: `\n     div class= child-component {{ content}} /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n\n        {{#partial messageWrapper}} em {{message}} /em {{/}}\n\n         div class= inner-content \n          {{  messageWrapper }}\n         /div \n\n       /ChildComponent \n     /div \n  `\n});", 
            "title": "{{&gt;content}}"
        }, 
        {
            "location": "/extend/components/#yield", 
            "text": "{{yield}}  renders the inner HTML in the context of the parent component. Partials, components, and any other valid template items can be used as inner HTML. A common use case of  {{yield}}  is to provide wrapper markup transparently.  In the following example, the result will print \"Hello World!\" because the inner HTML's context is the parent component's, whose  message  is \"Hello World!\".  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component {{ yield }} /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n         div class= inner-content {{ message }} /div \n       /ChildComponent \n     /div \n  `\n});  Yields can also be customized using named yields. Instead of rendering with the component's inner HTML, a named yield will look for a partial in the inner HTML with the same name and use that to render the yielded content.  In the following example,  ChildComponent  renders the yield content 3 times. However, the last two yields will look for  italicYield  and  boldYield  partials in the inner HTML and use that to render. What's rendered is three \"Hello World!\"s in regular, italic and bold.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component \n      {{ yield }}\n      {{ yield italicYield }}\n      {{ yield boldYield }}\n     /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n        {{#partial italicYield }} em {{message}} /em {{/}}\n        {{#partial boldYield }} strong {{message}} /strong {{/}}\n        {{message}}\n       /ChildComponent \n     /div \n  `\n});", 
            "title": "{{yield}}"
        }, 
        {
            "location": "/extend/components/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/decorators/", 
            "text": "Decorators\n\n\nA decorator is a simple way to add behaviour to a node when it is rendered, or to augment it in some way. Decorators are a good way to integrate DOM manipulation libraries with Ractive, such as \njQuery UI\n or \nBootstrap\n.\n\n\nWriting\n\n\nconst myDecorator = function(node[, ...args]) {\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    },\n    update: function([...args]){\n      // Update code\n    }\n  };\n};\n\n\n\n\nDecorators are simply functions that are called upon to setup the decorator once Ractive detects its use. It takes a \nnode\n argument and returns an object with a \nteardown\n and \nupdate\n property.\n\n\nnode\n is the element to which the decorator is applied to.\n\n\nargs\n are optional arguments provided by the decorator directive.\n\n\nteardown\n is a function that gets called when the decorator is torn down.\n\n\nupdate\n is an optional function that gets called when the arguments update.\n\n\nAny updates to the arguments will call the decorator's \nteardown\n and run the decorator function again, essentially setting up the decorator again. If an \nupdate\n function is provided on the return object, that will be called instead of the \nteardown\n and setup function.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register decorators:\n\n\nGlobally, via the \nRactive.decorators\n static property.\n\n\nRactive.decorators.myDecorator = myDecorator;\n\n\n\n\nPer component, via the component's \ndecorators\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  decorators: { myDecorator }\n});\n\n\n\n\nPer instance, via the instance's \ndecorators\n initialization property.\n\n\nconst ractive = new Ractive({\n  decorators: { myDecorator }\n});\n\n\n\n\nUsing\n\n\nYou can invoke one or more decorators on your elements by using a decorator directive. Arguments are optional. Argument-less decorators can simply use the directive without value. Decorators with arguments take a comma-separated set of expressions that resolve to the element's context.\n\n\n!-- without arguments --\n\n\ndiv as-myDecorator\n...\n/div\n\n\n\n!-- with arguments --\n\n\ndiv as-myDecorator=\narg1, .some.other.arg2, 10 * @index\n as-somethingElseToo\n...\n/div\n\n\n\n\n\nExamples\n\n\nThe following example builds a decorator that updates the time.\n\n\nRactive.decorators.timer = function(node, time) {\n  node.innerHTML = 'Hello World!';\n\n  return {\n    teardown: function() {\n      node.innerHTML = '';\n    },\n    update: function(time) {\n      node.innerHTML = time;\n    }\n  }\n};\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nspan as-timer=\ntime\n/span\n\n  `,\n  data: {\n    time: 0\n  }\n});\n\nsetInterval(function() {\n  ractive.set('time', Date.now())\n}, 1000);", 
            "title": "Decorators"
        }, 
        {
            "location": "/extend/decorators/#decorators", 
            "text": "A decorator is a simple way to add behaviour to a node when it is rendered, or to augment it in some way. Decorators are a good way to integrate DOM manipulation libraries with Ractive, such as  jQuery UI  or  Bootstrap .", 
            "title": "Decorators"
        }, 
        {
            "location": "/extend/decorators/#writing", 
            "text": "const myDecorator = function(node[, ...args]) {\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    },\n    update: function([...args]){\n      // Update code\n    }\n  };\n};  Decorators are simply functions that are called upon to setup the decorator once Ractive detects its use. It takes a  node  argument and returns an object with a  teardown  and  update  property.  node  is the element to which the decorator is applied to.  args  are optional arguments provided by the decorator directive.  teardown  is a function that gets called when the decorator is torn down.  update  is an optional function that gets called when the arguments update.  Any updates to the arguments will call the decorator's  teardown  and run the decorator function again, essentially setting up the decorator again. If an  update  function is provided on the return object, that will be called instead of the  teardown  and setup function.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/decorators/#registering", 
            "text": "Like other plugins, there's 3 ways you can register decorators:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/decorators/#globally-via-the-ractivedecorators-static-property", 
            "text": "Ractive.decorators.myDecorator = myDecorator;", 
            "title": "Globally, via the Ractive.decorators static property."
        }, 
        {
            "location": "/extend/decorators/#per-component-via-the-components-decorators-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  decorators: { myDecorator }\n});", 
            "title": "Per component, via the component's decorators initialization property."
        }, 
        {
            "location": "/extend/decorators/#per-instance-via-the-instances-decorators-initialization-property", 
            "text": "const ractive = new Ractive({\n  decorators: { myDecorator }\n});", 
            "title": "Per instance, via the instance's decorators initialization property."
        }, 
        {
            "location": "/extend/decorators/#using", 
            "text": "You can invoke one or more decorators on your elements by using a decorator directive. Arguments are optional. Argument-less decorators can simply use the directive without value. Decorators with arguments take a comma-separated set of expressions that resolve to the element's context.  !-- without arguments --  div as-myDecorator ... /div  !-- with arguments --  div as-myDecorator= arg1, .some.other.arg2, 10 * @index  as-somethingElseToo ... /div", 
            "title": "Using"
        }, 
        {
            "location": "/extend/decorators/#examples", 
            "text": "The following example builds a decorator that updates the time.  Ractive.decorators.timer = function(node, time) {\n  node.innerHTML = 'Hello World!';\n\n  return {\n    teardown: function() {\n      node.innerHTML = '';\n    },\n    update: function(time) {\n      node.innerHTML = time;\n    }\n  }\n};\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     span as-timer= time /span \n  `,\n  data: {\n    time: 0\n  }\n});\n\nsetInterval(function() {\n  ractive.set('time', Date.now())\n}, 1000);", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/easings/", 
            "text": "Easings\n\n\nEasing functions are used by \nractive.animate\n and some transitions. They describe the animation's progression from start to finish.\n\n\nWriting\n\n\nconst myEasing = function ( x ) {\n  // Calculation\n  return y;\n};\n\n\n\n\nEasing functions are simply functions that accept one argument, a numeric value \nx\n between 0 and 1 representing progress along a timeline. The function must return a numeric \ny\n value to represent its progression.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register an easing function:\n\n\nGlobally via the \nRactive.easing\n static property.\n\n\nRactive.easing.myEasing = myEasing;\n\n\n\n\nPer component via the component's \neasing\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  easing: { myEasing }\n});\n\n\n\n\nPer instance, via the instance's \neasing\n initialization property.\n\n\nconst ractive = new Ractive({\n  easing: { myEasing }\n});\n\n\n\n\nUsing\n\n\nEasing functions don't work alone. They are utilized by \nractive.animate()\n and \nTransitions\n to dictate animations.\n\n\nractive.animate('foo.bar', 1, {\n  easing: 'myEasing'\n});\n\n\n\n\nExamples\n\n\nHere's an \nelastic\n easing function taken from \ndanro\n's excellent \neasing.js\n library.\n\n\nRactive.easing.elastic = function ( x ) {\n  return -1 * Math.pow(4,-8*x) * Math.sin((x*6-1)*(2*Math.PI)/2) + 1;\n};", 
            "title": "Easings"
        }, 
        {
            "location": "/extend/easings/#easings", 
            "text": "Easing functions are used by  ractive.animate  and some transitions. They describe the animation's progression from start to finish.", 
            "title": "Easings"
        }, 
        {
            "location": "/extend/easings/#writing", 
            "text": "const myEasing = function ( x ) {\n  // Calculation\n  return y;\n};  Easing functions are simply functions that accept one argument, a numeric value  x  between 0 and 1 representing progress along a timeline. The function must return a numeric  y  value to represent its progression.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/easings/#registering", 
            "text": "Like other plugins, there's 3 ways you can register an easing function:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/easings/#globally-via-the-ractiveeasing-static-property", 
            "text": "Ractive.easing.myEasing = myEasing;", 
            "title": "Globally via the Ractive.easing static property."
        }, 
        {
            "location": "/extend/easings/#per-component-via-the-components-easing-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  easing: { myEasing }\n});", 
            "title": "Per component via the component's easing initialization property."
        }, 
        {
            "location": "/extend/easings/#per-instance-via-the-instances-easing-initialization-property", 
            "text": "const ractive = new Ractive({\n  easing: { myEasing }\n});", 
            "title": "Per instance, via the instance's easing initialization property."
        }, 
        {
            "location": "/extend/easings/#using", 
            "text": "Easing functions don't work alone. They are utilized by  ractive.animate()  and  Transitions  to dictate animations.  ractive.animate('foo.bar', 1, {\n  easing: 'myEasing'\n});", 
            "title": "Using"
        }, 
        {
            "location": "/extend/easings/#examples", 
            "text": "Here's an  elastic  easing function taken from  danro 's excellent  easing.js  library.  Ractive.easing.elastic = function ( x ) {\n  return -1 * Math.pow(4,-8*x) * Math.sin((x*6-1)*(2*Math.PI)/2) + 1;\n};", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/events/", 
            "text": "Events\n\n\nEvents allow custom-named events on DOM elements. Common use cases for custom DOM events include normalizing cross-browser events, normalizing cross-device events, implementing custom events, and so much more.\n\n\nWriting\n\n\nconst myEvent = function(node, fire){\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    }\n  };\n}\n\n\n\n\nEvents are simply functions that are called to set up the event on a DOM element. The event function accepts two arguments: \nnode\n and \nfire\n, and returns an object containing a \nteardown\n property.\n\n\nnode\n is the element to which the event is being applied.\n\n\nfire\n is the function that must be called when the event has taken place. \nfire\n takes a single argument, the event object received by handlers. The minimum requirement for the event object is a \nnode\n property that references DOM node the event is attached to, and an \noriginal\n property which references the native DOM \nevent\n object supplied by the native handler, if available.\n\n\nThe event object will be augmented with \ncontext\n, \nkeypath\n and \nindex\n properties, whose values depend on the data context the node is in. \ncontext\n references the data context that surrounds the node, \nkeypath\n is a string that leads to the current data context and \nindex\n is a number that references the index number of the data, should the data context be in an array.\n\n\nteardown\n is a function that gets called once the element is torn down. This allows the event to clean up after itself.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register events:\n\n\nGlobally, via the \nRactive.events\n static property.\n\n\nRactive.events.myEvent = myEvent;\n\n\n\n\nPer component, via the component's \nevents\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  events: { myEvent }\n});\n\n\n\n\nPer instance, via the instance's \nevents\n initialization property.\n\n\nconst ractive = new Ractive({\n  events: { myEvent }\n});\n\n\n\n\nUsing\n\n\nEvents use the same \non-*\n attribute syntax as component and DOM events. When Ractive encounters an \non-*\n attribute on a DOM element, it looks for a registered event and applies it on the element. If no matching event name was found, Ractive will think the event name is a native DOM event and will attach one accordingly.\n\n\n// This will apply the \nmyEvent\n custom event if one is registered.\n// Otherwise, Ractive will think it's a DOM event. You have been warned!\n\nspan on-myEvent=\nfoo()\nClick me!\n/span\n\n\n\n\n\nExamples\n\n\nHere's an example of a \"long press\" event which fires when the mouse is clicked and held for 1 second.\n\n\n// Definition\nRactive.events.longpress = function(node, fire){\n  let timer = null;\n\n  function clearTimer(){\n    if(timer) clearTimeout(timer);\n    timer = null;\n  }\n\n  function mouseDownHandler(event){\n    clearTimer();\n\n    timer = setTimeout(function(){\n      fire({\n        node: node,\n        original: event\n      });\n    }, 1000);\n  }\n\n  function mouseUpHandler(){\n    clearTimer();\n  }\n\n  node.addEventListener('mousedown', mouseDownHandler);\n  node.addEventListener('mouseup', mouseUpHandler);\n\n  return {\n    teardown: function(){\n      node.removeEventListener('mousedown', mouseDownHandler);\n      node.removeEventListener('mouseup', mouseUpHandler);\n    }\n  };\n};\n\n// Usage:\nnew Ractive({\n  el: 'body',\n  template: `\n    \nbutton type=\nbutton\n on-longpress=\n@this.greetz()\nClick Me!\n/button\n\n  `,\n  greetz: function(){\n    console.log('Hello World!');\n  }\n});", 
            "title": "Events"
        }, 
        {
            "location": "/extend/events/#events", 
            "text": "Events allow custom-named events on DOM elements. Common use cases for custom DOM events include normalizing cross-browser events, normalizing cross-device events, implementing custom events, and so much more.", 
            "title": "Events"
        }, 
        {
            "location": "/extend/events/#writing", 
            "text": "const myEvent = function(node, fire){\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    }\n  };\n}  Events are simply functions that are called to set up the event on a DOM element. The event function accepts two arguments:  node  and  fire , and returns an object containing a  teardown  property.  node  is the element to which the event is being applied.  fire  is the function that must be called when the event has taken place.  fire  takes a single argument, the event object received by handlers. The minimum requirement for the event object is a  node  property that references DOM node the event is attached to, and an  original  property which references the native DOM  event  object supplied by the native handler, if available.  The event object will be augmented with  context ,  keypath  and  index  properties, whose values depend on the data context the node is in.  context  references the data context that surrounds the node,  keypath  is a string that leads to the current data context and  index  is a number that references the index number of the data, should the data context be in an array.  teardown  is a function that gets called once the element is torn down. This allows the event to clean up after itself.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/events/#registering", 
            "text": "Like other plugins, there's 3 ways you can register events:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/events/#globally-via-the-ractiveevents-static-property", 
            "text": "Ractive.events.myEvent = myEvent;", 
            "title": "Globally, via the Ractive.events static property."
        }, 
        {
            "location": "/extend/events/#per-component-via-the-components-events-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  events: { myEvent }\n});", 
            "title": "Per component, via the component's events initialization property."
        }, 
        {
            "location": "/extend/events/#per-instance-via-the-instances-events-initialization-property", 
            "text": "const ractive = new Ractive({\n  events: { myEvent }\n});", 
            "title": "Per instance, via the instance's events initialization property."
        }, 
        {
            "location": "/extend/events/#using", 
            "text": "Events use the same  on-*  attribute syntax as component and DOM events. When Ractive encounters an  on-*  attribute on a DOM element, it looks for a registered event and applies it on the element. If no matching event name was found, Ractive will think the event name is a native DOM event and will attach one accordingly.  // This will apply the  myEvent  custom event if one is registered.\n// Otherwise, Ractive will think it's a DOM event. You have been warned! span on-myEvent= foo() Click me! /span", 
            "title": "Using"
        }, 
        {
            "location": "/extend/events/#examples", 
            "text": "Here's an example of a \"long press\" event which fires when the mouse is clicked and held for 1 second.  // Definition\nRactive.events.longpress = function(node, fire){\n  let timer = null;\n\n  function clearTimer(){\n    if(timer) clearTimeout(timer);\n    timer = null;\n  }\n\n  function mouseDownHandler(event){\n    clearTimer();\n\n    timer = setTimeout(function(){\n      fire({\n        node: node,\n        original: event\n      });\n    }, 1000);\n  }\n\n  function mouseUpHandler(){\n    clearTimer();\n  }\n\n  node.addEventListener('mousedown', mouseDownHandler);\n  node.addEventListener('mouseup', mouseUpHandler);\n\n  return {\n    teardown: function(){\n      node.removeEventListener('mousedown', mouseDownHandler);\n      node.removeEventListener('mouseup', mouseUpHandler);\n    }\n  };\n};\n\n// Usage:\nnew Ractive({\n  el: 'body',\n  template: `\n     button type= button  on-longpress= @this.greetz() Click Me! /button \n  `,\n  greetz: function(){\n    console.log('Hello World!');\n  }\n});", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/interpolators/", 
            "text": "Interpolators\n\n\nTODO\n\n\nWriting\n\n\nTODO\n\n\nRegistering\n\n\nTODO\n\n\nUsing\n\n\nTODO\n\n\nExamples\n\n\nTODO", 
            "title": "Interpolators"
        }, 
        {
            "location": "/extend/interpolators/#interpolators", 
            "text": "TODO", 
            "title": "Interpolators"
        }, 
        {
            "location": "/extend/interpolators/#writing", 
            "text": "TODO", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/interpolators/#registering", 
            "text": "TODO", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/interpolators/#using", 
            "text": "TODO", 
            "title": "Using"
        }, 
        {
            "location": "/extend/interpolators/#examples", 
            "text": "TODO", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/partials/", 
            "text": "Partials\n\n\nA partial is a template snippet which can be reused in templates or in other partials. They help to keep templates uncluttered, non-repetetive and easy to read.\n\n\nWriting\n\n\nconst myPartial = '\n!-- template --\n';\n\n\n\n\nPartials are simply Ractive templates.\n\n\nRegistering\n\n\nUnlike other plugins, partials have more than 3 registration options.\n\n\nGlobally via the \nRactive.partials\n static property.\n\n\nRactive.partials.myPartial = MyPartial;\n\n\n\n\nGlobally, via a non-executing script tag on the current page.\n\n\nscript type=\nractive/template\n id=\nmyPartial\n\n  ...\n\n/script\n\n\n\n\n\ntext/html\n is another good choice for \ntype\n because many editors will highlight the content of the tag as HTML. Anything other than \ntext/javascript\n, \napplication/javascript\n, or no \ntype\n at all will do.\n\n\nPer component, via the component's \npartials\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  partials: { myPartial }\n});\n\n\n\n\nPer instance, via the instance's \npartials\n initialization property.\n\n\nconst ractive = new Ractive({\n  partials: { myPartial }\n});\n\n\n\n\nInline, using the \n{{#partial}}\n mustache.\n\n\nAvailability depends on whoever uses the template containing the inline partial, whether it's a component, an instance or another partial. Inline partials are scoped to the nearest tag, be it component or element, and are available to any child of that element.\n\n\n{{#partial myPartial}}\n  ...\n{{/}}\n\n\n\n\nUsing\n\n\nPartials can be used using the \n{{\npartialName}}\n syntax. Partials work where any template would work. It works as if the partial template is manually put into where the partial mustache is positioned.\n\n\n{{#partial myPartial}}\n  \ndiv class=\nmessage\n{{message}}\n/div\n\n{{/}}\n\n\ndiv class=\napp\n\n  {{\nmyPartial}}\n\n/div\n\n\n\n\n\nValid names\n\n\nPartials may be named with the same rules as any other identifier in Ractive or JavaScript, but since there isn't much danger of trying to do math in a partial name, they enjoy relaxed naming requirements that allow otherwise reserved globals and keywords to be used for partial names.\n\n\nPartial names may also contain \n-\n and \n/\n characters as long as they are surrounded by other valid characters e.g. \ntemplates/some-partial-template\n.\n\n\nPartial context\n\n\nBy default, a partial's context is the context of wherever it is positioned.\n\n\nIn the following example, the context of the partial is the current item in the list.\n\n\n{{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{\nmyPartial}}\n{{/}}\n\n\n\n\n\nHowever, partials may be given explicit context using the \n{{\n[name expression] [context expression]}}\n syntax. It's similar to wrapping the partial with a \n{{#with}}\n mustache. Ancestor references, members, object literals, and any other expressions that resolve to an object may be used as a context expression.\n\n\nIn the following example, context of the partial is the current item's \nfoo.bar\n value.\n\n\n{{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{\nmyPartial .foo.bar}}\n{{/}}\n\n\n\n\nExplicit contexts can also be aliased. In the case of plain refereces, it can be used for two-way binding.\n\n\nIn the following example, the current item's \nfoo.bar\n path is aliased with \nitem\n. In the partial, \n.label\n refers to the current item's \nlabel\n property. However, \nitem\n is essentially the current item's \n{{.foo.bar.item}}\n. The \nitem\n binds two-way and updates the current item's \n.foo.bar\n.\n\n\n{{#partial myPartial}}\n  \nlabel\n{{.label}}\n/label\n\n  \ninput type=\ntext\n value=\n{{item}}\n\n{{/}}\n\n{{# list }}\n  {{\nmyPartial .foo.bar as item}}\n{{/}}\n\n\n\n\nRecursive partials\n\n\nPartials can be used recursively. A common use case for this is when reusing partials on a tree-like structure, like a directory listing.\n\n\ndiv class='fileSystem'\n\n  {{#root}}\n    {{\nfolder}}\n  {{/root}}\n\n/div\n\n\n{{#partial folder}}\n\nul class='folder'\n\n  {{#files}}\n    {{\nfile}}\n  {{/files}}\n\n/ul\n\n{{/partial}}\n\n{{#partial file}}\n\nli class='file'\n\n  \nimg class='icon-{{type}}'\n\n  \nspan\n{{filename}}\n/span\n\n\n  \n!-- if this is actually a folder, embed the folder partial --\n\n  {{# type === 'folder' }}\n    {{\nfolder}}\n  {{/ type === 'folder' }}\n\n/li\n\n{{/partial}}\n\n\n\n\nrv = new Ractive({\n  el: 'container',\n  template: '#myTemplate',\n  data: {\n    root: {\n      files: [\n        { type: 'jpg', filename: 'hello.jpg' },\n        { type: 'mp3', filename: 'NeverGonna.mp3' },\n        { type: 'folder', filename: 'subfolder', files: [\n          { type: 'txt', filename: 'README.txt' },\n          { type: 'folder', filename: 'rabbithole', files: [\n            { type: 'txt', filename: 'Inception.txt' }\n          ]}\n        ]}\n      ]\n    }\n  }\n});\n\n\n\n\nIn the example above, subfolders use the \n{{\nfolder}}\n partial, which uses the \n{{\nfile}}\n partial for each file, and if any of those files are folders, the \n{{\nfolder}}\n partial will be invoked again, and so on until there are no more files.\n\n\nBeware of cyclical data structures! Ractive makes no attempt to detect cyclicality, and will happily continue rendering partials until the \nBig Crunch\n (or your browser exceeds its maximum call stack size. Whichever is sooner).\n\n\nInjecting partials\n\n\nOne good use of partials is to vary the shape of a template according to some condition, the same way you might use \ndependency injection\n elsewhere in your code.\n\n\nFor example, you might offer a different view to mobile users:\n\n\ndiv class='main'\n\n  \ndiv class='content'\n\n    {{\ncontent}}\n  \n/div\n\n\n  \ndiv class='sidebar'\n\n    {{\nsidebar}}\n  \n/div\n\n\n/div\n\n\n\n\n\nisMobile = /mobile/i.test( navigator.userAgent ); // please don't do this in real life!\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  partials: {\n    content: isMobile ? mobileContentPartial : desktopContentPartial,\n    sidebar: isMobile ? mobileSidebarPartial : desktopSidebarPartial\n  }\n});\n\n\n\n\nOr you might make it possible to \nextend\n a subclass without overriding its template:\n\n\ndiv class='modal-background'\n\n  \ndiv class='modal'\n\n    {{\nmodalContent}}\n  \n/div\n\n\n/div\n\n\n\n\n\n// Create a Modal subclass\nModal = Ractive.extend({\n  template: modalTemplate,\n  init: function () {\n    var self = this, resizeHandler;\n\n    resizeHandler = function () {\n      self.center();\n    };\n\n    // when the window resizes, keep the modal horizontally and vertically centred\n    window.addEventListener( 'resize', resizeHandler );\n\n    // clean up after ourselves later\n    this.on( 'teardown', function () {\n      window.removeEventListener( 'resize', resizeHandler );\n    });\n\n    // manually call this.center() the first time\n    this.center();\n  },\n  center: function () {\n    // centering logic goes here\n  }\n});\n\nhelloModal = new Modal({\n  el: document.body,\n  partials: {\n    modalContent: '\np\nHello!\n/p\na class=\nmodal-button\n proxy-tap=\nclose\nClose\n/a\n'\n  }\n});\n\nhelloModal.on( 'close', function () {\n  this.teardown();\n});\n\n\n\n\nPartial expressions\n\n\nExpressions can also be used to reference a partial instead of fixed partial names. Ractive will evaluate the expression and use its return value to select a partial. This is useful when you want the data to indicate what type of partial it should render with.\n\n\nIn the following example, \norganisms\n contains a list of organisms whose \ntype\n can either be \nperson\n or \nanimal\n. Partials for each type is defined and the list uses the \ntype\n of each item to determine which partial to use.\n\n\n{{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n\nul\n\n  {{# organisms }}\n    \nli\n{{\n type }}\n/li\n\n  {{/}}\n\n/ul\n\n\n\n\n\nIn the case where there's a collision between the expression and a partial of the same name, Ractive will not evaluate the expression and instead, will immediately resolve to that partial.\n\n\nIn the following example, a partial named \ntype\n is defined. Instead of evaluating \ntype\n's value, it will resolve to the partial named \ntype\n.\n\n\n{{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n{{#partial type}}Hi! I am {{.name}}{{/}}\n\n\nul\n\n  {{# organisms }}\n    \nli\n{{\n type }}\n/li\n\n  {{/}}\n\n/ul\n\n\n\n\n\nPartials can also be registered on-the-fly as well as have functions determine the partial to use.\n\n\nIn the following example, \nmakePartial\n registers a partial on the fly using \ntemplate\n and \nid\n, and returns the partial name for use in the template.\n\n\nnew Ractive({\n  el: 'main',\n  template: `\n    \nspan\nAdd a partial:\n/span\n\n    \ntextarea value=\n{{tpl}}\n /\n/div\n\n    \nbutton on-click=\n@this.add()\nAdd\n/button\nbr/\n\n\n    {{#list}}\n      {{\n @this.makePartial(.id, .template) }}\n    {{/}}\n  `,\n  data: {\n    list: [],\n    tpl: '',\n\n  },\n  add: function() {\n    this.push('list', {\n      id: Math.random(),\n      template: this.get('tpl')\n    });\n    this.set('tpl', '');\n  },\n  makePartial: function(id, template) {\n    const name = 'partial-' + id;\n    this.partials[name] = this.partials[name] || template;\n    return name;\n  }\n});\n\n\n\n\nUpdating Partials\n\n\nPartials may be reset after they are rendered using \nractive.resetPartial()\n. A reset partial will update everywhere it is referenced, so if it is used multiple times or inherited by a component, those instances will be updated as well. If a component has a partial with the same name as a parent partial, partial resets will not affect it since it is a different partial.\n\n\nIt should be noted that partials evaluate lazily, so it is possible to cause a single partial to update by wrapping it in a conditional section and causing the section to be hidden and re-shown.\n\n\n{{^toggle}}{{\nrickroll}}{{/}}\n\n\n\n\nractive.partials.rickroll = 'I wouldn\\'t do that to you, chum.';\nractive.set('toggle', true);\nractive.set('toggle', false);\n\n\n\n\nExamples\n\n\nHere's an example of a gallery using a partial for its thumbnail information:\n\n\n!-- The partial called \nthumbnail\n --\n\n\nfigure class='thumbnail'\n\n  \nimg src='assets/thumbnails/{{id}}.jpg'\n\n  \nfigcaption\n{{description}}\n/figcaption\n\n\n/figure\n\n\n\n!-- The template that uses the partial --\n\n\ndiv class='gallery'\n\n  {{#items}}\n    {{\nthumbnail}}\n  {{/items}}\n\n/div", 
            "title": "Partials"
        }, 
        {
            "location": "/extend/partials/#partials", 
            "text": "A partial is a template snippet which can be reused in templates or in other partials. They help to keep templates uncluttered, non-repetetive and easy to read.", 
            "title": "Partials"
        }, 
        {
            "location": "/extend/partials/#writing", 
            "text": "const myPartial = ' !-- template -- ';  Partials are simply Ractive templates.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/partials/#registering", 
            "text": "Unlike other plugins, partials have more than 3 registration options.", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/partials/#globally-via-the-ractivepartials-static-property", 
            "text": "Ractive.partials.myPartial = MyPartial;", 
            "title": "Globally via the Ractive.partials static property."
        }, 
        {
            "location": "/extend/partials/#globally-via-a-non-executing-script-tag-on-the-current-page", 
            "text": "script type= ractive/template  id= myPartial \n  ... /script   text/html  is another good choice for  type  because many editors will highlight the content of the tag as HTML. Anything other than  text/javascript ,  application/javascript , or no  type  at all will do.", 
            "title": "Globally, via a non-executing script tag on the current page."
        }, 
        {
            "location": "/extend/partials/#per-component-via-the-components-partials-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  partials: { myPartial }\n});", 
            "title": "Per component, via the component's partials initialization property."
        }, 
        {
            "location": "/extend/partials/#per-instance-via-the-instances-partials-initialization-property", 
            "text": "const ractive = new Ractive({\n  partials: { myPartial }\n});", 
            "title": "Per instance, via the instance's partials initialization property."
        }, 
        {
            "location": "/extend/partials/#inline-using-the-partial-mustache", 
            "text": "Availability depends on whoever uses the template containing the inline partial, whether it's a component, an instance or another partial. Inline partials are scoped to the nearest tag, be it component or element, and are available to any child of that element.  {{#partial myPartial}}\n  ...\n{{/}}", 
            "title": "Inline, using the {{#partial}} mustache."
        }, 
        {
            "location": "/extend/partials/#using", 
            "text": "Partials can be used using the  {{ partialName}}  syntax. Partials work where any template would work. It works as if the partial template is manually put into where the partial mustache is positioned.  {{#partial myPartial}}\n   div class= message {{message}} /div \n{{/}} div class= app \n  {{ myPartial}} /div", 
            "title": "Using"
        }, 
        {
            "location": "/extend/partials/#valid-names", 
            "text": "Partials may be named with the same rules as any other identifier in Ractive or JavaScript, but since there isn't much danger of trying to do math in a partial name, they enjoy relaxed naming requirements that allow otherwise reserved globals and keywords to be used for partial names.  Partial names may also contain  -  and  /  characters as long as they are surrounded by other valid characters e.g.  templates/some-partial-template .", 
            "title": "Valid names"
        }, 
        {
            "location": "/extend/partials/#partial-context", 
            "text": "By default, a partial's context is the context of wherever it is positioned.  In the following example, the context of the partial is the current item in the list.  {{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{ myPartial}}\n{{/}}  However, partials may be given explicit context using the  {{ [name expression] [context expression]}}  syntax. It's similar to wrapping the partial with a  {{#with}}  mustache. Ancestor references, members, object literals, and any other expressions that resolve to an object may be used as a context expression.  In the following example, context of the partial is the current item's  foo.bar  value.  {{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{ myPartial .foo.bar}}\n{{/}}  Explicit contexts can also be aliased. In the case of plain refereces, it can be used for two-way binding.  In the following example, the current item's  foo.bar  path is aliased with  item . In the partial,  .label  refers to the current item's  label  property. However,  item  is essentially the current item's  {{.foo.bar.item}} . The  item  binds two-way and updates the current item's  .foo.bar .  {{#partial myPartial}}\n   label {{.label}} /label \n   input type= text  value= {{item}} \n{{/}}\n\n{{# list }}\n  {{ myPartial .foo.bar as item}}\n{{/}}", 
            "title": "Partial context"
        }, 
        {
            "location": "/extend/partials/#recursive-partials", 
            "text": "Partials can be used recursively. A common use case for this is when reusing partials on a tree-like structure, like a directory listing.  div class='fileSystem' \n  {{#root}}\n    {{ folder}}\n  {{/root}} /div \n\n{{#partial folder}} ul class='folder' \n  {{#files}}\n    {{ file}}\n  {{/files}} /ul \n{{/partial}}\n\n{{#partial file}} li class='file' \n   img class='icon-{{type}}' \n   span {{filename}} /span \n\n   !-- if this is actually a folder, embed the folder partial -- \n  {{# type === 'folder' }}\n    {{ folder}}\n  {{/ type === 'folder' }} /li \n{{/partial}}  rv = new Ractive({\n  el: 'container',\n  template: '#myTemplate',\n  data: {\n    root: {\n      files: [\n        { type: 'jpg', filename: 'hello.jpg' },\n        { type: 'mp3', filename: 'NeverGonna.mp3' },\n        { type: 'folder', filename: 'subfolder', files: [\n          { type: 'txt', filename: 'README.txt' },\n          { type: 'folder', filename: 'rabbithole', files: [\n            { type: 'txt', filename: 'Inception.txt' }\n          ]}\n        ]}\n      ]\n    }\n  }\n});  In the example above, subfolders use the  {{ folder}}  partial, which uses the  {{ file}}  partial for each file, and if any of those files are folders, the  {{ folder}}  partial will be invoked again, and so on until there are no more files.  Beware of cyclical data structures! Ractive makes no attempt to detect cyclicality, and will happily continue rendering partials until the  Big Crunch  (or your browser exceeds its maximum call stack size. Whichever is sooner).", 
            "title": "Recursive partials"
        }, 
        {
            "location": "/extend/partials/#injecting-partials", 
            "text": "One good use of partials is to vary the shape of a template according to some condition, the same way you might use  dependency injection  elsewhere in your code.  For example, you might offer a different view to mobile users:  div class='main' \n   div class='content' \n    {{ content}}\n   /div \n\n   div class='sidebar' \n    {{ sidebar}}\n   /div  /div   isMobile = /mobile/i.test( navigator.userAgent ); // please don't do this in real life!\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  partials: {\n    content: isMobile ? mobileContentPartial : desktopContentPartial,\n    sidebar: isMobile ? mobileSidebarPartial : desktopSidebarPartial\n  }\n});  Or you might make it possible to  extend  a subclass without overriding its template:  div class='modal-background' \n   div class='modal' \n    {{ modalContent}}\n   /div  /div   // Create a Modal subclass\nModal = Ractive.extend({\n  template: modalTemplate,\n  init: function () {\n    var self = this, resizeHandler;\n\n    resizeHandler = function () {\n      self.center();\n    };\n\n    // when the window resizes, keep the modal horizontally and vertically centred\n    window.addEventListener( 'resize', resizeHandler );\n\n    // clean up after ourselves later\n    this.on( 'teardown', function () {\n      window.removeEventListener( 'resize', resizeHandler );\n    });\n\n    // manually call this.center() the first time\n    this.center();\n  },\n  center: function () {\n    // centering logic goes here\n  }\n});\n\nhelloModal = new Modal({\n  el: document.body,\n  partials: {\n    modalContent: ' p Hello! /p a class= modal-button  proxy-tap= close Close /a '\n  }\n});\n\nhelloModal.on( 'close', function () {\n  this.teardown();\n});", 
            "title": "Injecting partials"
        }, 
        {
            "location": "/extend/partials/#partial-expressions", 
            "text": "Expressions can also be used to reference a partial instead of fixed partial names. Ractive will evaluate the expression and use its return value to select a partial. This is useful when you want the data to indicate what type of partial it should render with.  In the following example,  organisms  contains a list of organisms whose  type  can either be  person  or  animal . Partials for each type is defined and the list uses the  type  of each item to determine which partial to use.  {{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}} ul \n  {{# organisms }}\n     li {{  type }} /li \n  {{/}} /ul   In the case where there's a collision between the expression and a partial of the same name, Ractive will not evaluate the expression and instead, will immediately resolve to that partial.  In the following example, a partial named  type  is defined. Instead of evaluating  type 's value, it will resolve to the partial named  type .  {{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n{{#partial type}}Hi! I am {{.name}}{{/}} ul \n  {{# organisms }}\n     li {{  type }} /li \n  {{/}} /ul   Partials can also be registered on-the-fly as well as have functions determine the partial to use.  In the following example,  makePartial  registers a partial on the fly using  template  and  id , and returns the partial name for use in the template.  new Ractive({\n  el: 'main',\n  template: `\n     span Add a partial: /span \n     textarea value= {{tpl}}  / /div \n     button on-click= @this.add() Add /button br/ \n\n    {{#list}}\n      {{  @this.makePartial(.id, .template) }}\n    {{/}}\n  `,\n  data: {\n    list: [],\n    tpl: '',\n\n  },\n  add: function() {\n    this.push('list', {\n      id: Math.random(),\n      template: this.get('tpl')\n    });\n    this.set('tpl', '');\n  },\n  makePartial: function(id, template) {\n    const name = 'partial-' + id;\n    this.partials[name] = this.partials[name] || template;\n    return name;\n  }\n});", 
            "title": "Partial expressions"
        }, 
        {
            "location": "/extend/partials/#updating-partials", 
            "text": "Partials may be reset after they are rendered using  ractive.resetPartial() . A reset partial will update everywhere it is referenced, so if it is used multiple times or inherited by a component, those instances will be updated as well. If a component has a partial with the same name as a parent partial, partial resets will not affect it since it is a different partial.  It should be noted that partials evaluate lazily, so it is possible to cause a single partial to update by wrapping it in a conditional section and causing the section to be hidden and re-shown.  {{^toggle}}{{ rickroll}}{{/}}  ractive.partials.rickroll = 'I wouldn\\'t do that to you, chum.';\nractive.set('toggle', true);\nractive.set('toggle', false);", 
            "title": "Updating Partials"
        }, 
        {
            "location": "/extend/partials/#examples", 
            "text": "Here's an example of a gallery using a partial for its thumbnail information:  !-- The partial called  thumbnail  --  figure class='thumbnail' \n   img src='assets/thumbnails/{{id}}.jpg' \n   figcaption {{description}} /figcaption  /figure  !-- The template that uses the partial --  div class='gallery' \n  {{#items}}\n    {{ thumbnail}}\n  {{/items}} /div", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/transitions/", 
            "text": "Transitions\n\n\nTransitions allow you to control how enter the DOM and how they leave the DOM. This allows you to define intro and outro behavior, particularly animations, when elements go in and out of the page.\n\n\nWriting\n\n\nconst myTransition = function ( t, params ) {\n  // Manipulate the DOM.\n  // Call t.complete() when completed.\n};\n\n\n\n\nTransitions are simply functions that get called to animate a specified element.\n\n\nt\n is a \ntransition helper object\n that aids in the implementation of the transition.\n\n\nparams\n is the parameters passed in via the transition directive.\n\n\nTransitions are expected to be asynchronous. In order to signal Ractive that the transition has completed, the transition must call the \nt.complete()\n.\n\n\nNote that transitions control the element's arrival and departure to the page. That means upon completion, any styling done to the element will be removed automatically.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register transitions:\n\n\nGlobally, via the \nRactive.transitions\n static property.\n\n\nRactive.transitions.myTransition = myTransition;\n\n\n\n\nPer component, via the component's \ntransitions\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  transitions: { myTransition }\n});\n\n\n\n\nPer instance, via the instance's \ntransitions\n initialization property.\n\n\nconst ractive = new Ractive({\n  transitions: { myTransition }\n});\n\n\n\n\nUsing\n\n\nTransitions are added to an element via a transition directive. The directive starts with the transition name followed by one or more suffixes. The transition may be intro-only (upon rendering) using the suffix \n-in\n, outro-only (upon removal) using the suffix \n-out\n, or both using the suffix \n-in-out\n.\n\n\ndiv myTransition-in\nIntro-only\n/div\n\n\ndiv myTransition-out\nOutro-only\n/div\n\n\ndiv myTransition-in-out\nIntro and outro\n/div\n\n\n\n\n\nTo pass arguments to the transition, simply provide an expression as the directive's value. This will be passed as the second argument of the transition function.\n\n\ndiv myTransition-in=\n{ /*params */ }\nIntro-only\n/div\n\n\ndiv myTransition-out=\n{ /*params */ }\nOutro-only\n/div\n\n\ndiv myTransition-in-out=\n{ /*params */ }\nIntro and outro\n/div\n\n\n\n\n\nExamples\n\n\nThe following example demonstrates a \"flash\" transition which colors the element green upon attachment, and red prior to removal.\n\n\nRactive.transitions.flash = function(t, params) {\n  // Process params and declaring defaults.\n  const options = t.processParams(params, {\n    color: t.isIntro ? '#0f0' : '#f00',\n    duration: 400\n  });\n\n  // The \ntransition\n\n  t.setStyle('color', options.color);\n\n  // Signal Ractive that the transition is complete.\n  setTimeout(t.complete, options.duration);\n};\n\nnew Ractive({\n  el: 'body',\n  template: `\n    \nbutton on-click='@this.insert()'\nInsert item\n/button\n\n    \nbutton on-click='@this.remove()'\nRemove item\n/button\n\n    \nul\n\n      {{#items}}\n      \nli flash-in-out\n{{this}}\n/li\n\n      {{/items}}\n    \n/ul\n\n  `,\n  data: {\n    items: []\n  },\n  insert() {\n    this.push('items', Date.now());\n  },\n  remove() {\n    this.splice('items', 0, 1);\n  }\n});", 
            "title": "Transitions"
        }, 
        {
            "location": "/extend/transitions/#transitions", 
            "text": "Transitions allow you to control how enter the DOM and how they leave the DOM. This allows you to define intro and outro behavior, particularly animations, when elements go in and out of the page.", 
            "title": "Transitions"
        }, 
        {
            "location": "/extend/transitions/#writing", 
            "text": "const myTransition = function ( t, params ) {\n  // Manipulate the DOM.\n  // Call t.complete() when completed.\n};  Transitions are simply functions that get called to animate a specified element.  t  is a  transition helper object  that aids in the implementation of the transition.  params  is the parameters passed in via the transition directive.  Transitions are expected to be asynchronous. In order to signal Ractive that the transition has completed, the transition must call the  t.complete() .  Note that transitions control the element's arrival and departure to the page. That means upon completion, any styling done to the element will be removed automatically.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/transitions/#registering", 
            "text": "Like other plugins, there's 3 ways you can register transitions:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/transitions/#globally-via-the-ractivetransitions-static-property", 
            "text": "Ractive.transitions.myTransition = myTransition;", 
            "title": "Globally, via the Ractive.transitions static property."
        }, 
        {
            "location": "/extend/transitions/#per-component-via-the-components-transitions-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  transitions: { myTransition }\n});", 
            "title": "Per component, via the component's transitions initialization property."
        }, 
        {
            "location": "/extend/transitions/#per-instance-via-the-instances-transitions-initialization-property", 
            "text": "const ractive = new Ractive({\n  transitions: { myTransition }\n});", 
            "title": "Per instance, via the instance's transitions initialization property."
        }, 
        {
            "location": "/extend/transitions/#using", 
            "text": "Transitions are added to an element via a transition directive. The directive starts with the transition name followed by one or more suffixes. The transition may be intro-only (upon rendering) using the suffix  -in , outro-only (upon removal) using the suffix  -out , or both using the suffix  -in-out .  div myTransition-in Intro-only /div  div myTransition-out Outro-only /div  div myTransition-in-out Intro and outro /div   To pass arguments to the transition, simply provide an expression as the directive's value. This will be passed as the second argument of the transition function.  div myTransition-in= { /*params */ } Intro-only /div  div myTransition-out= { /*params */ } Outro-only /div  div myTransition-in-out= { /*params */ } Intro and outro /div", 
            "title": "Using"
        }, 
        {
            "location": "/extend/transitions/#examples", 
            "text": "The following example demonstrates a \"flash\" transition which colors the element green upon attachment, and red prior to removal.  Ractive.transitions.flash = function(t, params) {\n  // Process params and declaring defaults.\n  const options = t.processParams(params, {\n    color: t.isIntro ? '#0f0' : '#f00',\n    duration: 400\n  });\n\n  // The  transition \n  t.setStyle('color', options.color);\n\n  // Signal Ractive that the transition is complete.\n  setTimeout(t.complete, options.duration);\n};\n\nnew Ractive({\n  el: 'body',\n  template: `\n     button on-click='@this.insert()' Insert item /button \n     button on-click='@this.remove()' Remove item /button \n     ul \n      {{#items}}\n       li flash-in-out {{this}} /li \n      {{/items}}\n     /ul \n  `,\n  data: {\n    items: []\n  },\n  insert() {\n    this.push('items', Date.now());\n  },\n  remove() {\n    this.splice('items', 0, 1);\n  }\n});", 
            "title": "Examples"
        }, 
        {
            "location": "/integrations/loaders/", 
            "text": "Loaders\n\n\nBy itself, neither Ractive nor your tools know what to do with a \ncomponent file\n. You will need a \nloader\n to transform a component file into a representation that the target tool or environment can understand.\n\n\nAvailable loaders\n\n\nVanilla\n\n\n\n\nractive-load\n - Uses \nXHR\n to load your component files and creates component constructors at runtime.\n\n\n\n\nRequireJS\n\n\n\n\nrvc\n - Converts component files into \nAMD modules\n. Works with plain and \noptimized\n AMD modules.\n\n\n\n\nBrowserify\n\n\n\n\nractify\n - Converts component files into \nCJS modules\n.\n\n\nractiveify\n - Similar to ractify, but supports JS/CSS compilation.\n\n\nractive-componentify\n - Similar to ractiveify, but supports \nsource maps\n and partial imports.\n\n\n\n\nBroccoli\n\n\n\n\nbroccoli-ractive\n - Converts your component files into either AMD, CJS, or ES modules.\n\n\n\n\nWebpack\n\n\n\n\nractive-component-loader\n - Allows you to load component files as constructors via Webpack.\n\n\n\n\nLooking to write your own loader?\n\n\nHead over to the \ncomponent file specifications\n repo for a full rundown about the parts of a component file as well as loader behaviors and responsibilities.\n\n\nRactive also has a couple of handy modules to aid you in loader development:\n\n\n\n\nrcu\n - An importable/embeddable library that provides utility APIs to help your loader parse the different portions of the component file.\n\n\nrcu-builders\n - A module that provides utility APIs to help your loader convert parsed component files into other module formats like ES, AMD and CJS.", 
            "title": "Loaders"
        }, 
        {
            "location": "/integrations/loaders/#loaders", 
            "text": "By itself, neither Ractive nor your tools know what to do with a  component file . You will need a  loader  to transform a component file into a representation that the target tool or environment can understand.", 
            "title": "Loaders"
        }, 
        {
            "location": "/integrations/loaders/#available-loaders", 
            "text": "", 
            "title": "Available loaders"
        }, 
        {
            "location": "/integrations/loaders/#vanilla", 
            "text": "ractive-load  - Uses  XHR  to load your component files and creates component constructors at runtime.", 
            "title": "Vanilla"
        }, 
        {
            "location": "/integrations/loaders/#requirejs", 
            "text": "rvc  - Converts component files into  AMD modules . Works with plain and  optimized  AMD modules.", 
            "title": "RequireJS"
        }, 
        {
            "location": "/integrations/loaders/#browserify", 
            "text": "ractify  - Converts component files into  CJS modules .  ractiveify  - Similar to ractify, but supports JS/CSS compilation.  ractive-componentify  - Similar to ractiveify, but supports  source maps  and partial imports.", 
            "title": "Browserify"
        }, 
        {
            "location": "/integrations/loaders/#broccoli", 
            "text": "broccoli-ractive  - Converts your component files into either AMD, CJS, or ES modules.", 
            "title": "Broccoli"
        }, 
        {
            "location": "/integrations/loaders/#webpack", 
            "text": "ractive-component-loader  - Allows you to load component files as constructors via Webpack.", 
            "title": "Webpack"
        }, 
        {
            "location": "/integrations/loaders/#looking-to-write-your-own-loader", 
            "text": "Head over to the  component file specifications  repo for a full rundown about the parts of a component file as well as loader behaviors and responsibilities.  Ractive also has a couple of handy modules to aid you in loader development:   rcu  - An importable/embeddable library that provides utility APIs to help your loader parse the different portions of the component file.  rcu-builders  - A module that provides utility APIs to help your loader convert parsed component files into other module formats like ES, AMD and CJS.", 
            "title": "Looking to write your own loader?"
        }, 
        {
            "location": "/integrations/plugins/", 
            "text": "Plugins\n\n\nIt may not be apparent but Ractive is actually built with extreme extensibility in mind. Plugins allow you to augment Ractive with extra functionality. Whether you're a JavaScript developer, an interface designer or just trying to get away from your framework overlords, Ractive can accomodate one and all.\n\n\nAvailable plugins\n\n\nAdaptors\n\n\nInterface with different backends.\n\n\n\n\nBackbone\n\n\nBacon.js\n\n\nModella\n by \n@staygrimm\n\n\nPromises\n by \n@lluchs\n\n\nPromise-alt\n by \n@rstacruz\n\n\nRxJS\n\n\nRactive\n by \n@rstacruz\n - Synchronise several Ractive instances.\n\n\nss-ractive\n by Robert Hall \n@arxpoetica\n - Ractive Template Engine wrapper for \nSocketStream\n.\n\n\n\n\nComponents\n\n\nEncapsulate functionality behind the guise of a custom element.\n\n\n\n\nRactive-Require\n\n\nCodeMirror\n\n\nBootstrap\n\n\nDatatable\n\n\nSelect\n - A \nselect\n replacement component.\n\n\nStepper\n - A numeric stepper component.\n\n\nSplit\n\n\n\n\nDecorators\n\n\nAugment the DOM with more functionality.\n\n\n\n\nChosen\n by \n@rahulcs\n (\n@kalcifer\n)\n\n\nminmaxwidth\n by \n@cfenzo\n\n\nSelect2\n by \n@sandermarechal\n (\n@Prezent\n)\n\n\nSortable\n\n\nTooltip\n\n\n\n\nEasings\n\n\nCustom animation progressions.\n\n\nEvents\n\n\nAugment the DOM with custom events beyond those supported by the browser.\n\n\n\n\nDrag and Drop (HTML5)\n by \n@Nijikokun\n\n\nDrag and Drop (non-HTML5)\n by \n@smallhadroncollider\n\n\nDrag and Drop Sortable List\n by \n@Nijikokun\n\n\nResize\n by \n@smallhadroncollider\n\n\nHover\n\n\nKeys\n\n\nMousewheel\n\n\nTap\n\n\nTouch\n by \n@rstacruz\n\n\nTyping\n by \n@svapreddy\n\n\nViewport\n by \n@svapreddy\n\n\n\n\nPartials\n\n\nReusable pieces of markup.\n\n\nTransitions\n\n\nApply custom animation.\n\n\n\n\nFade\n\n\nFly\n\n\nScale\n by \n@1N50MN14\n\n\nSlide\n\n\nTypewriter\n\n\n\n\nAnd so much more!\n\n\nDue to the nature of how easy it is to write and distribute plugins as well as how diverse the distribution channels are, we cannot possibly know what other Ractive plugins exist in the wild.\n\n\nTo discover more, try searching your favorite package manager, search engine, or code hosting service for the keyword \"ractive\". I guarantee you'll be surprised.\n\n\nNote: Like any other open-source project, these plugins may not have been maintained for a while. Should bugs arise, we highly encourage reporting the issue to relevant parties so that it can be addressed.", 
            "title": "Plugins"
        }, 
        {
            "location": "/integrations/plugins/#plugins", 
            "text": "It may not be apparent but Ractive is actually built with extreme extensibility in mind. Plugins allow you to augment Ractive with extra functionality. Whether you're a JavaScript developer, an interface designer or just trying to get away from your framework overlords, Ractive can accomodate one and all.", 
            "title": "Plugins"
        }, 
        {
            "location": "/integrations/plugins/#available-plugins", 
            "text": "", 
            "title": "Available plugins"
        }, 
        {
            "location": "/integrations/plugins/#adaptors", 
            "text": "Interface with different backends.   Backbone  Bacon.js  Modella  by  @staygrimm  Promises  by  @lluchs  Promise-alt  by  @rstacruz  RxJS  Ractive  by  @rstacruz  - Synchronise several Ractive instances.  ss-ractive  by Robert Hall  @arxpoetica  - Ractive Template Engine wrapper for  SocketStream .", 
            "title": "Adaptors"
        }, 
        {
            "location": "/integrations/plugins/#components", 
            "text": "Encapsulate functionality behind the guise of a custom element.   Ractive-Require  CodeMirror  Bootstrap  Datatable  Select  - A  select  replacement component.  Stepper  - A numeric stepper component.  Split", 
            "title": "Components"
        }, 
        {
            "location": "/integrations/plugins/#decorators", 
            "text": "Augment the DOM with more functionality.   Chosen  by  @rahulcs  ( @kalcifer )  minmaxwidth  by  @cfenzo  Select2  by  @sandermarechal  ( @Prezent )  Sortable  Tooltip", 
            "title": "Decorators"
        }, 
        {
            "location": "/integrations/plugins/#easings", 
            "text": "Custom animation progressions.", 
            "title": "Easings"
        }, 
        {
            "location": "/integrations/plugins/#events", 
            "text": "Augment the DOM with custom events beyond those supported by the browser.   Drag and Drop (HTML5)  by  @Nijikokun  Drag and Drop (non-HTML5)  by  @smallhadroncollider  Drag and Drop Sortable List  by  @Nijikokun  Resize  by  @smallhadroncollider  Hover  Keys  Mousewheel  Tap  Touch  by  @rstacruz  Typing  by  @svapreddy  Viewport  by  @svapreddy", 
            "title": "Events"
        }, 
        {
            "location": "/integrations/plugins/#partials", 
            "text": "Reusable pieces of markup.", 
            "title": "Partials"
        }, 
        {
            "location": "/integrations/plugins/#transitions", 
            "text": "Apply custom animation.   Fade  Fly  Scale  by  @1N50MN14  Slide  Typewriter", 
            "title": "Transitions"
        }, 
        {
            "location": "/integrations/plugins/#and-so-much-more", 
            "text": "Due to the nature of how easy it is to write and distribute plugins as well as how diverse the distribution channels are, we cannot possibly know what other Ractive plugins exist in the wild.  To discover more, try searching your favorite package manager, search engine, or code hosting service for the keyword \"ractive\". I guarantee you'll be surprised.  Note: Like any other open-source project, these plugins may not have been maintained for a while. Should bugs arise, we highly encourage reporting the issue to relevant parties so that it can be addressed.", 
            "title": "And so much more!"
        }, 
        {
            "location": "/integrations/tools/", 
            "text": "Tools\n\n\nBrowserify\n\n\nBrowserify\n is a way of using \nnode-style\n requires in the browser, bundling your scripts into a single file for efficient deployment.\n\n\nThere are three Browserify transforms available that you can use for Ractive.js:\n\n\n\n\nRactivate\n, a transform that will pre-parse templates. Contributed by \njrajav\n. \n(Github repository)\n\n\nRactify\n, a transform that will pre-compile components. Contributed by \nmarcello3d\n. \n(Github repository)\n\n\nRactiveify\n, a transform that will pre-compile components with support for compiling embedded scripts and style tags (with Livescript, CoffeeScript, Sass, etc). Inspired by ractify. Contributed by \nnorcalli\n. \n(Github repository)\n\n\n\n\nA \nstarter project\n is available for using Ractivate with \ngulp.js\n build system.\n\n\nUsing plugins with Ractive and Browserify\n\n\nPlugins\n typically include a Universal Module Definition (UMD) block that, in a node.js or Browserify environment, calls \nrequire('ractive')\n. If you want to be explicit about \nwhich\n version of Ractive gets loaded, you can do it when you configure browserify like so:\n\n\nbrowserify.require('./my-copy-of-ractive.js', { expose: 'ractive' });\n\n\n\n\nRequireJS\n\n\nPsst! Looking for the \nRactive + RequireJS sample application\n?\n\n\nIf Ractive detects that you're using an \nAMD\n module loader (in other words, if \ntypeof define !== 'undefined' \n define.amd\n) such as \nRequireJS\n, it will register itself as an AMD module rather than as a browser global.\n\n\nYou'd then use Ractive the same as you'd use any other module, such as in this (contrived, oversimple) example:\n\n\n// define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'jquery', 'Ractive' ], function ( $, Ractive ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // load our template with jQuery AJAX\n      $.ajax( 'templates/main.html' ).then( function ( mainTemplate ) {\n\n        // render our main view\n        this.mainView = new Ractive({\n          el: 'container',\n          template: mainTemplate\n        });\n      });\n    }\n  };\n\n  return app;\n\n});\n\n\n\n\nLoading templates without AJAX\n\n\nWe can do one better than that. Rather than stuffing our code full of asynchronous logic, we can use AMD to do the donkey work for us.\n\n\nInclude the \nRequireJS text loader plugin\n in the root of your project (or whatever you've specified as the RequireJS \nbaseUrl\n) - you can now do this (note we no longer require jQuery):\n\n\n// define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'text!templates/main.html' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});\n\n\n\n\nBut we can do even better. If you use the \nRactive RequireJS loader plugin\n, it will pre-parse the template for us. We'll see in a moment why that's useful.\n\n\nPut the plugin in the same folder as the text loader plugin (which the Ractive plugin depends on). Note that we can omit the \n'.html'\n file extension:\n\n\n// define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'rv!templates/main' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});\n\n\n\n\nUsing the RequireJS optimiser\n\n\nYou might wonder why the third example is better than the second - after all, we've basically just added another middleman, right?\n\n\nThe answer is that you can now use the \nRequireJS optimiser\n to parse your template as part of your build process. The optimiser converts your project into a single minified file, which in most cases makes your app much quicker to load for the end user (because the browser only needs to make one HTTP request, and the total file size is reduced).\n\n\nBy pre-parsing templates, we save browsers having to do it, which shaves a few milliseconds off at render time.\n\n\nSo you get the best of both worlds - your templates stay neatly organised in their own files, where you can easily edit them, and the user gets the best possible experience.\n\n\nIf you're \nreally\n anal about performance, you can tweak things further still. We don't need the loader plugins any more (because everything has been inlined), but they're still there in our optimised file. We can instruct the optimiser to 'stub them out', saving ourselves a few precious bytes. In your optimiser config, add the following option:\n\n\n({\n    stubModules: [ 'rv', 'text' ]\n})\n\n\n\n\n(This assumes you're using a \nbuild.js\n file, or a build system like Grunt. If you're using the optimiser on the command line it will be different - consult the \ndocumentation\n for more info.)\n\n\nGetting to grips with AMD and RequireJS can be tricky at first, but it's worth the effort. Good luck!\n\n\nYeoman\n\n\nYeoman\n is a tool for scaffolding webapps. \nJorge Colindres\n has created \ngenerator-ractive\n, a Yeoman generator to quickly set up a Ractive application.\n\n\nRollup\n\n\nTODO\n\n\nBabel\n\n\nTODO", 
            "title": "Tools"
        }, 
        {
            "location": "/integrations/tools/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/integrations/tools/#browserify", 
            "text": "Browserify  is a way of using  node-style  requires in the browser, bundling your scripts into a single file for efficient deployment.  There are three Browserify transforms available that you can use for Ractive.js:   Ractivate , a transform that will pre-parse templates. Contributed by  jrajav .  (Github repository)  Ractify , a transform that will pre-compile components. Contributed by  marcello3d .  (Github repository)  Ractiveify , a transform that will pre-compile components with support for compiling embedded scripts and style tags (with Livescript, CoffeeScript, Sass, etc). Inspired by ractify. Contributed by  norcalli .  (Github repository)   A  starter project  is available for using Ractivate with  gulp.js  build system.", 
            "title": "Browserify"
        }, 
        {
            "location": "/integrations/tools/#using-plugins-with-ractive-and-browserify", 
            "text": "Plugins  typically include a Universal Module Definition (UMD) block that, in a node.js or Browserify environment, calls  require('ractive') . If you want to be explicit about  which  version of Ractive gets loaded, you can do it when you configure browserify like so:  browserify.require('./my-copy-of-ractive.js', { expose: 'ractive' });", 
            "title": "Using plugins with Ractive and Browserify"
        }, 
        {
            "location": "/integrations/tools/#requirejs", 
            "text": "Psst! Looking for the  Ractive + RequireJS sample application ?  If Ractive detects that you're using an  AMD  module loader (in other words, if  typeof define !== 'undefined'   define.amd ) such as  RequireJS , it will register itself as an AMD module rather than as a browser global.  You'd then use Ractive the same as you'd use any other module, such as in this (contrived, oversimple) example:  // define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'jquery', 'Ractive' ], function ( $, Ractive ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // load our template with jQuery AJAX\n      $.ajax( 'templates/main.html' ).then( function ( mainTemplate ) {\n\n        // render our main view\n        this.mainView = new Ractive({\n          el: 'container',\n          template: mainTemplate\n        });\n      });\n    }\n  };\n\n  return app;\n\n});", 
            "title": "RequireJS"
        }, 
        {
            "location": "/integrations/tools/#loading-templates-without-ajax", 
            "text": "We can do one better than that. Rather than stuffing our code full of asynchronous logic, we can use AMD to do the donkey work for us.  Include the  RequireJS text loader plugin  in the root of your project (or whatever you've specified as the RequireJS  baseUrl ) - you can now do this (note we no longer require jQuery):  // define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'text!templates/main.html' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});  But we can do even better. If you use the  Ractive RequireJS loader plugin , it will pre-parse the template for us. We'll see in a moment why that's useful.  Put the plugin in the same folder as the text loader plugin (which the Ractive plugin depends on). Note that we can omit the  '.html'  file extension:  // define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'rv!templates/main' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});", 
            "title": "Loading templates without AJAX"
        }, 
        {
            "location": "/integrations/tools/#using-the-requirejs-optimiser", 
            "text": "You might wonder why the third example is better than the second - after all, we've basically just added another middleman, right?  The answer is that you can now use the  RequireJS optimiser  to parse your template as part of your build process. The optimiser converts your project into a single minified file, which in most cases makes your app much quicker to load for the end user (because the browser only needs to make one HTTP request, and the total file size is reduced).  By pre-parsing templates, we save browsers having to do it, which shaves a few milliseconds off at render time.  So you get the best of both worlds - your templates stay neatly organised in their own files, where you can easily edit them, and the user gets the best possible experience.  If you're  really  anal about performance, you can tweak things further still. We don't need the loader plugins any more (because everything has been inlined), but they're still there in our optimised file. We can instruct the optimiser to 'stub them out', saving ourselves a few precious bytes. In your optimiser config, add the following option:  ({\n    stubModules: [ 'rv', 'text' ]\n})  (This assumes you're using a  build.js  file, or a build system like Grunt. If you're using the optimiser on the command line it will be different - consult the  documentation  for more info.)  Getting to grips with AMD and RequireJS can be tricky at first, but it's worth the effort. Good luck!", 
            "title": "Using the RequireJS optimiser"
        }, 
        {
            "location": "/integrations/tools/#yeoman", 
            "text": "Yeoman  is a tool for scaffolding webapps.  Jorge Colindres  has created  generator-ractive , a Yeoman generator to quickly set up a Ractive application.", 
            "title": "Yeoman"
        }, 
        {
            "location": "/integrations/tools/#rollup", 
            "text": "TODO", 
            "title": "Rollup"
        }, 
        {
            "location": "/integrations/tools/#babel", 
            "text": "TODO", 
            "title": "Babel"
        }, 
        {
            "location": "/integrations/libraries/", 
            "text": "Libraries\n\n\nWe heard that you love your framework so much, we put Ractive in your framework!\n\n\njQuery Mobile\n\n\nSergio Castillo\n has made a jQuery mobile plugin, which you can \nsee in action on this JSFiddle\n.", 
            "title": "Libraries"
        }, 
        {
            "location": "/integrations/libraries/#libraries", 
            "text": "We heard that you love your framework so much, we put Ractive in your framework!", 
            "title": "Libraries"
        }, 
        {
            "location": "/integrations/libraries/#jquery-mobile", 
            "text": "Sergio Castillo  has made a jQuery mobile plugin, which you can  see in action on this JSFiddle .", 
            "title": "jQuery Mobile"
        }, 
        {
            "location": "/concepts/architecture/overview/", 
            "text": "Ractive General Overview\n\n\nThere are three major sections in the Ractive source to handle each of data, the DOM and virtual DOM, and parsing template strings to Ractive's template AST. Each of those sections mostly lives in its own folder in the \nsrc\n tree: \nmodel\n, \nview\n, and \nparse\n, respectively. This document aims to give a general overview of what each section does so that you can hopefully find what you need to fix a bug, add a feature, or just understand how something works internally.\n\n\nData and Models\n\n\nRactive wraps any data given to it into a tree-like hierarchy of \nModel\n. Any data that is rendered into a template will be bound to a \nModel\n. Access to read and write data in Ractive is handled through the model hierarchy based on keypaths, which are, generally, a list of object properties that one would need to follow to reach a leaf of the data tree starting from the root. Each key along the keypath has its own corresponding model.\n\n\nModels allow entities that depend upon them to register themeselves to receive change notifications when the model value changes. This is how Ractive keeps track of exactly which parts of the view need to be updated when values change.\n\n\nRead more about models in the \nmodel overview\n.\n\n\nVirtual DOM\n\n\nEvery piece of DOM that Ractive can manage has a corresponding class in the virtual DOM to handle the DOM node, which generally end up being either Elements or Text Nodes. View items are grouped together as Fragments of view, which may then be owned by other fragments or items. At the root of every ractive instance is a Fragment instance that contains its entire virtual DOM tree. Each Ractive template construct has at least one analog in the virtual DOM. The bulk of Ractive's view functionality is implemented in the Section, Interpolator, and Element items, with there being a number of specialized element classes to handle special types of HTML element.\n\n\nAll virtual DOM items go through roughly the same lifecycle: creation, binding, rendering, bubbling, updating, unrendering, and unbinding. Creation is basically just the constructor call and almost always is immediately followed by binding. Binding is the point at which the item resolves and registers with its data references. Rendering is the point at which the item inserts an actual DOM node into the DOM. Bubbling and updating are the two halves of the update process, which is discussed in the next section. Unrendering is the point at which the item should no longer be present in the DOM, and it often occurs at the same point as unbinding, which is the point at which the item unregisters with the viewmodel and is effectively destroyed.\n\n\nThere a number of other members, such as events and decorators, and processes, such as change propagation, which are described in detail in the \nview overview\n.\n\n\nParsing\n\n\nRactive's parser is responsible for taking the (mostly :wink:) human-friendly mustachioed HTML of templates and turning it into an AST that can be turned into vDOM at runtime. Ractive's parser is somewhat unique among its peers in that it handles reading not only the mustache templates, but a fair amount of ES5 and ES6 syntax for expressions.\n\n\nEach item expressable in Ractive-flavored mustache has its own parsing function that may also be comprised of other parsing functions. Each bit of ES syntax that Ractive understands for expressions also has its own parsing function. The parser starts at the beginning of the template string and starts applying each parsing function in precedence order. Each function will then consume as much of the template as needed to return an item, like an element, a section, a partial, a bit of text, or an interpolator. It may also return nothing. Most items can also contain children, including items of the same type as themselves, and will thus recurse by trying to parse their content.\n\n\nThere is more information about Ractive's parsing in the \nparser overview\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/concepts/architecture/overview/#ractive-general-overview", 
            "text": "There are three major sections in the Ractive source to handle each of data, the DOM and virtual DOM, and parsing template strings to Ractive's template AST. Each of those sections mostly lives in its own folder in the  src  tree:  model ,  view , and  parse , respectively. This document aims to give a general overview of what each section does so that you can hopefully find what you need to fix a bug, add a feature, or just understand how something works internally.", 
            "title": "Ractive General Overview"
        }, 
        {
            "location": "/concepts/architecture/overview/#data-and-models", 
            "text": "Ractive wraps any data given to it into a tree-like hierarchy of  Model . Any data that is rendered into a template will be bound to a  Model . Access to read and write data in Ractive is handled through the model hierarchy based on keypaths, which are, generally, a list of object properties that one would need to follow to reach a leaf of the data tree starting from the root. Each key along the keypath has its own corresponding model.  Models allow entities that depend upon them to register themeselves to receive change notifications when the model value changes. This is how Ractive keeps track of exactly which parts of the view need to be updated when values change.  Read more about models in the  model overview .", 
            "title": "Data and Models"
        }, 
        {
            "location": "/concepts/architecture/overview/#virtual-dom", 
            "text": "Every piece of DOM that Ractive can manage has a corresponding class in the virtual DOM to handle the DOM node, which generally end up being either Elements or Text Nodes. View items are grouped together as Fragments of view, which may then be owned by other fragments or items. At the root of every ractive instance is a Fragment instance that contains its entire virtual DOM tree. Each Ractive template construct has at least one analog in the virtual DOM. The bulk of Ractive's view functionality is implemented in the Section, Interpolator, and Element items, with there being a number of specialized element classes to handle special types of HTML element.  All virtual DOM items go through roughly the same lifecycle: creation, binding, rendering, bubbling, updating, unrendering, and unbinding. Creation is basically just the constructor call and almost always is immediately followed by binding. Binding is the point at which the item resolves and registers with its data references. Rendering is the point at which the item inserts an actual DOM node into the DOM. Bubbling and updating are the two halves of the update process, which is discussed in the next section. Unrendering is the point at which the item should no longer be present in the DOM, and it often occurs at the same point as unbinding, which is the point at which the item unregisters with the viewmodel and is effectively destroyed.  There a number of other members, such as events and decorators, and processes, such as change propagation, which are described in detail in the  view overview .", 
            "title": "Virtual DOM"
        }, 
        {
            "location": "/concepts/architecture/overview/#parsing", 
            "text": "Ractive's parser is responsible for taking the (mostly :wink:) human-friendly mustachioed HTML of templates and turning it into an AST that can be turned into vDOM at runtime. Ractive's parser is somewhat unique among its peers in that it handles reading not only the mustache templates, but a fair amount of ES5 and ES6 syntax for expressions.  Each item expressable in Ractive-flavored mustache has its own parsing function that may also be comprised of other parsing functions. Each bit of ES syntax that Ractive understands for expressions also has its own parsing function. The parser starts at the beginning of the template string and starts applying each parsing function in precedence order. Each function will then consume as much of the template as needed to return an item, like an element, a section, a partial, a bit of text, or an interpolator. It may also return nothing. Most items can also contain children, including items of the same type as themselves, and will thus recurse by trying to parse their content.  There is more information about Ractive's parsing in the  parser overview .", 
            "title": "Parsing"
        }, 
        {
            "location": "/concepts/architecture/parser/", 
            "text": "Ractive uses a recursive descent parser that is comprised of a number readers and converters that are responsible for parsing individual bits of the template AST. The root-level parsers are text, mustache, and element.\n\n\nMustaches\n\n\nEach type of mustache has its own reader that calls the appropriate expression or reference readers internally. For instance, the partial reader reads the current open mustache delimiter (defaults to \n{{\n) followed by a \n. It then expects to find a relaxed reference, meaning it may contain dashes and slashes among other usually-forbidden characters. It may then optionally read a context expression or series of alias definitions\n\n\nExpressions\n\n\nThe expression readers are set arranged such that they can read valid ES expressions with the correct operator precedence by starting with ternary conditionals and trying different expression types from there. Once the expression tree has been parsed, it is flattened into an expression string and a list of references that are used within that string. If the parsing is done with \ncsp\n (Content Security Policy) support enabled, then the expression strings are also turned into functions and attached to the output template structure so that the template can be used as-is from a script tag without \neval\ning.\n\n\nCleanup\n\n\nAfter all of the nodes have been parsed from the template, the template is cleaned up in a process that, among other things, merges adjacent text nodes and forms individual conditional sections out of \nelseif\n/\nelse\n trees.", 
            "title": "Parser"
        }, 
        {
            "location": "/concepts/architecture/parser/#mustaches", 
            "text": "Each type of mustache has its own reader that calls the appropriate expression or reference readers internally. For instance, the partial reader reads the current open mustache delimiter (defaults to  {{ ) followed by a  . It then expects to find a relaxed reference, meaning it may contain dashes and slashes among other usually-forbidden characters. It may then optionally read a context expression or series of alias definitions", 
            "title": "Mustaches"
        }, 
        {
            "location": "/concepts/architecture/parser/#expressions", 
            "text": "The expression readers are set arranged such that they can read valid ES expressions with the correct operator precedence by starting with ternary conditionals and trying different expression types from there. Once the expression tree has been parsed, it is flattened into an expression string and a list of references that are used within that string. If the parsing is done with  csp  (Content Security Policy) support enabled, then the expression strings are also turned into functions and attached to the output template structure so that the template can be used as-is from a script tag without  eval ing.", 
            "title": "Expressions"
        }, 
        {
            "location": "/concepts/architecture/parser/#cleanup", 
            "text": "After all of the nodes have been parsed from the template, the template is cleaned up in a process that, among other things, merges adjacent text nodes and forms individual conditional sections out of  elseif / else  trees.", 
            "title": "Cleanup"
        }, 
        {
            "location": "/concepts/architecture/model/", 
            "text": "All of the data managed by Ractive is represented by its model hierarchy.\n\n\nModel\n\n\nAlmost every type of Model is a subclass of \nModel\n, so it seems a good place to start. Each model typically has a parent model, a key that is used to access its value from its parent, and a value. Most models also have children of some sort, which are tracked by key such that \n{ foo: { bar: 'baz' } }\n would have a model with a \nchildByKey['foo']\n, which would also have a model at \nchildByKey['bar']\n. The value of each of the models listed there would be the object containing \nfoo: { bar:\nbaz\n}\n, its \nfoo\n child would be the object \nbar: 'baz'\n, and its \nbar\n child would be the string \n'baz'\n. Where children of a model are other models, dependents (\ndeps\n) of a model may be anything that wants to be notified of changes, and each model will typically have a number of dependents, too.\n\n\nEach model has a unique keypath that is assembled by taking its key and each of its parents keys up to the root and joining them with a \n.\n.\n\n\nModels are also inherently lazy, meaning their value is not necessarily available when the are created. A value is retrieved from a model using its \nget\n method which may have the side effect of computing the value. Once a value has been computed, it is generally cached until a change happens that would cause the cache to be invalidated. In most models, there isn't really an opportunity for that change outside of normal change propagation.\n\n\nChange propagation\n\n\nWhen a change is supplied to a model, its \nset\n method is called, which usually delegates to \napplyValue\n. \napplyValue\n checks to see that the value has actually changed in some way (hint: setting to the same object or array is considered a change because something may have changed further in), and if it has, it will start change notification for all of the model's children and dependents. If the model has resolvers registered with it trying to get an unresolved value, then this is where the unresolved value will be resolved and the resolver satisfied and cleared. Next, any children will be notified that their parent has had a value change and that they may need to update accordingly, which may trigger further cascades of resolution and change notification. Next, any dependents of the model will be notified that the model has had a value change as their \nhandleChange\n methods are called. Finally, upstream models (parents) are notified that a change has taken place somewhere among its children.\n\n\nThe child notification of the propagation is handled by the model's \nmark\n method. \nmark\n also checks to see that the value has actually changed, and if it has, will notify its children and dependents that it has had a value change. This is also the method called when the user signals that they have changed some data externally by calling \nractive.update()\n.\n\n\nShuffling\n\n\nThere is a special form of change wherein an array is modified without being swapped out, which is triggered by array methods like \nsplice\n, \npush\n, and \npop\n. When an array modification happens, change propagation takes a special path through the model that allows more precise DOM manipulation rather than throwing all of the DOM out and replacing it with a new result. This is achieved by having the special array method handlers compute which indexes are actually changed and having the array model's deps that can actally handle a shuffle ignore any untouched indices.\n\n\nThe instance method \nmerge\n does something similar, but instead of modifying the underlying array, it compares the members of the new supplied array against the model array to compute the index changes. It the swaps in the new array and triggers a shuffle based on the computed index changes.\n\n\nAdaptation\n\n\nBetween the change check and the change propagation during \napplyValue\n, there is a step that handles part of adaptation so that external objects with special behaviors, like backbone models, can be used as data sources. An adaptors takes the special object, wraps it up, and returns the wrapper that also has a value that represents the object for consumption by Ractive. Most adaptors also have methods to update values in their source data as well, and those methods are called when an update is applied to an adapted model.\n\n\nRootModel\n\n\nEvery tree needs a root, and \nRootModel\n serves that purpose here. Each Ractive instance gets its own \nRootModel\n that is stored at its \nviewmodel\n property. This special model is also the storage point for computations and mappings.\n\n\nComputations\n\n\nA computation is exactly what is sounds like: a getter and optional setter function that are used to provide read and optional write access to some non-fixed piece of data. Each computation is stored in the root model \ncomputations\n hash by its keypath. Computations can be created in two places:\n\n\n\n\nExplicitly when a \ncomputed\n map is passed to a Ractive instantiation or when an entry is later added to a instance's computed map. These may be read/write and have a keypath that mirrors their name.\n\n\nImplicitly when an expression is used in a template. These are read-only and have a keypath that is an expanded representation of their expression.\n\n\n\n\nA computation is also a form of model, so anything that depends on it will subscribe to it as if it were a regular model. Change propagation happens in the same way as a regular model as well.\n\n\nSince computations may depend on other bits of data controlled by Ractive, while they are being retrieved, any references to other models will cause the extra references to be \ncapture\nd. When the computation is complete, the computation will register with each of its captured dependencies so that it will be notified when it needs to invalidate and notify its dependents of the change.\n\n\nMappings\n\n\nWhen a Ractive instance has children, typically components, it may supply a handles to its own data to them in the form of mappings. The child instance stores a reference to the parent model at its mapped name and uses it when its dependents request access to keypaths that start with the mapped name. This allows child instances, which may be isolated, to stay in sync with portions of their parents data easily, because the parent still controls the data (single source of truth) and there is no syncing involved. So if a parent has a component \nComponent foo=\"{{bar.baz.bat.bippy}}\" /\n, then the component instance will get a mapping \nfoo\n that references the parent model at \nbar.baz.bat.bippy\n.\n\n\nOther models\n\n\nThere are a few other types of \nModel\n in the code, such as the \nRactiveModel\n, which represents a Ractive instance, and the \nGlobalModel\n, which represents the global object of the current environment a.k.a. \nwindow\n for browsers and \nglobal\n for Node.js.\n\n\nKeyModel\n\n\nThe last major model remaining is the \nKeyModel\n. Instances of this represent indices of arrays and keys of objects during iteration. The key flavor never is immutable, becuase the keys of  objects never change (they may be removed, but that doesn't change the key itself). The index flavor \ndoes\n change, but only when the array represented by its parent model is shuffled.", 
            "title": "Model"
        }, 
        {
            "location": "/concepts/architecture/model/#model", 
            "text": "Almost every type of Model is a subclass of  Model , so it seems a good place to start. Each model typically has a parent model, a key that is used to access its value from its parent, and a value. Most models also have children of some sort, which are tracked by key such that  { foo: { bar: 'baz' } }  would have a model with a  childByKey['foo'] , which would also have a model at  childByKey['bar'] . The value of each of the models listed there would be the object containing  foo: { bar: baz } , its  foo  child would be the object  bar: 'baz' , and its  bar  child would be the string  'baz' . Where children of a model are other models, dependents ( deps ) of a model may be anything that wants to be notified of changes, and each model will typically have a number of dependents, too.  Each model has a unique keypath that is assembled by taking its key and each of its parents keys up to the root and joining them with a  . .  Models are also inherently lazy, meaning their value is not necessarily available when the are created. A value is retrieved from a model using its  get  method which may have the side effect of computing the value. Once a value has been computed, it is generally cached until a change happens that would cause the cache to be invalidated. In most models, there isn't really an opportunity for that change outside of normal change propagation.", 
            "title": "Model"
        }, 
        {
            "location": "/concepts/architecture/model/#change-propagation", 
            "text": "When a change is supplied to a model, its  set  method is called, which usually delegates to  applyValue .  applyValue  checks to see that the value has actually changed in some way (hint: setting to the same object or array is considered a change because something may have changed further in), and if it has, it will start change notification for all of the model's children and dependents. If the model has resolvers registered with it trying to get an unresolved value, then this is where the unresolved value will be resolved and the resolver satisfied and cleared. Next, any children will be notified that their parent has had a value change and that they may need to update accordingly, which may trigger further cascades of resolution and change notification. Next, any dependents of the model will be notified that the model has had a value change as their  handleChange  methods are called. Finally, upstream models (parents) are notified that a change has taken place somewhere among its children.  The child notification of the propagation is handled by the model's  mark  method.  mark  also checks to see that the value has actually changed, and if it has, will notify its children and dependents that it has had a value change. This is also the method called when the user signals that they have changed some data externally by calling  ractive.update() .", 
            "title": "Change propagation"
        }, 
        {
            "location": "/concepts/architecture/model/#shuffling", 
            "text": "There is a special form of change wherein an array is modified without being swapped out, which is triggered by array methods like  splice ,  push , and  pop . When an array modification happens, change propagation takes a special path through the model that allows more precise DOM manipulation rather than throwing all of the DOM out and replacing it with a new result. This is achieved by having the special array method handlers compute which indexes are actually changed and having the array model's deps that can actally handle a shuffle ignore any untouched indices.  The instance method  merge  does something similar, but instead of modifying the underlying array, it compares the members of the new supplied array against the model array to compute the index changes. It the swaps in the new array and triggers a shuffle based on the computed index changes.", 
            "title": "Shuffling"
        }, 
        {
            "location": "/concepts/architecture/model/#adaptation", 
            "text": "Between the change check and the change propagation during  applyValue , there is a step that handles part of adaptation so that external objects with special behaviors, like backbone models, can be used as data sources. An adaptors takes the special object, wraps it up, and returns the wrapper that also has a value that represents the object for consumption by Ractive. Most adaptors also have methods to update values in their source data as well, and those methods are called when an update is applied to an adapted model.", 
            "title": "Adaptation"
        }, 
        {
            "location": "/concepts/architecture/model/#rootmodel", 
            "text": "Every tree needs a root, and  RootModel  serves that purpose here. Each Ractive instance gets its own  RootModel  that is stored at its  viewmodel  property. This special model is also the storage point for computations and mappings.", 
            "title": "RootModel"
        }, 
        {
            "location": "/concepts/architecture/model/#computations", 
            "text": "A computation is exactly what is sounds like: a getter and optional setter function that are used to provide read and optional write access to some non-fixed piece of data. Each computation is stored in the root model  computations  hash by its keypath. Computations can be created in two places:   Explicitly when a  computed  map is passed to a Ractive instantiation or when an entry is later added to a instance's computed map. These may be read/write and have a keypath that mirrors their name.  Implicitly when an expression is used in a template. These are read-only and have a keypath that is an expanded representation of their expression.   A computation is also a form of model, so anything that depends on it will subscribe to it as if it were a regular model. Change propagation happens in the same way as a regular model as well.  Since computations may depend on other bits of data controlled by Ractive, while they are being retrieved, any references to other models will cause the extra references to be  capture d. When the computation is complete, the computation will register with each of its captured dependencies so that it will be notified when it needs to invalidate and notify its dependents of the change.", 
            "title": "Computations"
        }, 
        {
            "location": "/concepts/architecture/model/#mappings", 
            "text": "When a Ractive instance has children, typically components, it may supply a handles to its own data to them in the form of mappings. The child instance stores a reference to the parent model at its mapped name and uses it when its dependents request access to keypaths that start with the mapped name. This allows child instances, which may be isolated, to stay in sync with portions of their parents data easily, because the parent still controls the data (single source of truth) and there is no syncing involved. So if a parent has a component  Component foo=\"{{bar.baz.bat.bippy}}\" / , then the component instance will get a mapping  foo  that references the parent model at  bar.baz.bat.bippy .", 
            "title": "Mappings"
        }, 
        {
            "location": "/concepts/architecture/model/#other-models", 
            "text": "There are a few other types of  Model  in the code, such as the  RactiveModel , which represents a Ractive instance, and the  GlobalModel , which represents the global object of the current environment a.k.a.  window  for browsers and  global  for Node.js.", 
            "title": "Other models"
        }, 
        {
            "location": "/concepts/architecture/model/#keymodel", 
            "text": "The last major model remaining is the  KeyModel . Instances of this represent indices of arrays and keys of objects during iteration. The key flavor never is immutable, becuase the keys of  objects never change (they may be removed, but that doesn't change the key itself). The index flavor  does  change, but only when the array represented by its parent model is shuffled.", 
            "title": "KeyModel"
        }, 
        {
            "location": "/concepts/architecture/view/", 
            "text": "Ractive views are structured virtual DOM trees that are assembled from template AST and manage DOM nodes on the page when they are rendered. Virtual DOM items are grouped together in \nFragment\ns, which contain them, and they may also own \nFragment\ns that contain other items. Each item may contain a reference to a DOM node when rendered, though every item doesn not have a DOM analog.\n\n\nStates\n\n\nItems generally follow a fixed lifecycle.\n\n\n\n\nConstruction - the item is created and knows about its parent and the template chunk from which it was created. Its template may also indicate what its children should look like if it has them.\n\n\nbind\n - the item looks up any references is may have and registers with the model(s) that they represent. At this point, the item may create child items and bind them as well.\n\n\nrender\n - the item may create an actual DOM node and tell its children to create their DOM nodes as necessary. The resulting nodes will be inserted into the document.\n\n\nunrender\n - thie item is no longer needed and will be removed from the document immediately or in the near future.\n\n\nunbind\n - this typically goes along with \nunrender\n and tells the models on which this item depends that they should no longer send change notifications to it.\n\n\n\n\nThere is a sixth floating step \nrebind\n that happens any time one dependency models shuffles (and in certain other very special circumstances) that causes the items to re-resolve their models and re-register if necessary.\n\n\nVirtual DOM Items\n\n\nText\n\n\nText is the simplest item. It simply holds a string that it turns into a \nTextNode\n when rendered.\n\n\nInterpolator\n\n\nThis is the next simplest item. It resolves a model for its reference or expression and renders the value of the model as a text node if needed. Interpolators don't necessarily render directly, as they may be used for values by other items, such as attributes, mappings, and bindings.\n\n\nElement\n\n\nAn \nElement\n represents a DOM element. It also contains a number of other items in the form of \nAttribute\ns, \nDecorator\ns, \nTransition\ns, \nEventDirective\ns, and its children in a \nFragment\n.\n\n\nAttributes\n\n\nThere are actually several different items that are treated as attributes for \nElement\ns, event though only two of them actually may render into the DOM.\n\n\n\n\nAttribute\ns - maybe obvious, they these represent a DOM attribute on their parent element. There are a number of different handlers for updating attributes depending on the element and attribute name. The \nupdateDelegate\n for a particular attribute can be found in \ngetUpdateDelegate.js\n.\n\n\nConditionalAttribute\ns - render as a string and are parsed into actual DOM attributes using a \ndiv\n or an \nsvg\n depending on their parent element.\n\n\nMapping\ns - when rendered add a mapping to their component, and when unrendered, remove it. These aren't attached to \nElement\ns, but instead, are attached to \nComponent\ns (see below).\n\n\nEventDirective\ns - when rendered attach an event listener to their parent, and when unrenedered, remove it. Event parameters are kept in sync with their bindings and are evaluated when the event fires.\n\n\nBindingDirective\ns - when rendered and unrendered update their parent element's bindings, if they exist.\n\n\nDecorator\ns - when rendered call the named decorator with their parent element, and when unrenedered, remove it. \nDecorator\ns also have an update cycle related to their parameters.\n\n\nTransition\ns - are a sort of weird case. When rendered, they attach a transition handler to their element, and when the element renders or unrenders, if an appropriate transition handler is registered, will trigger the transition. Transition parameters are also kept in sync with their bindings.\n\n\n\n\nBindings\n\n\nCertain attributes may also trigger a binding to be created on their parent element. For instance, if two-way binding is enabled on the parent element, and the parent element is an \ninput\n, a \nvalue\n attribute with a single \nInterpolator\n as its content will cause a two-way binding to be created between the value of the \ninput\n and the model of the \nInterpolator\n. This binding will handle updating the model when the input \nvalue\n has changed. There are a few other types of bindings for managing check values, content editables, name-bound lists of checkboxes, and other miscellaneous special values.\n\n\nA \nlazy\n binding directive will cause any associated two-way bindings to fire either after a timeout or on blur, depending on the value of the \nlazy\n directive.\n\n\nSection\n\n\nSection\ns come in many flavors, depending on the chunk of template from which they are created. A section may provide context, be conditional (positive or negative), or be iterative. Generic sections (\n{{#something}}...{{/}}\n in template) will adjust their type, to a certain extent, based on the value of their model. A generic section will always provide context in the form of their model. An \nif\n-style conditional section, including \nelseif\n, \nelse\n, and \nunless\n do not provide context. An \neach\n section will always provide context in the form of the current iteration. A \nwith\n section will always provide context as its model, but it will only render if its model is considered truthy by Ractive, which is pretty much the same as JS truthy except \n{}\n and \n[]\n are falsey. A generic section will be context/conditional if it is anything other than an array, which will make it iterative.\n\n\nSections that provide context do so by binding their \nFragment\ns with their model so that the reference resolution process can find the appropriate contexts when resolving.\n\n\nContext/Conditional\n\n\nContext and conditional sections will render and unrender their child fragment as their model changes truthiness. Conditional sections always stand alone, even it they have \nelseif\n or \nelse\n branches nested within them, because those branches are turned into independent sections during parsing.\n\n\nIterative\n\n\nIf section is designated iterative (\n{{#each ...}}\n) or is a general section with an array value resolution, the section will create a special form of fragment for each index or key in the value. The special form \nRepeatedFragment\n handles mapping of indices, keys, and references to those to a corresponding model. Iterative sections also have special handling for shuffles so that DOM is not wholesale destroyed and recreated when the array shuffles.\n\n\nIterative sections may supply an alias for their context, so that referencing the iterated value is a little bit easier. See \nAliases\n below for more info, as this is just a slightly specialized form of that.\n\n\nIterative sections may also supply key and/or index aliases so that their keys and/or indices may be referenced by a name from within their child fragments.\n\n\nAlias\n\n\nAlias sections simply resolve their models and act as a lookup endpoint for reference resolution. Aliasing happens entirely in the view.\n\n\nComponent\n\n\nA component is a sort-of special form of \nElement\n that, instead of creating a DOM element, creates a new Ractive instance. The child instance will be rendered and unrendered in place of the component placeholder in the DOM.\n\n\nAny plain \nAttribute\ns with a single \nInterpolator\n as content in a component's template are turned into \nMapping\ns.\n\n\nResolution\n\n\nThe resolution process for references requires a keypath and a \nFragment\n as a starting point.\n\n\n\n\nIf the reference is a special reference (\n@index\n, \n@this\n, etc), the appropriate model is looked up and returned.\n\n\nIf the reference is relative (starts with \n~/\n, \n.\n, or \n../\n) the appropriate base model is retrieved and the rest of the keypath is joined onto it and the resulting model is returned.\n\n\nIf the reference is non-relative and the base of the keypath is a member of the current context, then the context is joined to the keypath and the resulting model is returned.\n\n\nThe reference is ambiguous, so the following loop until resolution or no fragments are left, starting with the given fragment:\n\n\nIf the fragment is an iteration, check to see if there is an index or key alias that matches the root of the reference, and if so, return it.\n\n\nIf the fragment has aliases, check to see if there is one that matches the root of the reference, and if so, return it.\n\n\nIf the fragment has context:\n\n\nIf the fragment is the root of an instance, note it\n\n\nIf the context has a child matching the root of the reference:\n\n\nIf we crossed a component boundary, create an implicit mapping the to the newly discovered model in the current component.\n\n\nReturn it\n\n\n\n\n\n\nIf the fragment belongs to a component, use the component's parent fragment and loop.\n\n\nUse the fragment's parent and loop.\n\n\n\n\nThe resolution process is no longer happens strictly the vDOM, as the result of \nRactive.getNodeInfo\n also uses the target \nElement\n's fragment to resolve relative references. Event objects are also extended with methods from the same helper.\n\n\nUpdates\n\n\nThe \nrunloop\n controls when the DOM is actually updated and when transitions start in \nbatch\nes. It also handles resolving promises when transitions have completed and the DOM is completely up to date.\n\n\nAs changes propagate through the viewmodel, view items are notified of the change through their \nhandleChange\n method. Most items just set a dirty flag and notify their parent, via their \nbubble\n method, that they will need to be updated at the completion of the runloop turn. The root fragment of each instance affected will then register with the runloop. Once the changes are ready to be flushed to the view, each fragment registered with the runloop is called on to update, where the process happens in reverse, with each parent fragment checking to see if there is a change it needs to respond to and propagating the update downward to its children.", 
            "title": "View"
        }, 
        {
            "location": "/concepts/architecture/view/#states", 
            "text": "Items generally follow a fixed lifecycle.   Construction - the item is created and knows about its parent and the template chunk from which it was created. Its template may also indicate what its children should look like if it has them.  bind  - the item looks up any references is may have and registers with the model(s) that they represent. At this point, the item may create child items and bind them as well.  render  - the item may create an actual DOM node and tell its children to create their DOM nodes as necessary. The resulting nodes will be inserted into the document.  unrender  - thie item is no longer needed and will be removed from the document immediately or in the near future.  unbind  - this typically goes along with  unrender  and tells the models on which this item depends that they should no longer send change notifications to it.   There is a sixth floating step  rebind  that happens any time one dependency models shuffles (and in certain other very special circumstances) that causes the items to re-resolve their models and re-register if necessary.", 
            "title": "States"
        }, 
        {
            "location": "/concepts/architecture/view/#virtual-dom-items", 
            "text": "", 
            "title": "Virtual DOM Items"
        }, 
        {
            "location": "/concepts/architecture/view/#text", 
            "text": "Text is the simplest item. It simply holds a string that it turns into a  TextNode  when rendered.", 
            "title": "Text"
        }, 
        {
            "location": "/concepts/architecture/view/#interpolator", 
            "text": "This is the next simplest item. It resolves a model for its reference or expression and renders the value of the model as a text node if needed. Interpolators don't necessarily render directly, as they may be used for values by other items, such as attributes, mappings, and bindings.", 
            "title": "Interpolator"
        }, 
        {
            "location": "/concepts/architecture/view/#element", 
            "text": "An  Element  represents a DOM element. It also contains a number of other items in the form of  Attribute s,  Decorator s,  Transition s,  EventDirective s, and its children in a  Fragment .", 
            "title": "Element"
        }, 
        {
            "location": "/concepts/architecture/view/#attributes", 
            "text": "There are actually several different items that are treated as attributes for  Element s, event though only two of them actually may render into the DOM.   Attribute s - maybe obvious, they these represent a DOM attribute on their parent element. There are a number of different handlers for updating attributes depending on the element and attribute name. The  updateDelegate  for a particular attribute can be found in  getUpdateDelegate.js .  ConditionalAttribute s - render as a string and are parsed into actual DOM attributes using a  div  or an  svg  depending on their parent element.  Mapping s - when rendered add a mapping to their component, and when unrendered, remove it. These aren't attached to  Element s, but instead, are attached to  Component s (see below).  EventDirective s - when rendered attach an event listener to their parent, and when unrenedered, remove it. Event parameters are kept in sync with their bindings and are evaluated when the event fires.  BindingDirective s - when rendered and unrendered update their parent element's bindings, if they exist.  Decorator s - when rendered call the named decorator with their parent element, and when unrenedered, remove it.  Decorator s also have an update cycle related to their parameters.  Transition s - are a sort of weird case. When rendered, they attach a transition handler to their element, and when the element renders or unrenders, if an appropriate transition handler is registered, will trigger the transition. Transition parameters are also kept in sync with their bindings.", 
            "title": "Attributes"
        }, 
        {
            "location": "/concepts/architecture/view/#bindings", 
            "text": "Certain attributes may also trigger a binding to be created on their parent element. For instance, if two-way binding is enabled on the parent element, and the parent element is an  input , a  value  attribute with a single  Interpolator  as its content will cause a two-way binding to be created between the value of the  input  and the model of the  Interpolator . This binding will handle updating the model when the input  value  has changed. There are a few other types of bindings for managing check values, content editables, name-bound lists of checkboxes, and other miscellaneous special values.  A  lazy  binding directive will cause any associated two-way bindings to fire either after a timeout or on blur, depending on the value of the  lazy  directive.", 
            "title": "Bindings"
        }, 
        {
            "location": "/concepts/architecture/view/#section", 
            "text": "Section s come in many flavors, depending on the chunk of template from which they are created. A section may provide context, be conditional (positive or negative), or be iterative. Generic sections ( {{#something}}...{{/}}  in template) will adjust their type, to a certain extent, based on the value of their model. A generic section will always provide context in the form of their model. An  if -style conditional section, including  elseif ,  else , and  unless  do not provide context. An  each  section will always provide context in the form of the current iteration. A  with  section will always provide context as its model, but it will only render if its model is considered truthy by Ractive, which is pretty much the same as JS truthy except  {}  and  []  are falsey. A generic section will be context/conditional if it is anything other than an array, which will make it iterative.  Sections that provide context do so by binding their  Fragment s with their model so that the reference resolution process can find the appropriate contexts when resolving.", 
            "title": "Section"
        }, 
        {
            "location": "/concepts/architecture/view/#contextconditional", 
            "text": "Context and conditional sections will render and unrender their child fragment as their model changes truthiness. Conditional sections always stand alone, even it they have  elseif  or  else  branches nested within them, because those branches are turned into independent sections during parsing.", 
            "title": "Context/Conditional"
        }, 
        {
            "location": "/concepts/architecture/view/#iterative", 
            "text": "If section is designated iterative ( {{#each ...}} ) or is a general section with an array value resolution, the section will create a special form of fragment for each index or key in the value. The special form  RepeatedFragment  handles mapping of indices, keys, and references to those to a corresponding model. Iterative sections also have special handling for shuffles so that DOM is not wholesale destroyed and recreated when the array shuffles.  Iterative sections may supply an alias for their context, so that referencing the iterated value is a little bit easier. See  Aliases  below for more info, as this is just a slightly specialized form of that.  Iterative sections may also supply key and/or index aliases so that their keys and/or indices may be referenced by a name from within their child fragments.", 
            "title": "Iterative"
        }, 
        {
            "location": "/concepts/architecture/view/#alias", 
            "text": "Alias sections simply resolve their models and act as a lookup endpoint for reference resolution. Aliasing happens entirely in the view.", 
            "title": "Alias"
        }, 
        {
            "location": "/concepts/architecture/view/#component", 
            "text": "A component is a sort-of special form of  Element  that, instead of creating a DOM element, creates a new Ractive instance. The child instance will be rendered and unrendered in place of the component placeholder in the DOM.  Any plain  Attribute s with a single  Interpolator  as content in a component's template are turned into  Mapping s.", 
            "title": "Component"
        }, 
        {
            "location": "/concepts/architecture/view/#resolution", 
            "text": "The resolution process for references requires a keypath and a  Fragment  as a starting point.   If the reference is a special reference ( @index ,  @this , etc), the appropriate model is looked up and returned.  If the reference is relative (starts with  ~/ ,  . , or  ../ ) the appropriate base model is retrieved and the rest of the keypath is joined onto it and the resulting model is returned.  If the reference is non-relative and the base of the keypath is a member of the current context, then the context is joined to the keypath and the resulting model is returned.  The reference is ambiguous, so the following loop until resolution or no fragments are left, starting with the given fragment:  If the fragment is an iteration, check to see if there is an index or key alias that matches the root of the reference, and if so, return it.  If the fragment has aliases, check to see if there is one that matches the root of the reference, and if so, return it.  If the fragment has context:  If the fragment is the root of an instance, note it  If the context has a child matching the root of the reference:  If we crossed a component boundary, create an implicit mapping the to the newly discovered model in the current component.  Return it    If the fragment belongs to a component, use the component's parent fragment and loop.  Use the fragment's parent and loop.   The resolution process is no longer happens strictly the vDOM, as the result of  Ractive.getNodeInfo  also uses the target  Element 's fragment to resolve relative references. Event objects are also extended with methods from the same helper.", 
            "title": "Resolution"
        }, 
        {
            "location": "/concepts/architecture/view/#updates", 
            "text": "The  runloop  controls when the DOM is actually updated and when transitions start in  batch es. It also handles resolving promises when transitions have completed and the DOM is completely up to date.  As changes propagate through the viewmodel, view items are notified of the change through their  handleChange  method. Most items just set a dirty flag and notify their parent, via their  bubble  method, that they will need to be updated at the completion of the runloop turn. The root fragment of each instance affected will then register with the runloop. Once the changes are ready to be flushed to the view, each fragment registered with the runloop is called on to update, where the process happens in reverse, with each parent fragment checking to see if there is a change it needs to respond to and propagating the update downward to its children.", 
            "title": "Updates"
        }, 
        {
            "location": "/concepts/data-binding/computed-properties/", 
            "text": "The idea is fairly simple: you can define computed properties that update reactively based on their dependencies. In previous versions you may have done something as follows.\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '{{width}} * {{height}} = {{ area() }}', // note the function invocation\n  data: {\n    width: 100,\n    height: 100,\n    area: function () { return this.get( 'width' ) * this.get( 'height' ); }\n  }\n});\n\n\n\n\nThat's nice and all - the \n{{ area() }}\n mustache updates reactively as \nwidth\n and \nheight\n change - but it's limited. To get the area value programmatically you'd have to do something like...\n\n\narea = ractive.get('area').call(ractive);\n\n\n\n\n...which effectively prevents you from composing computed values together in any meaningful way. And you can't 'observe' the area outside of the template, without doing something like this:\n\n\nractive.observe( 'width height', function () {\n    var area = this.get( 'width' ) * this.get( 'height' );\n    doSomething( area );\n});\n\n\n\n\nComputed properties to the rescue\n\n\nNow, you can do\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '{{width}} * {{height}} = {{area}}', // `area` looks like a regular property\n  data: {\n    width: 100,\n    height: 100\n  },\n  computed: {\n    area: function () { return this.get( 'width' ) * this.get( 'height' ); }\n  }\n});\n\n\n\n\nWith this, the \narea\n property can be treated like any other. It will update reactively (because the calls to \nractive.get()\n tell Ractive that it should be recomputed when \nwidth\n or \nheight\n change), so you can do...\n\n\nractive.observe( 'area', doSomething );\n\n\n\n\n...instead of manually recalculating it. And computed values can depend on other computed values, and so on (before anyone asks, we're not doing a topological sort or anything fancy like that - in real world scenarios I'd expect the overhead of doing the sort to be greater than the cost of occasionally recomputing a node in the dependency graph more times than is required).\n\n\nCompact syntax\n\n\nThe syntax used above, where each computed property is defined as a function, gives you a lot of flexibility. But there's a more compact string syntax you can use:\n\n\nractive = new Ractive({\n  ...,\n  computed: {\n    area: '${width} * ${height}'\n  }\n});\n\n\n\n\nThis string is turned into a function with the \nFunction\n constructor (which unfortunately means it isn't \nCSP compliant\n) - any \n${...}\n blocks are basically turned into \nractive.get('...')\n, so it works exactly the same way. Needless to say you can use any JavaScript here - \n${foo}.toUpperCase()\n, \nMath.round(${num})\n, and so on.\n\n\nSetting computed values\n\n\nBy default, computed values are read-only, and if you try to \nractive.set('someComputedProperty')\n an error will be thrown. But you can use a third syntax option which allows you to declare a \nset()\n method:\n\n\nractive = new Ractive({\n  data: { firstname: 'Douglas', lastname: 'Crockford' },\n  computed: {\n    fullname: {\n      get: '${firstname} + \n \n + ${lastname}', // or use the function syntax\n      set: function ( fullname ) {\n        var names = fullname.split( ' ' );\n\n        this.set({\n          firstname: names[0] || '',\n          lastname: names[1] || ''\n        });\n      }\n    }\n  }\n});\n\nractive.set( 'fullname', 'Rich Harris' );\n\nractive.get( 'firstname' ); // Rich\nractive.get( 'lastname' ); // Harris\n\n\n\n\nComponents\n\n\nYou can, of course, declare computed values on components:\n\n\nBox = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nbox = new Box({\n  ...,\n  data: { width: 20, height: 40 }\n});\n\nbox.get( 'area' ); // 800\n\n\n\n\nAdditional computed properties can be declared on the instance:\n\n\nbox2 = new Box({\n  ...,\n  data: { width: 20, height: 40, depth: 60 },\n  computed: { volume: '${area} * ${depth}' }\n});\n\nbox2.get( 'area' ); // 800\nbox2.get( 'volume' ); // 48000\n\n\n\n\nData context for computed properties\n\n\nComputed properties can only be calculated for the instance context as a whole. You can't, for example, directly\ncompute a value for each member of an array:\n\n\nnew Ractive({\n  template: '{{#boxes}}{{area}}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  // there's no way to specify this for \neach\n box :(\n  computed: { area: '${width} * ${height}' }\n});\n\n\n\n\nThe solution is to either use a function that calculates the value for each member:\n\n\n  template: '{{#boxes:b}}{{ getArea(b) }}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ],\n    getArea: function ( i ) {\n      var box = this.get( 'boxes.' + i );\n      return box.width * box.area;\n    }\n  }\n\n\n\n\nOr leverage a component to \"scope\" the data to each item:\n\n\nBox = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nnew Ractive({\n  template: '{{#boxes}}\nbox/\n{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  components: { box: Box }\n});", 
            "title": "Computed Properties"
        }, 
        {
            "location": "/concepts/data-binding/computed-properties/#computed-properties-to-the-rescue", 
            "text": "Now, you can do  ractive = new Ractive({\n  el: 'body',\n  template: '{{width}} * {{height}} = {{area}}', // `area` looks like a regular property\n  data: {\n    width: 100,\n    height: 100\n  },\n  computed: {\n    area: function () { return this.get( 'width' ) * this.get( 'height' ); }\n  }\n});  With this, the  area  property can be treated like any other. It will update reactively (because the calls to  ractive.get()  tell Ractive that it should be recomputed when  width  or  height  change), so you can do...  ractive.observe( 'area', doSomething );  ...instead of manually recalculating it. And computed values can depend on other computed values, and so on (before anyone asks, we're not doing a topological sort or anything fancy like that - in real world scenarios I'd expect the overhead of doing the sort to be greater than the cost of occasionally recomputing a node in the dependency graph more times than is required).", 
            "title": "Computed properties to the rescue"
        }, 
        {
            "location": "/concepts/data-binding/computed-properties/#compact-syntax", 
            "text": "The syntax used above, where each computed property is defined as a function, gives you a lot of flexibility. But there's a more compact string syntax you can use:  ractive = new Ractive({\n  ...,\n  computed: {\n    area: '${width} * ${height}'\n  }\n});  This string is turned into a function with the  Function  constructor (which unfortunately means it isn't  CSP compliant ) - any  ${...}  blocks are basically turned into  ractive.get('...') , so it works exactly the same way. Needless to say you can use any JavaScript here -  ${foo}.toUpperCase() ,  Math.round(${num}) , and so on.", 
            "title": "Compact syntax"
        }, 
        {
            "location": "/concepts/data-binding/computed-properties/#setting-computed-values", 
            "text": "By default, computed values are read-only, and if you try to  ractive.set('someComputedProperty')  an error will be thrown. But you can use a third syntax option which allows you to declare a  set()  method:  ractive = new Ractive({\n  data: { firstname: 'Douglas', lastname: 'Crockford' },\n  computed: {\n    fullname: {\n      get: '${firstname} +     + ${lastname}', // or use the function syntax\n      set: function ( fullname ) {\n        var names = fullname.split( ' ' );\n\n        this.set({\n          firstname: names[0] || '',\n          lastname: names[1] || ''\n        });\n      }\n    }\n  }\n});\n\nractive.set( 'fullname', 'Rich Harris' );\n\nractive.get( 'firstname' ); // Rich\nractive.get( 'lastname' ); // Harris", 
            "title": "Setting computed values"
        }, 
        {
            "location": "/concepts/data-binding/computed-properties/#components", 
            "text": "You can, of course, declare computed values on components:  Box = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nbox = new Box({\n  ...,\n  data: { width: 20, height: 40 }\n});\n\nbox.get( 'area' ); // 800  Additional computed properties can be declared on the instance:  box2 = new Box({\n  ...,\n  data: { width: 20, height: 40, depth: 60 },\n  computed: { volume: '${area} * ${depth}' }\n});\n\nbox2.get( 'area' ); // 800\nbox2.get( 'volume' ); // 48000", 
            "title": "Components"
        }, 
        {
            "location": "/concepts/data-binding/computed-properties/#data-context-for-computed-properties", 
            "text": "Computed properties can only be calculated for the instance context as a whole. You can't, for example, directly\ncompute a value for each member of an array:  new Ractive({\n  template: '{{#boxes}}{{area}}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  // there's no way to specify this for  each  box :(\n  computed: { area: '${width} * ${height}' }\n});  The solution is to either use a function that calculates the value for each member:    template: '{{#boxes:b}}{{ getArea(b) }}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ],\n    getArea: function ( i ) {\n      var box = this.get( 'boxes.' + i );\n      return box.width * box.area;\n    }\n  }  Or leverage a component to \"scope\" the data to each item:  Box = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nnew Ractive({\n  template: '{{#boxes}} box/ {{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  components: { box: Box }\n});", 
            "title": "Data context for computed properties"
        }, 
        {
            "location": "/concepts/data-binding/dependents/", 
            "text": "Ractive maintains a \ndependency graph\n in order to do the minimum amount of work necessary to keep the DOM up-to-date.\n\n\nIf you inspect a Ractive instance in your console, you'll see a property called \n_deps\n. This is where all dependants are listed, indexed by their dependency.\n\n\nThere is also a concept of 'priority', which exists to save us some work. If, for example, a section needs to be removed (perhaps it's a conditional section, and the condition just went from truthy to falsy), there is no point in updating all its children, so we make sure that we teardown the section first. As part of that teardown process, the children - which all have lower priority - unregister themselves as dependants before they get a chance to update.\n\n\nIndirect dependencies\n\n\nIf you have a mustache which depends on \nfoo.bar\n, and \nfoo\n changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an \nindirect dependency\n on \nfoo\n, or that it has a \ndirect dependency on a downstream keypath\n of \nfoo\n.\n\n\nThis relationship is expressed through the \n_depsMap\n property of a Ractive instance - whenever \nfoo\n changes, as well as dealing with direct \nfoo\n dependants we check the map for those indirect dependants.\n\n\nIn the case of \nexpressions\n and \nobservers\n, we also need to consider dependants of \nupstream keypaths\n. For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:\n\n\n{{#( sort( list, 'name' ) )}}\n  \np\n{{name}}\n/p\n\n{{/()}}\n\n\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],\n    sort: function ( list, property ) {\n      return list.slice().sort( function ( a, b ) {\n        return a[ property ] \n b[ property ] ? -1 : 1;\n      });\n    }\n  }\n});\n\n// renders Alice, Bob, Charles\n\nractive.set( 'list[0].name', 'Zebediah' );\n\n// updates to Alice, Charles, Zebediah\n\n\n\n\nIn the example, setting \nlist[0].name\n causes dependants of \nlist\n to be updated.\n\n\nAs well as \nexpressions\n, \nObservers\n respond to both upstream and downstream changes.\n\n\nExpressions with multiple dependencies\n\n\nThe expression \n{{ a + b }}\n has two dependencies - \na\n and \nb\n (or more accurately, whatever those \nreferences\n resolve to). The \n_deps\n graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.\n\n\nBecause the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing \nractive.set({ a: 1, b: 2 })\n will only trigger one update, not two.", 
            "title": "Dependents"
        }, 
        {
            "location": "/concepts/data-binding/dependents/#indirect-dependencies", 
            "text": "If you have a mustache which depends on  foo.bar , and  foo  changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an  indirect dependency  on  foo , or that it has a  direct dependency on a downstream keypath  of  foo .  This relationship is expressed through the  _depsMap  property of a Ractive instance - whenever  foo  changes, as well as dealing with direct  foo  dependants we check the map for those indirect dependants.  In the case of  expressions  and  observers , we also need to consider dependants of  upstream keypaths . For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:  {{#( sort( list, 'name' ) )}}\n   p {{name}} /p \n{{/()}}  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],\n    sort: function ( list, property ) {\n      return list.slice().sort( function ( a, b ) {\n        return a[ property ]   b[ property ] ? -1 : 1;\n      });\n    }\n  }\n});\n\n// renders Alice, Bob, Charles\n\nractive.set( 'list[0].name', 'Zebediah' );\n\n// updates to Alice, Charles, Zebediah  In the example, setting  list[0].name  causes dependants of  list  to be updated.  As well as  expressions ,  Observers  respond to both upstream and downstream changes.", 
            "title": "Indirect dependencies"
        }, 
        {
            "location": "/concepts/data-binding/dependents/#expressions-with-multiple-dependencies", 
            "text": "The expression  {{ a + b }}  has two dependencies -  a  and  b  (or more accurately, whatever those  references  resolve to). The  _deps  graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.  Because the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing  ractive.set({ a: 1, b: 2 })  will only trigger one update, not two.", 
            "title": "Expressions with multiple dependencies"
        }, 
        {
            "location": "/concepts/data-binding/observers/", 
            "text": "Like publish/subscribe, but different\n\n\nA common pattern in modern JavaScript is to make models \nobservable\n, using the traditional \npublish/subscribe\n mechanism.\n\n\nFor example, you can observe changes to attributes within a Backbone Model like so:\n\n\nmodel = Backbone.Model({ myValue: 1 });\n\nmodel.on( 'change:myValue', function ( model, value, options ) {\n  alert( 'myValue changed to ' + value );\n});\n\nmodel.set( 'myValue', 2 ); // alerts 'myValue changed to 2'\n\n\n\n\nThis works because \nBackbone.Model.prototype\n inherits from \nBackbone.Events\n.\n\n\nRactive implements pub/sub with \nractive.on()\n, \nractive.off()\n and \nractive.fire()\n, \nractive.off()\n and \nractive.fire\n - see \nEvents\n for more info.\n\n\nObserving models with nested properties\n\n\nBut the normal pub/sub mechanism won't work for monitoring data changes with Ractive, because our data can contain nested properties. It's no good subscribing to a \nchange:foo.bar\n event, if \nfoo.bar\n can change as a result of \nfoo\n changing.\n\n\nSo instead, we introduce the concept of \nobservers\n.\n\n\nAn observer observes a particular \nkeypath\n, and is \nnotified\n when the value of its keypath changes, whether directly or indirectly (because an \nupstream\n or \ndownstream\n keypath changed). You create one with \nractive.observe()\n (see \nractive.observe()\n for full method\nAPI).\n\n\nHere's an example:\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    foo: { bar: 1 }\n  }\n});\n\n// The observer will be initialised with ( currentValue, undefined ) unless\n// we pass a third `options` argument in which `init` is `false`. In other\n// words this will alert 'foo.bar changed to 1'\nobserver = ractive.observe( 'foo.bar', function ( newValue, oldValue, keypath ) {\n  alert( keypath + ' changed to ' + newValue );\n});\n\nractive.set( 'foo.bar', 2 ); // alerts 'foo.bar changed to 2'\nractive.get( 'foo' ); // returns { bar: 2 }\n\nractive.set( 'foo', { bar: 3 }); // alerts 'foo.bar changed to 3'\nractive.get( 'foo.bar' ); // returns 3\n\nobserver.cancel();\n\nractive.set( 'foo.bar', 4 ); // alerts nothing; the observer was cancelled\n\n\n\n\nObservers are most useful in the context of \ntwo\u2010way binding\n.\n\n\nPattern Observers\n\n\nIt is useful to observe on specific keypaths but in the event your data contains array, or a set of dynamic data it isn't logical to bind to every potential keypath that could exist. Pattern observers use a \n*\n to indicate to Ractive that you would like to be notified whenever anything changes in your data at a particular depth as well as below the specified depth.\n\n\nThere are a few caveats when it comes to observing on array data, when observing on keypath \npeople.*\n you are observing on the length of the array. This means that the \nnewValue\n will be the index at which the new object was pushed. However when you use \nset\n to change an item at a particular index or a key that is on an object in the array then it will provide the object as the \nnewValue\n.\n\n\nvar ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    people: [\n      {name: 'Rich Harris'},\n      {name: 'Marty Nelson'}\n    ]\n  }\n});\n\nractive.observe('people.*', function(newValue, oldValue, keypath) {\n\n});\n\nvar people = ractive.get('people');\npeople.push({name: 'Jason Brown'});\n//newValue will equal 3, and the keypath will be people.length\n\nractive.set('people.3', {name: 'Jack Black'});\n//newValue will be {name: 'Jack Black'} and the keypath will be people.3\n\nractive.set('people.3.isACelebrity', true);\n//newValue will be {name: 'Jack Black', isACelebrity: true} and the keypath will be people.3\n\nractive.set('people.0.info.isCreator', true);\n//newValue will be the object for index 0 and the keypath will be people.0\n\n\n\n\n\nNotice that because you are observing at the array level that \nnewValue\n will be set as the entire object. What if you were only interested in knowing when a user became a celebrity? Simply tell Ractive you only want to observe dynamically on the array but only be notified when the \nisACelebrity\n key changes, \npeople.*.isACelebrity\n.\n\n\nractive.observe('people.*.isACelebrity', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('people.0.isACelebrity', true); //Rich Harris is a celebrity\n//newValue will be `true` and the keypath will be people.0.isACelebrity\n\n\n\n\n\nYou are not limited to just one \n*\n for your pattern, you can use as many as you would like and in any particular order.\n\n\n\nractive.observe('people.*.comments.*', function(newValue, oldValue, keypath) {\n\n});\n\n//even arrays of arrays\n\nractive.observe('people.*.*', function(newValue, oldValue, keypath) {\n\n});\n\n\n\n\n\nFurthermore it works on objects as well \nconfig.*\n will notify you when a value is changed on any key on the config object. However this differs from observing on an array in that it will provide the value set and keypath to the key that was set.\n\n\nvar ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  }\n});\n\nractive.observe('config.*', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('config.allowEdit', true);\n//newValue will be true and the keypath will be config.allowEdit\n\n\n\n\n\nIn addition to \nnewValue\n, \noldValue\n, and \nkeypath\n, any widlcards that are matched in the \nkeypath\n will be passed to the callback. Each additional wildcard will cause an extra parameter to be passed to the callback. For instance:\n\n\nractive.observe('items.*.*', function(newValue, oldValue, keypath, idx, key) {\n  console.log('item', idx, key, 'is now', newValue);\n});\nractive.set('items.1.foo', 'bar');\n// logs 'item 1 foo is now bar'\n\n\n\n\nPattern observers are a simple and flexible that will allow you to observe your data any way that you want.\n\n\nSpace Delimited Observers\n\n\nSpace delimited observers are useful when different keypaths should trigger the same function. In previous version you would have had to bind each keypath individually to the function.\n\n\nThis is a contrived example but for examples sake bare with us.\n\n\nvar ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    user: {username: 'browniefed'},\n    config: {isAdmin: false},\n    commentCount: 0\n  }\n});\n\nfunction updateServer() {\n  //Make call to server because something in user, config, comments changed\n}\n\nractive.observe('user.username', updateServer);\nractive.observe('config.isAdmin', updateServer);\nractive.observe('commentCount', updateServer);\n\n\n\n\n\nThis is unecessarily verbose, now with space delimited observers this becomes a single line.\n\n\nractive.observe('user.username config.isAdmin commentCount', updateServer);\n\n\n\n\n\nThis will work with patterns observers as well.\n\n\nractive.observe('user.* config.* commentCount', updateServer);\n\n\n\n\n\nA 'gotcha' to be aware of\n\n\nObservers will be notified whenever the new value is not equal to the old value - \nsort of\n.\n\n\nWhat does 'not equal' mean? Well, with \nprimitive values\n such as strings and numbers, that's easy - they're either identical (in the \n===\n sense) or they're not.\n\n\nWith objects and arrays (hereafter, just 'objects', since that's what arrays technically are), it's not so straightforward:\n\n\na = { one: 1, two: 2, three: 3 };\nb = { one: 1, two: 2, three: 3 };\n\nalert( a === b ); // alerts 'false' - they look the same, but they ain't\n\nb = a;\nb.four = 4;\n\nalert( a === b ); // alerts 'true'. Hang on, `a` didn't have a 'four' property?\nalert( a.four ); // alerts '4'. Oh. Right.\n\n\n\n\nSo one the one hand, objects which look identical aren't. On the other, you can set a property of an object and have no idea whether doing so resulted in a change.\n\n\nThere are two possible responses to this problem. First, we could do a 'deep clone' of an object whenever we do \nractive.set(keypath, object)\n, using an algorithm similar to \njQuery extend\n. That would mean any references you held to \nobject\n would become irrelevant. It would also mean a whole load of extra computation, and probably some very strange behaviour with cyclical data structures. No thanks.\n\n\nThe second is to sidestep the issue, and simply state that for the purposes of determining whether to notify observers, \nno two objects are equal, even when they're identical\n (unless they're both \nnull\n, of course - since \ntypeof null === 'object'\n due to a \nbug in the language\n).\n\n\nThis is the safest, sanest behaviour, but it can lead to unexpected behaviour in one situation - accessing properties within an observer:\n\n\nobj = { a: { b: { c: 1 } } };\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: { obj: obj }\n});\n\n// We observe 'obj.a.b.c' indirectly, and directly\nractive.observe({\n  'obj': function ( newObj, oldObj ) {\n    alert( 'Indirect observer: changed from ' + oldObj.a.b.c + ' to ' + newObj.a.b.c );\n  },\n  'obj.a.b.c': function ( newC, oldC ) {\n    alert( 'Direct observer: changed from ' + oldC + ' to ' + newC );\n  }\n});\n\nobj.a.b.c = 2;\n\n// The next line will cause two alerts:\n//   'Direct observer: changed from 1 to 2'\n//   'Indirect observer: changed from 2 to 2' - because oldObj === newObj\nractive.set( 'obj', obj );\n\n\n\n\nThis is definitely an edge case, but one that it's worth being aware of.", 
            "title": "Observers"
        }, 
        {
            "location": "/concepts/data-binding/observers/#like-publishsubscribe-but-different", 
            "text": "A common pattern in modern JavaScript is to make models  observable , using the traditional  publish/subscribe  mechanism.  For example, you can observe changes to attributes within a Backbone Model like so:  model = Backbone.Model({ myValue: 1 });\n\nmodel.on( 'change:myValue', function ( model, value, options ) {\n  alert( 'myValue changed to ' + value );\n});\n\nmodel.set( 'myValue', 2 ); // alerts 'myValue changed to 2'  This works because  Backbone.Model.prototype  inherits from  Backbone.Events .  Ractive implements pub/sub with  ractive.on() ,  ractive.off()  and  ractive.fire() ,  ractive.off()  and  ractive.fire  - see  Events  for more info.", 
            "title": "Like publish/subscribe, but different"
        }, 
        {
            "location": "/concepts/data-binding/observers/#observing-models-with-nested-properties", 
            "text": "But the normal pub/sub mechanism won't work for monitoring data changes with Ractive, because our data can contain nested properties. It's no good subscribing to a  change:foo.bar  event, if  foo.bar  can change as a result of  foo  changing.  So instead, we introduce the concept of  observers .  An observer observes a particular  keypath , and is  notified  when the value of its keypath changes, whether directly or indirectly (because an  upstream  or  downstream  keypath changed). You create one with  ractive.observe()  (see  ractive.observe()  for full method\nAPI).  Here's an example:  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    foo: { bar: 1 }\n  }\n});\n\n// The observer will be initialised with ( currentValue, undefined ) unless\n// we pass a third `options` argument in which `init` is `false`. In other\n// words this will alert 'foo.bar changed to 1'\nobserver = ractive.observe( 'foo.bar', function ( newValue, oldValue, keypath ) {\n  alert( keypath + ' changed to ' + newValue );\n});\n\nractive.set( 'foo.bar', 2 ); // alerts 'foo.bar changed to 2'\nractive.get( 'foo' ); // returns { bar: 2 }\n\nractive.set( 'foo', { bar: 3 }); // alerts 'foo.bar changed to 3'\nractive.get( 'foo.bar' ); // returns 3\n\nobserver.cancel();\n\nractive.set( 'foo.bar', 4 ); // alerts nothing; the observer was cancelled  Observers are most useful in the context of  two\u2010way binding .", 
            "title": "Observing models with nested properties"
        }, 
        {
            "location": "/concepts/data-binding/observers/#pattern-observers", 
            "text": "It is useful to observe on specific keypaths but in the event your data contains array, or a set of dynamic data it isn't logical to bind to every potential keypath that could exist. Pattern observers use a  *  to indicate to Ractive that you would like to be notified whenever anything changes in your data at a particular depth as well as below the specified depth.  There are a few caveats when it comes to observing on array data, when observing on keypath  people.*  you are observing on the length of the array. This means that the  newValue  will be the index at which the new object was pushed. However when you use  set  to change an item at a particular index or a key that is on an object in the array then it will provide the object as the  newValue .  var ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    people: [\n      {name: 'Rich Harris'},\n      {name: 'Marty Nelson'}\n    ]\n  }\n});\n\nractive.observe('people.*', function(newValue, oldValue, keypath) {\n\n});\n\nvar people = ractive.get('people');\npeople.push({name: 'Jason Brown'});\n//newValue will equal 3, and the keypath will be people.length\n\nractive.set('people.3', {name: 'Jack Black'});\n//newValue will be {name: 'Jack Black'} and the keypath will be people.3\n\nractive.set('people.3.isACelebrity', true);\n//newValue will be {name: 'Jack Black', isACelebrity: true} and the keypath will be people.3\n\nractive.set('people.0.info.isCreator', true);\n//newValue will be the object for index 0 and the keypath will be people.0  Notice that because you are observing at the array level that  newValue  will be set as the entire object. What if you were only interested in knowing when a user became a celebrity? Simply tell Ractive you only want to observe dynamically on the array but only be notified when the  isACelebrity  key changes,  people.*.isACelebrity .  ractive.observe('people.*.isACelebrity', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('people.0.isACelebrity', true); //Rich Harris is a celebrity\n//newValue will be `true` and the keypath will be people.0.isACelebrity  You are not limited to just one  *  for your pattern, you can use as many as you would like and in any particular order.  \nractive.observe('people.*.comments.*', function(newValue, oldValue, keypath) {\n\n});\n\n//even arrays of arrays\n\nractive.observe('people.*.*', function(newValue, oldValue, keypath) {\n\n});  Furthermore it works on objects as well  config.*  will notify you when a value is changed on any key on the config object. However this differs from observing on an array in that it will provide the value set and keypath to the key that was set.  var ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  }\n});\n\nractive.observe('config.*', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('config.allowEdit', true);\n//newValue will be true and the keypath will be config.allowEdit  In addition to  newValue ,  oldValue , and  keypath , any widlcards that are matched in the  keypath  will be passed to the callback. Each additional wildcard will cause an extra parameter to be passed to the callback. For instance:  ractive.observe('items.*.*', function(newValue, oldValue, keypath, idx, key) {\n  console.log('item', idx, key, 'is now', newValue);\n});\nractive.set('items.1.foo', 'bar');\n// logs 'item 1 foo is now bar'  Pattern observers are a simple and flexible that will allow you to observe your data any way that you want.", 
            "title": "Pattern Observers"
        }, 
        {
            "location": "/concepts/data-binding/observers/#space-delimited-observers", 
            "text": "Space delimited observers are useful when different keypaths should trigger the same function. In previous version you would have had to bind each keypath individually to the function.  This is a contrived example but for examples sake bare with us.  var ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    user: {username: 'browniefed'},\n    config: {isAdmin: false},\n    commentCount: 0\n  }\n});\n\nfunction updateServer() {\n  //Make call to server because something in user, config, comments changed\n}\n\nractive.observe('user.username', updateServer);\nractive.observe('config.isAdmin', updateServer);\nractive.observe('commentCount', updateServer);  This is unecessarily verbose, now with space delimited observers this becomes a single line.  ractive.observe('user.username config.isAdmin commentCount', updateServer);  This will work with patterns observers as well.  ractive.observe('user.* config.* commentCount', updateServer);", 
            "title": "Space Delimited Observers"
        }, 
        {
            "location": "/concepts/data-binding/observers/#a-gotcha-to-be-aware-of", 
            "text": "Observers will be notified whenever the new value is not equal to the old value -  sort of .  What does 'not equal' mean? Well, with  primitive values  such as strings and numbers, that's easy - they're either identical (in the  ===  sense) or they're not.  With objects and arrays (hereafter, just 'objects', since that's what arrays technically are), it's not so straightforward:  a = { one: 1, two: 2, three: 3 };\nb = { one: 1, two: 2, three: 3 };\n\nalert( a === b ); // alerts 'false' - they look the same, but they ain't\n\nb = a;\nb.four = 4;\n\nalert( a === b ); // alerts 'true'. Hang on, `a` didn't have a 'four' property?\nalert( a.four ); // alerts '4'. Oh. Right.  So one the one hand, objects which look identical aren't. On the other, you can set a property of an object and have no idea whether doing so resulted in a change.  There are two possible responses to this problem. First, we could do a 'deep clone' of an object whenever we do  ractive.set(keypath, object) , using an algorithm similar to  jQuery extend . That would mean any references you held to  object  would become irrelevant. It would also mean a whole load of extra computation, and probably some very strange behaviour with cyclical data structures. No thanks.  The second is to sidestep the issue, and simply state that for the purposes of determining whether to notify observers,  no two objects are equal, even when they're identical  (unless they're both  null , of course - since  typeof null === 'object'  due to a  bug in the language ).  This is the safest, sanest behaviour, but it can lead to unexpected behaviour in one situation - accessing properties within an observer:  obj = { a: { b: { c: 1 } } };\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: { obj: obj }\n});\n\n// We observe 'obj.a.b.c' indirectly, and directly\nractive.observe({\n  'obj': function ( newObj, oldObj ) {\n    alert( 'Indirect observer: changed from ' + oldObj.a.b.c + ' to ' + newObj.a.b.c );\n  },\n  'obj.a.b.c': function ( newC, oldC ) {\n    alert( 'Direct observer: changed from ' + oldC + ' to ' + newC );\n  }\n});\n\nobj.a.b.c = 2;\n\n// The next line will cause two alerts:\n//   'Direct observer: changed from 1 to 2'\n//   'Indirect observer: changed from 2 to 2' - because oldObj === newObj\nractive.set( 'obj', obj );  This is definitely an edge case, but one that it's worth being aware of.", 
            "title": "A 'gotcha' to be aware of"
        }, 
        {
            "location": "/concepts/data-binding/parallel-dom/", 
            "text": "Ractive works by maintaining a simplified model of the part of the DOM that it's responsible for. This model contains all the information - about data-binding, event handling and so on - that it needs to keep things up-to-date.\n\n\nYou can inspect the parallel DOM to understand what's going on under the hood, if you're into that sort of thing. Each Ractive instance, once rendered, has a \nfragment\n property. Each fragment has a number of properties:\n\n\n\n\ncontextStack\n - the context stack in which mustache \nreferences\n should be evaluated\n\n\nroot\n - a reference to the Ractive instance to which it belongs\n\n\nowner\n - the \nitem\n that owns this fragment (in the case of the root fragment, the same as \nroot\n)\n\n\nitems\n - the items belonging to this fragment\n\n\n\n\nItems\n means elements, text nodes, and mustaches. Elements may have fragments of their own (i.e. if they have children). A partial mustache will have a fragment, and a section mustache will have zero or more fragments depending on the value of its keypath.\n\n\nElements may also have attributes, which have a different kind of fragment (a \ntext fragment\n as opposed to a \nDOM fragment\n), containing text and mustaches.\n\n\nEach item has a \ndescriptor\n, which is something like DNA. This comes straight from the \nparsed template\n.\n\n\nThis is the briefest of overviews - if you want to gain a deeper understanding of what's going on under the hood, \nuse the source\n.", 
            "title": "Parallel DOM"
        }, 
        {
            "location": "/concepts/data-binding/two-way-binding/", 
            "text": "By default, a Ractive instance will update its internal model based on user input, if you have \ninput\n, \ntextarea\n or \nselect\n elements.\n\n\nIf that's unhelpful for your app, you can disable it by passing \ntwoway: false\n as an \ninitialisation option\n.\n\n\nTwo-way vinding can also be overridden on a per-element basis using the \ntwoway\n directive e.g. \ninput value=\"{{foo}}\" twoway=\"false\"\n. If the \ntwoway\n option is set to false, it can be overridden on a per-element bases using \ntwoway\n as a boolean attribute e.g. \ninput value=\"{{foo}}\" twoway\n or \ninput value=\"{{foo}}\" twoway=\"true\"\n.\n\n\ninput\n elements\n\n\nTwo-way binding works with \ninput\n elements of any type, including the new HTML5 types such as \ncolor\n or \nemail\n. In most cases, you just add a mustache as the \nvalue\n attribute - this must be a single, standard \ninterpolator\n mustache, like this:\n\n\ninput placeholder='Type your name' value='{{user.name}}'\n\n\n\n\n\nIn the example above, any changes the user makes to the input will be reflected in the \nuser.name\n property.\n\n\nCheckboxes\n\n\nCheckboxes are used to flag a property as \ntrue\n or \nfalse\n. Rather than binding the \nvalue\n attribute, we bind the \nchecked\n attribute:\n\n\nlabel\n\n    \ninput type='checkbox' checked='{{on}}'\n\n    The lights are {{ on ? 'on' : 'off' }}\n\n/label\n\n\n\n\n\n(True HTML nerds will recognise that \nboolean attributes\n such as checked don't have a value, as such - they either exist on an element or they don't. This makes life unnecessarily difficult; Ractive treats dynamic (i.e., controlled by a mustache) boolean attributes as present if the mustache is \ntrue\n, absent if \nfalse\n.)\n\n\nCheckboxes may also be bound by the \nname\n attribute, which will result in the value specified in the \nname\n attribute containing an array of selected checkbox values.\n\n\n{{#colors}}\n  \nlabel\n\n    \ninput type='checkbox' name='{{selected}}' value='{{.}}' /\n{{.}}\n  \n/label\n\n{{/}}\n\n\n\n\nIf \ncolors\n is an array, \n['Red', 'Yellow', 'Green', 'Blue']\n, then checking the first box will result in \nselected\n becoming \n['Red']\n. Checking the third box will result in \nselected\n becoming \n['Red', 'Green']\n. The array may also be updated from code using \nset\n or any of the array modification methods available to Ractive, and the checkboxes will be updated to reflect the contents of the array in the Ractive viewmodel.\n\n\nNote\n that checkboxes with both a \nchecked\n and \nname\n binding will \nonly\n bind on \nchecked\n, not both. The \nname\n binding will be treated\nas a normal mustache variable.\n\n\nRadios\n\n\nRadio buttons can be controlled in the same way as checkboxes. However the chances are, if you're using radio buttons, you have a set of mutually exclusive options to choose between. In this case, if you set the \nname\n attribute on a radio input to e.g. \n{{someValue}}\n, \nsomeValue\n will reflect the \nvalue\n of the currently checked option:\n\n\nlabel\ninput type='radio' name='{{color}}' value='red' checked\n Red\n/label\n\n\nlabel\ninput type='radio' name='{{color}}' value='green'\n Green\n/label\n\n\nlabel\ninput type='radio' name='{{color}}' value='blue'\n Blue\n/label\n\n\n\np\nThe currently selected color is \nspan style='color: {{color}};'\n{{color}}\n/span\n/p\n\n\n\n\n\nIn the example above, the value of \ncolor\n will initially be \n'red'\n (because that input is checked in the template), and will update as and when the user selects another option.\n\n\ntextarea\n elements\n\n\nTextareas work exactly the same as standard text inputs - slap a dynamic \nvalue\n attribute on them, and you're done:\n\n\ntextarea value='{{content}}'\n/textarea\n\n\n\n\n\nselect\n elements\n\n\nDrop-down select menus are good when you have many options to choose from. They're straightforward to use in Ractive:\n\n\nselect value='{{selectedCountry}}'\n\n    \noption selected disabled\nSelect a country\n/option\n\n    {{#countries}}\n        \noption value='{{id}}'\n{{name}}\n/option\n\n    {{/countries}}\n\n/select\n\n\n\n\n\nractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        countries: [\n            { id: 'AFG', name: 'Afghanistan' },\n            { id: 'ALB', name: 'Albania' },\n            { id: 'DZA', name: 'Algeria' },\n            { id: 'ASM', name: 'American Samoa' }\n            // and so on...\n        ]\n    }\n});\n\n\n\n\nIn the example above, no country will initially be selected. If the user were to select Afghanistan from the list, the value of \nselectedCountry\n would change to \n'AFG'\n.\n\n\ncontenteditable\n\n\nRactive can two-way data bind contenteditable elements.\n\n\nvar ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        content: 'Edit me'\n    }\n});\n\nractive.observe('content', function(newValue, oldValue, keypath) {\n    //newValue will contain the new content of the div\n});\n\n\n\n\nmyTemplate\n\n\ndiv contenteditable=\ntrue\n value=\n{{content}}\n/div\n\n\n\n\n\nThis will be rendered as\n\n\ndiv contenteditable=\ntrue\nEdit Me\n/div\n\n\n\n\n\nAs the user edits the data the \ncontent\n will update, and observe will fire.\n\n\nThere are a few caveats that you need to know. Despite the value binding with only two curly braces \n{{content}}\n (double curly braces are required for two way data binding) the returned content may or may not be a string of HTML. If a user presses enter after most browsers will insert a \nbr /\n. The \ncontent\n would be set to \nEdit Me\nbr/\n. Additionally anything you set to \ncontent\n would be rendered as HTML and not escaped despite the lack of triple curly braces(\n{{{content}}}\n).\n\n\nractive.set('content', '\nul\nli\nEdit Me\n/li\n/ul\n');\n\n\n\n\nThis would actually render an editable unordered list.\n\n\nBe aware that not all browsers actually operate the same way when it comes to interacting with contenteditable. HTML generated by one browser may differ from another.\n\n\nAmbiguous references\n\n\nA mustache used in a two-way binding context must have an \nunambiguous reference\n. Consider the following:\n\n\n{{#foo}}\n    \ninput value='{{bar}}'\n\n{{/foo}}\n\n\n\n\nractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: { foo: {} }\n});\n\n\n\n\nRactive must decide, straight away, what \nkeypath\n to bind the input's \nvalue\n attribute to. It will first see if it can \nreference\n (\n'bar'\n) given the current context stack (which includes a single context - \n'foo'\n). It can't, so it is forced to make an assumption - that the \n'bar'\n reference should resolve to the \n'bar'\n keypath.\n\n\nBut this might not be what you want - maybe you \ndid\n want it to resolve to \n'foo.bar'\n.\n\n\nYou have two options - either use a \nrestricted reference\n, i.e. \ninput value='{{.bar}}'\n, or ensure that \nfoo\n has a \nbar\n property (even if the initial value is \nundefined\n).\n\n\nLazy updates\n\n\nUnder the hood, Ractive always binds to the \nchange\n event (and the \nclick\n event in IE, in the case of checkboxes, due to an IE bug). By default, it will also bind to the \ninput\n event, which means the model is updated instantly when the user enters data (the \nchange\n event fires when a change is \n'committed by the user'\n). In some situations, that's not what you want - if you want to only bind to \nchange\n, pass in \nlazy: true\n as an \ninitialisation option\n.\n\n\nAs with \ntwoway\n, laziness may be specified on a per-element basis. Besides \ntrue\n (or simply having the attribute preset) and \nfalse\n values, the \nlazy\n directive may also be a number that specifies the number of milliseconds to wait after the last \ninput\n event fires with subsequent \ninput\n events resetting the timeout. For instance \ninput value=\"{{foo}}\" lazy\n will trigger updates to \nfoo\n on \nchange\n and \ninput value=\"{{foo}}\" lazy=\"1000\"\n will trigger updates 1 second after the last keypress.\n\n\nObserving changes\n\n\nTo use user input elsewhere in your app, you'll need to observe it using \nractive.observe()\n:\n\n\ninput placeholder='Type your name' value='{{user.name}}'\n\n\n\n\n\nractive = new Ractive({\n    el: myContainer,\n    template: myTemplate\n});\n\nractive.observe( 'user.name', function ( newValue ) {\n    app.user.name = newValue;\n    triggerSomeBehaviour();\n});", 
            "title": "Two-Way Binding"
        }, 
        {
            "location": "/concepts/data-binding/two-way-binding/#input-elements", 
            "text": "Two-way binding works with  input  elements of any type, including the new HTML5 types such as  color  or  email . In most cases, you just add a mustache as the  value  attribute - this must be a single, standard  interpolator  mustache, like this:  input placeholder='Type your name' value='{{user.name}}'   In the example above, any changes the user makes to the input will be reflected in the  user.name  property.", 
            "title": "&lt;input&gt; elements"
        }, 
        {
            "location": "/concepts/data-binding/two-way-binding/#checkboxes", 
            "text": "Checkboxes are used to flag a property as  true  or  false . Rather than binding the  value  attribute, we bind the  checked  attribute:  label \n     input type='checkbox' checked='{{on}}' \n    The lights are {{ on ? 'on' : 'off' }} /label   (True HTML nerds will recognise that  boolean attributes  such as checked don't have a value, as such - they either exist on an element or they don't. This makes life unnecessarily difficult; Ractive treats dynamic (i.e., controlled by a mustache) boolean attributes as present if the mustache is  true , absent if  false .)  Checkboxes may also be bound by the  name  attribute, which will result in the value specified in the  name  attribute containing an array of selected checkbox values.  {{#colors}}\n   label \n     input type='checkbox' name='{{selected}}' value='{{.}}' / {{.}}\n   /label \n{{/}}  If  colors  is an array,  ['Red', 'Yellow', 'Green', 'Blue'] , then checking the first box will result in  selected  becoming  ['Red'] . Checking the third box will result in  selected  becoming  ['Red', 'Green'] . The array may also be updated from code using  set  or any of the array modification methods available to Ractive, and the checkboxes will be updated to reflect the contents of the array in the Ractive viewmodel.  Note  that checkboxes with both a  checked  and  name  binding will  only  bind on  checked , not both. The  name  binding will be treated\nas a normal mustache variable.", 
            "title": "Checkboxes"
        }, 
        {
            "location": "/concepts/data-binding/two-way-binding/#radios", 
            "text": "Radio buttons can be controlled in the same way as checkboxes. However the chances are, if you're using radio buttons, you have a set of mutually exclusive options to choose between. In this case, if you set the  name  attribute on a radio input to e.g.  {{someValue}} ,  someValue  will reflect the  value  of the currently checked option:  label input type='radio' name='{{color}}' value='red' checked  Red /label  label input type='radio' name='{{color}}' value='green'  Green /label  label input type='radio' name='{{color}}' value='blue'  Blue /label  p The currently selected color is  span style='color: {{color}};' {{color}} /span /p   In the example above, the value of  color  will initially be  'red'  (because that input is checked in the template), and will update as and when the user selects another option.", 
            "title": "Radios"
        }, 
        {
            "location": "/concepts/data-binding/two-way-binding/#textarea-elements", 
            "text": "Textareas work exactly the same as standard text inputs - slap a dynamic  value  attribute on them, and you're done:  textarea value='{{content}}' /textarea", 
            "title": "&lt;textarea&gt; elements"
        }, 
        {
            "location": "/concepts/data-binding/two-way-binding/#select-elements", 
            "text": "Drop-down select menus are good when you have many options to choose from. They're straightforward to use in Ractive:  select value='{{selectedCountry}}' \n     option selected disabled Select a country /option \n    {{#countries}}\n         option value='{{id}}' {{name}} /option \n    {{/countries}} /select   ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        countries: [\n            { id: 'AFG', name: 'Afghanistan' },\n            { id: 'ALB', name: 'Albania' },\n            { id: 'DZA', name: 'Algeria' },\n            { id: 'ASM', name: 'American Samoa' }\n            // and so on...\n        ]\n    }\n});  In the example above, no country will initially be selected. If the user were to select Afghanistan from the list, the value of  selectedCountry  would change to  'AFG' .", 
            "title": "&lt;select&gt; elements"
        }, 
        {
            "location": "/concepts/data-binding/two-way-binding/#contenteditable", 
            "text": "Ractive can two-way data bind contenteditable elements.  var ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        content: 'Edit me'\n    }\n});\n\nractive.observe('content', function(newValue, oldValue, keypath) {\n    //newValue will contain the new content of the div\n});  myTemplate  div contenteditable= true  value= {{content}} /div   This will be rendered as  div contenteditable= true Edit Me /div   As the user edits the data the  content  will update, and observe will fire.  There are a few caveats that you need to know. Despite the value binding with only two curly braces  {{content}}  (double curly braces are required for two way data binding) the returned content may or may not be a string of HTML. If a user presses enter after most browsers will insert a  br / . The  content  would be set to  Edit Me br/ . Additionally anything you set to  content  would be rendered as HTML and not escaped despite the lack of triple curly braces( {{{content}}} ).  ractive.set('content', ' ul li Edit Me /li /ul ');  This would actually render an editable unordered list.  Be aware that not all browsers actually operate the same way when it comes to interacting with contenteditable. HTML generated by one browser may differ from another.", 
            "title": "contenteditable"
        }, 
        {
            "location": "/concepts/data-binding/two-way-binding/#ambiguous-references", 
            "text": "A mustache used in a two-way binding context must have an  unambiguous reference . Consider the following:  {{#foo}}\n     input value='{{bar}}' \n{{/foo}}  ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: { foo: {} }\n});  Ractive must decide, straight away, what  keypath  to bind the input's  value  attribute to. It will first see if it can  reference  ( 'bar' ) given the current context stack (which includes a single context -  'foo' ). It can't, so it is forced to make an assumption - that the  'bar'  reference should resolve to the  'bar'  keypath.  But this might not be what you want - maybe you  did  want it to resolve to  'foo.bar' .  You have two options - either use a  restricted reference , i.e.  input value='{{.bar}}' , or ensure that  foo  has a  bar  property (even if the initial value is  undefined ).", 
            "title": "Ambiguous references"
        }, 
        {
            "location": "/concepts/data-binding/two-way-binding/#lazy-updates", 
            "text": "Under the hood, Ractive always binds to the  change  event (and the  click  event in IE, in the case of checkboxes, due to an IE bug). By default, it will also bind to the  input  event, which means the model is updated instantly when the user enters data (the  change  event fires when a change is  'committed by the user' ). In some situations, that's not what you want - if you want to only bind to  change , pass in  lazy: true  as an  initialisation option .  As with  twoway , laziness may be specified on a per-element basis. Besides  true  (or simply having the attribute preset) and  false  values, the  lazy  directive may also be a number that specifies the number of milliseconds to wait after the last  input  event fires with subsequent  input  events resetting the timeout. For instance  input value=\"{{foo}}\" lazy  will trigger updates to  foo  on  change  and  input value=\"{{foo}}\" lazy=\"1000\"  will trigger updates 1 second after the last keypress.", 
            "title": "Lazy updates"
        }, 
        {
            "location": "/concepts/data-binding/two-way-binding/#observing-changes", 
            "text": "To use user input elsewhere in your app, you'll need to observe it using  ractive.observe() :  input placeholder='Type your name' value='{{user.name}}'   ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate\n});\n\nractive.observe( 'user.name', function ( newValue ) {\n    app.user.name = newValue;\n    triggerSomeBehaviour();\n});", 
            "title": "Observing changes"
        }, 
        {
            "location": "/concepts/events/overview/", 
            "text": "Like many libraries, Ractive implements the \npublish/subscribe\n mechanism to allow you to respond to, or trigger, particular events.\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\nactivate\nclick me!\n/button\n'\n});\n\nractive.on( 'activate', function ( event ) {\n  alert( 'Activating!' );\n});\n\n\n\n\nThere are actually two-levels of event handling in Ractive:\n\n\n\n\nThe lower-level interaction with DOM events or \ncustom events\n. These are specified using \nEvent directives\n that also specify how the event is to be handled using either \nproxy events\n or \nmethod calls\n.\n\n\nThe \npublish-subscribe\n api and event system within Ractive and between components. Proxy events bridge the DOM event into a Ractive event, whereas method calls directly invoke the ractive instance and do not use the pub/sub infrastructure.\n\n\n\n\n\nThe \npublish-subscribe\n event handling in Ractive allows you to consistently handle three different categories of generated events:\n\n\n\n\nProxy events\n, mentioned above, proxy DOM and custom events defined in your template\n\n\nMethod calls\n are a more powerful alternative to proxy events that allow you to execute one or more expressions when an event fires.\n\n\nLifecycle events\n generated by each ractive instance - such as \ninit\n, \nrender\n and \nteardown\n\n\nCustom events\n fired in code using \nractive.fire()\n, which can be anything you like\n\n\n\n\nHygiene\n\n\nOne of the advantages of using Ractive events is that, in addition to being able to manually unsubscribe events, both DOM events and\nRactive Events will be automatically unsubscribed when the ractive instance or component is torndown.\n\n\nIn practice, this means adding a template directive like \non-click='select'\n is all that is needed to manage the DOM event.", 
            "title": "Overview"
        }, 
        {
            "location": "/concepts/events/overview/#hygiene", 
            "text": "One of the advantages of using Ractive events is that, in addition to being able to manually unsubscribe events, both DOM events and\nRactive Events will be automatically unsubscribed when the ractive instance or component is torndown.  In practice, this means adding a template directive like  on-click='select'  is all that is needed to manage the DOM event.", 
            "title": "Hygiene"
        }, 
        {
            "location": "/concepts/events/bubbling/", 
            "text": "Events that fire in components will bubble up the view hierarchy - \nsee this demonstration\n. Bubbling events are namespaced by the element name used for that component in the template:\n\n\nractive = new Ractive({\n    el: document.body,\n    template: '\nwidget/\n',\n    components: {\n        widget: Ractive.extend({\n            template: '\nbutton on-click=\nselect\nSelect Me\n/button\n'\n        })\n    },\n    oninit: function () {\n        this.on( 'widget.select', function () {\n            alert('selected!');\n        });\n    }\n});\n\n\n\n\nThe event will continue to bubble up under the name of the originating component, not the name of each parent component.\n\n\nCancelling\n\n\nReturning \nfalse\n from an event handler will prevent that event from bubbling further:\n\n\nthis.on( 'widget.select', function () {\n    return false;\n});\n\n\n\n\n\nSibling event handlers will still be called. Cancelling only applies to bubbling up to the next level of the view hierarchy.\n\n\nNote that returning \nfalse\n has a dual purpose of both cancelling the view hierarchy event bubbling \nand\n cancelling the DOM Event if the event was DOM-based.\n\n\nTemplate directives for handling component events \nimplicitly\n cancel bubbling of the subscribed event:\n\n\nwidget on-foo='bar'/\n\n\n\n\n\nIn this example, \nwidget.foo\n will not bubble. Instead a new event \nbar\n will be fired and bubbled, assuming the above template is also contained in a component, under the name of the new component.\n\n\nThe \nevent.component\n Property\n\n\nEvents that bubble add a \ncomponent\n property to the event object that is the component ractive instance raising the event:\n\n\nthis.on( 'widget.select', function ( event ) {\n    event.component.observe( 'foo', function ( n, o, k ) {\n        console.log( 'foo changed from', o, 'to', n );\n    });\n});", 
            "title": "Bubbling"
        }, 
        {
            "location": "/concepts/events/bubbling/#cancelling", 
            "text": "Returning  false  from an event handler will prevent that event from bubbling further:  this.on( 'widget.select', function () {\n    return false;\n});  Sibling event handlers will still be called. Cancelling only applies to bubbling up to the next level of the view hierarchy.  Note that returning  false  has a dual purpose of both cancelling the view hierarchy event bubbling  and  cancelling the DOM Event if the event was DOM-based.  Template directives for handling component events  implicitly  cancel bubbling of the subscribed event:  widget on-foo='bar'/   In this example,  widget.foo  will not bubble. Instead a new event  bar  will be fired and bubbled, assuming the above template is also contained in a component, under the name of the new component.", 
            "title": "Cancelling"
        }, 
        {
            "location": "/concepts/events/bubbling/#the-eventcomponent-property", 
            "text": "Events that bubble add a  component  property to the event object that is the component ractive instance raising the event:  this.on( 'widget.select', function ( event ) {\n    event.component.observe( 'foo', function ( n, o, k ) {\n        console.log( 'foo changed from', o, 'to', n );\n    });\n});", 
            "title": "The event.component Property"
        }, 
        {
            "location": "/concepts/events/directives/", 
            "text": "DOM events are handled with template directives that take the form of element attributes, similar to global native DOM handlers, but are prefixed with \non-\n plus the name of the event:\n\n\nbutton on-click=\nactivate\nclick me!\n/button\n\n\n\n\n\nYou can assign multiple events by separating them with a hyphen:\n\n\ndiv on-mouseover-mousemove='@this.set( \nhover\n, true )'\n...\n/div\n\n\n\n\n\nThe structure of the attribute content will vary depending on whether you are using \nproxy events\n (the first example) or \nmethod calls\n (the second example). See each respective section for more details.\n\n\nDOM events can be any supported event on the element node. Touch events - \ntouchstart\n, \ntouchmove\n, \ntouchend\n, \ntouchcancel\n, and \ntouchleave\n (not w3c, but supported in some browsers) - can be used as well, and will be safely ignored if not supported by the current browser.\n\n\nDOM Events will be automatically unsubscribed when the ractive instance is torndown.\n\n\nCancelling DOM Events\n\n\nSee \npublish-subscribe\n for information on automatically stopping DOM event propagation and default action.\n\n\nCustom events\n\n\nIn addition to all the usual DOM events, you can use \ncustom events\n via \nevent plugins\n. These allow you to define what conditions on the node should generate a directive-level event.\n\n\nFor example, you could add gesture support to your app with \nractive-touch\n, which integrates \nHammer.js\n with Ractive.\n\n\nOnce defined, the custom event can then be used like any other event directive:\n\n\ndiv on-swipeleft=\nnextPage\n...\n/div\n\n\n\n\n\nBe aware that custom event names take precedence over native DOM event names.\n\n\nComponent event directives\n\n\nTemplate component elements can also have event directives:\n\n\nmy-widget on-foo=\nbar\n/\n\n\n\n\n\nHowever, there are some differences and limitations to component event directives:\n\n\n\n\nThese only respond to component raised events and are not DOM event or custom event subscriptions.\n\n\nArguments to proxy events are ignored\n\n\nMethod calls are not currently supported\n\n\nPattern matching \nis\n supported (see \npublish-subscribe\n):\n\n\n\n\nmy-widget on-foo.*=\nbar\n/", 
            "title": "Directives"
        }, 
        {
            "location": "/concepts/events/directives/#cancelling-dom-events", 
            "text": "See  publish-subscribe  for information on automatically stopping DOM event propagation and default action.", 
            "title": "Cancelling DOM Events"
        }, 
        {
            "location": "/concepts/events/directives/#custom-events", 
            "text": "In addition to all the usual DOM events, you can use  custom events  via  event plugins . These allow you to define what conditions on the node should generate a directive-level event.  For example, you could add gesture support to your app with  ractive-touch , which integrates  Hammer.js  with Ractive.  Once defined, the custom event can then be used like any other event directive:  div on-swipeleft= nextPage ... /div   Be aware that custom event names take precedence over native DOM event names.", 
            "title": "Custom events"
        }, 
        {
            "location": "/concepts/events/directives/#component-event-directives", 
            "text": "Template component elements can also have event directives:  my-widget on-foo= bar /   However, there are some differences and limitations to component event directives:   These only respond to component raised events and are not DOM event or custom event subscriptions.  Arguments to proxy events are ignored  Method calls are not currently supported  Pattern matching  is  supported (see  publish-subscribe ):   my-widget on-foo.*= bar /", 
            "title": "Component event directives"
        }, 
        {
            "location": "/concepts/events/method-calls/", 
            "text": "See also: \nproxy events\n\n\nNote:\n Unqualified event method calls are deprecated and have been replaced with event expressions that resolve the same way as every other expression in a Ractive template. This means that to call, for instance, \nset('foo', 'bar')\n in an event, you would now use \n@this.set('foo', 'bar')\n. Unfortunately, this adds a bit of boilerplate to common method calls, but it is also resolves the disparity between event directives and other template references, allows calling data methods from events, and allows executing multiple, possibly more complex, expressions when an event fires.\n\n\nAs an alternative to \nevent directive\n, right from your template:\n\n\np\nfoo is {{foo}}\n/p\n\n\nbutton on-click='@this.toggle(\nfoo\n)'\ntoggle foo\n/button\n\n\n\n\n\nIn this case, because \nractive.toggle()\n is a built-in method, clicking the button will toggle the value of \nfoo\n between \ntrue\n and \nfalse\n (\ndemo\n).\n\n\nThis also works with custom methods:\n\n\nvar ractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\n@this.klaxon()\nsound the klaxon\n/button\n',\n  audio: new Audio( 'klaxon.mp3' ),\n  klaxon: function () {\n    this.audio.play();\n  }\n});\n\n\n\n\nYou can pass as many arguments to the method as you like, including data references:\n\n\n{{#each items :i}}\n  \nbutton on-click='@this.select(this,i)'\nselect this item\n/button\n\n{{/each}}\n\n\n\n\nNotice that mustaches are \nnot\n used with data reference in method calls, i.e. \n{{i}}\n and will cause errors if they are. String literals need to be in quotes:\n\n\nbutton on-click='@this.set(\nfoo\n, true)'\nmake foo true\n/button\n\n\n\n\n\nYou can also pass the \nevent\n object, or properties thereof (\nevent.original\n is the original DOM event) (\ndemo\n):\n\n\ndiv\n  on-mousemove='@this.set({\n    x: event.original.clientX,\n    y: event.original.clientY\n  })'\n  on-mouseleave='@this.set({\n    x: \nunknown\n,\n    y: \nunknown\n\n  })'\n\n\n  \np\ncurrent mouse position: {{x}} x {{y}}\n/p\n\n\n/div\n\n\n\n\n\nThe \nevent\n object is also available within body of the method call function as \nthis.event\n. Note that methods on your Ractive instance that may handle your events are effectively part of your public API, and \nthis.event\n will only be available during invocations triggered by an event.\n\n\nThe \nevent\n argument is also extended with contextual helper methods. See \nhelpers\n.\n\n\nIf you need to evaluate multiple expressions from an event directive, simply separate them with a \n,\n. For instance:\n\n\n{{#each someList as item}}\n\ndiv\n\n  {{item.display}}\n  \na href=\n#\n on-click=\nevent.pop('../'), @this.notifyUser('item removed!'), false\n\n    Remove and Notify\n  \n/a\n\n\n/div\n\n{{/each}}\n\n\n\n\nNote that this is a list of independent expressions, and as long as one doesn't throw, they will all be evaluated.\n\n\nCancelling events\n\n\nAs with proxy events, you can cancel a DOM event by returning \nfalse\n from your event handler. Ractive with then call \npreventDefault()\n and \nstopPropagation()\n on the original DOM event. You can also call any methods on the original event by having it passed to your handler or accessing it using \nthis.event.original\n. With event expressions, you can force the cancellation regardless of the return from any methods you call by simply including \nfalse\n as the last expression in your list, as above in the 'Remove and Notify' example. You can also override cancellation in much the same way by using \ntrue\n instead of \nfalse\n.", 
            "title": "Method Calls"
        }, 
        {
            "location": "/concepts/events/method-calls/#cancelling-events", 
            "text": "As with proxy events, you can cancel a DOM event by returning  false  from your event handler. Ractive with then call  preventDefault()  and  stopPropagation()  on the original DOM event. You can also call any methods on the original event by having it passed to your handler or accessing it using  this.event.original . With event expressions, you can force the cancellation regardless of the return from any methods you call by simply including  false  as the last expression in your list, as above in the 'Remove and Notify' example. You can also override cancellation in much the same way by using  true  instead of  false .", 
            "title": "Cancelling events"
        }, 
        {
            "location": "/concepts/events/proxy-events/", 
            "text": "See also: \nmethod calls from templates\n\n\nRactive has a concept of \nproxy events\n, which translate a user \naction\n (e.g. a mouseclick) defined via an \nevent directive\n into an \nintention\n (e.g. 'select this option'). This allows you to handle user interaction in a readable, declarative fashion, without resorting to peppering your markup with class names to use as 'hooks' (which must then be kept consistent between your markup and your JavaScript code).\n\n\nAs with all events in Ractive, you subscribe with \nractive.on()\n (also see \npublish-subscribe\n). Proxy events declare the handler name of the event that will be fired, along with any optional arguments:\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\nactivate\nclick me!\n/button\n'\n});\n\nractive.on( 'activate', function ( event ) {\n  alert( 'Activating!' );\n});\n\n\n\n\nIn this example, it is \nactivate\n (and not \nclick\n!) that is the name of the handler event that will be fired for any registered handlers created via \nractive.on()\n.\n\n\nEvent arguments\n\n\nThe \nevent\n object\n\n\nThe first argument to a proxy event handler is always a Ractive \nevent\n object. It contains various properties:\n\n\n\n\nevent.name\n - the name of the event, in this case 'activate'\n\n\nevent.node\n - the DOM node in question\n\n\nevent.keypath\n - the \nkeypath\n of the current context\n\n\nevent.context\n - the value of \nthis.get(event.keypath)\n\n\nevent.index\n - a map of index references\n\n\nevent.component\n - the component that raised the event, only present on \nbubbled events\n\n\nevent.original\n - the original DOM event, if available\n\n\n\n\nIn the example above, \nevent.keypath\n might be \nitems.0\n for the first item in the list, \nitems.1\n for the second, and so on. The \nevent.index\n map would have a property \ni\n, which would correspond to those indices.\n\n\nThe event object is also available in event handlers using \nthis.event\n, see \npublish-subscribe\n for more details.\n\n\nCustom arguments\n\n\nNOTE:\n Arguments to proxy events have been deprecated because they are too easy to break. If you need to pass arguments with your event, you can use \n@this.fire('myEvent', event, arg1, arg2, etc)\n.\n\n\nWe might want to pass arguments to our handler in addition to the \nevent\n object. We can do that by listing them, comma-separated, after the event name:\n\n\nh1\nLet's shop!\n/h1\n\n\nul\n\n  {{#each items: i}}\n    \nli\n\n      \np\n{{i+1}}: {{description}}\n/p\n\n      \nlabel\ninput value='{{qty}}'\n Quantity\n/label\n\n\n      \n!-- when the user clicks this button, add {{qty}} of this item --\n\n      \nbutton on-click='addToCart:{{this}},{{qty}}'\nAdd to cart\n/button\n\n    \n/li\n\n  {{/each}}\n\n/ul\n\n\n\n\n\nractive.on( 'addToCart', function ( event, item, qty ) {\n  /* code goes here */\n});\n\n\n\n\nCancelling DOM events\n\n\nIf you return \nfalse\n from a proxy event handler, ractive will automatically call both \npreventDefault()\n and \nstopPropagation()\n on the original DOM event.\n\n\nNote that returning \nfalse\n has a dual purpose of both cancelling further bubbling up the view hierarchy \nevent bubbling\n \nas well as\n cancelling the DOM Event if the event was DOM-based.\n\n\nIf you only want to cancel the DOM event, you can call the appropriate methods directly on \nevent.original\n or \nthis.event.original\n, which are both references to the current DOM event object.\n\n\nReserved event names\n\n\nNote: the built-in \nlifecycle events\n are \nreserved\n, which means you can't use their names as proxy events.\n\n\nDynamic proxy event names\n\n\nMustache references\n can be used as proxy event names:\n\n\nbutton on-click=\n{{handler}}\nclick me!\n/button\n\n\n\n\n\nIn practive this is of limited value, but a more important side effect is that if no handler is specified (a falsey value) the DOM event is not subscribed and will unsubscribe or resubscribe as the handler value changes. Combined with a conditional section, this allows a proxy event to be conditionally subscribed \nat the DOM level\n:\n\n\nbutton on-click=\n{{#active}}select{{/}}\nclick me!\n/button\n\n\n\n\n\nIn this example, the DOM \nclick\n event is subscribed and unsubscribed as the value of \nactive\n is truthy or falsey.", 
            "title": "Proxy Events"
        }, 
        {
            "location": "/concepts/events/proxy-events/#event-arguments", 
            "text": "", 
            "title": "Event arguments"
        }, 
        {
            "location": "/concepts/events/proxy-events/#the-event-object", 
            "text": "The first argument to a proxy event handler is always a Ractive  event  object. It contains various properties:   event.name  - the name of the event, in this case 'activate'  event.node  - the DOM node in question  event.keypath  - the  keypath  of the current context  event.context  - the value of  this.get(event.keypath)  event.index  - a map of index references  event.component  - the component that raised the event, only present on  bubbled events  event.original  - the original DOM event, if available   In the example above,  event.keypath  might be  items.0  for the first item in the list,  items.1  for the second, and so on. The  event.index  map would have a property  i , which would correspond to those indices.  The event object is also available in event handlers using  this.event , see  publish-subscribe  for more details.", 
            "title": "The event object"
        }, 
        {
            "location": "/concepts/events/proxy-events/#custom-arguments", 
            "text": "NOTE:  Arguments to proxy events have been deprecated because they are too easy to break. If you need to pass arguments with your event, you can use  @this.fire('myEvent', event, arg1, arg2, etc) .  We might want to pass arguments to our handler in addition to the  event  object. We can do that by listing them, comma-separated, after the event name:  h1 Let's shop! /h1  ul \n  {{#each items: i}}\n     li \n       p {{i+1}}: {{description}} /p \n       label input value='{{qty}}'  Quantity /label \n\n       !-- when the user clicks this button, add {{qty}} of this item -- \n       button on-click='addToCart:{{this}},{{qty}}' Add to cart /button \n     /li \n  {{/each}} /ul   ractive.on( 'addToCart', function ( event, item, qty ) {\n  /* code goes here */\n});", 
            "title": "Custom arguments"
        }, 
        {
            "location": "/concepts/events/proxy-events/#cancelling-dom-events", 
            "text": "If you return  false  from a proxy event handler, ractive will automatically call both  preventDefault()  and  stopPropagation()  on the original DOM event.  Note that returning  false  has a dual purpose of both cancelling further bubbling up the view hierarchy  event bubbling   as well as  cancelling the DOM Event if the event was DOM-based.  If you only want to cancel the DOM event, you can call the appropriate methods directly on  event.original  or  this.event.original , which are both references to the current DOM event object.", 
            "title": "Cancelling DOM events"
        }, 
        {
            "location": "/concepts/events/proxy-events/#reserved-event-names", 
            "text": "Note: the built-in  lifecycle events  are  reserved , which means you can't use their names as proxy events.", 
            "title": "Reserved event names"
        }, 
        {
            "location": "/concepts/events/proxy-events/#dynamic-proxy-event-names", 
            "text": "Mustache references  can be used as proxy event names:  button on-click= {{handler}} click me! /button   In practive this is of limited value, but a more important side effect is that if no handler is specified (a falsey value) the DOM event is not subscribed and will unsubscribe or resubscribe as the handler value changes. Combined with a conditional section, this allows a proxy event to be conditionally subscribed  at the DOM level :  button on-click= {{#active}}select{{/}} click me! /button   In this example, the DOM  click  event is subscribed and unsubscribed as the value of  active  is truthy or falsey.", 
            "title": "Dynamic proxy event names"
        }, 
        {
            "location": "/concepts/events/publish-subscribe/", 
            "text": "Like many libraries, Ractive implements the \npublish/subscribe\n mechanism to allow you to respond to, or trigger, particular events.\n\n\nSubscribe\n\n\nTo subscribe to an event, use \nractive.on()\n:\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\nactivate\nclick me!\n/button\n'\n});\n\nractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});\n\n\n\n\nThis can be used to subscribe to any of the following type of events:\n\n\n\n\nProxy events\n for DOM and custom events defined in your template\n\n\nLifecycle events\n generated by each ractive instance - such as \ninit\n, \nrender\n and \nteardown\n\n\nCustom events\n fired in code using \nractive.fire()\n, which can be anything you like, see below.\n\n\n\n\nMultiple events to one handler\n\n\nYou can subscribe a handler to more than one event by separating event names with a space:\n\n\nractive.on( 'activate select', function () {...} );\n\n\n\n\nThis example will fire for either an \nactivate\n event or a \nselect\n event.\n\n\nObject map of multiple event/handler pairs\n\n\nMultiple hander/function pairs can be subscribed using an object hash:\n\n\nractive.on({\n    activate: function () {...},\n    select: function () {...}\n});\n\n\n\n\nWildcard pattern handlers\n\n\nEvent names that use a keypath-like name can be subscribed using the pattern-matching wildcard \"\n*\n\" for any name path segment:\n\n\nractive.on( 'foo.*', function () {...} );\n\n\n\n\nThis example will fire on any event name that starts with \nfoo.\n - \nfoo.active\n, \nfoo.select\n, etc.\n\n\nThis is very useful with \nevent bubbling\n and auto-prefixed event names that bubble up from components.\n\n\nBe aware that handlers like \nwidget.*\n or \n*\n will fire for \nall\n matching events, including \nlifecycle events\n.\n\n\nAccessing the event object\n\n\nIn addition to the event argument that is passed with proxy events, the event object can be accessed using \nthis.event\n in the function body of any handler. This object is also present in non-proxy events including lifecycle events, though it includes a more limited set of properties.\n\n\nProperties on all \nthis.event\n objects:\n\n\n\n\nthis.event.name\n - the name of the event\n\n\nthis.event.context\n - the value of \nthis.get(event.keypath)\n or \nractive.get()\n for non-proxy events\n\n\nthis.event.component\n - the component that raised the event, only present on \nbubbled events\n\n\nthis.event.original\n - the original DOM event, if available\n\n\n\n\nProperties only on proxy events:\n\n \nthis.event.node\n - the DOM node in question\n\n \nthis.event.keypath\n - the \nkeypath\n of the current context\n* \nthis.event.index\n - a map of index references\n\n\nOne useful aspect of \nthis.event\n is that the name of the event can be determined when wildcards are used:\n\n\nractive.on( 'foo.*', function () {\n    console.log( this.event.name );\n});\n\n\n\n\nCancelling DOM events\n\n\nIf you return 'false' from a proxy event handler, ractive will automatically call both \npreventDefault()\n and \nstopPropagation()\n on the original DOM event.\n\n\nNote that returning \nfalse\n has a dual purpose of both cancelling the view hierarchy \nevent bubbling\n \nas well as\n cancelling the DOM Event if the event was DOM-based.\n\n\nUnsubscribe\n\n\nEvent handlers are automatically removed if the instance is torn down (e.g. with \nractive.teardown()\n) (which also happens as components are removed due to template/data logic).\n\n\nYou can also unsubscribe event handlers manually using one of two approaches:\n\n\nvar listener = ractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});\n\n// later...\nlistener.cancel();\n\n\n\n\nor...\n\n\nvar handler = function () {\n  alert( 'Activating!' );\n};\n\nractive.on( 'activate', handler );\n\n// later...\nractive.off( 'activate', handler );\n\n\n\n\nIn the second case, note that if you don't specify a handler, all 'activate' handlers will be removed. If you don't specify an event name, \nall\n event handlers will be removed from the instance. See \nractive.off()\n for more detail.\n\n\nThe \nractive.off()\n method is chainable for easily replacing subscribtions:\n\n\nractive.off( 'activate' ).on( 'activate', function () {...} );\n\n\n\n\nPublish\n\n\nIn addition to the built-in \nlifecycle events\n and \nproxy events\n, you can fire your own events with \nractive.fire()\n.\n\n\nThis is most useful in the context of a \ncomponent\n that needs to emit custom events. Here's a (somewhat contrived) example:\n\n\nvar Ticker = Ractive.extend({\n  oninit: function () {\n    var i = 1;\n\n    this.interval = setInterval( function () {\n      this.fire( 'tick', i++ );\n    }.bind( this ), 1000 );\n  },\n  onteardown: function () {\n    clearInterval( this.interval );\n  }\n});\n\nvar ticker = new Ticker();\n\nticker.on( 'tick', function ( i ) {\n  console.log( i % 2 ? 'tick' : 'tock' );\n});", 
            "title": "Publish-Subscribe"
        }, 
        {
            "location": "/concepts/events/publish-subscribe/#subscribe", 
            "text": "To subscribe to an event, use  ractive.on() :  ractive = new Ractive({\n  el: 'body',\n  template: ' button on-click= activate click me! /button '\n});\n\nractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});  This can be used to subscribe to any of the following type of events:   Proxy events  for DOM and custom events defined in your template  Lifecycle events  generated by each ractive instance - such as  init ,  render  and  teardown  Custom events  fired in code using  ractive.fire() , which can be anything you like, see below.", 
            "title": "Subscribe"
        }, 
        {
            "location": "/concepts/events/publish-subscribe/#multiple-events-to-one-handler", 
            "text": "You can subscribe a handler to more than one event by separating event names with a space:  ractive.on( 'activate select', function () {...} );  This example will fire for either an  activate  event or a  select  event.", 
            "title": "Multiple events to one handler"
        }, 
        {
            "location": "/concepts/events/publish-subscribe/#object-map-of-multiple-eventhandler-pairs", 
            "text": "Multiple hander/function pairs can be subscribed using an object hash:  ractive.on({\n    activate: function () {...},\n    select: function () {...}\n});", 
            "title": "Object map of multiple event/handler pairs"
        }, 
        {
            "location": "/concepts/events/publish-subscribe/#wildcard-pattern-handlers", 
            "text": "Event names that use a keypath-like name can be subscribed using the pattern-matching wildcard \" * \" for any name path segment:  ractive.on( 'foo.*', function () {...} );  This example will fire on any event name that starts with  foo.  -  foo.active ,  foo.select , etc.  This is very useful with  event bubbling  and auto-prefixed event names that bubble up from components.  Be aware that handlers like  widget.*  or  *  will fire for  all  matching events, including  lifecycle events .", 
            "title": "Wildcard pattern handlers"
        }, 
        {
            "location": "/concepts/events/publish-subscribe/#accessing-the-event-object", 
            "text": "In addition to the event argument that is passed with proxy events, the event object can be accessed using  this.event  in the function body of any handler. This object is also present in non-proxy events including lifecycle events, though it includes a more limited set of properties.  Properties on all  this.event  objects:   this.event.name  - the name of the event  this.event.context  - the value of  this.get(event.keypath)  or  ractive.get()  for non-proxy events  this.event.component  - the component that raised the event, only present on  bubbled events  this.event.original  - the original DOM event, if available   Properties only on proxy events:   this.event.node  - the DOM node in question   this.event.keypath  - the  keypath  of the current context\n*  this.event.index  - a map of index references  One useful aspect of  this.event  is that the name of the event can be determined when wildcards are used:  ractive.on( 'foo.*', function () {\n    console.log( this.event.name );\n});", 
            "title": "Accessing the event object"
        }, 
        {
            "location": "/concepts/events/publish-subscribe/#cancelling-dom-events", 
            "text": "If you return 'false' from a proxy event handler, ractive will automatically call both  preventDefault()  and  stopPropagation()  on the original DOM event.  Note that returning  false  has a dual purpose of both cancelling the view hierarchy  event bubbling   as well as  cancelling the DOM Event if the event was DOM-based.", 
            "title": "Cancelling DOM events"
        }, 
        {
            "location": "/concepts/events/publish-subscribe/#unsubscribe", 
            "text": "Event handlers are automatically removed if the instance is torn down (e.g. with  ractive.teardown() ) (which also happens as components are removed due to template/data logic).  You can also unsubscribe event handlers manually using one of two approaches:  var listener = ractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});\n\n// later...\nlistener.cancel();  or...  var handler = function () {\n  alert( 'Activating!' );\n};\n\nractive.on( 'activate', handler );\n\n// later...\nractive.off( 'activate', handler );  In the second case, note that if you don't specify a handler, all 'activate' handlers will be removed. If you don't specify an event name,  all  event handlers will be removed from the instance. See  ractive.off()  for more detail.  The  ractive.off()  method is chainable for easily replacing subscribtions:  ractive.off( 'activate' ).on( 'activate', function () {...} );", 
            "title": "Unsubscribe"
        }, 
        {
            "location": "/concepts/events/publish-subscribe/#publish", 
            "text": "In addition to the built-in  lifecycle events  and  proxy events , you can fire your own events with  ractive.fire() .  This is most useful in the context of a  component  that needs to emit custom events. Here's a (somewhat contrived) example:  var Ticker = Ractive.extend({\n  oninit: function () {\n    var i = 1;\n\n    this.interval = setInterval( function () {\n      this.fire( 'tick', i++ );\n    }.bind( this ), 1000 );\n  },\n  onteardown: function () {\n    clearInterval( this.interval );\n  }\n});\n\nvar ticker = new Ticker();\n\nticker.on( 'tick', function ( i ) {\n  console.log( i % 2 ? 'tick' : 'tock' );\n});", 
            "title": "Publish"
        }, 
        {
            "location": "/concepts/rendering/progressive-enhancement/", 
            "text": "Progressive Enhancement\n\n\nTODO", 
            "title": "Progressive Enhancement"
        }, 
        {
            "location": "/concepts/rendering/progressive-enhancement/#progressive-enhancement", 
            "text": "TODO", 
            "title": "Progressive Enhancement"
        }, 
        {
            "location": "/concepts/rendering/server-side-rendering/", 
            "text": "Server-Side Rendering\n\n\nTODO", 
            "title": "Server-Side Rendering"
        }, 
        {
            "location": "/concepts/rendering/server-side-rendering/#server-side-rendering", 
            "text": "TODO", 
            "title": "Server-Side Rendering"
        }, 
        {
            "location": "/concepts/security/csp/", 
            "text": "CSP\n\n\nTo use ractive with \nContent Security Policy\n, you'll currently need \n'unsafe-eval'\n specified for \nscriptSrc\n in your CSP header. This may change in future - see https://github.com/ractivejs/ractive/issues/1897 .", 
            "title": "CSP"
        }, 
        {
            "location": "/concepts/security/csp/#csp", 
            "text": "To use ractive with  Content Security Policy , you'll currently need  'unsafe-eval'  specified for  scriptSrc  in your CSP header. This may change in future - see https://github.com/ractivejs/ractive/issues/1897 .", 
            "title": "CSP"
        }, 
        {
            "location": "/concepts/templates/elements/", 
            "text": "Elements\n\n\nStrictly speaking, Ractive templates are are not HTML. It has a few special directives and other constructs built into its element representation to make DOM manipulation a bit easier. You can think of them as \"HTML-like\" - they look like HTML for ease of authoring but are not really HTML nor even a superset of HTML. However, when rendered, they are emitted as perfectly valid HTML.\n\n\nIn addition, Ractive's template parser is not quite as forgiving as the browser's HTML parser either and may throw parser errors where it sees ambiguity. However, it does allow things like implicitly closed elements.\n\n\nConditional attributes\n\n\nYou can wrap one or more attributes inside an element tag in a conditional section, and Ractive will add and remove those attributes as the conditional section is rendered and unrendered. For instance:\n\n\ndiv {{#if highlighted}}class=\nhighlighted\n{{/if}}\nHighlightable element\n/div\n\n\n\n\n\nAny number of attributes can be used in a section, and other \nMustache\n constructs can be used to supply attributes.\n\n\ndiv {{#if highlighted}}class=\nhighlighted {{ anotherClass }}\n title=\nI'm highlighted\n{{/if}}\nHighlightable element\n/div", 
            "title": "Elements"
        }, 
        {
            "location": "/concepts/templates/elements/#elements", 
            "text": "Strictly speaking, Ractive templates are are not HTML. It has a few special directives and other constructs built into its element representation to make DOM manipulation a bit easier. You can think of them as \"HTML-like\" - they look like HTML for ease of authoring but are not really HTML nor even a superset of HTML. However, when rendered, they are emitted as perfectly valid HTML.  In addition, Ractive's template parser is not quite as forgiving as the browser's HTML parser either and may throw parser errors where it sees ambiguity. However, it does allow things like implicitly closed elements.", 
            "title": "Elements"
        }, 
        {
            "location": "/concepts/templates/elements/#conditional-attributes", 
            "text": "You can wrap one or more attributes inside an element tag in a conditional section, and Ractive will add and remove those attributes as the conditional section is rendered and unrendered. For instance:  div {{#if highlighted}}class= highlighted {{/if}} Highlightable element /div   Any number of attributes can be used in a section, and other  Mustache  constructs can be used to supply attributes.  div {{#if highlighted}}class= highlighted {{ anotherClass }}  title= I'm highlighted {{/if}} Highlightable element /div", 
            "title": "Conditional attributes"
        }, 
        {
            "location": "/concepts/templates/expressions/", 
            "text": "Expressions allow you to use logic within a template. At their simplest, that may just mean a basic arithmetic operation, such as converting to percentages, or making your \nindex references\n start at 1 rather than 0:\n\n\ndiv class='bar-chart'\n\n  {{#bars:i}}\n    \ndiv style='width: {{ value * 100 }}%;'\n{{ i + 1 }}\n/div\n\n  {{/bars}}\n\n/div\n\n\n\n\n\nOr it could mean formatting a currency so that \n1.79\n renders as \n\u00a31.79p\n:\n\n\np\nPrice: \nstrong\n{{ format( price ) }}\n/strong\n/p\n\n\n\n\n\nOr it could mean adding a class based on some condition:\n\n\na class='button {{ active ? \non\n : \noff\n }}'\nswitch\n/a\n\n\n\n\n\nOr it could mean filtering a list to exclude certain records:\n\n\nul\n\n{{# exclude( list, 'N/A' ) }}\n  \nli\n{{author}}: {{title}}\n/li\n\n{{/ end of filter }}\n\n/ul\n\n\n\n\n\nThese are all examples casually plucked from the air - whether they would be useful or not in real life depends on what you're trying to do. The point is that you can include more of your view logic at the declarative layer - the template - where it's easier to \nreason about\n.\n\n\nFrequently Used Expressions\n\n\nIf you use a particular expression frequently, you can save time by adding it Ractive's default data. This way you won't have to set up the expressions on each individual \nractive\n instance.\n\n\nThe example below adds expressions for some frequenlty used parts of \nmoment.js\n to the default data:\n\n\nvar helpers = Ractive.defaults.data;\nhelpers.fromNow = function(timeString){\n    return moment(timeString).fromNow()\n}\nhelpers.formatTime = function(timeString){\n    return moment(timeString).format(\nddd, h:mmA\n);\n}\nhelpers.humanizeTime = function(timeString){\n    return moment.duration(timeString).humanize();\n}\n\n\n\n\nValid expressions\n\n\nThese are, of course, JavaScript expressions. Almost any valid JavaScript expression can be used, with a few exceptions:\n\n\n\n\nNo assignment operators (i.e. \na = b\n, \na += 1\n, \na--\n and so on)\n\n\nNo \nnew\n, \ndelete\n, or \nvoid\n operators\n\n\nNo function literals (i.e. anything that involves the \nfunction\n keyword)\n\n\n\n\nAside from a subset of global objects (e.g. \nMath\n, \nArray\n, \nparseInt\n, \nencodeURIComponent\n - full list below), any references must be to properties (however deeply nested) of the Ractive instance's data, rather than arbitrary variables. Reference resolution follows the \nnormal process\n.\n\n\nDoes this use \neval\n?\n\n\nYes and no. You've probably read that 'eval is evil', or some other such nonsense. The truth is that while it does get abused, and can theoretically introduce security risks when user input gets involved, there are some situations where it's both necessary and sensible.\n\n\nBut repeatedly \neval\ning the same code is a performance disaster. Instead, we use the \nFunction\n constructor, which is a form of \neval\n, except that the code gets compiled once instead of every time it executes.\n\n\nA note about efficiency\n\n\nUsing the \nFunction\n constructor instead of \neval\n is just one way that Ractive optimises expressions. Consider a case like this:\n\n\n{{a}} + {{b}} = {{ a + b }}\n{{c}} + {{d}} = {{ c+d }}\n\n\n\n\nAt \nparse time\n, Ractive generates an \nabstract syntax tree\n (AST) from these expressions, to verify that it's a valid expression and to extract any references that are used. It then 'stringifies' the AST, so that the expression can later be compiled into a function.\n\n\nAs anyone who has seen minified JavaScript can attest, JavaScript cares not one fig what your variables are called. It also doesn't care about whitespace. So both of the expressions can be stringified the same way:\n\n\n_0+_1\n\n\n\n\n\nWhen we \nevaluate\n \n{{ a + b }}\n or \n{{ c+d }}\n, we can therefore use the same function but with different arguments. Recognising this, the function only gets compiled once, after which it is cached. (The cache is shared between all Ractive instances on the page.) Further, the result of the evaluation is itself cached (until one or more of the dependencies change), so you can repeat expressions as often as you like without creating unnecessary work.\n\n\nAll of this means that you could have an expression within a list section that was repeated 10,000 times, and the corresponding function would be created once \nat most\n, and only called when necessary.\n\n\nThe \nthis\n reference\n\n\nWithin an expression, you can use \nthis\n to refer to the current \ncontext\n:\n\n\nul\n\n  {{#items}}\n    \n!-- here, `this` means 'the current array member' --\n\n    \nli\n{{this.toUpperCase()}}\n/li\n\n  {{/items}}\n\n/ul\n\n\n\n\n\nIn regular mustache, we have something called the \nimplicit iterator\n - \n{{.}}\n - which does the same thing. Ractive allows you to use \nthis\n in place of \n.\n for purely aesthetic reasons.\n\n\nSupported global objects\n\n\n\n\nArray\n\n\nDate\n\n\nJSON\n\n\nMath\n\n\nNaN\n\n\nRegExp\n\n\ndecodeURI\n\n\ndecodeURIComponent\n\n\nencodeURI\n\n\nencodeURIComponent\n\n\nisFinite\n\n\nisNaN\n\n\nnull\n\n\nparseFloat\n\n\nparseInt\n\n\nundefined\n\n\n\n\nFunctions\n\n\nAny functions that you want to call, outside of the available globals above, must be properties of the Ractive instance's data as well. Functions can also depend on other references and will be re-evaulated when one of their dependencies is changed.\n\n\nDepedendencies are determined by capturing references in the viewmodel while the function is executing. Dependencies for functions are re-captured each time the function is executed.\n\n\np\n{{ formattedName() }}\n/p\n\n\n\n\n\nvar ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    user: { firstName: 'John', lastName: 'Public' },\n    formattedName: function() {\n      return this.get('user.lastName') + ', ' + this.get('user.firstName');\n    }\n  }\n};\n\n\n\n\nResult:\n\n\np\nPublic, John\n/p\n\n\n\n\n\nIn this example, the function \nformattedName\n will depend on both \nuser.firstName\n and \nuser.lastName\n, and updating either (or \nuser\n) will cause any expressions referencing \nformattedName\n to be re-evaluated as well.\n\n\nractive.set('user.firstName', 'Jane')\n\n\n\n\nResult:\n\n\np\nPublic, Jane\n/p\n\n\n\n\n\nFunctions on helper objects and third-party libraries\n\n\nYou can also add helper objects to your data and call functions on those objects in expressions. For example, you could add a reference to \nunderscore.js\n:\n\n\nvar ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    items: [ 2, 10, 200, 3, 1, 4],\n    _: _\n  }\n};\n\n\n\n\nAnd use that to sort an array in your template:\n\n\n{{# _.sortBy(items) }}{{.}}, {{/}}\n\n\n!-- Result: --\n\n1, 2, 3, 4, 10, 200,", 
            "title": "Expressions"
        }, 
        {
            "location": "/concepts/templates/expressions/#frequently-used-expressions", 
            "text": "If you use a particular expression frequently, you can save time by adding it Ractive's default data. This way you won't have to set up the expressions on each individual  ractive  instance.  The example below adds expressions for some frequenlty used parts of  moment.js  to the default data:  var helpers = Ractive.defaults.data;\nhelpers.fromNow = function(timeString){\n    return moment(timeString).fromNow()\n}\nhelpers.formatTime = function(timeString){\n    return moment(timeString).format( ddd, h:mmA );\n}\nhelpers.humanizeTime = function(timeString){\n    return moment.duration(timeString).humanize();\n}", 
            "title": "Frequently Used Expressions"
        }, 
        {
            "location": "/concepts/templates/expressions/#valid-expressions", 
            "text": "These are, of course, JavaScript expressions. Almost any valid JavaScript expression can be used, with a few exceptions:   No assignment operators (i.e.  a = b ,  a += 1 ,  a--  and so on)  No  new ,  delete , or  void  operators  No function literals (i.e. anything that involves the  function  keyword)   Aside from a subset of global objects (e.g.  Math ,  Array ,  parseInt ,  encodeURIComponent  - full list below), any references must be to properties (however deeply nested) of the Ractive instance's data, rather than arbitrary variables. Reference resolution follows the  normal process .", 
            "title": "Valid expressions"
        }, 
        {
            "location": "/concepts/templates/expressions/#does-this-use-eval", 
            "text": "Yes and no. You've probably read that 'eval is evil', or some other such nonsense. The truth is that while it does get abused, and can theoretically introduce security risks when user input gets involved, there are some situations where it's both necessary and sensible.  But repeatedly  eval ing the same code is a performance disaster. Instead, we use the  Function  constructor, which is a form of  eval , except that the code gets compiled once instead of every time it executes.", 
            "title": "Does this use eval?"
        }, 
        {
            "location": "/concepts/templates/expressions/#a-note-about-efficiency", 
            "text": "Using the  Function  constructor instead of  eval  is just one way that Ractive optimises expressions. Consider a case like this:  {{a}} + {{b}} = {{ a + b }}\n{{c}} + {{d}} = {{ c+d }}  At  parse time , Ractive generates an  abstract syntax tree  (AST) from these expressions, to verify that it's a valid expression and to extract any references that are used. It then 'stringifies' the AST, so that the expression can later be compiled into a function.  As anyone who has seen minified JavaScript can attest, JavaScript cares not one fig what your variables are called. It also doesn't care about whitespace. So both of the expressions can be stringified the same way:  _0+_1   When we  evaluate   {{ a + b }}  or  {{ c+d }} , we can therefore use the same function but with different arguments. Recognising this, the function only gets compiled once, after which it is cached. (The cache is shared between all Ractive instances on the page.) Further, the result of the evaluation is itself cached (until one or more of the dependencies change), so you can repeat expressions as often as you like without creating unnecessary work.  All of this means that you could have an expression within a list section that was repeated 10,000 times, and the corresponding function would be created once  at most , and only called when necessary.", 
            "title": "A note about efficiency"
        }, 
        {
            "location": "/concepts/templates/expressions/#the-this-reference", 
            "text": "Within an expression, you can use  this  to refer to the current  context :  ul \n  {{#items}}\n     !-- here, `this` means 'the current array member' -- \n     li {{this.toUpperCase()}} /li \n  {{/items}} /ul   In regular mustache, we have something called the  implicit iterator  -  {{.}}  - which does the same thing. Ractive allows you to use  this  in place of  .  for purely aesthetic reasons.", 
            "title": "The this reference"
        }, 
        {
            "location": "/concepts/templates/expressions/#supported-global-objects", 
            "text": "Array  Date  JSON  Math  NaN  RegExp  decodeURI  decodeURIComponent  encodeURI  encodeURIComponent  isFinite  isNaN  null  parseFloat  parseInt  undefined", 
            "title": "Supported global objects"
        }, 
        {
            "location": "/concepts/templates/expressions/#functions", 
            "text": "Any functions that you want to call, outside of the available globals above, must be properties of the Ractive instance's data as well. Functions can also depend on other references and will be re-evaulated when one of their dependencies is changed.  Depedendencies are determined by capturing references in the viewmodel while the function is executing. Dependencies for functions are re-captured each time the function is executed.  p {{ formattedName() }} /p   var ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    user: { firstName: 'John', lastName: 'Public' },\n    formattedName: function() {\n      return this.get('user.lastName') + ', ' + this.get('user.firstName');\n    }\n  }\n};  Result:  p Public, John /p   In this example, the function  formattedName  will depend on both  user.firstName  and  user.lastName , and updating either (or  user ) will cause any expressions referencing  formattedName  to be re-evaluated as well.  ractive.set('user.firstName', 'Jane')  Result:  p Public, Jane /p", 
            "title": "Functions"
        }, 
        {
            "location": "/concepts/templates/expressions/#functions-on-helper-objects-and-third-party-libraries", 
            "text": "You can also add helper objects to your data and call functions on those objects in expressions. For example, you could add a reference to  underscore.js :  var ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    items: [ 2, 10, 200, 3, 1, 4],\n    _: _\n  }\n};  And use that to sort an array in your template:  {{# _.sortBy(items) }}{{.}}, {{/}} !-- Result: -- \n1, 2, 3, 4, 10, 200,", 
            "title": "Functions on helper objects and third-party libraries"
        }, 
        {
            "location": "/concepts/templates/keypaths/", 
            "text": "The main way to interact with a Ractive instance is by setting \nkeypaths\n. A keypath is a string representing the location of a piece of data:\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n});\n\n// Simple keypath\nractive.get( 'foo' ); // returns { bar: 'baz' }\n\n// Compound keypath\nractive.get( 'foo.bar' ); // returns 'baz'\n\n\n\n\nUpstream and downstream keypaths\n\n\nIn the example above, we say that \n'foo.bar'\n is a \ndownstream keypath\n of \n'foo'\n, while \n'foo'\n is an \nupstream keypath\n of \n'foo.bar'\n.\n\n\nArray versus dot notation\n\n\nThe \n'foo.bar'\n keypath is an example of \ndot notation\n. With arrays, you can use dot notation or \narray notation\n, which may feel more familiar (internally, it gets converted to dot notation):\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [ 'a', 'b', 'c' ]\n  }\n});\n\n// Array notation\nractive.get( 'list[0]' ); // returns 'a'\n\n// Dot notation\nractive.get( 'list.0' ); // also returns 'a'\n\n\n\n\nMissing properties\n\n\nOrdinarily in JavaScript, trying to access a child property of an object that didn't exist would cause an error:\n\n\ndata = { numbers: [ 1, 2, 3 ]};\ndata.letters[0]; // throws an error - cannot read property '0' of undefined\n\n\n\n\nWithin Ractive, this will simply return \nundefined\n:\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    numbers: [ 1, 2, 3 ]\n  }\n});\n\nractive.get( 'letters[0]' ); // returns undefined\n\n\n\n\nEscaping\n\n\nWhile not ideal, sometimes properties of objects have \n.\ns in name e.g. \nfoo['bar.baz']\n. Note that while numbers are supported in array notation, strings are not. To access a peypath with a literal \n.\n in one of the keys, you can escape it with a \n\\\n e.g. \nfoo.bar\\.baz\n. Any keys accessible in the template will be unescaped, so if you're trying to use them with simple string concatenation to access a keypath with a \n.\n in it, you'll need to make sure you escape it first.", 
            "title": "Keypaths"
        }, 
        {
            "location": "/concepts/templates/keypaths/#upstream-and-downstream-keypaths", 
            "text": "In the example above, we say that  'foo.bar'  is a  downstream keypath  of  'foo' , while  'foo'  is an  upstream keypath  of  'foo.bar' .", 
            "title": "Upstream and downstream keypaths"
        }, 
        {
            "location": "/concepts/templates/keypaths/#array-versus-dot-notation", 
            "text": "The  'foo.bar'  keypath is an example of  dot notation . With arrays, you can use dot notation or  array notation , which may feel more familiar (internally, it gets converted to dot notation):  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [ 'a', 'b', 'c' ]\n  }\n});\n\n// Array notation\nractive.get( 'list[0]' ); // returns 'a'\n\n// Dot notation\nractive.get( 'list.0' ); // also returns 'a'", 
            "title": "Array versus dot notation"
        }, 
        {
            "location": "/concepts/templates/keypaths/#missing-properties", 
            "text": "Ordinarily in JavaScript, trying to access a child property of an object that didn't exist would cause an error:  data = { numbers: [ 1, 2, 3 ]};\ndata.letters[0]; // throws an error - cannot read property '0' of undefined  Within Ractive, this will simply return  undefined :  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    numbers: [ 1, 2, 3 ]\n  }\n});\n\nractive.get( 'letters[0]' ); // returns undefined", 
            "title": "Missing properties"
        }, 
        {
            "location": "/concepts/templates/keypaths/#escaping", 
            "text": "While not ideal, sometimes properties of objects have  . s in name e.g.  foo['bar.baz'] . Note that while numbers are supported in array notation, strings are not. To access a peypath with a literal  .  in one of the keys, you can escape it with a  \\  e.g.  foo.bar\\.baz . Any keys accessible in the template will be unescaped, so if you're trying to use them with simple string concatenation to access a keypath with a  .  in it, you'll need to make sure you escape it first.", 
            "title": "Escaping"
        }, 
        {
            "location": "/concepts/templates/mustaches/", 
            "text": "What is Mustache?\n\n\nMustache\n is one of the most popular templating languages. It's a very lightweight, readable syntax with a comprehensive specification - which means that implementations (such as Ractive) can test that they're doing things correctly.\n\n\nIf you've used \nHandlebars\n or \nAngular\n you'll also find mustaches familiar.\n\n\n\n\nWhat are mustaches?\n\n\nMustache basics\n\n\nVariables\n\n\nSections\n\n\nComments\n\n\nPartials\n\n\nCustom delimiters\n\n\nExtensions\n\n\nArray indices\n\n\nObject iteration\n\n\nSpecial references\n\n\nRestricted references\n\n\nExpressions\n\n\nHandlebars-style sections\n\n\nAliasing\n\n\nStatic mustaches\n\n\n{{else}}\n and \n{{elseif}}\n\n\nEscaping Mustaches\n\n\n\n\n\n\nWhat are mustaches?\n\n\nWithin this documentation, and within Ractive's code, 'mustache' means two things - a snippet of a template which uses mustache delimiters, such as \n{{name}}\n, and the object within our \nparallel DOM\n that is responsible for listening to data changes and updating the (real) DOM.\n\n\nWe say that the \n{{name}}\n mustache has a \nreference\n of \nname\n. When it gets rendered, and we create the object whose job it is to represent \nname\n in the DOM, we attempt to \nresolve the reference according to the current context stack\n. For example if we're in the \nuser\n context, and \nuser\n has a property of \nname\n, \nname\n will resolve to a \nkeypath\n of \nuser.name\n.\n\n\nAs soon as the mustache knows what its keypath is (which may not be at render time, if data has not yet been set), it registers itself as a \ndependant\n of the keypath. Then, whenever data changes, Ractive scans the dependency graph to see which mustaches need to update, and notifies them accordingly.\n\n\n\n\nMustache basics\n\n\nIf you already know Mustache, Ractive supports all the Mustache features - basic Mustache variables like \n{{name}}\n, as well as sections, partials, and even delimiter changes. If you're already familiar with Mustache, skip to the Extensions section below.\n\n\nYou can also check out the \ntutorials\n.\n\n\n\n\nVariables\n\n\nThe most basic mustache type is the variable. A \n{{name}}\n tag in a template will try to find the \nname\n key in the current context. If there is no \nname\n key in the current context, the parent contexts will be checked recursively. If the top context is reached and the name key is still not found, nothing will be rendered.\n\n\nAll variables are HTML escaped by default. If you want to return unescaped HTML, use the triple mustache: \n{{{name}}}\n.\n\n\nYou can also use \n to unescape a variable: \n{{\n name}}\n. This may be useful when changing delimiters (see \"Set Delimiter\" below).\n\n\nTemplate:\n\n\n * {{name}}\n * {{age}}\n * {{company}}\n * {{{company}}}\n\n\n\n\nWith the following data:\n\n\n{\n  \nname\n: \nChris\n,\n  \ncompany\n: \nb\nGitHub\n/b\n\n}\n\n\n\n\nWill generate the following output:\n\n\n * Chris\n *\n * \nlt;b\ngt;GitHub\nlt;/b\ngt;\n * \nb\nGitHub\n/b\n\n\n\n\n\n\n\nSections\n\n\nSections render blocks of text one or more times, depending on the value of the key in the current context.\n\n\nA section begins with a pound and ends with a slash. That is, \n{{#person}}\n begins a \"person\" section while \n{{/person}}\n ends it.\n\n\nThe behavior of the section is determined by the value of the key.\n\n\nFalse Values or Empty Lists\n\n\nIf the person key exists and has a value of false or an empty list, the HTML between the pound and slash will not be displayed.\n\n\nTemplate:\n\n\nShown.\n{{#person}}\n  Never shown!\n{{/person}}\n\n\n\n\nData:\n\n\n{\n  \nperson\n: false\n}\n\n\n\n\nOutput:\n\n\nShown.\n\n\n\n\nNon-Empty Lists\n\n\nIf the person key exists and has a non-false value, the HTML between the pound and slash will be rendered and displayed one or more times.\n\n\nWhen the value is a non-empty list, the text in the block will be displayed once for each item in the list. The context of the block will be set to the current item for each iteration. In this way we can loop over collections.\n\n\nTemplate:\n\n\n{{#repo}}\n  \nb\n{{name}}\n/b\n\n{{/repo}}\n\n\n\n\nData:\n\n\n{\n  \nrepo\n: [\n    { \nname\n: \nresque\n },\n    { \nname\n: \nhub\n },\n    { \nname\n: \nrip\n }\n  ]\n}\n\n\n\n\nOutput:\n\n\nb\nresque\n/b\n\n\nb\nhub\n/b\n\n\nb\nrip\n/b\n\n\n\n\n\nNon-False Values\n\n\nWhen the value is non-false but not a list, it will be used as the context for a single rendering of the block.\n\n\nTemplate:\n\n\n{{#person?}}\n  Hi {{name}}!\n{{/person?}}\n\n\n\n\nData:\n\n\n{\n  \nperson?\n: { \nname\n: \nJon\n }\n}\n\n\n\n\nOutput:\n\n\nHi Jon!\n\n\n\n\nInverted Sections\n\n\nAn inverted section begins with a caret (hat) and ends with a slash. That is  \n{{^person}}\n begins a \"person\" inverted section while \n{{/person}}\n ends it.\n\n\nWhile sections can be used to render text one or more times based on the value of the key, inverted sections may render text once based on the inverse value of the key. That is, they will be rendered if the key doesn't exist, is false, or is an empty list.\n\n\nTemplate:\n\n\n{{#repo}}\n  \nb\n{{name}}\n/b\n\n{{/repo}}\n{{^repo}}\n  No repos :(\n{{/repo}}\n\n\n\n\nAttributes\n\n\nSections may also be used within attribute values and around attribute values. Using a conditional section around an attribute or group of attributes will exclude those attributes from the DOM when the conditional is \nfalse\n and include them when it is \ntrue\n. Using a conditional section within an attribute only affects the value of the attribute, and there may be multiple sections within an attribute value.\n\n\nIn the following terribly contrived example, if \nbig\n is truthy, then the button will have a class \nbig\n in addition to the fixed class \nbutton\n. If \nplanetsAligned\n is truthy, the button will also get an annoying \nonmousemove\n attribute. \nNote\n that ractive directives cannot currently be placed within a section, but that may change in the future.\n\n\nbutton class=\n{{#big}}big {{/}}button\n {{#planetsAligned}}onmousemove=\nalert('I am annoying...')\n{{/}}\nI sure hope the planets aren't aligned...\n/button\n\n\n\n\n\n\n\nComments\n\n\nComments begin with a bang and are ignored. The following template:\n\n\nh1\nToday{{! ignore me }}.\n/h1\n\n\n\n\n\nWill render as follows:\n\n\nh1\nToday.\n/h1\n\n\n\n\n\nIf you'd like the comments to show up, just use html comments and set \nstripComments\n to \nfalse\n.\nComments may contain newlines.\n\n\n\n\nPartials\n\n\nPartials begin with a greater than sign:\n\n\n{{\n box}}\n\n\n\n\nRecursive partials are possible. Just avoid infinite loops.\n\n\nThey also inherit the calling context. For example:\n\n\n{{\n next_more}}\n\n\n\n\nIn this case, \nnext_more.mustache\n file will inherit the size and start methods from the calling context.\n\n\nIn this way you may want to think of partials as includes, or template expansion:\n\n\nFor example, this template and partial:\n\n\nbase.mustache:\n\n\nh2\nNames\n/h2\n\n{{#names}}\n  {{\n user}}\n{{/names}}\n\n\n\n\nWith \nuser.mustache\n containing:\n\n\nstrong\n{{name}}\n/strong\n\n\n\n\n\nCan be thought of as a single, expanded template:\n\n\nh2\nNames\n/h2\n\n{{#names}}\n  \nstrong\n{{name}}\n/strong\n\n{{/names}}\n\n\n\n\nPartials are a very useful construct, and you can find out more about them on the \npartials\n page.\n\n\n\n\nCustom delimiters\n\n\nCustom delimiters are set with a 'Set delimiter' tag. Set delimiter tags start with an equal sign and change the tag delimiters from \n{{\n and \n}}\n to custom strings.\n\n\n{{foo}}\n  {{=[[ ]]=}}\n[[bar]]\n\n\n\n\nCustom delimiters may not contain whitespace or the equals sign.\n\n\nYou can also set custom delimiters using the \ndelimiters\n and \ntripleDelimiters\n options in your Ractive instance.\n\n\nvar ractive = new Ractive({\n  el: whatever,\n  template: myTemplate,\n  data: {\n    greeting: 'Hello',\n    greeted: 'world',\n    triple: '\nstrong\nThis is a triple-stache\n/strong\n'\n  },\n  delimiters: [ '[[', ']]' ],\n  tripleDelimiters: [ '[[[', ']]]' ]\n});\n\n\n\n\n\n\nExtensions\n\n\nRactive is 99% backwards-compatible with Mustache, but adds several additional features.\n\n\n\n\nArray index references\n\n\nIndex references are a way of determining where we are within a list section. It's best explained with an example:\n\n\n{{#items:i}}\n  \n!-- within here, {{i}} refers to the current index --\n\n  \np\nItem {{i}}: {{content}}\n/p\n\n{{/items}}\n\n\n\n\nIf you then set \nitems\n to \n[{content: 'zero'}, {content: 'one'}, {content: 'two'}]\n, the result would be\n\n\np\nItem 0: zero\n/p\n\n\np\nItem 1: one\n/p\n\n\np\nItem 2: two\n/p\n\n\n\n\n\nThis is particularly useful when you need to respond to user interaction. For example you could add a \ndata-index='{{i}}'\n attribute, then easily find which item a user clicked on.\n\n\n\n\nObject iteration\n\n\nMustache can also iterate over objects, rather than array. The syntax is the same as for Array indices. Given the following ractive:\n\n\nractive = new Ractive({\n  el: container,\n  template: template,\n  data: {\n    users: {\n      'Joe': { email: 'joe@example.com' },\n      'Jane': { email: 'jane@example.com' },\n      'Mary': { email: 'mary@example.com' }\n    }\n  }\n});\n\n\n\n\nWe can iterate over the users object with the following:\n\n\nul\n\n  {{#users:name}}\n    \nli\n{{name}}: {{email}}\n/li\n\n  {{/users}}\n\n/ul\n\n\n\n\n\nto create:\n\n\nul\n\n  \nli\nJoe: joe@example.com\n/li\n\n  \nli\nJane: jane@example.com\n/li\n\n  \nli\nMary: mary@example.com\n/li\n\n\n/ul\n\n\n\n\n\nIn previous versions of Ractive it was required to close a section with the opening keypath. In the example above \n{{#users}}\n is closed by \n{{/users}}\n. This is no longer the case, you can now simply close an iterator with \n{{/}}\n. Ractive will attempt to warn you in the event of a mismatch, \n{{#users}}\n cannot be closed by \n{{/comments}}\n. This will not effect \nExpressions\n as they have always been able to be closed by \n{{/}}\n.\n\n\n!--- valid markup --\n\n{{#users}}\n\n{{/users}}\n\n{{#users:i}}\n\n{{/users}}\n\n{{#users}}\n\n{{/}}\n\n{{#users.topUsers}}\n\n!-- still matches the first part of the keypath, thus a valid closing tag --\n\n{{/users}}\n\n\n!-- invalid markup --\n\n{{#users}}\n\n{{/comments}}\n\n\n\n\n\n\nExpressions\n\n\nExpressions are a big topic, so they have a \npage of their own\n. But this section is about explaining the difference between vanilla Mustache and Ractive Mustache, so they deserve a mention here.\n\n\nExpressions look like any normal mustache. For example this expression converts \nnum\n to a percentage:\n\n\np\n{{ num * 100 }}%\n/p\n\n\n\n\n\nThe neat part is that this expression will recognise it has a dependency on whatever keypath \nnum\n resolves to, and will re-evaluate whenever the value of \nnum\n changes.\n\n\nMustache fans may bristle at expressions - after all, the whole point is that mustache templates are \nlogic-less\n, right? But what that really means is that the logic is \nembedded in the syntax\n (what are conditionals and iterators if not forms of logic?) rather than being language dependent. Expressions just allow you to add a little more, and in so doing make complex tasks simple.\n\n\n\n\nHandlebars-style sections\n\n\nIn addition to Mustache-style conditional and iterative sections, Ractive adds Handlebars-style \nif\n, \nunless\n, \neach\n, and \nwith\n to handle branching, iteration, and context control. For \nif\n, \nwith\n, and \neach\n, \n{{elseif}}\n and \n{{else}}\n may be used to provide alternate branches for false conditions, missing contexts, or empty iterables.\n\n\nbutton on-click=\nflip\nFlip Coin\n/button\n\n\np\nCoin flip result: {{#if heads}}heads{{else}}tails{{/if}}\n/p\n\n\nul\n\n  {{#each result}}\n    \nli\n{{.}}\n/li\n\n  {{else}}\n    \nli\nNo results yet...\n/li\n\n  {{/each}}\n\n/ul\n\n\np\nHere is a {{#with some.nested.value}}{{.}}{{/with}} value.\n/p\n\n\n\n\n\nvar ractive = new Ractive({\n  el: document.body,\n  template: myTemplate,\n  data: {\n    results: [],\n    heads: true,\n    some: { nested: { value: 'nested' } }\n  }\n});\n\nractive.on('flip', function() {\n  var sadRandom = Math.floor(Math.random() * 2) === 1;\n  this.set('heads', sadRandom);\n  this.unshift('results', sadRandom ? 'heads' : 'tails');\n});\n\n\n\n\nIn this example, clicking the button gets a \"random\" coin flip result, sets it in an \nif\n conditional section, and prepends it in an \neach\n iterative section. There is also a \nwith\n context section throw in for good measure.\n\n\n\n\nAliasing\n\n\nAny section (or \n{{#with}}\n section) provides its own context to the template that falls within it, and any references within the section will be resolved against the section context. Ambiguous references are resolved up the model hierarchy \nand\n the context hierarchy. Given a data structure that looks like\n\n\n{\n  foo: {\n    baz: 99,\n    bar: {\n      baz: 42\n    }\n  },\n  list: [\n    baz: 198,\n    bar: {\n      baz: 84\n    }\n  ]\n}\n\n\n\n\nand a template\n\n\n{{#each list}}\n  explicit 1: {{.bar.baz}}\n  {{#with .bar}}\n    implicit 1: {{baz}}\n    {{#with ~/foo}}\n      explicit 2: {{.bar.baz}}\n      implicit 2: {{baz}}\n    {{/with}}\n  {{/with}}\n{{/each}}\n\n\n\n\nthere is no way to reference \n~/list.0.baz\n from the second implicit site because the site has a different context (\n~/foo\n) and using an ambiguous reference (\nbaz\n) results in \n~/foo.baz\n  being used. Aliasing offers an escape hatch for similarly complex scenarios where ambiguity can cause the wrong reference to be used or performance issues to arise, because ambiguity is expensive.\n\n\nAlias block use the existing \n{{#with}}\n mustache, but instead of setting a context, they set names for one or more keypaths. Aliases follow the form \ndestination as alias\n, where destination is any valid reference at that point in the template e.g. \n{{#with .foo as myFoo, @key as someKey, 10 * @index + ~/offset as someCalculation, .baz.bat as lastOne}}\n. Because plain reference aliases, like the \nmyFoo\n and \nlastOne\n aliases in the example, refer to exactly one non-computed keypath, they can also be used for two-way binding deeper in the template. For example, \ninput value=\"{{myFoo}}\" /\n as a child of the alias block would bind to \n.foo\n in the context where the alias block is defined.\n\n\nAliasing is also extended to \n{{#each}}\n blocks so that the iterated item can be named rather than just referred to as \nthis\n or \n.\n. For instance, \n{{#each list as item}}\n would make \nitem\n equivalent to \nthis\n directly within the \neach\n block, but \nitem\n would still refer to same value in further nested contexts. Index and key aliases can still be used with an aliased iteration e.g. \n{{#each object as item: key, index}}\n.\n\n\nFinally, partials can also be used with alias shorthand in much the same way that they can be passed context e.g. \n{{\nsomePartial .foo.bar as myBar, 20 * @index + baz as myComp}}\n.\n\n\n\n\nStatic mustaches\n\n\nSometimes it is useful to have portions of a template render once and stay the same even if their references change. A static mustache will be updated only when its template is rendered and not when its keypath is updated. So, if a static mustache is a child of a section or partial that get re-rendered, the mustache will also be re-rendered using the current value of its keypath.\n\n\nThe default static mustache delimiters are \n[[ ]]\n for escaped values and \n[[[ ]]]\n for unescaped values.\n\n\n[[ foo ]] {{ foo }}\n{{^flag}}\n  [[ foo ]]\n{{/}}\n\n\n\n\nvar ractive = new Ractive({\n  data: { foo: 'bar' },\n  ...\n});\nractive.set('foo', 'bippy');\nractive.set('flag', true);\nractive.set('flag', false);\n\n\n\n\nOutput:\n\n\nbar bippy bippy\n\n\n\n\nStatic mustaches may also be used for sections that should only be updated on render.\n\n\n[[# if admin ]]\nHello, admin\n[[else]]\nHello, normal user\n[[/if]]\n\n\n\n\nvar ractive = new Ractive({\n  data: { admin: false },\n  ...\n});\nractive.set('admin', true);\n\n\n\n\nOutput:\n\n\nHello, normal user\n\n\n\n\n\n\n{{else}} and {{elseif}}\n\n\nRactive borrows a trick from Handlebars here and lets you perform:\n\n\n{{#repo}}\n  \nb\n{{name}}\n/b\n\n{{else}}\n  No repos :(\n{{/repo}}\n\n\n\n\nData:\n\n\n{\n  \nrepo\n: []\n}\n\n\n\n\nOutput:\n\n\nNo repos :(\n\n\n\n\nRactive takes it a step further and also allows you to use \n{{elseif otherCondition}}\n for alternate cases.\n\n\n{{#if foo}}\n  foo\n{{elseif bar}}\n  bar but not foo\n{{else}}\n  neither foo nor bar\n{{/if}}\n\n\n\n\nIn this case, the output would be what you would expect. If \nfoo\n is true, then the output will be \nfoo\n. If \nfoo\n is false and \nbar\n is true, the the output will be \nbar but not foo\n. If neither \nfoo\n nor \nbar\n is true, the the output will be \nneither foo nor bar\n.\n\n\nFurther, \n{{else}}\n and \n{{elseif}}\n clauses can be used with \n{{#with}}\n and \n{{#each}}\n sections too. If the context for the \n{{#with}}\n section doesn't exist, then any else clauses will be processed as if the entire section were a conditional with a false first branch. If the array for the \n{{#each}}\n (or regular iterative section) is empty or the object has no keys, then any else clauses will be processed as if the entire section were a conditional with a false first branch.\n\n\n\n\nEscaping mustaches\n\n\nIf you need to have Ractive ignore some mustaches in your template, you can escape them with a '\\'.\n\n\n{{ interpolated }} {{backslash}}{{ left alone }}\n\n\n\n\nIf you need to have a backslash before an interpolated mustache, you can escape the backslash with another '\\'. Any additional mustaches will be exported into the template.\n\n\n{{backslash}}{{backslash}}{{ interpolated }} and preceeded by a single slash.\n{{backslash}}{{backslash}}{{backslash}}{{ interpolated }} and preceeded by two slashes.\n\n\n\n\nFootnote\n\n\n*Ractive implements the Mustache specification as closely as possible. 100% compliance is impossible, because it's unlike other templating libraries - rather than turning a string into a string, Ractive turns a string into DOM, which has to be restringified so we can test compliance. Some things, like lambdas, get lost in translation - it's unavoidable, and unimportant.", 
            "title": "Mustaches"
        }, 
        {
            "location": "/concepts/templates/mustaches/#what-is-mustache", 
            "text": "Mustache  is one of the most popular templating languages. It's a very lightweight, readable syntax with a comprehensive specification - which means that implementations (such as Ractive) can test that they're doing things correctly.  If you've used  Handlebars  or  Angular  you'll also find mustaches familiar.   What are mustaches?  Mustache basics  Variables  Sections  Comments  Partials  Custom delimiters  Extensions  Array indices  Object iteration  Special references  Restricted references  Expressions  Handlebars-style sections  Aliasing  Static mustaches  {{else}}  and  {{elseif}}  Escaping Mustaches", 
            "title": "What is Mustache?"
        }, 
        {
            "location": "/concepts/templates/mustaches/#what-are-mustaches", 
            "text": "Within this documentation, and within Ractive's code, 'mustache' means two things - a snippet of a template which uses mustache delimiters, such as  {{name}} , and the object within our  parallel DOM  that is responsible for listening to data changes and updating the (real) DOM.  We say that the  {{name}}  mustache has a  reference  of  name . When it gets rendered, and we create the object whose job it is to represent  name  in the DOM, we attempt to  resolve the reference according to the current context stack . For example if we're in the  user  context, and  user  has a property of  name ,  name  will resolve to a  keypath  of  user.name .  As soon as the mustache knows what its keypath is (which may not be at render time, if data has not yet been set), it registers itself as a  dependant  of the keypath. Then, whenever data changes, Ractive scans the dependency graph to see which mustaches need to update, and notifies them accordingly.", 
            "title": "What are mustaches?"
        }, 
        {
            "location": "/concepts/templates/mustaches/#mustache-basics", 
            "text": "If you already know Mustache, Ractive supports all the Mustache features - basic Mustache variables like  {{name}} , as well as sections, partials, and even delimiter changes. If you're already familiar with Mustache, skip to the Extensions section below.  You can also check out the  tutorials .", 
            "title": "Mustache basics"
        }, 
        {
            "location": "/concepts/templates/mustaches/#variables", 
            "text": "The most basic mustache type is the variable. A  {{name}}  tag in a template will try to find the  name  key in the current context. If there is no  name  key in the current context, the parent contexts will be checked recursively. If the top context is reached and the name key is still not found, nothing will be rendered.  All variables are HTML escaped by default. If you want to return unescaped HTML, use the triple mustache:  {{{name}}} .  You can also use   to unescape a variable:  {{  name}} . This may be useful when changing delimiters (see \"Set Delimiter\" below).  Template:   * {{name}}\n * {{age}}\n * {{company}}\n * {{{company}}}  With the following data:  {\n   name :  Chris ,\n   company :  b GitHub /b \n}  Will generate the following output:   * Chris\n *\n *  lt;b gt;GitHub lt;/b gt;\n *  b GitHub /b", 
            "title": "Variables"
        }, 
        {
            "location": "/concepts/templates/mustaches/#sections", 
            "text": "Sections render blocks of text one or more times, depending on the value of the key in the current context.  A section begins with a pound and ends with a slash. That is,  {{#person}}  begins a \"person\" section while  {{/person}}  ends it.  The behavior of the section is determined by the value of the key.", 
            "title": "Sections"
        }, 
        {
            "location": "/concepts/templates/mustaches/#false-values-or-empty-lists", 
            "text": "If the person key exists and has a value of false or an empty list, the HTML between the pound and slash will not be displayed.  Template:  Shown.\n{{#person}}\n  Never shown!\n{{/person}}  Data:  {\n   person : false\n}  Output:  Shown.", 
            "title": "False Values or Empty Lists"
        }, 
        {
            "location": "/concepts/templates/mustaches/#non-empty-lists", 
            "text": "If the person key exists and has a non-false value, the HTML between the pound and slash will be rendered and displayed one or more times.  When the value is a non-empty list, the text in the block will be displayed once for each item in the list. The context of the block will be set to the current item for each iteration. In this way we can loop over collections.  Template:  {{#repo}}\n   b {{name}} /b \n{{/repo}}  Data:  {\n   repo : [\n    {  name :  resque  },\n    {  name :  hub  },\n    {  name :  rip  }\n  ]\n}  Output:  b resque /b  b hub /b  b rip /b", 
            "title": "Non-Empty Lists"
        }, 
        {
            "location": "/concepts/templates/mustaches/#non-false-values", 
            "text": "When the value is non-false but not a list, it will be used as the context for a single rendering of the block.  Template:  {{#person?}}\n  Hi {{name}}!\n{{/person?}}  Data:  {\n   person? : {  name :  Jon  }\n}  Output:  Hi Jon!", 
            "title": "Non-False Values"
        }, 
        {
            "location": "/concepts/templates/mustaches/#inverted-sections", 
            "text": "An inverted section begins with a caret (hat) and ends with a slash. That is   {{^person}}  begins a \"person\" inverted section while  {{/person}}  ends it.  While sections can be used to render text one or more times based on the value of the key, inverted sections may render text once based on the inverse value of the key. That is, they will be rendered if the key doesn't exist, is false, or is an empty list.  Template:  {{#repo}}\n   b {{name}} /b \n{{/repo}}\n{{^repo}}\n  No repos :(\n{{/repo}}", 
            "title": "Inverted Sections"
        }, 
        {
            "location": "/concepts/templates/mustaches/#attributes", 
            "text": "Sections may also be used within attribute values and around attribute values. Using a conditional section around an attribute or group of attributes will exclude those attributes from the DOM when the conditional is  false  and include them when it is  true . Using a conditional section within an attribute only affects the value of the attribute, and there may be multiple sections within an attribute value.  In the following terribly contrived example, if  big  is truthy, then the button will have a class  big  in addition to the fixed class  button . If  planetsAligned  is truthy, the button will also get an annoying  onmousemove  attribute.  Note  that ractive directives cannot currently be placed within a section, but that may change in the future.  button class= {{#big}}big {{/}}button  {{#planetsAligned}}onmousemove= alert('I am annoying...') {{/}} I sure hope the planets aren't aligned... /button", 
            "title": "Attributes"
        }, 
        {
            "location": "/concepts/templates/mustaches/#comments", 
            "text": "Comments begin with a bang and are ignored. The following template:  h1 Today{{! ignore me }}. /h1   Will render as follows:  h1 Today. /h1   If you'd like the comments to show up, just use html comments and set  stripComments  to  false .\nComments may contain newlines.", 
            "title": "Comments"
        }, 
        {
            "location": "/concepts/templates/mustaches/#partials", 
            "text": "Partials begin with a greater than sign:  {{  box}}  Recursive partials are possible. Just avoid infinite loops.  They also inherit the calling context. For example:  {{  next_more}}  In this case,  next_more.mustache  file will inherit the size and start methods from the calling context.  In this way you may want to think of partials as includes, or template expansion:  For example, this template and partial:  base.mustache:  h2 Names /h2 \n{{#names}}\n  {{  user}}\n{{/names}}  With  user.mustache  containing:  strong {{name}} /strong   Can be thought of as a single, expanded template:  h2 Names /h2 \n{{#names}}\n   strong {{name}} /strong \n{{/names}}  Partials are a very useful construct, and you can find out more about them on the  partials  page.", 
            "title": "Partials"
        }, 
        {
            "location": "/concepts/templates/mustaches/#custom-delimiters", 
            "text": "Custom delimiters are set with a 'Set delimiter' tag. Set delimiter tags start with an equal sign and change the tag delimiters from  {{  and  }}  to custom strings.  {{foo}}\n  {{=[[ ]]=}}\n[[bar]]  Custom delimiters may not contain whitespace or the equals sign.  You can also set custom delimiters using the  delimiters  and  tripleDelimiters  options in your Ractive instance.  var ractive = new Ractive({\n  el: whatever,\n  template: myTemplate,\n  data: {\n    greeting: 'Hello',\n    greeted: 'world',\n    triple: ' strong This is a triple-stache /strong '\n  },\n  delimiters: [ '[[', ']]' ],\n  tripleDelimiters: [ '[[[', ']]]' ]\n});", 
            "title": "Custom delimiters"
        }, 
        {
            "location": "/concepts/templates/mustaches/#extensions", 
            "text": "Ractive is 99% backwards-compatible with Mustache, but adds several additional features.", 
            "title": "Extensions"
        }, 
        {
            "location": "/concepts/templates/mustaches/#array-index-references", 
            "text": "Index references are a way of determining where we are within a list section. It's best explained with an example:  {{#items:i}}\n   !-- within here, {{i}} refers to the current index -- \n   p Item {{i}}: {{content}} /p \n{{/items}}  If you then set  items  to  [{content: 'zero'}, {content: 'one'}, {content: 'two'}] , the result would be  p Item 0: zero /p  p Item 1: one /p  p Item 2: two /p   This is particularly useful when you need to respond to user interaction. For example you could add a  data-index='{{i}}'  attribute, then easily find which item a user clicked on.", 
            "title": "Array index references"
        }, 
        {
            "location": "/concepts/templates/mustaches/#object-iteration", 
            "text": "Mustache can also iterate over objects, rather than array. The syntax is the same as for Array indices. Given the following ractive:  ractive = new Ractive({\n  el: container,\n  template: template,\n  data: {\n    users: {\n      'Joe': { email: 'joe@example.com' },\n      'Jane': { email: 'jane@example.com' },\n      'Mary': { email: 'mary@example.com' }\n    }\n  }\n});  We can iterate over the users object with the following:  ul \n  {{#users:name}}\n     li {{name}}: {{email}} /li \n  {{/users}} /ul   to create:  ul \n   li Joe: joe@example.com /li \n   li Jane: jane@example.com /li \n   li Mary: mary@example.com /li  /ul   In previous versions of Ractive it was required to close a section with the opening keypath. In the example above  {{#users}}  is closed by  {{/users}} . This is no longer the case, you can now simply close an iterator with  {{/}} . Ractive will attempt to warn you in the event of a mismatch,  {{#users}}  cannot be closed by  {{/comments}} . This will not effect  Expressions  as they have always been able to be closed by  {{/}} .  !--- valid markup -- \n{{#users}}\n\n{{/users}}\n\n{{#users:i}}\n\n{{/users}}\n\n{{#users}}\n\n{{/}}\n\n{{#users.topUsers}} !-- still matches the first part of the keypath, thus a valid closing tag -- \n{{/users}} !-- invalid markup -- \n{{#users}}\n\n{{/comments}}", 
            "title": "Object iteration"
        }, 
        {
            "location": "/concepts/templates/mustaches/#expressions", 
            "text": "Expressions are a big topic, so they have a  page of their own . But this section is about explaining the difference between vanilla Mustache and Ractive Mustache, so they deserve a mention here.  Expressions look like any normal mustache. For example this expression converts  num  to a percentage:  p {{ num * 100 }}% /p   The neat part is that this expression will recognise it has a dependency on whatever keypath  num  resolves to, and will re-evaluate whenever the value of  num  changes.  Mustache fans may bristle at expressions - after all, the whole point is that mustache templates are  logic-less , right? But what that really means is that the logic is  embedded in the syntax  (what are conditionals and iterators if not forms of logic?) rather than being language dependent. Expressions just allow you to add a little more, and in so doing make complex tasks simple.", 
            "title": "Expressions"
        }, 
        {
            "location": "/concepts/templates/mustaches/#handlebars-style-sections", 
            "text": "In addition to Mustache-style conditional and iterative sections, Ractive adds Handlebars-style  if ,  unless ,  each , and  with  to handle branching, iteration, and context control. For  if ,  with , and  each ,  {{elseif}}  and  {{else}}  may be used to provide alternate branches for false conditions, missing contexts, or empty iterables.  button on-click= flip Flip Coin /button  p Coin flip result: {{#if heads}}heads{{else}}tails{{/if}} /p  ul \n  {{#each result}}\n     li {{.}} /li \n  {{else}}\n     li No results yet... /li \n  {{/each}} /ul  p Here is a {{#with some.nested.value}}{{.}}{{/with}} value. /p   var ractive = new Ractive({\n  el: document.body,\n  template: myTemplate,\n  data: {\n    results: [],\n    heads: true,\n    some: { nested: { value: 'nested' } }\n  }\n});\n\nractive.on('flip', function() {\n  var sadRandom = Math.floor(Math.random() * 2) === 1;\n  this.set('heads', sadRandom);\n  this.unshift('results', sadRandom ? 'heads' : 'tails');\n});  In this example, clicking the button gets a \"random\" coin flip result, sets it in an  if  conditional section, and prepends it in an  each  iterative section. There is also a  with  context section throw in for good measure.", 
            "title": "Handlebars-style sections"
        }, 
        {
            "location": "/concepts/templates/mustaches/#aliasing", 
            "text": "Any section (or  {{#with}}  section) provides its own context to the template that falls within it, and any references within the section will be resolved against the section context. Ambiguous references are resolved up the model hierarchy  and  the context hierarchy. Given a data structure that looks like  {\n  foo: {\n    baz: 99,\n    bar: {\n      baz: 42\n    }\n  },\n  list: [\n    baz: 198,\n    bar: {\n      baz: 84\n    }\n  ]\n}  and a template  {{#each list}}\n  explicit 1: {{.bar.baz}}\n  {{#with .bar}}\n    implicit 1: {{baz}}\n    {{#with ~/foo}}\n      explicit 2: {{.bar.baz}}\n      implicit 2: {{baz}}\n    {{/with}}\n  {{/with}}\n{{/each}}  there is no way to reference  ~/list.0.baz  from the second implicit site because the site has a different context ( ~/foo ) and using an ambiguous reference ( baz ) results in  ~/foo.baz   being used. Aliasing offers an escape hatch for similarly complex scenarios where ambiguity can cause the wrong reference to be used or performance issues to arise, because ambiguity is expensive.  Alias block use the existing  {{#with}}  mustache, but instead of setting a context, they set names for one or more keypaths. Aliases follow the form  destination as alias , where destination is any valid reference at that point in the template e.g.  {{#with .foo as myFoo, @key as someKey, 10 * @index + ~/offset as someCalculation, .baz.bat as lastOne}} . Because plain reference aliases, like the  myFoo  and  lastOne  aliases in the example, refer to exactly one non-computed keypath, they can also be used for two-way binding deeper in the template. For example,  input value=\"{{myFoo}}\" /  as a child of the alias block would bind to  .foo  in the context where the alias block is defined.  Aliasing is also extended to  {{#each}}  blocks so that the iterated item can be named rather than just referred to as  this  or  . . For instance,  {{#each list as item}}  would make  item  equivalent to  this  directly within the  each  block, but  item  would still refer to same value in further nested contexts. Index and key aliases can still be used with an aliased iteration e.g.  {{#each object as item: key, index}} .  Finally, partials can also be used with alias shorthand in much the same way that they can be passed context e.g.  {{ somePartial .foo.bar as myBar, 20 * @index + baz as myComp}} .", 
            "title": "Aliasing"
        }, 
        {
            "location": "/concepts/templates/mustaches/#static-mustaches", 
            "text": "Sometimes it is useful to have portions of a template render once and stay the same even if their references change. A static mustache will be updated only when its template is rendered and not when its keypath is updated. So, if a static mustache is a child of a section or partial that get re-rendered, the mustache will also be re-rendered using the current value of its keypath.  The default static mustache delimiters are  [[ ]]  for escaped values and  [[[ ]]]  for unescaped values.  [[ foo ]] {{ foo }}\n{{^flag}}\n  [[ foo ]]\n{{/}}  var ractive = new Ractive({\n  data: { foo: 'bar' },\n  ...\n});\nractive.set('foo', 'bippy');\nractive.set('flag', true);\nractive.set('flag', false);  Output:  bar bippy bippy  Static mustaches may also be used for sections that should only be updated on render.  [[# if admin ]]\nHello, admin\n[[else]]\nHello, normal user\n[[/if]]  var ractive = new Ractive({\n  data: { admin: false },\n  ...\n});\nractive.set('admin', true);  Output:  Hello, normal user", 
            "title": "Static mustaches"
        }, 
        {
            "location": "/concepts/templates/mustaches/#else-and-elseif", 
            "text": "Ractive borrows a trick from Handlebars here and lets you perform:  {{#repo}}\n   b {{name}} /b \n{{else}}\n  No repos :(\n{{/repo}}  Data:  {\n   repo : []\n}  Output:  No repos :(  Ractive takes it a step further and also allows you to use  {{elseif otherCondition}}  for alternate cases.  {{#if foo}}\n  foo\n{{elseif bar}}\n  bar but not foo\n{{else}}\n  neither foo nor bar\n{{/if}}  In this case, the output would be what you would expect. If  foo  is true, then the output will be  foo . If  foo  is false and  bar  is true, the the output will be  bar but not foo . If neither  foo  nor  bar  is true, the the output will be  neither foo nor bar .  Further,  {{else}}  and  {{elseif}}  clauses can be used with  {{#with}}  and  {{#each}}  sections too. If the context for the  {{#with}}  section doesn't exist, then any else clauses will be processed as if the entire section were a conditional with a false first branch. If the array for the  {{#each}}  (or regular iterative section) is empty or the object has no keys, then any else clauses will be processed as if the entire section were a conditional with a false first branch.", 
            "title": "{{else}} and {{elseif}}"
        }, 
        {
            "location": "/concepts/templates/mustaches/#escaping-mustaches", 
            "text": "If you need to have Ractive ignore some mustaches in your template, you can escape them with a '\\'.  {{ interpolated }} {{backslash}}{{ left alone }}  If you need to have a backslash before an interpolated mustache, you can escape the backslash with another '\\'. Any additional mustaches will be exported into the template.  {{backslash}}{{backslash}}{{ interpolated }} and preceeded by a single slash.\n{{backslash}}{{backslash}}{{backslash}}{{ interpolated }} and preceeded by two slashes.", 
            "title": "Escaping mustaches"
        }, 
        {
            "location": "/concepts/templates/mustaches/#footnote", 
            "text": "*Ractive implements the Mustache specification as closely as possible. 100% compliance is impossible, because it's unlike other templating libraries - rather than turning a string into a string, Ractive turns a string into DOM, which has to be restringified so we can test compliance. Some things, like lambdas, get lost in translation - it's unavoidable, and unimportant.", 
            "title": "Footnote"
        }, 
        {
            "location": "/concepts/templates/parsing/", 
            "text": "Parsing\n\n\nIn order for Ractive to utilize templates, it first parses the templates into a tree-like data structure, much like how a browser's HTML parser would process HTML. This data structure contains everything Ractive needs to know to construct an instance's DOM, data bindings, events and transitions etc.\n\n\n\n\n\nRactive.parse('\ndiv class=\nmessage\nHello World!\n/div\n');\n\n// {\nv\n:4,\nt\n:[{\nt\n:7,\ne\n:\ndiv\n,\nm\n:[{\nn\n:\nclass\n,\nf\n:\nmessage\n,\nt\n:13}],\nf\n:[\nHello World!\n]}]}\n\n\n\n\nNormally, parsing is done automatically. Ractive will use \nRactive.parse()\n under the hood if a string template is provided to the \ntemplate\n initialization option.\n\n\nThe parsed template is not designed to be readable nor editable by a human. It is meant to represent the template structure as an object in a way Ractive understands with as few bytes as possible. Where the template doesn't use Ractive-specific features, these parts will be represented as plain HTML in the data structure.\n\n\nPre-parsing\n\n\nParsing templates can be a very slow operation, particularly for very large apps, very complex templates, or intricate SVGs. As an optimization option, templates can be pre-parsed into their object form outside of runtime. This would allow Ractive to skip parsing during runtime and speed up app initialization. Typically, a parsed template is only about 30-40% larger than the string version, making pre-parsing a trade-off between space and processing.\n\n\nPre-parsing can be done in many different ways as long as Ractive receives the parsed template during runtime. One way would be to simply serve the pre-parsed template separately from the component or instance and load it via AJAX. Another would be to extract and replace the template on the file with the parsed version during compile time - an approach that works well with \ncomponent files\n. Read more about \nloaders\n to know more about how loaders do pre-parsing on compile time.", 
            "title": "Parsing"
        }, 
        {
            "location": "/concepts/templates/parsing/#parsing", 
            "text": "In order for Ractive to utilize templates, it first parses the templates into a tree-like data structure, much like how a browser's HTML parser would process HTML. This data structure contains everything Ractive needs to know to construct an instance's DOM, data bindings, events and transitions etc.   Ractive.parse(' div class= message Hello World! /div ');\n\n// { v :4, t :[{ t :7, e : div , m :[{ n : class , f : message , t :13}], f :[ Hello World! ]}]}  Normally, parsing is done automatically. Ractive will use  Ractive.parse()  under the hood if a string template is provided to the  template  initialization option.  The parsed template is not designed to be readable nor editable by a human. It is meant to represent the template structure as an object in a way Ractive understands with as few bytes as possible. Where the template doesn't use Ractive-specific features, these parts will be represented as plain HTML in the data structure.", 
            "title": "Parsing"
        }, 
        {
            "location": "/concepts/templates/parsing/#pre-parsing", 
            "text": "Parsing templates can be a very slow operation, particularly for very large apps, very complex templates, or intricate SVGs. As an optimization option, templates can be pre-parsed into their object form outside of runtime. This would allow Ractive to skip parsing during runtime and speed up app initialization. Typically, a parsed template is only about 30-40% larger than the string version, making pre-parsing a trade-off between space and processing.  Pre-parsing can be done in many different ways as long as Ractive receives the parsed template during runtime. One way would be to simply serve the pre-parsed template separately from the component or instance and load it via AJAX. Another would be to extract and replace the template on the file with the parsed version during compile time - an approach that works well with  component files . Read more about  loaders  to know more about how loaders do pre-parsing on compile time.", 
            "title": "Pre-parsing"
        }, 
        {
            "location": "/concepts/templates/references/", 
            "text": "References\n\n\nA reference is a string that refers to a piece of data. They may look like a regular \nkeypath\n, like \n{{ foo.bar.baz }}\n or may contain special keywords and glyphs, like \n{{ @this.sayHello() }}\n.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    foo: 'bar',\n  },\n  template: `\n    \ndiv\nI reference foo with a value: {{ foo }}\n/div\n\n    \nbutton type=\nbutton\n on-click=\n@this.sayHello()\nClick Me\n/button\n\n  `,\n  sayHello(){\n    console.log('Called from an event that used a reference to a method')\n  }\n});\n\n\n\n\nReference resolution\n\n\nIn order for a reference to be usable, it has to resolve to something. Ractive follows the following resolution algorithm to find the value of a reference:\n\n\n\n\nIf the reference a \nspecial reference\n, resolve with that keypath.\n\n\nIf the reference is \nexplicit\n or matches a path in the current context exactly, resolve with that keypath.\n\n\nGrab the current virtual node from the template hierarchy.\n\n\nIf the reference matches an \nalias\n, section indexes, or keys, resolve with that keypath.\n\n\nIf the reference matches any \nmappings\n, resolve with that keypath.\n\n\nIf the reference matches a path on the context, resolve with that keypath.\n\n\nRemove the innermost context from the stack. Repeat steps 3-7.\n\n\nIf the reference is a valid keypath by itself, resolve with that keypath.\n\n\nIf the reference is still unresolved, add it to the 'pending resolution' pile. Each time potentially matching keypaths are updated, resolution will be attempted for the unresolved reference.\n\n\n\n\nContext stack\n\n\nSteps 6 and 7 of the \nresolution algorithm\n defines the ability of Ractive to \"climb\" contexts when a reference does not resolve in the current context. This is similar to how JavaScript climbs to the global scope to resolve a variable.\n\n\nTo do this, whenever Ractive encounters \nsection mustaches\n or similar constructs, it stores the context in a \ncontext stack\n. Ractive then resolves references starting with the context on the top of the stack, and popping off contexts until the reference resolves to a keypath.\n\n\n\n\n\nRactive({\n  el: 'body',\n  template: `\n    {{#user}}\n      \np\nWelcome back, {{name}}!\n        {{#messages}}\n          You have {{unread}} unread of {{total}} total messages.\n          You last logged in on {{lastLogin}}.\n        {{/messages}}\n      \n/p\n\n    {{/user}}\n  `,\n  data: {\n    user: {\n      name: 'Jim',\n      messages: {\n        total: 10,\n        unread: 3\n      },\n      lastLogin: 'Wednesday'\n    }\n  }\n});\n\n// Welcome back, Jim! You have 3 unread of 10 total messages. You last logged in on Wednesday.\n\n\n\n\n{{# user }}\n creates a context and the context stack becomes \n['user']\n. To resolve \nname\n, the following context resolution order is followed, where \nname\n resolves with the \nuser.name\n keypath:\n\n\n\n\nuser.name\n (resolved here)\n\n\nname\n\n\n\n\nIn the same way, \n{{# messages }}\n also creates a context. Since the \nmessages\n section under the \nuser\n section, the context stack becomes \n['user', 'user.messages']\n. To resolve \nunread\n and \ntotal\n, the following resolution order is followed:\n\n\nunread\n\n\n\n\nuser.messages.unread\n (resolved here)\n\n\nuser.unread\n\n\nunread\n\n\n\n\ntotal\n\n\n\n\nuser.messages.total\n (resolved here)\n\n\nuser.total\n\n\ntotal\n\n\n\n\nIn the case of \nlastLogin\n, the \nuser.messages.lastLogin\n keypath does not exist. What Ractive does is pop off \nuser.messages\n from the context stack and tries to resolve \nlastLogin\n using \nuser.lastLogin\n. Since \nuser.lastLogin\n is a valid keypath, \nlastLogin\n resolves as \nuser.lastLogin\n.\n\n\n\n\nuser.messages.lastLogin\n\n\nuser.lastLogin\n (resolved here)\n\n\nlastLogin\n\n\n\n\nArrays\n\n\nUnlike objects where the section uses the object as context, the context of a section that goes over an array are the items of that array.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    items: [\n      { content: 'zero' },\n      { content: 'one' },\n      { content: 'two' }\n    ]\n  },\n  template: `\n  {{#items}}\n    {{content}}\n  {{/items}}\n  `\n});\n\n// zeroonetwo\n\n\n\n\nIn the example above, context is created for each item on the array. The first time it is \nitems.0\n, then \nitems.1\n, then \nitems.2\n. \ncontent\n will be resolved for relative to each, doing \nitems.0.content\n, then \nitems.1.content\n and finally \nitems.2.content\n.", 
            "title": "References"
        }, 
        {
            "location": "/concepts/templates/references/#references", 
            "text": "A reference is a string that refers to a piece of data. They may look like a regular  keypath , like  {{ foo.bar.baz }}  or may contain special keywords and glyphs, like  {{ @this.sayHello() }} .   Ractive({\n  el: 'body',\n  data: {\n    foo: 'bar',\n  },\n  template: `\n     div I reference foo with a value: {{ foo }} /div \n     button type= button  on-click= @this.sayHello() Click Me /button \n  `,\n  sayHello(){\n    console.log('Called from an event that used a reference to a method')\n  }\n});", 
            "title": "References"
        }, 
        {
            "location": "/concepts/templates/references/#reference-resolution", 
            "text": "In order for a reference to be usable, it has to resolve to something. Ractive follows the following resolution algorithm to find the value of a reference:   If the reference a  special reference , resolve with that keypath.  If the reference is  explicit  or matches a path in the current context exactly, resolve with that keypath.  Grab the current virtual node from the template hierarchy.  If the reference matches an  alias , section indexes, or keys, resolve with that keypath.  If the reference matches any  mappings , resolve with that keypath.  If the reference matches a path on the context, resolve with that keypath.  Remove the innermost context from the stack. Repeat steps 3-7.  If the reference is a valid keypath by itself, resolve with that keypath.  If the reference is still unresolved, add it to the 'pending resolution' pile. Each time potentially matching keypaths are updated, resolution will be attempted for the unresolved reference.", 
            "title": "Reference resolution"
        }, 
        {
            "location": "/concepts/templates/references/#context-stack", 
            "text": "Steps 6 and 7 of the  resolution algorithm  defines the ability of Ractive to \"climb\" contexts when a reference does not resolve in the current context. This is similar to how JavaScript climbs to the global scope to resolve a variable.  To do this, whenever Ractive encounters  section mustaches  or similar constructs, it stores the context in a  context stack . Ractive then resolves references starting with the context on the top of the stack, and popping off contexts until the reference resolves to a keypath.   Ractive({\n  el: 'body',\n  template: `\n    {{#user}}\n       p Welcome back, {{name}}!\n        {{#messages}}\n          You have {{unread}} unread of {{total}} total messages.\n          You last logged in on {{lastLogin}}.\n        {{/messages}}\n       /p \n    {{/user}}\n  `,\n  data: {\n    user: {\n      name: 'Jim',\n      messages: {\n        total: 10,\n        unread: 3\n      },\n      lastLogin: 'Wednesday'\n    }\n  }\n});\n\n// Welcome back, Jim! You have 3 unread of 10 total messages. You last logged in on Wednesday.  {{# user }}  creates a context and the context stack becomes  ['user'] . To resolve  name , the following context resolution order is followed, where  name  resolves with the  user.name  keypath:   user.name  (resolved here)  name   In the same way,  {{# messages }}  also creates a context. Since the  messages  section under the  user  section, the context stack becomes  ['user', 'user.messages'] . To resolve  unread  and  total , the following resolution order is followed:  unread   user.messages.unread  (resolved here)  user.unread  unread   total   user.messages.total  (resolved here)  user.total  total   In the case of  lastLogin , the  user.messages.lastLogin  keypath does not exist. What Ractive does is pop off  user.messages  from the context stack and tries to resolve  lastLogin  using  user.lastLogin . Since  user.lastLogin  is a valid keypath,  lastLogin  resolves as  user.lastLogin .   user.messages.lastLogin  user.lastLogin  (resolved here)  lastLogin", 
            "title": "Context stack"
        }, 
        {
            "location": "/concepts/templates/references/#arrays", 
            "text": "Unlike objects where the section uses the object as context, the context of a section that goes over an array are the items of that array.   Ractive({\n  el: 'body',\n  data: {\n    items: [\n      { content: 'zero' },\n      { content: 'one' },\n      { content: 'two' }\n    ]\n  },\n  template: `\n  {{#items}}\n    {{content}}\n  {{/items}}\n  `\n});\n\n// zeroonetwo  In the example above, context is created for each item on the array. The first time it is  items.0 , then  items.1 , then  items.2 .  content  will be resolved for relative to each, doing  items.0.content , then  items.1.content  and finally  items.2.content .", 
            "title": "Arrays"
        }, 
        {
            "location": "/articles/introducing-ractive-js/", 
            "text": "Introducing Ractive.js\n\n\nOriginally posted on the \nGuardian developer blog\n\n\n\n\nRactive.js is used to create guardian.co.uk interactives, such as \nFood game: How well do you know the world?\n\n\nAnyone with fond memories of the \nsound of dial-up internet\n will understand how ridiculous it would have seemed, to the web's pioneers, that we would one day be using this geeky information exchange format to play games, do grocery shopping, collaborate on spreadsheets and even \nbuild more webapps\n. Yet here we are.\n\n\nBut despite taking over the world, the web has a dirty secret: it's actually a lousy platform for creating many of the experiences we take for granted. Let me qualify that: it's an amazing technology for creating \ndocuments\n, but for creating \napps\n - interactive experiences that respond to user input, and represent changing data - web development can be akin to pulling teeth.\n\n\n\n\n\nConsider the following simple task. We have an interface that shows our user, Dave, how many unread messages he has. When he gets a new message, how do we update the interface?\n\n\np\nHello Dave! You have 4 new messages.\n/p\n\n\n\n\n\nIn the bad old days, you'd have to reload the page, and the server would send you some freshly-rendered HTML. But let's assume we've got a model that contains our data, and that we need to update the existing view. Here are our options:\n\n\n1. Just use jQuery\n\n\nvar p = $('p');\n\nfunction updateView (username, msgCount) {\n    p.text('Hello ' + username + '! You have ' + msgCount + ' new messages.');\n};\n\n\n\n\nThis is generally agreed to be a Bad Idea - mixing your templates and your logic will end in tears. What if a non-programmer needs to change the wording? They'll probably break something, that's what.\n\n\n2. Target specific elements\n\n\np\n\n    Hello \nspan id='username'\n/span\n!\n    You have \nspan id='msgCount'\n/span\n new messages.\n\n/p\n\n\n\n\n\nvar usernameSpan = $('#username'),\n    msgCountSpan = $('#msgCount');\n\nfunction updateUserName (username) {\n    usernameSpan.text(username);\n};\n\nfunction updateMsgCount (msgCount) {\n    msgCountSpan.text(msgCount);\n};\n\n// initialise our view\nupdateUsername(model.username);\nupdateMsgCount(model.msgCount);\n\n\n\n\nBetter, except that now we've added two extra \nspan\n elements to the DOM. That means more work for the browser, which can become particularly noticeable on mobile devices. And we've got to traverse the DOM and store references to elements.\n\n\n3. Templating\n\n\np\nHello \n%= username %\n! You have \n%= msgCount %\n new messages.\n/p\n\n\n\n\n\nNow we're getting somewhere - our templates and our logic are cleanly separated. But wait! What happens when we update the view?\n\n\nvar body = $(body),\n    // we're using Underscore templates here\n    template = new _.template(templateStr);\n\nfunction updateView (model) {\n    var html = template({\n        username: model.username,\n        msgCount: model.msgCount\n    });\n\n    body.html(html);\n};\n\n// initialise\nupdateView(model);\n\n\n\n\nWhat happens is that the existing element gets removed from the DOM, and a new one gets created. At best, the old one will be hoovered up by the \ngarbage collector\n; at worst, it will remain in memory. Either way, it's bad for performance.\n\n\nIn the context of this contrived example it might seem trivial, but as an app becomes more complex, these things start to show.\n\n\n4. Just use Angular\n\n\nAt this point, many developers will point you towards a framework such as \nAngularJS\n or \nEmberJS\n. These frameworks do a lot of the heavy lifting for you, particularly as far as model-view data binding is concerned.\n\n\nAngular in particular is hugely popular at the moment. (The Guardian is currently using it for a major internal project, in fact.)\n\n\nBut these frameworks also have a cost - they tend to be fairly large, and once you've finished the 'hello world' tutorials they have steep learning curves. Particularly for smaller projects, it's often a case of using a sledgehammer to crack a nut.\n\n\nYou see the problem. What should be an incredibly basic task is a snakepit of compromises and ugly code - yet we're all so used to developing this way that we're barely even aware of how awkward it is.\n\n\nEnter Ractive.js\n\n\nRactive was initially created to tackle the data binding problem in a more elegant way. We on the \nGuardian interactive team\n are acutely aware of the challenges of creating app-like experiences on the web; interactives, by their nature, require a huge amount of DOM manipulation, and as slaves to the editorial agenda we typically have tight deadlines.\n\n\nThe above example, with Ractive, would go something like this:\n\n\np\nHello {{username}}! You have {{msgCount}} new messages.\n/p\n\n\n\n\n\nvar view = new Ractive({\n    el: document.body,\n    template: templateStr,\n    data: model // contains our username and msgCount properties\n});\n\nfunction updateView (model) {\n    view.set(model);\n};\n\n\n\n\nInitially, Ractive parses the template and determines that \n{{msgCount}}\n should be treated as a separate \ntext node\n, which depends on the \nmsgCount\n property of our model.\n\n\nWhen you call \nview.set()\n, Ractive compares the new data against its current state, and scans its internal dependency graph to see if any part of the DOM needs to be updated. If so, it only touches those parts - which means no DOM nodes will be created or destroyed.\n\n\nThe browser has much less work to do, but - and this is the crucial part - so does the developer. The benefits of this approach become increasingly apparent as you deal with more complex templates, representing more complex data. You can see for yourself how it makes life easier by following the \ntutorials\n or checking out the \nexamples\n.\n\n\nBeyond data binding\n\n\nIt soon became apparent that this approach enables us to do other things more efficiently as well. It's a philosophical change in the relationship between HTML and JavaScript - HTML is no longer an inert substance which must have life breathed into it, but a blueprint for an app that is interactive by default.\n\n\nTake event handling for example. Web developers are used to peppering their HTML with meaningless \nid\n and \nclass\n attributes as 'hooks', so that they can later traverse the DOM, find them, and add event handlers:\n\n\nbutton id='activate'\nActivate!\n/button\n\n\nbutton id='deactivate'\nDeactivate!\n/button\n\n\n\n\n\n$('#activate').on('click', function () {\n    alert('Activating!');\n});\n\n$('#deactivate').on('click', function () {\n    alert('Deactivating!');\n});\n\n\n\n\nBut if you treat the HTML as a blueprint, you can bake the semantics of user interaction right into your template:\n\n\nbutton proxy-click='activate'\nActivate!\n/button\n\n\nbutton proxy-click='deactivate'\nDeactivate!\n/button\n\n\n\n\n\nview.on({\n    activate: function () {\n        alert('Activating!');\n    },\n    deactivate: function () {\n        alert('Deactivating!');\n    }\n});\n\n\n\n\nMoreover, we can now automatically take care of things like reusing event handlers and automatically unbinding them when they're no longer needed. Event delegation becomes unnecessary. As with data binding, this approach prevents your code from becoming unwieldy as your app grows.\n\n\nSexy features\n\n\nSo far, this all sounds fairly prosaic - handy, perhaps, but nothing you can't already do with \nvanilla JS\n. But the real fun starts when we start exploiting some of the features that emerge from Ractive's statefulness and dependency tracking, such as complex but easy-to-create animations. We're one step closer to the holy grail of completely declarative, reactive programming.\n\n\nBut we're only getting started. While it's been used in production in several interactives, it's still an early-stage project which needs brave souls to try it out in projects and (if necessary!) submit bug reports. If you build something with it, we'd love to hear from you.\n\n\n\n\nInteractive \ndata visualisations\n are much easier to create with Ractive.js - no DOM event handling, no state management, no labyrinthine render methods\n\n\nAcknowledgements\n\n\nThe development of Ractive was made possible, in part, by the \nBill and Melinda Gates Foundation\n's support for the Guardian \nGlobal Development\n desk.", 
            "title": "Introducing Ractive.js"
        }, 
        {
            "location": "/articles/introducing-ractive-js/#introducing-ractivejs", 
            "text": "Originally posted on the  Guardian developer blog   Ractive.js is used to create guardian.co.uk interactives, such as  Food game: How well do you know the world?  Anyone with fond memories of the  sound of dial-up internet  will understand how ridiculous it would have seemed, to the web's pioneers, that we would one day be using this geeky information exchange format to play games, do grocery shopping, collaborate on spreadsheets and even  build more webapps . Yet here we are.  But despite taking over the world, the web has a dirty secret: it's actually a lousy platform for creating many of the experiences we take for granted. Let me qualify that: it's an amazing technology for creating  documents , but for creating  apps  - interactive experiences that respond to user input, and represent changing data - web development can be akin to pulling teeth.   Consider the following simple task. We have an interface that shows our user, Dave, how many unread messages he has. When he gets a new message, how do we update the interface?  p Hello Dave! You have 4 new messages. /p   In the bad old days, you'd have to reload the page, and the server would send you some freshly-rendered HTML. But let's assume we've got a model that contains our data, and that we need to update the existing view. Here are our options:", 
            "title": "Introducing Ractive.js"
        }, 
        {
            "location": "/articles/introducing-ractive-js/#1-just-use-jquery", 
            "text": "var p = $('p');\n\nfunction updateView (username, msgCount) {\n    p.text('Hello ' + username + '! You have ' + msgCount + ' new messages.');\n};  This is generally agreed to be a Bad Idea - mixing your templates and your logic will end in tears. What if a non-programmer needs to change the wording? They'll probably break something, that's what.", 
            "title": "1. Just use jQuery"
        }, 
        {
            "location": "/articles/introducing-ractive-js/#2-target-specific-elements", 
            "text": "p \n    Hello  span id='username' /span !\n    You have  span id='msgCount' /span  new messages. /p   var usernameSpan = $('#username'),\n    msgCountSpan = $('#msgCount');\n\nfunction updateUserName (username) {\n    usernameSpan.text(username);\n};\n\nfunction updateMsgCount (msgCount) {\n    msgCountSpan.text(msgCount);\n};\n\n// initialise our view\nupdateUsername(model.username);\nupdateMsgCount(model.msgCount);  Better, except that now we've added two extra  span  elements to the DOM. That means more work for the browser, which can become particularly noticeable on mobile devices. And we've got to traverse the DOM and store references to elements.", 
            "title": "2. Target specific elements"
        }, 
        {
            "location": "/articles/introducing-ractive-js/#3-templating", 
            "text": "p Hello  %= username % ! You have  %= msgCount %  new messages. /p   Now we're getting somewhere - our templates and our logic are cleanly separated. But wait! What happens when we update the view?  var body = $(body),\n    // we're using Underscore templates here\n    template = new _.template(templateStr);\n\nfunction updateView (model) {\n    var html = template({\n        username: model.username,\n        msgCount: model.msgCount\n    });\n\n    body.html(html);\n};\n\n// initialise\nupdateView(model);  What happens is that the existing element gets removed from the DOM, and a new one gets created. At best, the old one will be hoovered up by the  garbage collector ; at worst, it will remain in memory. Either way, it's bad for performance.  In the context of this contrived example it might seem trivial, but as an app becomes more complex, these things start to show.", 
            "title": "3. Templating"
        }, 
        {
            "location": "/articles/introducing-ractive-js/#4-just-use-angular", 
            "text": "At this point, many developers will point you towards a framework such as  AngularJS  or  EmberJS . These frameworks do a lot of the heavy lifting for you, particularly as far as model-view data binding is concerned.  Angular in particular is hugely popular at the moment. (The Guardian is currently using it for a major internal project, in fact.)  But these frameworks also have a cost - they tend to be fairly large, and once you've finished the 'hello world' tutorials they have steep learning curves. Particularly for smaller projects, it's often a case of using a sledgehammer to crack a nut.  You see the problem. What should be an incredibly basic task is a snakepit of compromises and ugly code - yet we're all so used to developing this way that we're barely even aware of how awkward it is.", 
            "title": "4. Just use Angular"
        }, 
        {
            "location": "/articles/introducing-ractive-js/#enter-ractivejs", 
            "text": "Ractive was initially created to tackle the data binding problem in a more elegant way. We on the  Guardian interactive team  are acutely aware of the challenges of creating app-like experiences on the web; interactives, by their nature, require a huge amount of DOM manipulation, and as slaves to the editorial agenda we typically have tight deadlines.  The above example, with Ractive, would go something like this:  p Hello {{username}}! You have {{msgCount}} new messages. /p   var view = new Ractive({\n    el: document.body,\n    template: templateStr,\n    data: model // contains our username and msgCount properties\n});\n\nfunction updateView (model) {\n    view.set(model);\n};  Initially, Ractive parses the template and determines that  {{msgCount}}  should be treated as a separate  text node , which depends on the  msgCount  property of our model.  When you call  view.set() , Ractive compares the new data against its current state, and scans its internal dependency graph to see if any part of the DOM needs to be updated. If so, it only touches those parts - which means no DOM nodes will be created or destroyed.  The browser has much less work to do, but - and this is the crucial part - so does the developer. The benefits of this approach become increasingly apparent as you deal with more complex templates, representing more complex data. You can see for yourself how it makes life easier by following the  tutorials  or checking out the  examples .", 
            "title": "Enter Ractive.js"
        }, 
        {
            "location": "/articles/introducing-ractive-js/#beyond-data-binding", 
            "text": "It soon became apparent that this approach enables us to do other things more efficiently as well. It's a philosophical change in the relationship between HTML and JavaScript - HTML is no longer an inert substance which must have life breathed into it, but a blueprint for an app that is interactive by default.  Take event handling for example. Web developers are used to peppering their HTML with meaningless  id  and  class  attributes as 'hooks', so that they can later traverse the DOM, find them, and add event handlers:  button id='activate' Activate! /button  button id='deactivate' Deactivate! /button   $('#activate').on('click', function () {\n    alert('Activating!');\n});\n\n$('#deactivate').on('click', function () {\n    alert('Deactivating!');\n});  But if you treat the HTML as a blueprint, you can bake the semantics of user interaction right into your template:  button proxy-click='activate' Activate! /button  button proxy-click='deactivate' Deactivate! /button   view.on({\n    activate: function () {\n        alert('Activating!');\n    },\n    deactivate: function () {\n        alert('Deactivating!');\n    }\n});  Moreover, we can now automatically take care of things like reusing event handlers and automatically unbinding them when they're no longer needed. Event delegation becomes unnecessary. As with data binding, this approach prevents your code from becoming unwieldy as your app grows.", 
            "title": "Beyond data binding"
        }, 
        {
            "location": "/articles/introducing-ractive-js/#sexy-features", 
            "text": "So far, this all sounds fairly prosaic - handy, perhaps, but nothing you can't already do with  vanilla JS . But the real fun starts when we start exploiting some of the features that emerge from Ractive's statefulness and dependency tracking, such as complex but easy-to-create animations. We're one step closer to the holy grail of completely declarative, reactive programming.  But we're only getting started. While it's been used in production in several interactives, it's still an early-stage project which needs brave souls to try it out in projects and (if necessary!) submit bug reports. If you build something with it, we'd love to hear from you.   Interactive  data visualisations  are much easier to create with Ractive.js - no DOM event handling, no state management, no labyrinthine render methods", 
            "title": "Sexy features"
        }, 
        {
            "location": "/articles/introducing-ractive-js/#acknowledgements", 
            "text": "The development of Ractive was made possible, in part, by the  Bill and Melinda Gates Foundation 's support for the Guardian  Global Development  desk.", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/articles/the-origins-of-ractive/", 
            "text": "The Origins of Ractive.js\n\n\nOriginally posted on \nSource\n, the blog for newsroom developers and hacker-journalists\n\n\nMaking interactives is hard. You have to:\n\n\n\n\nfigure out the story\n\n\nfind some data (possibly) and clean it/transform it (almost certainly)\n\n\ndesign a user interface\n\n\nmark it up with HTML\n\n\nstyle it with CSS\n\n\nmake it dance with JavaScript\n\n\ntest it in different browsers and on mobile devices\n\n\ndeploy it\n\n\nfix all the bugs you missed\n\n\ndeploy it again\n\n\n\n\n...and you have to do all that against deadlines that would make most developers wince. And yet here\u2019s the thing: in many newsrooms, the people building these interactive stories \u2014 and in so doing figuring out the rules of a \nfundamentally new form of media\n \u2014 are not experienced developers.\n\n\nThey\u2019re journalist-hackers and lone crusaders, fighting for the future of news against (in some cases) bureaucratic overlords who still think video on the web is the next big thing. And they\u2014we\u2014deserve better weapons for the fight.\n\n\n\n\n\nOrigins\n\n\nTwo years ago, as a journalist at \nCitywire\n, I began tinkering with JavaScript. I was lucky\u2014I had supportive bosses, and the dev team decided it was better to help me become less dangerous than to try and shut me down\u2014and so we were able to produce a few interactives, such as \nthis piece on UK-wide rent hikes\n.\n\n\nBut I was so far out of my depth. Keeping all the different components of an interactive in sync, handling user events like mouse clicks, storing dozens of references to jQuery objects so I could manipulate them\u2014it was chaos. I longed for a library that would help me do all these things.\n\n\nLater, when I joined the \nGuardian Interactive team\n, I found myself surrounded by brilliant and experienced developers, and quickly realised my jQuery spaghetti wasn\u2019t going to cut it any more. But if my dream library didn\u2019t exist, I was going to have to build it.\n\n\nHow does Ractive.js help?\n\n\nThe core premise of Ractive is that \ndeclarative programming\n is easier than \nimperative programming\n. In other words, if you can \ndeclare\n your intentions, rather than laboriously describing the steps you want the computer to take to realise your intentions, you can finish work and get to the pub sooner.\n\n\nWhat this means in practice is that more of your app is defined in HTML templates. To take the simplest possible example, let\u2019s make a Hello World template:\n\n\np\nHello, {{name}}!\n/p\n\n\n\n\n\nDescribing our interactive with an HTML template is obviously better than \ndocument.createElement('p').innerHTML = 'Hello ,' + name + '!'\n \u2014 very few people would dispute that. But where Ractive differs radically from other templating libraries is that it \nparses\n the HTML and fully understands its structure \u2014 and the bits of data it depends on \u2014 rather than simply replacing \n{{name}}\n and dumping the resulting HTML onto the page.\n\n\nThe result is that updating the interactive with new data is painless:\n\n\nractive.set( 'name', 'World' );\n\n\n\n\nMoreover, because Ractive is \nstate-aware\n, it can avoid doing unnecessary updates, thus easing what\u2019s generally considered to be the biggest performance bottleneck in web development.\n\n\nThat\u2019s just the beginning\n\n\nIt turns out that this approach makes it really easy to do a whole suite of things\u2014animations, SVG data visualisations, neater event handling, collecting user input, and so on.\n\n\nIf these sound like things that could make your life easier then you can find all the \nexamples\n, \ntutorials\n and \ndocumentation\n you need to get started\u2014including the \n60-second set-up\n \u2014 via \nractive.js.org\n.\n\n\nRactive has been used to build a number of Guardian interactives, so even though development is still ongoing (\nissues and pull requests\n are always welcome!) it\u2019s definitely production-ready. It\u2019s been tested successfully in IE8+ and in all modern browsers.\n\n\nIf you build something with Ractive, we\u2019d love to hear about it.\n\n\nAcknowledgment\n\n\nThe development of Ractive.js was made possible, in part, by the \nBill \n Melinda Gates Foundation\n\u2019s support for \nGuardian Global development\n.", 
            "title": "The Origins Of Ractive"
        }, 
        {
            "location": "/articles/the-origins-of-ractive/#the-origins-of-ractivejs", 
            "text": "Originally posted on  Source , the blog for newsroom developers and hacker-journalists  Making interactives is hard. You have to:   figure out the story  find some data (possibly) and clean it/transform it (almost certainly)  design a user interface  mark it up with HTML  style it with CSS  make it dance with JavaScript  test it in different browsers and on mobile devices  deploy it  fix all the bugs you missed  deploy it again   ...and you have to do all that against deadlines that would make most developers wince. And yet here\u2019s the thing: in many newsrooms, the people building these interactive stories \u2014 and in so doing figuring out the rules of a  fundamentally new form of media  \u2014 are not experienced developers.  They\u2019re journalist-hackers and lone crusaders, fighting for the future of news against (in some cases) bureaucratic overlords who still think video on the web is the next big thing. And they\u2014we\u2014deserve better weapons for the fight.", 
            "title": "The Origins of Ractive.js"
        }, 
        {
            "location": "/articles/the-origins-of-ractive/#origins", 
            "text": "Two years ago, as a journalist at  Citywire , I began tinkering with JavaScript. I was lucky\u2014I had supportive bosses, and the dev team decided it was better to help me become less dangerous than to try and shut me down\u2014and so we were able to produce a few interactives, such as  this piece on UK-wide rent hikes .  But I was so far out of my depth. Keeping all the different components of an interactive in sync, handling user events like mouse clicks, storing dozens of references to jQuery objects so I could manipulate them\u2014it was chaos. I longed for a library that would help me do all these things.  Later, when I joined the  Guardian Interactive team , I found myself surrounded by brilliant and experienced developers, and quickly realised my jQuery spaghetti wasn\u2019t going to cut it any more. But if my dream library didn\u2019t exist, I was going to have to build it.", 
            "title": "Origins"
        }, 
        {
            "location": "/articles/the-origins-of-ractive/#how-does-ractivejs-help", 
            "text": "The core premise of Ractive is that  declarative programming  is easier than  imperative programming . In other words, if you can  declare  your intentions, rather than laboriously describing the steps you want the computer to take to realise your intentions, you can finish work and get to the pub sooner.  What this means in practice is that more of your app is defined in HTML templates. To take the simplest possible example, let\u2019s make a Hello World template:  p Hello, {{name}}! /p   Describing our interactive with an HTML template is obviously better than  document.createElement('p').innerHTML = 'Hello ,' + name + '!'  \u2014 very few people would dispute that. But where Ractive differs radically from other templating libraries is that it  parses  the HTML and fully understands its structure \u2014 and the bits of data it depends on \u2014 rather than simply replacing  {{name}}  and dumping the resulting HTML onto the page.  The result is that updating the interactive with new data is painless:  ractive.set( 'name', 'World' );  Moreover, because Ractive is  state-aware , it can avoid doing unnecessary updates, thus easing what\u2019s generally considered to be the biggest performance bottleneck in web development.", 
            "title": "How does Ractive.js help?"
        }, 
        {
            "location": "/articles/the-origins-of-ractive/#thats-just-the-beginning", 
            "text": "It turns out that this approach makes it really easy to do a whole suite of things\u2014animations, SVG data visualisations, neater event handling, collecting user input, and so on.  If these sound like things that could make your life easier then you can find all the  examples ,  tutorials  and  documentation  you need to get started\u2014including the  60-second set-up  \u2014 via  ractive.js.org .  Ractive has been used to build a number of Guardian interactives, so even though development is still ongoing ( issues and pull requests  are always welcome!) it\u2019s definitely production-ready. It\u2019s been tested successfully in IE8+ and in all modern browsers.  If you build something with Ractive, we\u2019d love to hear about it.", 
            "title": "That\u2019s just the beginning"
        }, 
        {
            "location": "/articles/the-origins-of-ractive/#acknowledgment", 
            "text": "The development of Ractive.js was made possible, in part, by the  Bill   Melinda Gates Foundation \u2019s support for  Guardian Global development .", 
            "title": "Acknowledgment"
        }, 
        {
            "location": "/articles/ractive-js-expressions-and-the-new-wave-of-reactive-programming/", 
            "text": "Ractive.js expressions and the new wave of reactive programming\n\n\nOriginally posted at \nflippinawesome.org\n\n\nDedicated followers of JavaScript fashion will by now have noticed this season\u2019s hot new trend. If you haven\u2019t spotted it yet, here are a few projects sporting this style on the GitHub catwalk \u2013 \nReact\n, \nReactive.js\n, \ncomponent/reactive\n and \nreactive.coffee\n.\n\n\nThat\u2019s right: \nreactive programming\n is the new black.\n\n\nAt a high level, the idea behind reactive programming is that changes in state propagate throughout a system. Put crudely, this means that in a reactive system where \na = b * 2\n, whenever the value of \nb\n changes, the value of \na\n will also change, rather than forever being equal to whatever \nb * 2\n was at the time of the statement.\n\n\nWhen we take this idea and apply it to user interfaces, we eliminate the DOM manipulation drudgery that dominates web developers\u2019 lives.\n\n\n\n\n\nRactive.js is a new library initially developed to create interactive (hence the name \u2013 not to be confused with Reactive.js!) news applications at \ntheguardian.com\n. It is designed to dramatically reduce the effort involved in creating web apps by embracing these principles.\n\n\nLet\u2019s look at a simple example:\n\n\n// We create a new ractive, which renders the following to a container element:\n// \np\nHello, Dave! You have 4 tasks remaining.\n/p\n\n\nvar ractive = new Ractive({\n    el: container,\n    template: '\np\nHello, {{name}}! You have {{tasks.incomplete}} tasks remaining.\n/p\n',\n    data: { name: 'Dave', tasks: { incomplete: 4, total: 11 } }\n});\n\n// Later we get some new data:\nractive.set( 'tasks', { incomplete: 5, total: 12 });\n\n// The ractive reacts accordingly, surgically updating the part of the DOM that is\n// now out of date:\n// \np\nHello, Dave! You have 5 tasks remaining.\n/p\n\n\n\n\n\nRather than doing any kind of polling or brute-force \u2018dirty checking,\u2019 this uses an elegant dependency tracking system: the text node containing the number of incomplete tasks depends on the \ntasks.incomplete\n \nkeypath\n, which is a child of the \ntasks\n keypath. So when we update \ntasks\n, we know that we need to check to see if \ntasks.incomplete\n has changed \u2013 but we don\u2019t need to bother checking \ntasks.total\n, because nothing depends on that keypath.\n\n\nAs applications grow in complexity, this means much less work for the developer. You might think it sounds like more work for the browser, but it\u2019s not. The non-reactive way to do interactive UI typically involves re-rendering views regardless of whether they\u2019ve changed, and replacing chunks of perfectly good DOM (why hello, \ngarbage collector\n), which is typically much less efficient.\n\n\nIn other words, reactive UI is a win-win \u2013 better for performance, and better for your sanity.\n\n\nThe secret sauce: expressions\n\n\nThis article won\u2019t go any further into the basics of what Ractive does or why we built it \u2013 if you\u2019re interested, you can \nfollow the interactive tutorials\n or \nread the introductory blog post\n. Instead, we\u2019re going to focus on one of the features that helps Ractive stand out from its peers, namely \nexpressions\n.\n\n\nExpressions allow you to take the logic that only your interface cares about, and put it in your template \nwhere it belongs\n. Yes, I just said that! If you\u2019ve ever had to debug badly written PHP (for example), you may well shudder at the suggestion that logic belongs in templates. But while it\u2019s true that \nbusiness logic\n doesn\u2019t belong in your templates, it\u2019s equally true that a lot of \npresentation logic\n \u2013 aka \u2018data massaging\u2019 \u2013 doesn\u2019t really belong in your code.\n\n\n(If you still need convincing, here\u2019s a couple of good articles on the subject: \nThe Case Against Logic-less Templates\n and \nCult of Logic-Less Templates\n.)\n\n\nLet\u2019s take our initial example and turn it into a basic todo app along the lines of \nTodoMVC\n. Our template looks like this \u2013 ignore the question marks for now:\n\n\np\nHello, {{name}}! You have ??? tasks remaining.\n/p\n\n\n\nul\n\n{{#tasks :i}}\n    \nli class='task'\n{{i}}: {{description}}\n/li\n\n{{/tasks}}\n\n/ul\n\n\n\n\n\nMeanwhile our \nmodel\n, if you want to use MVC terminology, is a simple array of objects representing tasks:\n\n\ntasks = [\n    { completed: true,  description: 'Add a task' },\n    { completed: false, description: 'Add some more tasks' }.\n    { completed: false, description: 'Solve P = NP' }\n];\n\nractive = new Ractive({\n    el: container,\n    template: template,\n    data: { name: 'Dave', tasks: tasks }\n});\n\n\n\n\nThis renders the following:\n\n\np\nHello, Dave! You have ??? tasks remaining.\n/p\n\n\n\nul\n\n    \nli class='task'\n0: Add a task\n/li\n\n    \nli class='task'\n1: Add some more tasks\n/li\n\n    \nli class='task'\n2: Solve P = NP\n/li\n\n\n/ul\n\n\n\n\n\nThis time, there\u2019s no \ntasks.incomplete\n property, because \ntasks\n is an array. We\u2019ll come back to that. The first job is to rejig the numbers so that it starts at 1, because lists starting with 0 only make sense to programmers. Doing so is trivial:\n\n\nli class='task'\n{{i+1}}: {{description}}\n/li\n\n\n\n\n\nNext, let\u2019s add a \ncomplete\n class to any completed task:\n\n\nli class='task {{ completed ? \ncomplete\n : \npending\n }}'\n{{i+1}}: {{description}}\n/li\n\n\n\n\n\nNow, our rendered task list looks like this:\n\n\np\nHello, Dave! You have ??? tasks remaining.\n/p\n\n\n\nul\n\n    \nli class='task complete'\n1: Add a task\n/li\n\n    \nli class='task pending'\n2: Add some more tasks\n/li\n\n    \nli class='task pending'\n3: Solve P = NP\n/li\n\n\n/ul\n\n\n\n\n\nNow, let\u2019s deal with those question marks. One way \u2013 the traditional way \u2013 would be to keep track of the incomplete count as a separate value in our model (or viewmodel, depending on which tribe you belong to), and update it every time the task list changed. The trouble with that is you have to add the necessary logic to every bit of your app that can change the model in some way \u2013 a toggle on each task, a \u2018mark all as complete\u2019 button, the code that reads from the server (or local storage), or whatever else gets added in future. It doesn\u2019t scale.\n\n\nA better way is to have the template react to changes by calling any necessary logic \nwhen it needs to\n:\n\n\np\nHello, Dave! You have {{ tasks.filter( incomplete ).length }} tasks remaining.\n/p\n\n\n\n\n\nThen, we just need to add an \nincomplete\n filter to our model:\n\n\nractive = new Ractive({\n    el: container,\n    template: template,\n    data: {\n        name: 'Dave',\n        tasks: tasks,\n        incomplete: function ( item ) {\n            return !item.completed;\n        }\n    }\n});\n\n\n\n\nNow, whenever \ntasks\n changes \u2013 whether because we\u2019ve added a new one, or changed the status of one or more tasks, or whatever \u2013 the expression will be re-evaluated. If the number of incomplete tasks has changed, the DOM will be updated.\n\n\nAs our app becomes more complex, this approach scales beautifully, saving us from a convoluted observing/massaging/updating of our data.\n\n\n(You can see a \nfully fleshed out TodoMVC implementation here\n \u2013 (the \nsource code\n is possibly the shortest of any implementation, and arguably some of the most readable).\n)\n\n\nIt also allows us to do things like \nsophisticated animations\n, without reams of complex render logic.\n\n\nHow does it work?\n\n\nTraditional templating engines work by \ninterpolating strings\n, the result of which is typically rendered using \ninnerHTML\n. Ractive is different \u2013 it parses templates into a tree-like JSON structure which contains the DNA of the app, using a \nPEG-style parser\n. When it encounters an expression, the parser first creates an \nabstract syntax tree\n representation of it, then extracts the \nreferences\n from the AST, then collapses it down to a string representation.\n\n\nRactive.parse( '{{i+1}}' );\n\n// results in the following - it's deliberately terse, so that\n// you can parse on the server and send the result to browsers\n// without wasting bytes:\n// {\n//   t: 2,                  // the type of mustache\n//   x: {                    // the expression\n//       r: [ \ni\n ],    // the references used in the expression\n//       s: \n${0}+1\n    // a reference-agnostic string representation\n//   }\n// }\n\n\n\n\nLater, when Ractive renders this mustache, it will try to \nresolve the references\n used in the expression. In this example, there\u2019s only one reference \u2013 \ni\n \u2013 which resolves to \n0\n for the first task, then \n1\n, then \n2\n and so on. Ractive creates a function \u2013 using the \nFunction constructor\n \u2013 that takes the value of \ni\n as an argument and returns \ni+1\n.\n\n\nThis might seem like a roundabout way to add 1 to something. But because we only need to create the function once, rather than repeatedly \neval\ning code (which is slow), it\u2019s a memory-efficient and performant way to solve the problem even when dealing with hundreds of tasks.\n\n\nAnd because we know which references are involved, we know when to call the function again. Consider the next expression:\n\n\nRactive.parse( '{{ completed ? \ncomplete\n : \npending\n }}' );\n\n// {\n//   t: 2,\n//   x: {\n//       r: [ \ncompleted\n ],\n//       s: \n${0}?'complete':'pending'\n\n//   }\n// }\n\n\n\n\nFor the first task, the \ncompleted\n reference resolves to the keypath \ntasks.0.completed\n \u2013 for the second, \ntasks.1.completed\n and so on. In each case, Ractive \nregisters the mustache\n as a \ndependant\n of the keypath, so that when \ntasks.0.completed\n changes (again, it doesn\u2019t matter what happened to cause it to change \u2013 that\u2019s the beauty of reactive programming), the expression is re-evaluated and the DOM is updated.\n\n\nSo is it \u2018real JavaScript\u2019?\n\n\nUp to a point. Since in a reactive system we don\u2019t have control over when the expression is evaluated, it\u2019s important that expressions don\u2019t have \nside effects\n \u2013 so if we try to use assignment operators such as \nfoo = bar\n or \nfoo += 1\n, the parser will fail. The same goes for certain keywords, such as \nnew\n, \ndelete\n and \nfunction\n.\n\n\nOf course, it\u2019s still possible to create side-effects by referencing a function which itself has side-effects. Remember our \nincomplete\n filter? There\u2019s nothing to stop you doing this:\n\n\nractive = new Ractive({\n    el: container,\n    template: template,\n    data: {\n        name: 'Dave',\n        tasks: tasks,\n        incomplete: function ( item ) {\n            doSomeExpensiveComputation();\n            counter += 1;\n            return !item.completed;\n        }\n    }\n});\n\n\n\n\nBut by parsing expressions and blocking \u2018accidental\u2019 side-effects, we can encourage best practices without preventing power users from manipulating the system to their own ends.\n\n\nThe future\n\n\nExpect to see more examples of the reactive programming trend coming to a repository near you. As with all programming paradigms, it\u2019s not a silver bullet, but by integrating reactive thinking into our work we can start to structure our applications in a way that is more readable and (often) more efficient.\n\n\nRactive.js is under active development \u2013 it\u2019s production-ready (to get started, \ntry the 60 second setup\n or \nfollow the interactive tutorials\n), but will continue to evolve as we collectively figure out the secrets of reactive programming. If you\u2019re interested in being part of that conversation, \ncome on over to GitHub\n and help shape the future of web development.", 
            "title": "Ractive.js Expressions And The New Wave Of Reactive Programming"
        }, 
        {
            "location": "/articles/ractive-js-expressions-and-the-new-wave-of-reactive-programming/#ractivejs-expressions-and-the-new-wave-of-reactive-programming", 
            "text": "Originally posted at  flippinawesome.org  Dedicated followers of JavaScript fashion will by now have noticed this season\u2019s hot new trend. If you haven\u2019t spotted it yet, here are a few projects sporting this style on the GitHub catwalk \u2013  React ,  Reactive.js ,  component/reactive  and  reactive.coffee .  That\u2019s right:  reactive programming  is the new black.  At a high level, the idea behind reactive programming is that changes in state propagate throughout a system. Put crudely, this means that in a reactive system where  a = b * 2 , whenever the value of  b  changes, the value of  a  will also change, rather than forever being equal to whatever  b * 2  was at the time of the statement.  When we take this idea and apply it to user interfaces, we eliminate the DOM manipulation drudgery that dominates web developers\u2019 lives.   Ractive.js is a new library initially developed to create interactive (hence the name \u2013 not to be confused with Reactive.js!) news applications at  theguardian.com . It is designed to dramatically reduce the effort involved in creating web apps by embracing these principles.  Let\u2019s look at a simple example:  // We create a new ractive, which renders the following to a container element:\n//  p Hello, Dave! You have 4 tasks remaining. /p \n\nvar ractive = new Ractive({\n    el: container,\n    template: ' p Hello, {{name}}! You have {{tasks.incomplete}} tasks remaining. /p ',\n    data: { name: 'Dave', tasks: { incomplete: 4, total: 11 } }\n});\n\n// Later we get some new data:\nractive.set( 'tasks', { incomplete: 5, total: 12 });\n\n// The ractive reacts accordingly, surgically updating the part of the DOM that is\n// now out of date:\n//  p Hello, Dave! You have 5 tasks remaining. /p   Rather than doing any kind of polling or brute-force \u2018dirty checking,\u2019 this uses an elegant dependency tracking system: the text node containing the number of incomplete tasks depends on the  tasks.incomplete   keypath , which is a child of the  tasks  keypath. So when we update  tasks , we know that we need to check to see if  tasks.incomplete  has changed \u2013 but we don\u2019t need to bother checking  tasks.total , because nothing depends on that keypath.  As applications grow in complexity, this means much less work for the developer. You might think it sounds like more work for the browser, but it\u2019s not. The non-reactive way to do interactive UI typically involves re-rendering views regardless of whether they\u2019ve changed, and replacing chunks of perfectly good DOM (why hello,  garbage collector ), which is typically much less efficient.  In other words, reactive UI is a win-win \u2013 better for performance, and better for your sanity.", 
            "title": "Ractive.js expressions and the new wave of reactive programming"
        }, 
        {
            "location": "/articles/ractive-js-expressions-and-the-new-wave-of-reactive-programming/#the-secret-sauce-expressions", 
            "text": "This article won\u2019t go any further into the basics of what Ractive does or why we built it \u2013 if you\u2019re interested, you can  follow the interactive tutorials  or  read the introductory blog post . Instead, we\u2019re going to focus on one of the features that helps Ractive stand out from its peers, namely  expressions .  Expressions allow you to take the logic that only your interface cares about, and put it in your template  where it belongs . Yes, I just said that! If you\u2019ve ever had to debug badly written PHP (for example), you may well shudder at the suggestion that logic belongs in templates. But while it\u2019s true that  business logic  doesn\u2019t belong in your templates, it\u2019s equally true that a lot of  presentation logic  \u2013 aka \u2018data massaging\u2019 \u2013 doesn\u2019t really belong in your code.  (If you still need convincing, here\u2019s a couple of good articles on the subject:  The Case Against Logic-less Templates  and  Cult of Logic-Less Templates .)  Let\u2019s take our initial example and turn it into a basic todo app along the lines of  TodoMVC . Our template looks like this \u2013 ignore the question marks for now:  p Hello, {{name}}! You have ??? tasks remaining. /p  ul \n{{#tasks :i}}\n     li class='task' {{i}}: {{description}} /li \n{{/tasks}} /ul   Meanwhile our  model , if you want to use MVC terminology, is a simple array of objects representing tasks:  tasks = [\n    { completed: true,  description: 'Add a task' },\n    { completed: false, description: 'Add some more tasks' }.\n    { completed: false, description: 'Solve P = NP' }\n];\n\nractive = new Ractive({\n    el: container,\n    template: template,\n    data: { name: 'Dave', tasks: tasks }\n});  This renders the following:  p Hello, Dave! You have ??? tasks remaining. /p  ul \n     li class='task' 0: Add a task /li \n     li class='task' 1: Add some more tasks /li \n     li class='task' 2: Solve P = NP /li  /ul   This time, there\u2019s no  tasks.incomplete  property, because  tasks  is an array. We\u2019ll come back to that. The first job is to rejig the numbers so that it starts at 1, because lists starting with 0 only make sense to programmers. Doing so is trivial:  li class='task' {{i+1}}: {{description}} /li   Next, let\u2019s add a  complete  class to any completed task:  li class='task {{ completed ?  complete  :  pending  }}' {{i+1}}: {{description}} /li   Now, our rendered task list looks like this:  p Hello, Dave! You have ??? tasks remaining. /p  ul \n     li class='task complete' 1: Add a task /li \n     li class='task pending' 2: Add some more tasks /li \n     li class='task pending' 3: Solve P = NP /li  /ul   Now, let\u2019s deal with those question marks. One way \u2013 the traditional way \u2013 would be to keep track of the incomplete count as a separate value in our model (or viewmodel, depending on which tribe you belong to), and update it every time the task list changed. The trouble with that is you have to add the necessary logic to every bit of your app that can change the model in some way \u2013 a toggle on each task, a \u2018mark all as complete\u2019 button, the code that reads from the server (or local storage), or whatever else gets added in future. It doesn\u2019t scale.  A better way is to have the template react to changes by calling any necessary logic  when it needs to :  p Hello, Dave! You have {{ tasks.filter( incomplete ).length }} tasks remaining. /p   Then, we just need to add an  incomplete  filter to our model:  ractive = new Ractive({\n    el: container,\n    template: template,\n    data: {\n        name: 'Dave',\n        tasks: tasks,\n        incomplete: function ( item ) {\n            return !item.completed;\n        }\n    }\n});  Now, whenever  tasks  changes \u2013 whether because we\u2019ve added a new one, or changed the status of one or more tasks, or whatever \u2013 the expression will be re-evaluated. If the number of incomplete tasks has changed, the DOM will be updated.  As our app becomes more complex, this approach scales beautifully, saving us from a convoluted observing/massaging/updating of our data.  (You can see a  fully fleshed out TodoMVC implementation here  \u2013 (the  source code  is possibly the shortest of any implementation, and arguably some of the most readable). )  It also allows us to do things like  sophisticated animations , without reams of complex render logic.", 
            "title": "The secret sauce: expressions"
        }, 
        {
            "location": "/articles/ractive-js-expressions-and-the-new-wave-of-reactive-programming/#how-does-it-work", 
            "text": "Traditional templating engines work by  interpolating strings , the result of which is typically rendered using  innerHTML . Ractive is different \u2013 it parses templates into a tree-like JSON structure which contains the DNA of the app, using a  PEG-style parser . When it encounters an expression, the parser first creates an  abstract syntax tree  representation of it, then extracts the  references  from the AST, then collapses it down to a string representation.  Ractive.parse( '{{i+1}}' );\n\n// results in the following - it's deliberately terse, so that\n// you can parse on the server and send the result to browsers\n// without wasting bytes:\n// {\n//   t: 2,                  // the type of mustache\n//   x: {                    // the expression\n//       r: [  i  ],    // the references used in the expression\n//       s:  ${0}+1     // a reference-agnostic string representation\n//   }\n// }  Later, when Ractive renders this mustache, it will try to  resolve the references  used in the expression. In this example, there\u2019s only one reference \u2013  i  \u2013 which resolves to  0  for the first task, then  1 , then  2  and so on. Ractive creates a function \u2013 using the  Function constructor  \u2013 that takes the value of  i  as an argument and returns  i+1 .  This might seem like a roundabout way to add 1 to something. But because we only need to create the function once, rather than repeatedly  eval ing code (which is slow), it\u2019s a memory-efficient and performant way to solve the problem even when dealing with hundreds of tasks.  And because we know which references are involved, we know when to call the function again. Consider the next expression:  Ractive.parse( '{{ completed ?  complete  :  pending  }}' );\n\n// {\n//   t: 2,\n//   x: {\n//       r: [  completed  ],\n//       s:  ${0}?'complete':'pending' \n//   }\n// }  For the first task, the  completed  reference resolves to the keypath  tasks.0.completed  \u2013 for the second,  tasks.1.completed  and so on. In each case, Ractive  registers the mustache  as a  dependant  of the keypath, so that when  tasks.0.completed  changes (again, it doesn\u2019t matter what happened to cause it to change \u2013 that\u2019s the beauty of reactive programming), the expression is re-evaluated and the DOM is updated.", 
            "title": "How does it work?"
        }, 
        {
            "location": "/articles/ractive-js-expressions-and-the-new-wave-of-reactive-programming/#so-is-it-real-javascript", 
            "text": "Up to a point. Since in a reactive system we don\u2019t have control over when the expression is evaluated, it\u2019s important that expressions don\u2019t have  side effects  \u2013 so if we try to use assignment operators such as  foo = bar  or  foo += 1 , the parser will fail. The same goes for certain keywords, such as  new ,  delete  and  function .  Of course, it\u2019s still possible to create side-effects by referencing a function which itself has side-effects. Remember our  incomplete  filter? There\u2019s nothing to stop you doing this:  ractive = new Ractive({\n    el: container,\n    template: template,\n    data: {\n        name: 'Dave',\n        tasks: tasks,\n        incomplete: function ( item ) {\n            doSomeExpensiveComputation();\n            counter += 1;\n            return !item.completed;\n        }\n    }\n});  But by parsing expressions and blocking \u2018accidental\u2019 side-effects, we can encourage best practices without preventing power users from manipulating the system to their own ends.", 
            "title": "So is it \u2018real JavaScript\u2019?"
        }, 
        {
            "location": "/articles/ractive-js-expressions-and-the-new-wave-of-reactive-programming/#the-future", 
            "text": "Expect to see more examples of the reactive programming trend coming to a repository near you. As with all programming paradigms, it\u2019s not a silver bullet, but by integrating reactive thinking into our work we can start to structure our applications in a way that is more readable and (often) more efficient.  Ractive.js is under active development \u2013 it\u2019s production-ready (to get started,  try the 60 second setup  or  follow the interactive tutorials ), but will continue to evolve as we collectively figure out the secrets of reactive programming. If you\u2019re interested in being part of that conversation,  come on over to GitHub  and help shape the future of web development.", 
            "title": "The future"
        }, 
        {
            "location": "/articles/ractive-vs-angular/", 
            "text": "Ractive vs Angular\n\n\n\n\nLots of people have asked what the difference is between Ractive and other libraries and frameworks. It's long been my intention to write a series of articles attempting to answer, but I've always put it off because a) I didn't have anywhere to post the articles, and b) I didn't feel qualified to compare Ractive to libraries that I'm not particularly familiar with.\n\n\nNow that I've got round to setting up this blog, a) is no longer an issue. As for b)... well, if I get stuff wrong, people will correct me - this is the Internet, after all. And I'll edit these posts as necessary to keep them accurate.\n\n\nI was going to begin the series by comparing Ractive to \nReact.js\n, which in my view is one of the more interesting JavaScript libraries of 2013. It has lots of philosophical similarities to Ractive, but also some stark differences. It should be an interesting study.\n\n\nBut the question I've had more frequently - and \nmost recently\n - is how Ractive compares to \nAngular\n. So I'm going to start there.\n\n\n\n\n\nWhat is Angular?\n\n\nYou're kidding, right? Angular is a wildly successful project. Its \nGitHub repo\n has 18,579 stargazers (at the time of writing) - almost ten times Ractive's 1,950. Their \ntwitter account\n has 28,629 followers, and there are hundreds if not thousands of \nAngular apps\n in the wild. Most days, an article or video or tutorial about Angular will show up on the Hacker News front page if not on dozens of other front end blogs.\n\n\n\n\n(Fun fact! Way back in the mists of time, Ractive was called Anglebars - because it was kind of halfway between Angular and Handlebars. I even ripped off the logo. In other words, Angular was a big inspiration for Ractive.)\n\n\n\n\n\nIt is, by any measure, an impressive showing. And it's built and maintained by the geniuses at Google, several of whom work on it full time. Ractive, by contrast, has one core contributor - yours truly (though it has an excellent community which has made it immeasurably better) - and is the product of unpaid evenings and weekends. Given a choice between Angular and Ractive for a large production application, most developers would probably be wise to select Angular.\n\n\nSo why bother with Ractive?\n\n\nOne word: simplicity. Angular looks easy at first, but to master it you have to learn some novel concepts (scope, dependency injection, transclusions, modules, directives...) that make writing Angular code feel quite different from writing regular JavaScript. (Before I continue, I should emphasise that I'm not an Angular expert by any stretch - my impressions are largely formed from reading what other people have written.)\n\n\nRactive, on the other hand, is designed to be as simple as possible, but no simpler. That's because of its heritage: it was \ncreated in the newsroom\n of \ntheguardian.com\n for building interactive news applications. These apps have to be built in a very short space of time and work reliably across different environments - there's no time for prototyping etc. Just build it and ship it. You can't spend long optimising things, so the library has to make smart decisions for you.\n\n\n@dmitrigrabov\n Simplest binding framework I\nve ever used is new: \n@RactiveJS\n from the Guardian. \n1. have object\n2. have template\nDone.\n Mike MacCana (@mikemaccana) \nDecember 12, 2013\n\n\n\n\n\n\nMost of all, a lot of people building these kinds of apps aren't experienced developers - they're journalists or graphics people who have learned some JavaScript because they want to expand their skillsets and stay relevant, not because they get a kick out of watching Douglas Crockford videos.\n\n\nFirst piece of code that actually makes sense to my design-oriented brain: \n@RactiveJS\n - still on lesson 5, though\n K. Ant. \uf8ff (@konstantinosant) \nNovember 27, 2013\n\n\n\n\n\n\nDon't try explaining to a hacker-journalist that they need to call \n$scope.digest()\n or that, having just got their head around minification, they need to perform some elaborate maneouvres to prevent the dependency injection from breaking - trust me, they won't care!\n\n\nEnough with the sales pitch. What do they have in common?\n\n\nWell, they're both largely concerned with eliminating ad-hoc DOM manipulation from the list of things developers have to worry about, by doing what's called \ndata binding\n - modifying the page as data (your \nmodel\n, in MVC jargon) changes. Both libraries also offer \ntwo-way data binding\n, so that user interactions with the page update the model as necessary.\n\n\nAngular wasn't the first framework to offer data binding, but it arguably did it better than anyone had before, with a concise syntax based on the \nMustache\n templating language. Ractive also uses Mustache, since it is easy to read and write, is widely used, and comes with a \nformal test suite\n against which implementations like Ractive can check compliance.\n\n\nThey also share philosophical underpinnings. From \nangularjs.org\n:\n\n\n\n\nHTML is great for declaring static documents, but it falters when we try to use it for declaring dynamic views in web-applications ... Other frameworks deal with HTML\u2019s shortcomings by either abstracting away HTML, CSS, and/or JavaScript or by providing an imperative way for manipulating the DOM. Neither of these address the root problem that HTML was not designed for dynamic views.\n\n\n\n\nAmen! Ractive, like Angular, takes the view that we should augment HTML to make it better suited to modern application development, rather than hiding the guts of our apps in JavaScript files, where it's hard to form complete mental models and \nreason effectively\n about them.\n\n\nFinally, both Angular and Ractive believe that your model should take the form of \nPOJOs\n. Loading data from a server without having to convert it to some kind of \nModel\n or \nCollection\n object before you can use it is a liberating feeling. (That said, some apps benefit from the more rigorous approach, and Ractive fully supports that via \nadaptors\n)\n\n\nAnd where do they differ?\n\n\nFirstly, Angular isn't just about your user interface - it has opinions on routing, validation, server communication, testing, and so on. In other words it's a \nframework\n rather than a \nlibrary\n.\n\n\nRactive only really cares about UI. Use any router/backend/whatever you want - that's your responsibility.\n\n\nIn some situations the framework is exactly what you need - a consistent, opinionated foundation on which to build your app. In other situations, it's a straitjacket. Personally I prefer building apps in a more modular fashion, but that's probably because of the type of app I build for a living. YMMV.\n\n\nSecondly, they have very different approaches to data binding. Angular uses 'dirty checking', whereby properties of the model are checked on every \n$scope.digest()\n, which is called automatically most of the time. Ractive uses a dependency tracking mechanism instead. When you call \nractive.set('foo', 'bar')\n, all the \ndependants\n of \nfoo\n are notified (if its value changed). The same principle applies when dealing with complex \nexpressions\n, which means you don't have to constantly worry about whether your computed properties will cause performance issues.\n\n\nMi\u0161ko Hevery, the father of Angular, wrote \nthis Stack Overflow post\n defending dirty checking, containing this zinger when comparing it to dependency tracking as seen in \nKnockout.js\n:\n\n\n\n\nKO dependency tracking is a clever feature for a problem which angular does not have.\n\n\n\n\nTrue, but Angular's \n$digest\n loop is a clever solution for a problem that no other library has! In any case, Pete Hunt of \nReact.js\n fame \ntakes issue\n with the notion that Angular's dirty checking is fast enough.\n\n\nA final important difference is in how your app is rendered. Traditional templating engines compile a string template to a function that, given some data, returns another string (which typically is \ninnerHTML\n'd into the page). Angular (and also Knockout) work by traversing the DOM, reading attributes, and setting up bindings accordingly. Aside from the \nFOUC\n that you then have to work around, this means that your page is peppered with non-validating gubbins like \nng-model\n.\n\n\nRactive takes a different approach. Your template lives as a string, and is parsed (on the server, if needs be - Ractive is \nisomorphic\n) into a tree-like structure that can be transported as JSON. From there, Ractive constructs a lightweight \nparallel DOM\n containing all the information it needs to construct the real DOM and set up data-binding etc. In my view, this is a more hygienic approach. Parsing the template before the browser has a chance to has many benefits, even if some people do question the sanity of doing so:\n\n\nThis is both brilliant \n ridiculous at the same time: \u201cIntroducing Ractive.js: next-generation DOM manipulation\u201d \nhttp://t.co/17uHMKZFCQ\n Rev Dan Catt (@revdancatt) \nJuly 25, 2013\n\n\n\n\n\n\nHonestly, just try it\n\n\nThis was a long post - if you made it this far, I salute you. But if you really want to know the differences between Angular and Ractive, you should just try them both. Ractive has a \n60-second setup guide\n and a set of \ninteractive tutorials\n (with more coming soon), and Angular has \nlearning resources\n of its own.\n\n\nRactive's development has been very community-driven - there is no ivory tower master plan, just hard-won real-life experience distilled into feature requests. It tastes of delicious \ndogfood\n. So if it doesn't have a feature you need, there's a very real chance it could do soon - just \ncome on over to GitHub\n and raise an issue.", 
            "title": "Ractive.js vs Angular"
        }, 
        {
            "location": "/articles/ractive-vs-angular/#ractive-vs-angular", 
            "text": "Lots of people have asked what the difference is between Ractive and other libraries and frameworks. It's long been my intention to write a series of articles attempting to answer, but I've always put it off because a) I didn't have anywhere to post the articles, and b) I didn't feel qualified to compare Ractive to libraries that I'm not particularly familiar with.  Now that I've got round to setting up this blog, a) is no longer an issue. As for b)... well, if I get stuff wrong, people will correct me - this is the Internet, after all. And I'll edit these posts as necessary to keep them accurate.  I was going to begin the series by comparing Ractive to  React.js , which in my view is one of the more interesting JavaScript libraries of 2013. It has lots of philosophical similarities to Ractive, but also some stark differences. It should be an interesting study.  But the question I've had more frequently - and  most recently  - is how Ractive compares to  Angular . So I'm going to start there.", 
            "title": "Ractive vs Angular"
        }, 
        {
            "location": "/articles/ractive-vs-angular/#what-is-angular", 
            "text": "You're kidding, right? Angular is a wildly successful project. Its  GitHub repo  has 18,579 stargazers (at the time of writing) - almost ten times Ractive's 1,950. Their  twitter account  has 28,629 followers, and there are hundreds if not thousands of  Angular apps  in the wild. Most days, an article or video or tutorial about Angular will show up on the Hacker News front page if not on dozens of other front end blogs.   (Fun fact! Way back in the mists of time, Ractive was called Anglebars - because it was kind of halfway between Angular and Handlebars. I even ripped off the logo. In other words, Angular was a big inspiration for Ractive.)   It is, by any measure, an impressive showing. And it's built and maintained by the geniuses at Google, several of whom work on it full time. Ractive, by contrast, has one core contributor - yours truly (though it has an excellent community which has made it immeasurably better) - and is the product of unpaid evenings and weekends. Given a choice between Angular and Ractive for a large production application, most developers would probably be wise to select Angular.", 
            "title": "What is Angular?"
        }, 
        {
            "location": "/articles/ractive-vs-angular/#so-why-bother-with-ractive", 
            "text": "One word: simplicity. Angular looks easy at first, but to master it you have to learn some novel concepts (scope, dependency injection, transclusions, modules, directives...) that make writing Angular code feel quite different from writing regular JavaScript. (Before I continue, I should emphasise that I'm not an Angular expert by any stretch - my impressions are largely formed from reading what other people have written.)  Ractive, on the other hand, is designed to be as simple as possible, but no simpler. That's because of its heritage: it was  created in the newsroom  of  theguardian.com  for building interactive news applications. These apps have to be built in a very short space of time and work reliably across different environments - there's no time for prototyping etc. Just build it and ship it. You can't spend long optimising things, so the library has to make smart decisions for you.  @dmitrigrabov  Simplest binding framework I ve ever used is new:  @RactiveJS  from the Guardian.  1. have object 2. have template Done.  Mike MacCana (@mikemaccana)  December 12, 2013   Most of all, a lot of people building these kinds of apps aren't experienced developers - they're journalists or graphics people who have learned some JavaScript because they want to expand their skillsets and stay relevant, not because they get a kick out of watching Douglas Crockford videos.  First piece of code that actually makes sense to my design-oriented brain:  @RactiveJS  - still on lesson 5, though  K. Ant. \uf8ff (@konstantinosant)  November 27, 2013   Don't try explaining to a hacker-journalist that they need to call  $scope.digest()  or that, having just got their head around minification, they need to perform some elaborate maneouvres to prevent the dependency injection from breaking - trust me, they won't care!", 
            "title": "So why bother with Ractive?"
        }, 
        {
            "location": "/articles/ractive-vs-angular/#enough-with-the-sales-pitch-what-do-they-have-in-common", 
            "text": "Well, they're both largely concerned with eliminating ad-hoc DOM manipulation from the list of things developers have to worry about, by doing what's called  data binding  - modifying the page as data (your  model , in MVC jargon) changes. Both libraries also offer  two-way data binding , so that user interactions with the page update the model as necessary.  Angular wasn't the first framework to offer data binding, but it arguably did it better than anyone had before, with a concise syntax based on the  Mustache  templating language. Ractive also uses Mustache, since it is easy to read and write, is widely used, and comes with a  formal test suite  against which implementations like Ractive can check compliance.  They also share philosophical underpinnings. From  angularjs.org :   HTML is great for declaring static documents, but it falters when we try to use it for declaring dynamic views in web-applications ... Other frameworks deal with HTML\u2019s shortcomings by either abstracting away HTML, CSS, and/or JavaScript or by providing an imperative way for manipulating the DOM. Neither of these address the root problem that HTML was not designed for dynamic views.   Amen! Ractive, like Angular, takes the view that we should augment HTML to make it better suited to modern application development, rather than hiding the guts of our apps in JavaScript files, where it's hard to form complete mental models and  reason effectively  about them.  Finally, both Angular and Ractive believe that your model should take the form of  POJOs . Loading data from a server without having to convert it to some kind of  Model  or  Collection  object before you can use it is a liberating feeling. (That said, some apps benefit from the more rigorous approach, and Ractive fully supports that via  adaptors )", 
            "title": "Enough with the sales pitch. What do they have in common?"
        }, 
        {
            "location": "/articles/ractive-vs-angular/#and-where-do-they-differ", 
            "text": "Firstly, Angular isn't just about your user interface - it has opinions on routing, validation, server communication, testing, and so on. In other words it's a  framework  rather than a  library .  Ractive only really cares about UI. Use any router/backend/whatever you want - that's your responsibility.  In some situations the framework is exactly what you need - a consistent, opinionated foundation on which to build your app. In other situations, it's a straitjacket. Personally I prefer building apps in a more modular fashion, but that's probably because of the type of app I build for a living. YMMV.  Secondly, they have very different approaches to data binding. Angular uses 'dirty checking', whereby properties of the model are checked on every  $scope.digest() , which is called automatically most of the time. Ractive uses a dependency tracking mechanism instead. When you call  ractive.set('foo', 'bar') , all the  dependants  of  foo  are notified (if its value changed). The same principle applies when dealing with complex  expressions , which means you don't have to constantly worry about whether your computed properties will cause performance issues.  Mi\u0161ko Hevery, the father of Angular, wrote  this Stack Overflow post  defending dirty checking, containing this zinger when comparing it to dependency tracking as seen in  Knockout.js :   KO dependency tracking is a clever feature for a problem which angular does not have.   True, but Angular's  $digest  loop is a clever solution for a problem that no other library has! In any case, Pete Hunt of  React.js  fame  takes issue  with the notion that Angular's dirty checking is fast enough.  A final important difference is in how your app is rendered. Traditional templating engines compile a string template to a function that, given some data, returns another string (which typically is  innerHTML 'd into the page). Angular (and also Knockout) work by traversing the DOM, reading attributes, and setting up bindings accordingly. Aside from the  FOUC  that you then have to work around, this means that your page is peppered with non-validating gubbins like  ng-model .  Ractive takes a different approach. Your template lives as a string, and is parsed (on the server, if needs be - Ractive is  isomorphic ) into a tree-like structure that can be transported as JSON. From there, Ractive constructs a lightweight  parallel DOM  containing all the information it needs to construct the real DOM and set up data-binding etc. In my view, this is a more hygienic approach. Parsing the template before the browser has a chance to has many benefits, even if some people do question the sanity of doing so:  This is both brilliant   ridiculous at the same time: \u201cIntroducing Ractive.js: next-generation DOM manipulation\u201d  http://t.co/17uHMKZFCQ  Rev Dan Catt (@revdancatt)  July 25, 2013", 
            "title": "And where do they differ?"
        }, 
        {
            "location": "/articles/ractive-vs-angular/#honestly-just-try-it", 
            "text": "This was a long post - if you made it this far, I salute you. But if you really want to know the differences between Angular and Ractive, you should just try them both. Ractive has a  60-second setup guide  and a set of  interactive tutorials  (with more coming soon), and Angular has  learning resources  of its own.  Ractive's development has been very community-driven - there is no ivory tower master plan, just hard-won real-life experience distilled into feature requests. It tastes of delicious  dogfood . So if it doesn't have a feature you need, there's a very real chance it could do soon - just  come on over to GitHub  and raise an issue.", 
            "title": "Honestly, just try it"
        }, 
        {
            "location": "/articles/ractive-vs-react/", 
            "text": "Ractive vs React\n\n\n\n\nThe last post on this blog attempted to \ncompare Ractive.js with Angular.js\n - two very different projects with superficial similarities. This time, we'll be comparing Ractive with \nReact.js\n, which despite appearances is much closer to Ractive in terms of purpose and philosophy.\n\n\n\n\n\nWhat is React?\n\n\nThe \nproject homepage\n calls React 'a JavaScript library for building user interfaces', and goes on to describe it as 'the V in MVC'. In other words, it has one job - taking your application state and turning it into a \nview\n that can be displayed to the user. This focus separates it from frameworks like Angular and Ember.js, which handle things like routing, and communicating with a server, and myriad other concerns in addition to managing views.\n\n\nWhat's really interesting about React is \nhow\n it does its job. As Chris Granger \ndescribes it\n, React is 'the \nimmediate mode\n abstraction over the \nretained mode\n DOM'. Rather than describing what changes are required to bring the view up to date, you describe \nwhat the view should look like\n. Under the hood, React uses \nsmart algorithms\n to 'diff' that description with the current state of the DOM, then tells the browser what it needs to do.\n\n\nThe similarities between Ractive and React\n\n\nReact's first public release came about a month before Ractive's. I distinctly remember reading \nthe post on Hacker News\n and thinking 'well I may as well give up' - so many of Ractive's ideas, which a day earlier had seemed entirely novel, had already been implemented by a team of engineers with the might of Facebook behind them.\n\n\nThe most striking similarity was the use of a \nvirtual DOM\n. Like Ractive, React had discovered that creating an abstract representation of the DOM allows for lightning-fast operations by minimising the amount of DOM manipulation (the bottleneck in most webapps) that needs to take place. It also facilitates server-side rendering without some of the \ncrazy hacks\n users of other tools have had to employ.\n\n\nAnother was the focus on \nreactive programming\n. This is one of those phrases that threatens to become meaningless with overuse, but it's a useful concept. Put simply, in a reactive system where the value of \nb\n depends on the value of \na\n, if \na\n changes then \nb\n will also change. Applied to user interfaces, that means that when your application state changes, your view also changes. With traditional MVC libraries you typically have to implement all your render logic manually and wire it up with a web of publish/subscribe events; with React and Ractive you're spared that (tedious, error-prone, hard-to-optimise) step when building your apps.\n\n\nFinally, both libraries believe that the way to help developers build complex apps is to give them tools that encourage \nsimplicity\n and \ncomposability\n and then get out of their way.\n\n\nHaving said all that, there are also some stark differences.\n\n\nTemplating\n\n\nThe most obvious way in which the two libraries differ is that Ractive wholly embraces templating - specifically, views are described using a variant of \nMustache\n, extended to include inline JavaScript expressions. Support for other languages is on the roadmap.\n\n\n(The logic-less template cultists would have you believe that allowing expressions in templates is a Bad Thing. \nThey're wrong\n. \nHere's why\n.)\n\n\nReact doesn't use templating. Instead, you describe your view by calling functions like \nReact.DOM.div(props, children)\n.\n\n\nThis is, it must be said, a totally brilliant idea. It means that your view code is subject to the same rules as the rest of your app - it gets linted, analysed and optimised with everything else, and allows you to (for example) use functional programming techniques.\n\n\nBut personally, I still prefer templates. Manipulating markup, rather than code, brings you closer to the final rendered UI, and (in general) allows you to express the same ideas more concisely. The striking thing about markup is that it's as easy to read as to write, which is a huge productivity boon when working in a team. HTML is generally the first thing new web developers learn, and it is so pervasive in web dev culture (manifested in a million ways, from the vast quantities of high quality learning and reference materials to that fact that every text editor supports HTML syntax highlighting out of the box), that embracing HTML means embracing the entire skill spectrum of the web developer community.\n\n\nAs someone who \nlearned to code in a newsroom\n, and works alongside others walking the same path, I believe that creating tools that beginners can use, as well as experts, is our most urgent task.\n\n\nChange tracking\n\n\nReact re-renders the entire app on each state change, and diffs the result. Ractive, on the other hand, implements a change tracking mechanism, so only a subset of the virtual DOM gets notified of any change.\n\n\nThere's no right answer to the question 'which approach is better?'. Ractive's more conservative approach is often faster - as you'd expect, because there's generally less work to do - but React's is undoubtedly \nsimpler\n, in the sense of that word \nas used by Clojure author Rich Hickey\n. (The Clojure community appears to have had a profound influence on React's design, as evidenced by its popularity among prominent ClojureScript developers such as \nDavid Nolen\n, the author of \nOm\n, and the aforementioned Chris Granger who created \nLight Table\n.)\n\n\nOne point is worth noting however. Unlike just about every other data-binding tool (except Angular, which does something totally different), Ractive doesn't require you to wrap your data up in some library-specific observable class (e.g. \nko.observable()\n or \nBackbone.Model()\n) - a requirement that React developers criticise, not without justification. Instead, it uses an approach based on \nkeypaths\n, which means you can use plain old JavaScript objects (though you certainly can use observables, with the use of \nadaptors\n, if that's how your app is built).\n\n\nTwo-way binding\n\n\nMost data-binding tools implement some form of \ntwo-way binding\n, where user interaction - such as text entry in an \ninput\n element, or toggling a checkbox - causes the application state to be updated. Implementing this manually is often finicky and requires the developer to be aware of various browser inconsistencies, and so robust two-way binding support is a real timesaver.\n\n\nReact rejects this. In the React world, data flows one way - from parent to child - and two-way binding is seen as a source of bugs and confusion since (\nits detractors say\n) there's no longer a 'single source of truth' (SSOT).\n\n\nDone correctly, two-way binding doesn't violate SSOT at all - it simply means that the \ninput\n automatically \nrequests\n changes to the SSOT without each developer having to write bothersome (and possibly incorrect!) boilerplate code. In my experience, two-way binding is a huge productivity win.\n\n\nHaving said that, particularly complex interactions between Ractive components \nhave\n been a source of bugs in the past. Our test suite will guard against those bugs reappearing, but it's fair to say that my life would have been easier for a couple of weeks earlier this year had two-way binding never been possible in Ractive.\n\n\nWould we design the library differently now? No - I believe that solving these hard problems on developers' behalf is exactly what a library like Ractive is for.\n\n\nWhere React shines\n\n\nIt's only fair to point out that React is \nextremely\n well battle-tested, having been used at \nfacebook.com\n (you may have heard of it?) for some time. If it's good enough for them (where 'good' is defined as performant, testable, maintainable and so on) then it's almost certainly good enough for the rest of us.\n\n\nThe React community is smart and passionate. Not just smart - \nwise\n. The attention to code quality is obvious. Online and in real life, React people are thoughtful, interesting and kind: these things matter.\n\n\nReact beats Ractive on \nclarity of vision\n. When you hear React people talk, it's obvious that it wasn't created as a slightly-better version of what already existed; it's an implementation of ideas that are simultaneously ancient (in programming terms) and radical. Ractive, on the other hand, grew \ninto\n its philosophy, from a starting point of 'here are some tasks that are way harder than they ought to be'.\n\n\nIn short, I'd recommend React as the best way to build user interfaces, if Ractive didn't exist!\n\n\nWhere Ractive shines\n\n\nFor starters, you can \nlearn Ractive in 60 seconds\n. If you know HTML and the basics of Mustache (which itself has almost zero learning curve), then all you need to learn is the \nractive.set()\n method and you're already most of the way there. People of all levels of experience 'get' Ractive very quickly, because there are so few concepts to learn.\n\n\nBecause of Ractive's newsroom heritage, it has always prioritised certain features that make it easy to build UIs that are \nslick\n - declarative transitions, animations, and first-class SVG support. A Ractive component can include CSS in its definition, which is encapsulated by default (i.e. component styles don't leak into the page). These are tricky problems that other libraries have, for the most part, yet to solve well, if at all.\n\n\nLike React, Ractive's community is awesome. I'm constantly amazed and humbled by people's readiness to help each other with creative solutions to tricky problems, and then to work on baking those solutions into the library. I'm truly excited to see how Ractive develops, because the direction is so heavily driven by real-world problem solving that it's impossible to predict what will happen next.\n\n\nConclusion\n\n\nAnd I'm excited to see where React goes too. I hope the respect I have for the library and its developers is apparent in this post: it really is a great tool.\n\n\nSo which should you use? Try both. It's an interesting time to be in this space because there are so many competing ideas; if we want the best ones to win, they each need to go under the microscope.", 
            "title": "Ractive.js vs React"
        }, 
        {
            "location": "/articles/ractive-vs-react/#ractive-vs-react", 
            "text": "The last post on this blog attempted to  compare Ractive.js with Angular.js  - two very different projects with superficial similarities. This time, we'll be comparing Ractive with  React.js , which despite appearances is much closer to Ractive in terms of purpose and philosophy.", 
            "title": "Ractive vs React"
        }, 
        {
            "location": "/articles/ractive-vs-react/#what-is-react", 
            "text": "The  project homepage  calls React 'a JavaScript library for building user interfaces', and goes on to describe it as 'the V in MVC'. In other words, it has one job - taking your application state and turning it into a  view  that can be displayed to the user. This focus separates it from frameworks like Angular and Ember.js, which handle things like routing, and communicating with a server, and myriad other concerns in addition to managing views.  What's really interesting about React is  how  it does its job. As Chris Granger  describes it , React is 'the  immediate mode  abstraction over the  retained mode  DOM'. Rather than describing what changes are required to bring the view up to date, you describe  what the view should look like . Under the hood, React uses  smart algorithms  to 'diff' that description with the current state of the DOM, then tells the browser what it needs to do.", 
            "title": "What is React?"
        }, 
        {
            "location": "/articles/ractive-vs-react/#the-similarities-between-ractive-and-react", 
            "text": "React's first public release came about a month before Ractive's. I distinctly remember reading  the post on Hacker News  and thinking 'well I may as well give up' - so many of Ractive's ideas, which a day earlier had seemed entirely novel, had already been implemented by a team of engineers with the might of Facebook behind them.  The most striking similarity was the use of a  virtual DOM . Like Ractive, React had discovered that creating an abstract representation of the DOM allows for lightning-fast operations by minimising the amount of DOM manipulation (the bottleneck in most webapps) that needs to take place. It also facilitates server-side rendering without some of the  crazy hacks  users of other tools have had to employ.  Another was the focus on  reactive programming . This is one of those phrases that threatens to become meaningless with overuse, but it's a useful concept. Put simply, in a reactive system where the value of  b  depends on the value of  a , if  a  changes then  b  will also change. Applied to user interfaces, that means that when your application state changes, your view also changes. With traditional MVC libraries you typically have to implement all your render logic manually and wire it up with a web of publish/subscribe events; with React and Ractive you're spared that (tedious, error-prone, hard-to-optimise) step when building your apps.  Finally, both libraries believe that the way to help developers build complex apps is to give them tools that encourage  simplicity  and  composability  and then get out of their way.  Having said all that, there are also some stark differences.", 
            "title": "The similarities between Ractive and React"
        }, 
        {
            "location": "/articles/ractive-vs-react/#templating", 
            "text": "The most obvious way in which the two libraries differ is that Ractive wholly embraces templating - specifically, views are described using a variant of  Mustache , extended to include inline JavaScript expressions. Support for other languages is on the roadmap.  (The logic-less template cultists would have you believe that allowing expressions in templates is a Bad Thing.  They're wrong .  Here's why .)  React doesn't use templating. Instead, you describe your view by calling functions like  React.DOM.div(props, children) .  This is, it must be said, a totally brilliant idea. It means that your view code is subject to the same rules as the rest of your app - it gets linted, analysed and optimised with everything else, and allows you to (for example) use functional programming techniques.  But personally, I still prefer templates. Manipulating markup, rather than code, brings you closer to the final rendered UI, and (in general) allows you to express the same ideas more concisely. The striking thing about markup is that it's as easy to read as to write, which is a huge productivity boon when working in a team. HTML is generally the first thing new web developers learn, and it is so pervasive in web dev culture (manifested in a million ways, from the vast quantities of high quality learning and reference materials to that fact that every text editor supports HTML syntax highlighting out of the box), that embracing HTML means embracing the entire skill spectrum of the web developer community.  As someone who  learned to code in a newsroom , and works alongside others walking the same path, I believe that creating tools that beginners can use, as well as experts, is our most urgent task.", 
            "title": "Templating"
        }, 
        {
            "location": "/articles/ractive-vs-react/#change-tracking", 
            "text": "React re-renders the entire app on each state change, and diffs the result. Ractive, on the other hand, implements a change tracking mechanism, so only a subset of the virtual DOM gets notified of any change.  There's no right answer to the question 'which approach is better?'. Ractive's more conservative approach is often faster - as you'd expect, because there's generally less work to do - but React's is undoubtedly  simpler , in the sense of that word  as used by Clojure author Rich Hickey . (The Clojure community appears to have had a profound influence on React's design, as evidenced by its popularity among prominent ClojureScript developers such as  David Nolen , the author of  Om , and the aforementioned Chris Granger who created  Light Table .)  One point is worth noting however. Unlike just about every other data-binding tool (except Angular, which does something totally different), Ractive doesn't require you to wrap your data up in some library-specific observable class (e.g.  ko.observable()  or  Backbone.Model() ) - a requirement that React developers criticise, not without justification. Instead, it uses an approach based on  keypaths , which means you can use plain old JavaScript objects (though you certainly can use observables, with the use of  adaptors , if that's how your app is built).", 
            "title": "Change tracking"
        }, 
        {
            "location": "/articles/ractive-vs-react/#two-way-binding", 
            "text": "Most data-binding tools implement some form of  two-way binding , where user interaction - such as text entry in an  input  element, or toggling a checkbox - causes the application state to be updated. Implementing this manually is often finicky and requires the developer to be aware of various browser inconsistencies, and so robust two-way binding support is a real timesaver.  React rejects this. In the React world, data flows one way - from parent to child - and two-way binding is seen as a source of bugs and confusion since ( its detractors say ) there's no longer a 'single source of truth' (SSOT).  Done correctly, two-way binding doesn't violate SSOT at all - it simply means that the  input  automatically  requests  changes to the SSOT without each developer having to write bothersome (and possibly incorrect!) boilerplate code. In my experience, two-way binding is a huge productivity win.  Having said that, particularly complex interactions between Ractive components  have  been a source of bugs in the past. Our test suite will guard against those bugs reappearing, but it's fair to say that my life would have been easier for a couple of weeks earlier this year had two-way binding never been possible in Ractive.  Would we design the library differently now? No - I believe that solving these hard problems on developers' behalf is exactly what a library like Ractive is for.", 
            "title": "Two-way binding"
        }, 
        {
            "location": "/articles/ractive-vs-react/#where-react-shines", 
            "text": "It's only fair to point out that React is  extremely  well battle-tested, having been used at  facebook.com  (you may have heard of it?) for some time. If it's good enough for them (where 'good' is defined as performant, testable, maintainable and so on) then it's almost certainly good enough for the rest of us.  The React community is smart and passionate. Not just smart -  wise . The attention to code quality is obvious. Online and in real life, React people are thoughtful, interesting and kind: these things matter.  React beats Ractive on  clarity of vision . When you hear React people talk, it's obvious that it wasn't created as a slightly-better version of what already existed; it's an implementation of ideas that are simultaneously ancient (in programming terms) and radical. Ractive, on the other hand, grew  into  its philosophy, from a starting point of 'here are some tasks that are way harder than they ought to be'.  In short, I'd recommend React as the best way to build user interfaces, if Ractive didn't exist!", 
            "title": "Where React shines"
        }, 
        {
            "location": "/articles/ractive-vs-react/#where-ractive-shines", 
            "text": "For starters, you can  learn Ractive in 60 seconds . If you know HTML and the basics of Mustache (which itself has almost zero learning curve), then all you need to learn is the  ractive.set()  method and you're already most of the way there. People of all levels of experience 'get' Ractive very quickly, because there are so few concepts to learn.  Because of Ractive's newsroom heritage, it has always prioritised certain features that make it easy to build UIs that are  slick  - declarative transitions, animations, and first-class SVG support. A Ractive component can include CSS in its definition, which is encapsulated by default (i.e. component styles don't leak into the page). These are tricky problems that other libraries have, for the most part, yet to solve well, if at all.  Like React, Ractive's community is awesome. I'm constantly amazed and humbled by people's readiness to help each other with creative solutions to tricky problems, and then to work on baking those solutions into the library. I'm truly excited to see how Ractive develops, because the direction is so heavily driven by real-world problem solving that it's impossible to predict what will happen next.", 
            "title": "Where Ractive shines"
        }, 
        {
            "location": "/articles/ractive-vs-react/#conclusion", 
            "text": "And I'm excited to see where React goes too. I hope the respect I have for the library and its developers is apparent in this post: it really is a great tool.  So which should you use? Try both. It's an interesting time to be in this space because there are so many competing ideas; if we want the best ones to win, they each need to go under the microscope.", 
            "title": "Conclusion"
        }
    ]
}