{
    "docs": [
        {
            "location": "/", 
            "text": "Ractive.js\n\n  \nThe diamond age of web development\n\n\n\n\n\n\n  \nscript src=\"\nhttps://cdn.jsdelivr.net/npm/ractive\n\"\n/script\n\n\n\n\n\n\n  \n\n    \nLive, reactive templating\n\n    Ractive.js is a template-driven UI library, but unlike other tools that generate inert HTML, it transforms your templates into blueprints for apps that are interactive by default.\n  \n\n  \n\n    \nPowerful and extensible\n\n    Two-way binding, animations, SVG support and much more are provided out-of-the-box - but you can add whatever functionality you need by downloading and creating plugins.\n  \n\n  \n\n    \nOptimised for your sanity\n\n    Some tools force you to learn a new vocabulary and structure your app in a particular way. Ractive works for you, not the other way around - and it plays well with other libraries.\n  \n\n\n\n\n\nUsage\n\n\nUsing Ractive is very simple. Create a new instance using \nnew Ractive({...})\n with the desired options. Code blocks with a \u21f2 or \u25b6 button in the top-right corner will open the code in the interactive playground, so feel free to try them out and play around with them.\n\n\n\n\n\nvar ractive = Ractive({\n    target: 'body',\n    template: '\np\n{{greeting}}, {{recipient}}\n/p\n',\n    data: {\n        greeting: 'Hello',\n        recipient: 'World!'\n    }\n});\n\n\n\n\nWhile there are \nno required options\n, \ntarget\n, \ntemplate\n and \ndata\n are the most common. They specify \nwhat element\n to attach an instance with \nthis markup\n having \nthis data\n. Check out \nInitialization Options\n to learn more about the available options.\n\n\nIf you get stuck at any point, visit the \nGet Support\n page for places to find help.\n\n\nOther Downloads\n\n\nRactive is available via the following channels:\n\n\n# jsDelivr\nhttps://cdn.jsdelivr.net/npm/ractive\n\n# CDNjs\nhttps://cdnjs.com/libraries/ractive\n\n# unpkg\nhttps://unpkg.com/ractive\n\n# npm\nnpm install --save-dev ractive\n\n# Bower\nbower install --save ractive\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbout Ractive.js\n\n\nRactive was originally created at \nThe Guardian (theguardian.com)\n to produce news applications. A typical news app is heavily interactive, combines HTML and SVG, and is developed under extreme deadline pressure. It has to work reliably across browsers, and perform well even on mobile devices.\n\n\nUnlike other frameworks, \nRactive works for you\n, not the other way around. It doesn't have an opinion about the other tools you want to use with it. It also adapts to the approach you want to take. This means you're not locked-in to a framework-specific way of thinking. Should you hate one of your tools for some reason, you can easily swap it out for another and move on with life.\n\n\nThis project is the brainchild of an Englishman and has contributors from all over the world. There is an ecclectic mix of primarily the Queen's English, a fair amount of 'Murican English, and a bit of others here and there. Things like \nadaptor\n, \nbehaviour\n, and \ndependant\n may have more than one spelling but we try to stick to the Queen's English to the extent that we are able.\n\n\nFun fact: Fun fact: The name is a reference to Neal Stephenson's \nThe Diamond Age: Or, A Young Lady's Illustrated Primer\n \u2013 a book about (among other things) the future of storytelling.", 
            "title": "Ractive.js"
        }, 
        {
            "location": "/#usage", 
            "text": "Using Ractive is very simple. Create a new instance using  new Ractive({...})  with the desired options. Code blocks with a \u21f2 or \u25b6 button in the top-right corner will open the code in the interactive playground, so feel free to try them out and play around with them.   var ractive = Ractive({\n    target: 'body',\n    template: ' p {{greeting}}, {{recipient}} /p ',\n    data: {\n        greeting: 'Hello',\n        recipient: 'World!'\n    }\n});  While there are  no required options ,  target ,  template  and  data  are the most common. They specify  what element  to attach an instance with  this markup  having  this data . Check out  Initialization Options  to learn more about the available options.  If you get stuck at any point, visit the  Get Support  page for places to find help.", 
            "title": "Usage"
        }, 
        {
            "location": "/#other-downloads", 
            "text": "Ractive is available via the following channels:  # jsDelivr\nhttps://cdn.jsdelivr.net/npm/ractive\n\n# CDNjs\nhttps://cdnjs.com/libraries/ractive\n\n# unpkg\nhttps://unpkg.com/ractive\n\n# npm\nnpm install --save-dev ractive\n\n# Bower\nbower install --save ractive", 
            "title": "Other Downloads"
        }, 
        {
            "location": "/#about-ractivejs", 
            "text": "Ractive was originally created at  The Guardian (theguardian.com)  to produce news applications. A typical news app is heavily interactive, combines HTML and SVG, and is developed under extreme deadline pressure. It has to work reliably across browsers, and perform well even on mobile devices.  Unlike other frameworks,  Ractive works for you , not the other way around. It doesn't have an opinion about the other tools you want to use with it. It also adapts to the approach you want to take. This means you're not locked-in to a framework-specific way of thinking. Should you hate one of your tools for some reason, you can easily swap it out for another and move on with life.  This project is the brainchild of an Englishman and has contributors from all over the world. There is an ecclectic mix of primarily the Queen's English, a fair amount of 'Murican English, and a bit of others here and there. Things like  adaptor ,  behaviour , and  dependant  may have more than one spelling but we try to stick to the Queen's English to the extent that we are able.  Fun fact: Fun fact: The name is a reference to Neal Stephenson's  The Diamond Age: Or, A Young Lady's Illustrated Primer  \u2013 a book about (among other things) the future of storytelling.", 
            "title": "About Ractive.js"
        }, 
        {
            "location": "/get-started/tutorials/hello-world/", 
            "text": "Hello, world!\n\n\nWelcome to the Ractive.js tutorials. This is a set of interactive tutorials which you can take at your own pace. Each tutorial consists of a number of steps \u2013 first up is step 1 of the 'Hello world!' tutorial.\n\n\nAt any time you can start or reset a step by clicking its Start button.\n\n\nStep 1\n\n\n\n    \nStart\n\n\n\n\nTry creating a new Ractive by executing the JavaScript in the script tab of the playground by hitting the \n button on the top right-hand corner of the playground.\n\n\n\n\nIn later steps, if you can't get it to work (or if you're just lazy!) you can click the Fix Code button, if there is one available, next to the Start button to insert working code as though you'd followed the instructions exactly.\n\n\nThroughout the tutorials, boxes like this will contain technical notes and asides, for the particularly nerdy or curious.\n\n\n\n\nStep 2\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nThat's not very exciting. Let's make our template more templatey \u2013 replace the hard-coded text in the template with some variables:\n\n\np\n{{greeting}} {{name}}!\n/p\n\n\n\n\n\nThen, add some data to it, by adding a data initialisation option to our code on the script tab so that it looks like this:\n\n\nvar ractive = new Ractive({\n  target: output,\n  template: template,\n  data: { greeting: 'Hello', name: 'world' }\n});\n\n\n\n\nExecute the code (with the \n button). It should look exactly as it did before.\n\n\nStep 3\n\n\n\n  \nStart\n\n\n\n\nHere's where Ractive differs from other templating libraries. Normally, if you wanted to change the data, you would have to re-render the entire view, which would have the effect of discarding the DOM nodes you'd already created. That's wasteful.\n\n\nInstead, we can manipulate views we've already created. Try running this code - click the \n button in the top-right corner:\n\n\n\n\n\nractive.set('greeting', 'Bonjour');\n\n\n\n\nAnd now this:\n\n\n\n\n\nractive.set('name', 'tout le monde');\n\n\n\n\nOoh la la! Even better, we could set both properties in one go. Let's do it in Mandarin this time:\n\n\n\n\n\nractive.set({\n  greeting: '\u4f60\u597d',\n  name: '\u4e16\u754c'\n});\n\n\n\n\nWhat's happening here is that the contents of the \np\n element are split into four text nodes \u2013 one for \n{{greeting}}\n, one for the comma and space characters, one for \n{{name}}\n, and one for the \n!\n. Ractive stores references to the nodes that correspond to the variables, and updates them when the data changes, leaving everything else untouched.\n\n\nSurgically updating text nodes is much faster than replacing elements, particularly when you only need to change part of your ractive.\n\n\n\n\nNote that due to the way the tutorials interact with the playground, the eval blocks above are actually running after the entire example is reloaded in the output pane. That's why running the last eval before running the next to last eval doesn't leave the Mandarin greeting intact. Under normal circumstances, the entire example wouldn't need to be re-run, which \nwould\n leave the Mandarin greeting intact.", 
            "title": "Hello, world!"
        }, 
        {
            "location": "/get-started/tutorials/hello-world/#hello-world", 
            "text": "Welcome to the Ractive.js tutorials. This is a set of interactive tutorials which you can take at your own pace. Each tutorial consists of a number of steps \u2013 first up is step 1 of the 'Hello world!' tutorial.  At any time you can start or reset a step by clicking its Start button.", 
            "title": "Hello, world!"
        }, 
        {
            "location": "/get-started/tutorials/hello-world/#step-1", 
            "text": "Start   Try creating a new Ractive by executing the JavaScript in the script tab of the playground by hitting the   button on the top right-hand corner of the playground.   In later steps, if you can't get it to work (or if you're just lazy!) you can click the Fix Code button, if there is one available, next to the Start button to insert working code as though you'd followed the instructions exactly.  Throughout the tutorials, boxes like this will contain technical notes and asides, for the particularly nerdy or curious.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/hello-world/#step-2", 
            "text": "Start \n     Fix Code   That's not very exciting. Let's make our template more templatey \u2013 replace the hard-coded text in the template with some variables:  p {{greeting}} {{name}}! /p   Then, add some data to it, by adding a data initialisation option to our code on the script tab so that it looks like this:  var ractive = new Ractive({\n  target: output,\n  template: template,\n  data: { greeting: 'Hello', name: 'world' }\n});  Execute the code (with the   button). It should look exactly as it did before.", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/hello-world/#step-3", 
            "text": "Start   Here's where Ractive differs from other templating libraries. Normally, if you wanted to change the data, you would have to re-render the entire view, which would have the effect of discarding the DOM nodes you'd already created. That's wasteful.  Instead, we can manipulate views we've already created. Try running this code - click the   button in the top-right corner:   ractive.set('greeting', 'Bonjour');  And now this:   ractive.set('name', 'tout le monde');  Ooh la la! Even better, we could set both properties in one go. Let's do it in Mandarin this time:   ractive.set({\n  greeting: '\u4f60\u597d',\n  name: '\u4e16\u754c'\n});  What's happening here is that the contents of the  p  element are split into four text nodes \u2013 one for  {{greeting}} , one for the comma and space characters, one for  {{name}} , and one for the  ! . Ractive stores references to the nodes that correspond to the variables, and updates them when the data changes, leaving everything else untouched.  Surgically updating text nodes is much faster than replacing elements, particularly when you only need to change part of your ractive.   Note that due to the way the tutorials interact with the playground, the eval blocks above are actually running after the entire example is reloaded in the output pane. That's why running the last eval before running the next to last eval doesn't leave the Mandarin greeting intact. Under normal circumstances, the entire example wouldn't need to be re-run, which  would  leave the Mandarin greeting intact.", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/nested-properties/", 
            "text": "Nested Properties\n\n\nRactive uses the \nmustache syntax\n, which supports nested properties \u2013 in JavaScript-land, that means properties that are objects with their own properties (which might be objects with their own properties...).\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nLet's say we were building an app that displayed information about different countries. An object representing a country could look like this:\n\n\n{\n  name: 'The UK',\n  climate: { temperature: 'cold', rainfall: 'excessive' },\n  population: 63230000,\n  capital: { name: 'London', lat: 51.5171, lon: -0.1062 }\n}\n\n\n\n\nAdd that data to our JavaScript \u2013 there's a placeholder \ncountry\n property.\n\n\nWe can refer to these nested properties in our template using dot notation. So to refer to the country's name, we use \n{{country.name}}\n.\n\n\nGo ahead and replace the placeholders in the template with mustaches. Don't forget the \nhref\n on the 'see map' link. If you get stuck, click the \nFix Code\n button.\n\n\nExecute the code. You should see an accurate description of the UK.\n\n\n\n\n\n// Once we've rendered our view, we can change the country info\nractive.set( 'country', {\n  name: 'Australia',\n  climate: { temperature: 'hot', rainfall: 'limited' },\n  population: 22620600,\n  capital: { name: 'Canberra', lat: -35.2828, lon: 149.1314 }\n});\n\n\n\n\nStep 2\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nThat's all well and good, but it's a little on the verbose side. You can imagine if we had lots more properties on the capital city object that we wanted to refer to \u2013 we don't want to keep writing \n{{country.capital.xyz}}\n if we don't have to.\n\n\nWe don't have to. Instead, we can use a \nwith section\n to provide \ncontext\n:\n\n\n{{#with country}}\n  \np\n{{name}} is a {{climate.temperature}} country\n  with {{climate.rainfall}} rainfall and a population\n  of {{population}}.\n/p\n\n{{/with}}\n\n\n\n\n\n\nStrictly speaking, you don't need the with - you can just use a # sign by itself:\n\n\n{{#country}}\n  \np\n{{name}} is a {{climate.temperature}} country\n  with {{climate.rainfall}} rainfall and a population\n  of {{population}}.\n/p\n\n{{/country}}\n\n\n\nIn this case, when Ractive looks up country, it will decide whether to render a with, if or each section based on its value. We'll learn about if and each shortly.\n\n\nGenerally, it's better to be explicit about which type of section you intend \u2013 other programmers (including future you) will be grateful.\n\n\n\n\nGo ahead and update the template, creating a section for the capital as well. (You can either create a \n{{#with country.capital}}\n section, or a  \n{{#with capital}}\n section inside the \n{{#with country}}\n section. Use whichever structure is easier in a given situation.)\n\n\n\n\nNotice that if you create a \n{{#with capital}}\n section, you could end up having two \n{{name}}\n variables \u2013 one for the country, one for the capital.\n\n\nWe say that the capital \n{{name}}\n reference has a two-level context stack \u2013 if the innermost context (\ncountry.capital\n) has a name property, \n{{name}}\n resolves to the \ncountry.capital.name\n keypath.\n\n\nIf not, Ractive moves \nup the context stack\n (in this case, to \ncountry\n, and then to the root \ndata\n object) until it \ndoes\n find a context with a \nname\n property. If no matching property is found, then the reference will resolve to the current context. Once a reference is resolved, its keypath is fixed.\n\n\nIf you ever need to \nforce\n a reference to resolve in the current context, rather than potentially somewhere up the context stack, you can simply prefix the reference with a \n.\n. \n.stats.area\n will \nalways\n resolve to \ncountry.capital.stats.area\n in \n{{#with country.capital}}{{.stats.area}}{{/with}}\n, even if there is not already a \nstats\n property on \ncountry.capital\n and there is one on \ncountry\n. If/when \ncountry.capital.stats\n is set, any references will be ready to update.\n\n\n\n\nIf you get stuck, hit the \nFix Code\n button.\n\n\nStep 3\n\n\n\n    \nStart\n\n\n\n\nLet's say we want to update a nested property. If we'd stored a reference to our model object, we could do it like this:\n\n\n\n\n\n// we didn't store a reference, so let's do it now\nvar country = ractive.get('country');\n\ncountry.climate.rainfall = 'very high';\nractive.update('country');\n\n\n\n\nRactive will recognise that only the rainfall property has changed, and leave everything else untouched.\n\n\nBut there's an easier way to do it:\n\n\n\n\n\nractive.set('country.climate.rainfall', 'too much');\n\n\n\n\nTry changing properties. (If you're not from the UK, suitable values for rainfall include 'near-constant', 'unnecessarily high', or 'an unholy amount of'.)", 
            "title": "Nested Properties"
        }, 
        {
            "location": "/get-started/tutorials/nested-properties/#nested-properties", 
            "text": "Ractive uses the  mustache syntax , which supports nested properties \u2013 in JavaScript-land, that means properties that are objects with their own properties (which might be objects with their own properties...).", 
            "title": "Nested Properties"
        }, 
        {
            "location": "/get-started/tutorials/nested-properties/#step-1", 
            "text": "Start \n   Fix Code   Let's say we were building an app that displayed information about different countries. An object representing a country could look like this:  {\n  name: 'The UK',\n  climate: { temperature: 'cold', rainfall: 'excessive' },\n  population: 63230000,\n  capital: { name: 'London', lat: 51.5171, lon: -0.1062 }\n}  Add that data to our JavaScript \u2013 there's a placeholder  country  property.  We can refer to these nested properties in our template using dot notation. So to refer to the country's name, we use  {{country.name}} .  Go ahead and replace the placeholders in the template with mustaches. Don't forget the  href  on the 'see map' link. If you get stuck, click the  Fix Code  button.  Execute the code. You should see an accurate description of the UK.   // Once we've rendered our view, we can change the country info\nractive.set( 'country', {\n  name: 'Australia',\n  climate: { temperature: 'hot', rainfall: 'limited' },\n  population: 22620600,\n  capital: { name: 'Canberra', lat: -35.2828, lon: 149.1314 }\n});", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/nested-properties/#step-2", 
            "text": "Start \n     Fix Code   That's all well and good, but it's a little on the verbose side. You can imagine if we had lots more properties on the capital city object that we wanted to refer to \u2013 we don't want to keep writing  {{country.capital.xyz}}  if we don't have to.  We don't have to. Instead, we can use a  with section  to provide  context :  {{#with country}}\n   p {{name}} is a {{climate.temperature}} country\n  with {{climate.rainfall}} rainfall and a population\n  of {{population}}. /p \n{{/with}}   Strictly speaking, you don't need the with - you can just use a # sign by itself:  {{#country}}\n   p {{name}} is a {{climate.temperature}} country\n  with {{climate.rainfall}} rainfall and a population\n  of {{population}}. /p \n{{/country}}  In this case, when Ractive looks up country, it will decide whether to render a with, if or each section based on its value. We'll learn about if and each shortly.  Generally, it's better to be explicit about which type of section you intend \u2013 other programmers (including future you) will be grateful.   Go ahead and update the template, creating a section for the capital as well. (You can either create a  {{#with country.capital}}  section, or a   {{#with capital}}  section inside the  {{#with country}}  section. Use whichever structure is easier in a given situation.)   Notice that if you create a  {{#with capital}}  section, you could end up having two  {{name}}  variables \u2013 one for the country, one for the capital.  We say that the capital  {{name}}  reference has a two-level context stack \u2013 if the innermost context ( country.capital ) has a name property,  {{name}}  resolves to the  country.capital.name  keypath.  If not, Ractive moves  up the context stack  (in this case, to  country , and then to the root  data  object) until it  does  find a context with a  name  property. If no matching property is found, then the reference will resolve to the current context. Once a reference is resolved, its keypath is fixed.  If you ever need to  force  a reference to resolve in the current context, rather than potentially somewhere up the context stack, you can simply prefix the reference with a  . .  .stats.area  will  always  resolve to  country.capital.stats.area  in  {{#with country.capital}}{{.stats.area}}{{/with}} , even if there is not already a  stats  property on  country.capital  and there is one on  country . If/when  country.capital.stats  is set, any references will be ready to update.   If you get stuck, hit the  Fix Code  button.", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/nested-properties/#step-3", 
            "text": "Start   Let's say we want to update a nested property. If we'd stored a reference to our model object, we could do it like this:   // we didn't store a reference, so let's do it now\nvar country = ractive.get('country');\n\ncountry.climate.rainfall = 'very high';\nractive.update('country');  Ractive will recognise that only the rainfall property has changed, and leave everything else untouched.  But there's an easier way to do it:   ractive.set('country.climate.rainfall', 'too much');  Try changing properties. (If you're not from the UK, suitable values for rainfall include 'near-constant', 'unnecessarily high', or 'an unholy amount of'.)", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/expressions/", 
            "text": "Expressions\n\n\nOne problem with the last example \u2013 the population number. Printing out a number like 63230000 just looks a bit daft.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nWe could replace the number with a string, like '63.2 million'. But numbers are generally a hell of a lot easier to work with.\n\n\nInstead, we can use an \nexpression\n. Expressions look just like regular mustaches:\n\n\n{{ format(population) }}\n\n\n\n\nAdd a \nformat\n property alongside the country data (it may seem weird adding a function as 'data', but it will make sense in due course!):\n\n\nfunction ( num ) {\n  if ( num \n 1000000000 ) return ( num / 1000000000 ).toFixed( 1 ) + ' billion';\n  if ( num \n 1000000 ) return ( num / 1000000 ).toFixed( 1 ) + ' million';\n  if ( num \n 1000 ) return ( Math.floor( num / 1000 ) ) + ',' + ( num % 1000 );\n  return num;\n}\n\n\n\n\nExecute the code. Doesn't that look better? Try changing the values.\n\n\n\n\n\nractive.set({\n  country: 'China',\n  population: 1351000000\n});\n\n\n\n\n\n\nNote that expressions are not part of the mustache syntax \u2013 they are specific to Ractive.js.\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nYou can also use mathematical expressions. Let's rummage around in the bag of contrived examples and see what comes out... yep... this one will do... it's a shopping basket.\n\n\nWe have an \nitem\n property, a \nprice\n, and a \nquantity\n. Add an expression where the total should go:\n\n\ntd\n{{ price * quantity }}\n/td\n\n\n\n\n\nExecute the code. The total should appear. Now we just need to add a currency formatter \u2013 here's one for the UK (if you're not from here, write one for your own currency for extra credit):\n\n\nfunction ( num ) {\n  if ( num \n 1 ) return ( 100 * num ) + 'p';\n  return '\u00a3' + num.toFixed( 2 );\n}\n\n\n\n\nAdd that, and use in the template it for both the price and the total. Try changing the price and the quantity.\n\n\n\n\n\nractive.set({\n  item: 'banana',\n  price: 0.19,\n  quantity: 7\n});\n\n\n\n\n\n\nYou might reasonably ask how this works. What happens is this: when the template is parsed, any \nreferences\n inside expressions (such as \nprice\n, \nquantity\n or \nformat\n in the example above) are identified. At render time, the expression binds to those references and creates a function to calculate the result. (Whenever possible, Ractive.js will re-use functions \u2013 for example \n{{a+b}}\n and \n{{c+d}}\n would share the same function.)\n\n\nWhen the value of one or more of those references change, the expression is re-evaluated. If the result changes, the DOM is updated.\n\n\nFor the super-curious, there's more information on the \ndocs\n.\n\n\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIn this next contrived example, we're going to make a colour mixer.\n\n\nFirst, we want to show how much we're using of each colour. We'll use \ndiv\n elements with a percentage width corresponding to the amount. All the colour values are between 0 and 1, so we need to multiply by 100:\n\n\ndiv style='background-color: red;\n     width: {{red*100}}%;'\n/div\n\n\n\n\n\nUpdate the first three \ndiv\n elements in the template accordingly.\n\n\n\n\nPro-tip: in the playground editors, hold the \nCmd\n key (or \nCtrl\n if you're not on a Mac) and click in each of the places where you need to type 100. Multiple cursors FTW!\n\n\n\n\nTo show the result, we can use an \nrgb(r,g,b)\n CSS colour value. But instead of percentages, these need to be between 0 and 255:\n\n\ndiv style='background-color:\n  rgb({{red   * 255}},\n      {{green * 255}},\n      {{blue  * 255}})'\n\n\n/div\n\n\n\n\n\nUpdate the template and execute the code. Did it work?\n\n\nNo, it didn't. That's because CSS insists that you use integers \u2013 no decimals allowed. So let's use \nMath.round\n to turn the numbers into integers:\n\n\ndiv style='background-color:\n  rgb({{Math.round(red   * 255)}},\n      {{Math.round(green * 255)}},\n      {{Math.round(blue  * 255)}})'\n\n\n/div\n\n\n\n\n\nExecute the code. Ta-da! Try changing the colours.\n\n\n\n\n\nractive.set( 'red', 1 );\n// PSST! Want a sneak preview of something neat?\n// Try using ractive.animate() instead of ractive.set().\n// You can drop it in after the line 9 in the Script content.\n\n\n\n\n\n\nThe \nMath\n object is one of several built-in JavaScript objects you have direct access to within expressions, alongside \nDate\n, \nencodeURI\n, \nparseInt\n, \nJSON\n and various others. Consult the documentation for a full list. You can also access other globals using the \n@global\n special reference, where the \nJSON\n object would be accessible as \n@global.JSON\n.\n\n\nExpressions can be as simple or as complex as you like, as long as they only refer to properties of their view model (i.e. the properties on the data object), don't include assignment operators (including \n+=\n, \n-=\n, \n++\n and  \n--\n), \nnew\n, \ndelete\n or \nvoid\n, and don't use function literals.", 
            "title": "Expressions"
        }, 
        {
            "location": "/get-started/tutorials/expressions/#expressions", 
            "text": "One problem with the last example \u2013 the population number. Printing out a number like 63230000 just looks a bit daft.", 
            "title": "Expressions"
        }, 
        {
            "location": "/get-started/tutorials/expressions/#step-1", 
            "text": "Start \n   Fix Code   We could replace the number with a string, like '63.2 million'. But numbers are generally a hell of a lot easier to work with.  Instead, we can use an  expression . Expressions look just like regular mustaches:  {{ format(population) }}  Add a  format  property alongside the country data (it may seem weird adding a function as 'data', but it will make sense in due course!):  function ( num ) {\n  if ( num   1000000000 ) return ( num / 1000000000 ).toFixed( 1 ) + ' billion';\n  if ( num   1000000 ) return ( num / 1000000 ).toFixed( 1 ) + ' million';\n  if ( num   1000 ) return ( Math.floor( num / 1000 ) ) + ',' + ( num % 1000 );\n  return num;\n}  Execute the code. Doesn't that look better? Try changing the values.   ractive.set({\n  country: 'China',\n  population: 1351000000\n});   Note that expressions are not part of the mustache syntax \u2013 they are specific to Ractive.js.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/expressions/#step-2", 
            "text": "Start \n   Fix Code   You can also use mathematical expressions. Let's rummage around in the bag of contrived examples and see what comes out... yep... this one will do... it's a shopping basket.  We have an  item  property, a  price , and a  quantity . Add an expression where the total should go:  td {{ price * quantity }} /td   Execute the code. The total should appear. Now we just need to add a currency formatter \u2013 here's one for the UK (if you're not from here, write one for your own currency for extra credit):  function ( num ) {\n  if ( num   1 ) return ( 100 * num ) + 'p';\n  return '\u00a3' + num.toFixed( 2 );\n}  Add that, and use in the template it for both the price and the total. Try changing the price and the quantity.   ractive.set({\n  item: 'banana',\n  price: 0.19,\n  quantity: 7\n});   You might reasonably ask how this works. What happens is this: when the template is parsed, any  references  inside expressions (such as  price ,  quantity  or  format  in the example above) are identified. At render time, the expression binds to those references and creates a function to calculate the result. (Whenever possible, Ractive.js will re-use functions \u2013 for example  {{a+b}}  and  {{c+d}}  would share the same function.)  When the value of one or more of those references change, the expression is re-evaluated. If the result changes, the DOM is updated.  For the super-curious, there's more information on the  docs .", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/expressions/#step-3", 
            "text": "Start \n   Fix Code   In this next contrived example, we're going to make a colour mixer.  First, we want to show how much we're using of each colour. We'll use  div  elements with a percentage width corresponding to the amount. All the colour values are between 0 and 1, so we need to multiply by 100:  div style='background-color: red;\n     width: {{red*100}}%;' /div   Update the first three  div  elements in the template accordingly.   Pro-tip: in the playground editors, hold the  Cmd  key (or  Ctrl  if you're not on a Mac) and click in each of the places where you need to type 100. Multiple cursors FTW!   To show the result, we can use an  rgb(r,g,b)  CSS colour value. But instead of percentages, these need to be between 0 and 255:  div style='background-color:\n  rgb({{red   * 255}},\n      {{green * 255}},\n      {{blue  * 255}})'  /div   Update the template and execute the code. Did it work?  No, it didn't. That's because CSS insists that you use integers \u2013 no decimals allowed. So let's use  Math.round  to turn the numbers into integers:  div style='background-color:\n  rgb({{Math.round(red   * 255)}},\n      {{Math.round(green * 255)}},\n      {{Math.round(blue  * 255)}})'  /div   Execute the code. Ta-da! Try changing the colours.   ractive.set( 'red', 1 );\n// PSST! Want a sneak preview of something neat?\n// Try using ractive.animate() instead of ractive.set().\n// You can drop it in after the line 9 in the Script content.   The  Math  object is one of several built-in JavaScript objects you have direct access to within expressions, alongside  Date ,  encodeURI ,  parseInt ,  JSON  and various others. Consult the documentation for a full list. You can also access other globals using the  @global  special reference, where the  JSON  object would be accessible as  @global.JSON .  Expressions can be as simple or as complex as you like, as long as they only refer to properties of their view model (i.e. the properties on the data object), don't include assignment operators (including  += ,  -= ,  ++  and   -- ),  new ,  delete  or  void , and don't use function literals.", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/events/", 
            "text": "Events\n\n\nDOM events are central to anything interactive on the web. You've probably written \nelement.addEventListener('click', handler)\n or \n$('#button').on('click', handler)\n, or similar code, a thousand times.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nWith Ractive.js, events are declarative instead, and you declare an event handler like this:\n\n\nbutton on-click=\n@global.alert( 'Activating!' )\nActivate!\n/button\n\n\n\n\n\n\n\n\"But wait!\", you say. \"That looks like some sort of global inline event listener horribleness!\". It's not though, I promise. Instead, the \non-\n directive will bind a shared callback directly to the element using \naddEventListener\n when it is rendered. When the shared callback is triggered, it will evaluate the expression (or list of expressions) that was passed to the event directive. If you inspect the button element in your browser's Dev Tools, you'll notice that there is no \non-click\n attribute. That's because directives don't render directly to the DOM, but instead control behavior related to rendering like attaching event listeners.\n\n\n\n\nThis is generally more convenient - you don't need to pepper the DOM with id and class attributes just you've got a hook to identify elements with. It also takes the guesswork out of when to attach and detach event listeners, since Ractive.js will automatically attach and detach handlers as elements are rendered and unrendered. Since the event directive actually accepts a list of expressions as its argument, so go ahead and log a console message after the alert is acknowledged:\n\n\nbutton on-click=\n@global.alert( 'Activating!' ), console.log( 'alert was acknowledged' )\nActivate!\n/button\n\n\n\n\n\n\n\nconsole\n is one of the globals that is exposed to Ractive.js templates, but if you want to get to \nalert\n, you have to go through the \n@global\n special reference.\n\n\nThe playground watches for console messages in the output pane and displays them on the \nConsole\n tab, so if you happen to be reading through this in a browser that doesn't have Dev Tools, you can still see most console messages.\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nOkay, we can now annoy users and log debug info. What about something a bit more useful? Back into the bag of contrived examples, and out comes... a number incrementer!\n\n\n{{number}} \nbutton on-click=\n@this.add('number')\n+\n/button\n\n\n\n\n\n\n\n@this\n is a reference to the Ractive.js instance that is controlling the template, so you can call any methods on the Ractive.js API with the \n@this\n special reference. Since \n@this\n is a \nvery\n common reference, it also has an ever so slightly shorter shorthand \n@\n. \n@this.toggle('visible')\n and \n@.toggle('visible')\n are equivalent.\n\n\n\n\nGiven that there is a \nsubtract\n method in the Ractive.js API, can you add a decrement button to the example as well?\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nTo further wangle our incrementer contrivance, suppose we devised a web version of the old traveling game wherein you collect all of the cows that you pass on your side of the car. So we'll need two objects, one for \nme\n and one for my \nsibling\n. Each person will have a poroperty, \ncows\n, which is an integer representing accumulated bovine beasts.\n\n\n{\n  me: { cows: 0 },\n  sibling: { cows: 0 }\n}\n\n\n\n\nThe template for this game will include a \ntable\n containing counts for each person and buttons to increment each person's taurine total.\n\n\ntable\n\n  \ntr\n\n    \nth\nMe\n/th\nth\nSibling\n/th\n\n  \n/tr\n\n  \ntr\n\n    \ntd\n\n      {{#with me}}\n        {{.cows}}\n        \nbutton\n+\n/button\n\n      {{/with}}\n    \n/td\n\n    \ntd\n\n      {{#with sibling}}\n        {{.cows}}\n        \nbutton\n+\n/button\n\n      {{/with}}\n    \n/td\n\n  \n/tr\n\n\n/table\n\n\n\n\n\nThe event listeners \ncould\n use the full path to the appropriate \ncows\n property, which is not too large an imposition here, but with a deeper context, it would quickly become inconvenient. They could also do some keypath manipulation using the special reference \n@keypath\n, which resolves to the keypath to the current context at any point in the template. That's a bit painful in most contexts and impossible in others. To address this particular issue, Ractive.js provides a special \n@context\n reference that acts as an API adaptor that is rooted in the current context of the template. \n@context\n objects have most of the same API methods as a Ractive.js instance, but they can resolve relative keypaths. Add this event directive to each of the buttons to see it in action:\n\n\nbutton on-click=\n@context.add( '.cows' )\n+\n/button\n\n\n\n\n\nTo complete the rules of the game, when you pass a cemetery on your side of the car, you lose all of your cows. It's a weird game, I know, but I didn't make it up. What would be the easiest way to reset a person's cow count?\n\n\nStep 4\n\n\n\n  \nStart\n\n\n\n\nSuppose you need to track the mouse cursor as it moves across a \ndiv\n for... reasons. Perhaps you've landed the contract for the frontend of a missile targeting system. Ractive.js provides access to the DOM event object in event directive expressions as the special \n@event\n reference. Any properties and methods available on the event object passed to the \naddEventListener\n callback are available from the \n@event\n reference e.g. \n@event.clientX\n.\n\n\ndiv id=\ntracker\n on-mousemove=\n@.set({ x: @event.clientX, y: @event.clientY })\n on-click=\nconsole.log(`firing at (${@event.clientX}, ${@event.clientY})!`)\n\n  ({{x}}, {{y}})\n\n/div\n\n\n\n\n\nThe element on which the event directive is installed is also available within event directive expressions as the special \n@node\n reference. Like the \n@event\n reference, you can access any properties or methods of the DOM element or even pass it as an argument to another function using \n@node\n.\n\n\ninput value=\nexample\n on-focus=\n@node.select()\n /\n\n\n\n\n\n\n\nIf you need to cancel an event by calling \nstopPropagation\n, you can simply make \nfalse\n the last expression in your event directive expression list.\n\n\na href=\"/nope\" on-click=\"doSomething(), false\"\nThis will do something rather than /nope.\n/a\n\n\n\n\n\n\nStep 5\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nRactive.js also provides its own instance-level event system, so that you can raise and respond to internal events in a more abstract way. You can name your events however you like, so you can convey more meaning about the intent of the action that triggered the event, such as \naddUser\n as opposed to \nclick\n.\n\n\nTo listen to an event, you attach an event listener to your Ractive.js instance with the \non\n method.\n\n\nractive.on( 'activate', function ( context ) {\n  // `this` is the ractive instance\n  // `context` is a context object\n  // any additional event arguments would follow `context`, if supplied\n  alert( 'Activating!' );\n});\n\n\n\n\nTo raise an event, you pass the event name and optional context and arguments to the \nfire\n method.\n\n\n// this will trigger the \nractive.fire( 'activate' );\n\n\n\n\nUpdate the template and JavaScript to fire and handle an instance event, then execute. Remember, you can access the current Ractive.js instance with the \n@this\n special reference or \n@\n shorthand.\n\n\n\n\nA Ractive.js instance doesn't need to be rendered to update data or fire and handle events.\n\n\n\n\nStep 6\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nYou can subscribe to multiple instance events in one go:\n\n\nractive.on({\n  activate: function () {\n    alert( 'Activating!' );\n  },\n  deactivate: function () {\n    alert( 'Deactivating!' );\n  }\n});\n\n\n\n\nAdd a 'deactivate' button and wire it up.\n\n\nStep 7\n\n\n\n  \nStart\n\n\n\n\nConverting a DOM event into an instance event is a terribly convenient way to handle user actions in a meaningful way. The signature of the \nfire\n method is a little cumbersome to include all over your template, especially if you need to pass the \n@context\n and a few additional arguments. To address that, Ractive.js provides a convenient shorthand method for firing and instance event from an event directive. If there is only one expression in the event directive arguments, that expression returns an array, and that array has a string as the first member, the event directive will fire an internal event with the first array element as the name, the current \n@context\n as the context, and any remaining members of the array as event arguments. This is generally referred to as a \"proxy event\".\n\n\nbutton on-click=\n['activate', user]\nActivate!\n/button\n\n\n!-- which is a bit more convenient than --\n\n\nbutton on-click=\n@this.fire('activate', @context, user)\nActivate!\n/button\n\n\n\n\n\n\n\nDepending on your editor and personal tastes, it might be convenient to use an unquoted attribute for your proxied events: \nbutton on-click=['activate', user]\nActivate!\n/button\n. There is nothing special going on there - Ractive.js supports just about everything that HTML does, and HTML supports unquoted attributes e.g. \ninput value=green /\n.\n\n\n\n\nAs with regular event expressions, if a handler for a proxied event returns \nfalse\n, it will cancel the event.\n\n\nStep 8\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nThere are a couple of ways to unsubscribe from events. If you've used jQuery, you'll be used to this syntax:\n\n\nractive.on( 'select', selectHandler );\n\n// later...\nractive.off( 'select', selectHandler );\n\n\n\n\nThat's fine, as long as you stored a reference to selectHandler (i.e. you didn't just use an anonymous function). If you didn't, you can also do this:\n\n\n// remove ALL 'select' handlers\nractive.off( 'select' );\n\n// remove all handlers of ANY type\nractive.off();\n\n\n\n\nAlternatively, you can do this:\n\n\nvar listener = ractive.on( 'select', selectHandler );\n\nvar otherListeners = ractive.on({\n  activate: function () { alert( 'Activating' ); },\n  deactivate: function () { alert( 'Deactivating!' ); }\n});\n\n// later...\nlistener.cancel();\notherListeners.cancel();\n\n\n\n\nTry adding a 'stop' button which removes the 'activate' and 'deactivate' handlers.\n\n\nYou can also temporarily disable an event handler or set of event handlers by calling \nsilence\n on the handle returned by \non\n. You can resume processing of the handler or handlers by calling the conveniently named \nresume\n method on the handle.\n\n\nvar listener = ractive.on({\n  'select', function () { alert( 'Selected!' ); },\n  'delete', function () { alert( 'Deleted!' ); }\n});\n\n// later...\nlistener.silence();\n\n// no alerts here\nractive.fire( 'select' );\nractive.fire( 'delete' );\n\n// later...\nlistener.resume();\n\n// alert here\nractive.fire( 'select' );\n\n\n\n\nTry adding a silence button that checks to see if the listener is silenced using the handle's \nisSilenced\n method, and silences or resumes it as appropriate.\n\n\n\n\nIf you remove your ractive from the DOM with \nractive.teardown()\n, any event handlers will be automatically cleaned up.\n\n\n\n\nStep 9\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIt's possible to define custom template events in Ractive.js. You use them just like normal events:\n\n\nbutton on-tap='activate'\nActivate!\n/button\n\n\n\n\n\nNote that we're using on-tap here instead of \non-click\n \u2013 \ntap\n is a custom event.\n\n\n\n\nCustom events are distributed as plugins, which can be downloaded from here to include in your project.\n\n\nYou can also create your own plugins \u2013 just follow the instructions on the docs.\n\n\n\n\nThe trouble with \nclick\n is that it's nonsense. If you put your mouse down on the 'activate' button, waggle it about, then lift your finger up after a few seconds, the browser will in most cases consider it a 'click'. I don't. Do you?\n\n\nFurthermore, if your interface needs to work on touch devices, using \nclick\n means a 300ms delay between the \ntouchstart\n-\ntouchend\n sequence event and the simulated \nmousedown\n-\nmouseup\n-\nclick\n sequence.\n\n\nThe tap event corrects for both of these anomalies. Try replacing the click proxies in the template.", 
            "title": "Events"
        }, 
        {
            "location": "/get-started/tutorials/events/#events", 
            "text": "DOM events are central to anything interactive on the web. You've probably written  element.addEventListener('click', handler)  or  $('#button').on('click', handler) , or similar code, a thousand times.", 
            "title": "Events"
        }, 
        {
            "location": "/get-started/tutorials/events/#step-1", 
            "text": "Start \n   Fix Code   With Ractive.js, events are declarative instead, and you declare an event handler like this:  button on-click= @global.alert( 'Activating!' ) Activate! /button    \"But wait!\", you say. \"That looks like some sort of global inline event listener horribleness!\". It's not though, I promise. Instead, the  on-  directive will bind a shared callback directly to the element using  addEventListener  when it is rendered. When the shared callback is triggered, it will evaluate the expression (or list of expressions) that was passed to the event directive. If you inspect the button element in your browser's Dev Tools, you'll notice that there is no  on-click  attribute. That's because directives don't render directly to the DOM, but instead control behavior related to rendering like attaching event listeners.   This is generally more convenient - you don't need to pepper the DOM with id and class attributes just you've got a hook to identify elements with. It also takes the guesswork out of when to attach and detach event listeners, since Ractive.js will automatically attach and detach handlers as elements are rendered and unrendered. Since the event directive actually accepts a list of expressions as its argument, so go ahead and log a console message after the alert is acknowledged:  button on-click= @global.alert( 'Activating!' ), console.log( 'alert was acknowledged' ) Activate! /button    console  is one of the globals that is exposed to Ractive.js templates, but if you want to get to  alert , you have to go through the  @global  special reference.  The playground watches for console messages in the output pane and displays them on the  Console  tab, so if you happen to be reading through this in a browser that doesn't have Dev Tools, you can still see most console messages.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/events/#step-2", 
            "text": "Start \n   Fix Code   Okay, we can now annoy users and log debug info. What about something a bit more useful? Back into the bag of contrived examples, and out comes... a number incrementer!  {{number}}  button on-click= @this.add('number') + /button    @this  is a reference to the Ractive.js instance that is controlling the template, so you can call any methods on the Ractive.js API with the  @this  special reference. Since  @this  is a  very  common reference, it also has an ever so slightly shorter shorthand  @ .  @this.toggle('visible')  and  @.toggle('visible')  are equivalent.   Given that there is a  subtract  method in the Ractive.js API, can you add a decrement button to the example as well?", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/events/#step-3", 
            "text": "Start \n   Fix Code   To further wangle our incrementer contrivance, suppose we devised a web version of the old traveling game wherein you collect all of the cows that you pass on your side of the car. So we'll need two objects, one for  me  and one for my  sibling . Each person will have a poroperty,  cows , which is an integer representing accumulated bovine beasts.  {\n  me: { cows: 0 },\n  sibling: { cows: 0 }\n}  The template for this game will include a  table  containing counts for each person and buttons to increment each person's taurine total.  table \n   tr \n     th Me /th th Sibling /th \n   /tr \n   tr \n     td \n      {{#with me}}\n        {{.cows}}\n         button + /button \n      {{/with}}\n     /td \n     td \n      {{#with sibling}}\n        {{.cows}}\n         button + /button \n      {{/with}}\n     /td \n   /tr  /table   The event listeners  could  use the full path to the appropriate  cows  property, which is not too large an imposition here, but with a deeper context, it would quickly become inconvenient. They could also do some keypath manipulation using the special reference  @keypath , which resolves to the keypath to the current context at any point in the template. That's a bit painful in most contexts and impossible in others. To address this particular issue, Ractive.js provides a special  @context  reference that acts as an API adaptor that is rooted in the current context of the template.  @context  objects have most of the same API methods as a Ractive.js instance, but they can resolve relative keypaths. Add this event directive to each of the buttons to see it in action:  button on-click= @context.add( '.cows' ) + /button   To complete the rules of the game, when you pass a cemetery on your side of the car, you lose all of your cows. It's a weird game, I know, but I didn't make it up. What would be the easiest way to reset a person's cow count?", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/events/#step-4", 
            "text": "Start   Suppose you need to track the mouse cursor as it moves across a  div  for... reasons. Perhaps you've landed the contract for the frontend of a missile targeting system. Ractive.js provides access to the DOM event object in event directive expressions as the special  @event  reference. Any properties and methods available on the event object passed to the  addEventListener  callback are available from the  @event  reference e.g.  @event.clientX .  div id= tracker  on-mousemove= @.set({ x: @event.clientX, y: @event.clientY })  on-click= console.log(`firing at (${@event.clientX}, ${@event.clientY})!`) \n  ({{x}}, {{y}}) /div   The element on which the event directive is installed is also available within event directive expressions as the special  @node  reference. Like the  @event  reference, you can access any properties or methods of the DOM element or even pass it as an argument to another function using  @node .  input value= example  on-focus= @node.select()  /    If you need to cancel an event by calling  stopPropagation , you can simply make  false  the last expression in your event directive expression list.  a href=\"/nope\" on-click=\"doSomething(), false\" This will do something rather than /nope. /a", 
            "title": "Step 4"
        }, 
        {
            "location": "/get-started/tutorials/events/#step-5", 
            "text": "Start \n   Fix Code   Ractive.js also provides its own instance-level event system, so that you can raise and respond to internal events in a more abstract way. You can name your events however you like, so you can convey more meaning about the intent of the action that triggered the event, such as  addUser  as opposed to  click .  To listen to an event, you attach an event listener to your Ractive.js instance with the  on  method.  ractive.on( 'activate', function ( context ) {\n  // `this` is the ractive instance\n  // `context` is a context object\n  // any additional event arguments would follow `context`, if supplied\n  alert( 'Activating!' );\n});  To raise an event, you pass the event name and optional context and arguments to the  fire  method.  // this will trigger the \nractive.fire( 'activate' );  Update the template and JavaScript to fire and handle an instance event, then execute. Remember, you can access the current Ractive.js instance with the  @this  special reference or  @  shorthand.   A Ractive.js instance doesn't need to be rendered to update data or fire and handle events.", 
            "title": "Step 5"
        }, 
        {
            "location": "/get-started/tutorials/events/#step-6", 
            "text": "Start \n   Fix Code   You can subscribe to multiple instance events in one go:  ractive.on({\n  activate: function () {\n    alert( 'Activating!' );\n  },\n  deactivate: function () {\n    alert( 'Deactivating!' );\n  }\n});  Add a 'deactivate' button and wire it up.", 
            "title": "Step 6"
        }, 
        {
            "location": "/get-started/tutorials/events/#step-7", 
            "text": "Start   Converting a DOM event into an instance event is a terribly convenient way to handle user actions in a meaningful way. The signature of the  fire  method is a little cumbersome to include all over your template, especially if you need to pass the  @context  and a few additional arguments. To address that, Ractive.js provides a convenient shorthand method for firing and instance event from an event directive. If there is only one expression in the event directive arguments, that expression returns an array, and that array has a string as the first member, the event directive will fire an internal event with the first array element as the name, the current  @context  as the context, and any remaining members of the array as event arguments. This is generally referred to as a \"proxy event\".  button on-click= ['activate', user] Activate! /button  !-- which is a bit more convenient than --  button on-click= @this.fire('activate', @context, user) Activate! /button    Depending on your editor and personal tastes, it might be convenient to use an unquoted attribute for your proxied events:  button on-click=['activate', user] Activate! /button . There is nothing special going on there - Ractive.js supports just about everything that HTML does, and HTML supports unquoted attributes e.g.  input value=green / .   As with regular event expressions, if a handler for a proxied event returns  false , it will cancel the event.", 
            "title": "Step 7"
        }, 
        {
            "location": "/get-started/tutorials/events/#step-8", 
            "text": "Start \n   Fix Code   There are a couple of ways to unsubscribe from events. If you've used jQuery, you'll be used to this syntax:  ractive.on( 'select', selectHandler );\n\n// later...\nractive.off( 'select', selectHandler );  That's fine, as long as you stored a reference to selectHandler (i.e. you didn't just use an anonymous function). If you didn't, you can also do this:  // remove ALL 'select' handlers\nractive.off( 'select' );\n\n// remove all handlers of ANY type\nractive.off();  Alternatively, you can do this:  var listener = ractive.on( 'select', selectHandler );\n\nvar otherListeners = ractive.on({\n  activate: function () { alert( 'Activating' ); },\n  deactivate: function () { alert( 'Deactivating!' ); }\n});\n\n// later...\nlistener.cancel();\notherListeners.cancel();  Try adding a 'stop' button which removes the 'activate' and 'deactivate' handlers.  You can also temporarily disable an event handler or set of event handlers by calling  silence  on the handle returned by  on . You can resume processing of the handler or handlers by calling the conveniently named  resume  method on the handle.  var listener = ractive.on({\n  'select', function () { alert( 'Selected!' ); },\n  'delete', function () { alert( 'Deleted!' ); }\n});\n\n// later...\nlistener.silence();\n\n// no alerts here\nractive.fire( 'select' );\nractive.fire( 'delete' );\n\n// later...\nlistener.resume();\n\n// alert here\nractive.fire( 'select' );  Try adding a silence button that checks to see if the listener is silenced using the handle's  isSilenced  method, and silences or resumes it as appropriate.   If you remove your ractive from the DOM with  ractive.teardown() , any event handlers will be automatically cleaned up.", 
            "title": "Step 8"
        }, 
        {
            "location": "/get-started/tutorials/events/#step-9", 
            "text": "Start \n   Fix Code   It's possible to define custom template events in Ractive.js. You use them just like normal events:  button on-tap='activate' Activate! /button   Note that we're using on-tap here instead of  on-click  \u2013  tap  is a custom event.   Custom events are distributed as plugins, which can be downloaded from here to include in your project.  You can also create your own plugins \u2013 just follow the instructions on the docs.   The trouble with  click  is that it's nonsense. If you put your mouse down on the 'activate' button, waggle it about, then lift your finger up after a few seconds, the browser will in most cases consider it a 'click'. I don't. Do you?  Furthermore, if your interface needs to work on touch devices, using  click  means a 300ms delay between the  touchstart - touchend  sequence event and the simulated  mousedown - mouseup - click  sequence.  The tap event corrects for both of these anomalies. Try replacing the click proxies in the template.", 
            "title": "Step 9"
        }, 
        {
            "location": "/get-started/tutorials/conditional-sections/", 
            "text": "Conditional Sections\n\n\nOften, you want to show or hide part of your view depending on whether a particular condition is met. For example you might want to show a slightly different view to users depending on whether they're signed in or not.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIn this example we've already set up a mock sign-in mechanism \u2013 click the 'sign in' button and enter your name in the prompt.\n\n\nAll we need to do is hide the 'please sign in' message when we're signed in, and the 'welcome back!' message when we're not.\n\n\nWrap the first block in an \n#if\n section that uses the \nsignedIn\n property:\n\n\n{{#if signedIn}}\n  \n!-- message for signed-in users --\n\n  \np\nWelcome back, {{username}}!\n/p\n\n{{/if}}\n\n\n\n\nNow do the same for the other block, except with the \nnotSignedIn\n property. Execute the code.\n\n\n\n\nThe plain mustache block \n{{#...}}\n is equivalent to \n{{#if ...}}{{#with ...}}\n. It is both conditional and contextual.\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nHaving two properties (\nsignedIn\n and \nnotSignedIn\n) to represent one piece of data (whether or not the user is signed in) is the sort of thing that makes most programmers itch uncontrollably.\n\n\nWe have a couple of options. We could use an \n#unless\n section:\n\n\n{{#unless signedIn}}\n  \n!-- not-signed-in block --\n\n{{/unless}}\n\n\n\n\n\n\nThere's also a plain mustache for negated sections, \n{{^signedIn}}...{{/}}\n.\n\n\n\n\nAlternatively, we could use else:\n\n\n{{#if signedIn}}\n  \n!-- signed-in block --\n\n{{else}}\n  \n!-- not-signed-in block --\n\n{{/if}}\n\n\n\n\nUpdate the template. Then, remove the references to notSignedIn in the JavaScript. Then breathe a sigh of relief \u2013 doesn't that feel better?\n\n\n\n\nIf you have another branch in your conditional, you can include it with an \n{{elseif ...}}\n mustache. An \n{{#if}}\n section can include as many \nelseif\ns as you need, but it can only contain one \nelse\n.", 
            "title": "Conditional Sections"
        }, 
        {
            "location": "/get-started/tutorials/conditional-sections/#conditional-sections", 
            "text": "Often, you want to show or hide part of your view depending on whether a particular condition is met. For example you might want to show a slightly different view to users depending on whether they're signed in or not.", 
            "title": "Conditional Sections"
        }, 
        {
            "location": "/get-started/tutorials/conditional-sections/#step-1", 
            "text": "Start \n   Fix Code   In this example we've already set up a mock sign-in mechanism \u2013 click the 'sign in' button and enter your name in the prompt.  All we need to do is hide the 'please sign in' message when we're signed in, and the 'welcome back!' message when we're not.  Wrap the first block in an  #if  section that uses the  signedIn  property:  {{#if signedIn}}\n   !-- message for signed-in users -- \n   p Welcome back, {{username}}! /p \n{{/if}}  Now do the same for the other block, except with the  notSignedIn  property. Execute the code.   The plain mustache block  {{#...}}  is equivalent to  {{#if ...}}{{#with ...}} . It is both conditional and contextual.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/conditional-sections/#step-2", 
            "text": "Start \n   Fix Code   Having two properties ( signedIn  and  notSignedIn ) to represent one piece of data (whether or not the user is signed in) is the sort of thing that makes most programmers itch uncontrollably.  We have a couple of options. We could use an  #unless  section:  {{#unless signedIn}}\n   !-- not-signed-in block -- \n{{/unless}}   There's also a plain mustache for negated sections,  {{^signedIn}}...{{/}} .   Alternatively, we could use else:  {{#if signedIn}}\n   !-- signed-in block -- \n{{else}}\n   !-- not-signed-in block -- \n{{/if}}  Update the template. Then, remove the references to notSignedIn in the JavaScript. Then breathe a sigh of relief \u2013 doesn't that feel better?   If you have another branch in your conditional, you can include it with an  {{elseif ...}}  mustache. An  {{#if}}  section can include as many  elseif s as you need, but it can only contain one  else .", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/iterative-sections/", 
            "text": "Iterative Sections\n\n\nLists of data, of some form or another, are often at the heart of webapps. In this tutorial we're going to build a sortable table of superheroes, using data taken from \nsuperherodb.com\n.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nWe've already got an array of objects representing four of the X-Men, over there on the right. We just need to update the template.\n\n\nBegin by wrapping the second \ntr\n in an \n#each\n section:\n\n\n{{#each superheroes}}\n  \ntr\n\n    \n!-- row content --\n\n  \n/tr\n\n{{/each}}\n\n\n\n\n\n\nAs with \n#with\n and \n#if\n sections, you could just do \n{{#superheroes}}...{{/superheroes}}\n and it would work the same way, as long as superheroes is an array.\n\n\n\n\nThen, insert mustaches representing each of the three properties in the table \u2013 \nname\n, \nrealname\n and \npower\n. For extra credit, wrap the name in a link pointing to the info URL.\n\n\nExecute the code.\n\n\n// You can use array notation to update the data:\nractive.set( 'superheroes[1].power', 'Martial arts' );\n\n// Or, you can use dot notation. Whichever you prefer:\nractive.set( 'superheroes.3.power', 'Enhanced senses' );\n\n\n\n\n\n\nWhat if there weren't any items in the array? Displaying a table with no rows has been recognized by the International Web Decorum Foundation as impolite, so Ractive.js will allow you to provide alternate content using an \n{{else}}\n section in the \n#each\n block, which will be rendered if the array is empty.\n\n\n{{#each superheroes}}\n  \ntr\n...\n/tr\n\n{{else}}\n  \ntr\ntd colspan=\"4\"\nOh no! There are no superheroes!\n/td\n/tr\n\n{{/each}}\n\n\n\nThis also works with plain mustache sections.\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nOften when working with lists, we want to know the index of the list item we're currently rendering.\n\n\nMustache doesn't have a good way of doing this, so Ractive.js introduces the \nindex reference\n:\n\n\n{{#each list: num}}\n  \n!-- inside here, {{num}} is the index --\n\n{{/each}}\n\n\n\n\n\n\nIf you don't want to name your index, you can also use the generic index special reference \n@index\n. \n@index\n will resolve to the index of the nearest iteration, so if you happen to have nested iterations, it will be the nearest parent iteration, not the root.\n\n\nIf your section happens to be iterating an object rather than an array, you can use the \n@key\n special reference to get the object key of the current iteration.\n\n\n\n\nBy declaring \nnum\n to be an index reference, we can use it the same way we'd use any other variable. Let's add a number column to our table \u2013 first add the column to the header row:\n\n\ntr\n\n  \nth\n#\n/th\n\n  \nth\nSuperhero name\n/th\n\n  \n!-- etc --\n\n\n/tr\n\n\n\n\n\nThen to the list row:\n\n\n{{#each superheroes: num}}\n  \ntr\n\n    \ntd\n{{num}}\n/td\n\n    \ntd\na href='{{info}}'\n{{name}}\n/a\n/td\n\n    \ntd\n{{realname}}\n/td\n\n    \ntd\n{{power}}\n/td\n\n  \n/tr\n\n{{/each}}\n\n\n\n\nExecute the code.\n\n\nNot bad, but it would look better if the numbers started at 1 rather than 0. Use an expression to increment each row number by 1.\n\n\nStep 3\n\n\n\n  \nStart\n\n\n\n\nLet's say you wanted to add an item to your list. You could use \nractive.set()\n the way you're used to, but you'd have to find the length of the existing array first:\n\n\nvar index = ractive.get( 'superheroes' ).length;\nractive.set( 'superheroes[' + index + ']', newSuperhero );\n\n\n\n\nThat's not ideal. We could use \nractive.update('superheroes')\n instead, which will make sure that the table is up to date:\n\n\nxmen[ xmen.length ] = newSuperhero;\nractive.update( 'superheroes' );\n\n\n\n\n\n\nIf you don't pass a keypath argument to \nractive.update()\n, Ractive.js will update everything that has changed since the last set or update.\n\n\n\n\nBut there's a more convenient way. Ractive.js provides mutator methods for arrays (push, pop, shift, unshift, splice, sort and reverse) that work with a keypath:\n\n\nractive.push( 'superheroes', newSuperhero );\n\n\n\n\nTry adding Storm to the list by pushing to the array in the Script pane:\n\n\nvar newSuperhero = {\n  name: 'Storm',\n  realname: 'Monroe, Ororo',\n  power: 'Controlling the weather',\n  info: 'http://www.superherodb.com/Storm/10-135/'\n};\n\n// add the code here...\n\n\n\n\nStep 4\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIt's time to make our table sortable. We've added a 'sortable' class to the three headers to indicate they can be clicked on.\n\n\nFirst, let's add an event listener to each column header, calling the instance \nsort\n method with the column header as an argument:\n\n\nth class='sortable' on-click='@.sort(\nname\n)'\nSuperhero name\n/th\n\n\nth class='sortable' on-click='@.sort(\nrealname\n)'\nReal name\n/th\n\n\nth class='sortable' on-click='@.sort(\npower\n)'\nSuperpower\n/th\n\n\n\n\n\nThat way, when the user clicks one of the column headers, the view will fire call the \nsort\n method.\n\n\nractive.sort = function ( column ) {\n  alert( 'Sorting by ' + column );\n});\n\n\n\n\n\n\nYou can add methods and properties directly to a Ractive.js instance by simply including them in the init options. Any keys that don't match know init options are added to the instance upon creation.\n\n\n\n\nExecute the code. When you click on the three sortable headers, the browser should alert the name of the column we're sorting by. Now we just need to add the sorting logic.\n\n\nStep 5\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nSo we've wired up our event handler, and it's behaving as it should. The next step is to add some logic that actually sorts the table. For bonus points, we'll add a 'sorted' class to the header of the sorted column.\n\n\nThere's a nice easy way to ensure that the table remains sorted, even when we add more data: an expression. That's right, you can use expressions with sections.\n\n\nUpdate the template:\n\n\n{{#each sort( superheroes ) : num}}\n  \ntr\n\n   \n!-- row contents --\n\n  \n/tr\n\n{{/each}}\n\n\n\n\nNow we need to add the \nsort\n function. Here's one (if you're not sure why this works, \nhere's an MDN page\n that will help explain):\n\n\nfunction ( array ) {\n  // grab the current sort column\n  var column = this.get( 'sortColumn' ); \n\n  // clone the array so as not to modify the underlying data\n  var arr = array.slice();\n\n  return arr.sort( function ( a, b ) {\n    return a[ sortColumn ] \n b[ sortColumn ] ? -1 : 1;\n  });\n}\n\n\n\n\nWiring it up is easy:\n\n\nractive.sort = function ( column ) {\n  this.set( 'sortColumn', column );\n});\n\n\n\n\nTry executing this code and clicking different headers to sort the table. (You could specify an initial sort column by adding e.g. \nsortColumn: 'name'\n to \ndata\n.)\n\n\nThe last job is to add a sorted class to the header of the currently sorted column. There are several ways we could do this \u2013 you could use a bit of jQuery inside the sort proxy event handler, for example. But for this demonstration we'll put the logic in the template, using the conditional operator:\n\n\nth class='sortable' class-sorted=\nsortColumn === 'name'\n on-click='@.sort(\nname\n)'\n\n  Superhero name\n\n/th\n\n\n\n\n\n\n\nThe \nclass-\n directive is similar to the \nstyle-\n directive - it gives you direct control over the presence of a single class. The \nclass-\n directive exists in an expression context, so mustaches are not required. If the expression passed to the directive is truthy, Ractive.js will add the class to the element, and if it's false-y, it will remove it.\n\n\nYou could also add an additional expression within the existing \nclass\n attribute using a ternary e.g. \nclass=\"sortable {{ sortColumn === 'name' ? 'sorted' : '' }}\n.\n\n\n\n\nDo this for each of the headers, then execute the code. Congratulations! You've built a sortable table in just a few steps. Now comes the fun part \u2013 add Storm back to the table. The table will maintain its sort order.\n\n\nractive.push( 'superheroes', {\n  name: 'Storm',\n  realname: 'Monroe, Ororo',\n  power: 'Controlling the weather',\n  info: 'http://www.superherodb.com/Storm/10-135/'\n});", 
            "title": "Iterative Sections"
        }, 
        {
            "location": "/get-started/tutorials/iterative-sections/#iterative-sections", 
            "text": "Lists of data, of some form or another, are often at the heart of webapps. In this tutorial we're going to build a sortable table of superheroes, using data taken from  superherodb.com .", 
            "title": "Iterative Sections"
        }, 
        {
            "location": "/get-started/tutorials/iterative-sections/#step-1", 
            "text": "Start \n   Fix Code   We've already got an array of objects representing four of the X-Men, over there on the right. We just need to update the template.  Begin by wrapping the second  tr  in an  #each  section:  {{#each superheroes}}\n   tr \n     !-- row content -- \n   /tr \n{{/each}}   As with  #with  and  #if  sections, you could just do  {{#superheroes}}...{{/superheroes}}  and it would work the same way, as long as superheroes is an array.   Then, insert mustaches representing each of the three properties in the table \u2013  name ,  realname  and  power . For extra credit, wrap the name in a link pointing to the info URL.  Execute the code.  // You can use array notation to update the data:\nractive.set( 'superheroes[1].power', 'Martial arts' );\n\n// Or, you can use dot notation. Whichever you prefer:\nractive.set( 'superheroes.3.power', 'Enhanced senses' );   What if there weren't any items in the array? Displaying a table with no rows has been recognized by the International Web Decorum Foundation as impolite, so Ractive.js will allow you to provide alternate content using an  {{else}}  section in the  #each  block, which will be rendered if the array is empty.  {{#each superheroes}}\n   tr ... /tr \n{{else}}\n   tr td colspan=\"4\" Oh no! There are no superheroes! /td /tr \n{{/each}}  This also works with plain mustache sections.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/iterative-sections/#step-2", 
            "text": "Start \n   Fix Code   Often when working with lists, we want to know the index of the list item we're currently rendering.  Mustache doesn't have a good way of doing this, so Ractive.js introduces the  index reference :  {{#each list: num}}\n   !-- inside here, {{num}} is the index -- \n{{/each}}   If you don't want to name your index, you can also use the generic index special reference  @index .  @index  will resolve to the index of the nearest iteration, so if you happen to have nested iterations, it will be the nearest parent iteration, not the root.  If your section happens to be iterating an object rather than an array, you can use the  @key  special reference to get the object key of the current iteration.   By declaring  num  to be an index reference, we can use it the same way we'd use any other variable. Let's add a number column to our table \u2013 first add the column to the header row:  tr \n   th # /th \n   th Superhero name /th \n   !-- etc --  /tr   Then to the list row:  {{#each superheroes: num}}\n   tr \n     td {{num}} /td \n     td a href='{{info}}' {{name}} /a /td \n     td {{realname}} /td \n     td {{power}} /td \n   /tr \n{{/each}}  Execute the code.  Not bad, but it would look better if the numbers started at 1 rather than 0. Use an expression to increment each row number by 1.", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/iterative-sections/#step-3", 
            "text": "Start   Let's say you wanted to add an item to your list. You could use  ractive.set()  the way you're used to, but you'd have to find the length of the existing array first:  var index = ractive.get( 'superheroes' ).length;\nractive.set( 'superheroes[' + index + ']', newSuperhero );  That's not ideal. We could use  ractive.update('superheroes')  instead, which will make sure that the table is up to date:  xmen[ xmen.length ] = newSuperhero;\nractive.update( 'superheroes' );   If you don't pass a keypath argument to  ractive.update() , Ractive.js will update everything that has changed since the last set or update.   But there's a more convenient way. Ractive.js provides mutator methods for arrays (push, pop, shift, unshift, splice, sort and reverse) that work with a keypath:  ractive.push( 'superheroes', newSuperhero );  Try adding Storm to the list by pushing to the array in the Script pane:  var newSuperhero = {\n  name: 'Storm',\n  realname: 'Monroe, Ororo',\n  power: 'Controlling the weather',\n  info: 'http://www.superherodb.com/Storm/10-135/'\n};\n\n// add the code here...", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/iterative-sections/#step-4", 
            "text": "Start \n   Fix Code   It's time to make our table sortable. We've added a 'sortable' class to the three headers to indicate they can be clicked on.  First, let's add an event listener to each column header, calling the instance  sort  method with the column header as an argument:  th class='sortable' on-click='@.sort( name )' Superhero name /th  th class='sortable' on-click='@.sort( realname )' Real name /th  th class='sortable' on-click='@.sort( power )' Superpower /th   That way, when the user clicks one of the column headers, the view will fire call the  sort  method.  ractive.sort = function ( column ) {\n  alert( 'Sorting by ' + column );\n});   You can add methods and properties directly to a Ractive.js instance by simply including them in the init options. Any keys that don't match know init options are added to the instance upon creation.   Execute the code. When you click on the three sortable headers, the browser should alert the name of the column we're sorting by. Now we just need to add the sorting logic.", 
            "title": "Step 4"
        }, 
        {
            "location": "/get-started/tutorials/iterative-sections/#step-5", 
            "text": "Start \n   Fix Code   So we've wired up our event handler, and it's behaving as it should. The next step is to add some logic that actually sorts the table. For bonus points, we'll add a 'sorted' class to the header of the sorted column.  There's a nice easy way to ensure that the table remains sorted, even when we add more data: an expression. That's right, you can use expressions with sections.  Update the template:  {{#each sort( superheroes ) : num}}\n   tr \n    !-- row contents -- \n   /tr \n{{/each}}  Now we need to add the  sort  function. Here's one (if you're not sure why this works,  here's an MDN page  that will help explain):  function ( array ) {\n  // grab the current sort column\n  var column = this.get( 'sortColumn' ); \n\n  // clone the array so as not to modify the underlying data\n  var arr = array.slice();\n\n  return arr.sort( function ( a, b ) {\n    return a[ sortColumn ]   b[ sortColumn ] ? -1 : 1;\n  });\n}  Wiring it up is easy:  ractive.sort = function ( column ) {\n  this.set( 'sortColumn', column );\n});  Try executing this code and clicking different headers to sort the table. (You could specify an initial sort column by adding e.g.  sortColumn: 'name'  to  data .)  The last job is to add a sorted class to the header of the currently sorted column. There are several ways we could do this \u2013 you could use a bit of jQuery inside the sort proxy event handler, for example. But for this demonstration we'll put the logic in the template, using the conditional operator:  th class='sortable' class-sorted= sortColumn === 'name'  on-click='@.sort( name )' \n  Superhero name /th    The  class-  directive is similar to the  style-  directive - it gives you direct control over the presence of a single class. The  class-  directive exists in an expression context, so mustaches are not required. If the expression passed to the directive is truthy, Ractive.js will add the class to the element, and if it's false-y, it will remove it.  You could also add an additional expression within the existing  class  attribute using a ternary e.g.  class=\"sortable {{ sortColumn === 'name' ? 'sorted' : '' }} .   Do this for each of the headers, then execute the code. Congratulations! You've built a sortable table in just a few steps. Now comes the fun part \u2013 add Storm back to the table. The table will maintain its sort order.  ractive.push( 'superheroes', {\n  name: 'Storm',\n  realname: 'Monroe, Ororo',\n  power: 'Controlling the weather',\n  info: 'http://www.superherodb.com/Storm/10-135/'\n});", 
            "title": "Step 5"
        }, 
        {
            "location": "/get-started/tutorials/two-way-binding/", 
            "text": "Two-way Binding\n\n\nHTML forms are a very important part of many web applications. Most data-binding in a template only goes in one direction - from the model to the view, but form elements provide a point at which the view could update the model. To that end, Ractive.js provides special bindings for form elements that go both ways - from the model to the view and from the view to the model - or two-way bindings.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nThe 'Hello, world!' of two-way data binding looks like this:\n\n\nlabel\n\n  Enter your name:\n  \ninput value='{{name}}'\n\n\n/label\n\n\n\np\nHello, {{name}}!\n/p\n\n\n\n\n\nUpdate the template and re-render it, then type your name in the box.\n\n\n\n\nInternally, we're binding to \ninput\n events (and \nkeyup\n for IE, since it doesn't fire \ninput\n correctly) alongside \nchange\n and \nblur\n events \u2013 this ensures instantaneous feedback for a slick experience.\n\n\nIf you'd rather the updates only happened on \nchange\n and \nblur\n, pass in \nlazy: true\n as an initialisation option.\n\n\nIf you'd rather disable two-way binding altogether, you can do so with \ntwoway: false\n.\n\n\nYou can also control two-way bindings and laziness on a per-element basis using the \ntwoway\n and \nlazy\n directives. The \nlazy\n directive may be boolean, or if you'd like to get updates without a blur, you can pass it a number of milliseconds to wait after the last \ninput\n event to trigger the update.\n\n\n\n\nThat's a cute demo, but it doesn't have much real world use. In all likelihood we want to do something with the data when it changes. For that, we use \nractive.observe()\n:\n\n\nractive.observe( 'name', function ( newValue, oldValue ) {\n  doSomethingWith( newValue );\n});\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nYou can control whether checkboxes are checked or not like so:\n\n\nlabel\n\n  \ninput type='checkbox' checked='{{checked}}'\n\n  {{#if checked}}checked!{{else}}not checked{{/if}}\n\n/label\n\n\n\n\n\nUpdate the template and try toggling the checkbox.\n\n\nIf you have a group of radio buttons, whose values are mutually exclusive, you can do this:\n\n\nlabel\ninput type='radio' name='{{color}}' value='red' checked\n red\n/label\n\n\nlabel\ninput type='radio' name='{{color}}' value='green'\n green\n/label\n\n\nlabel\ninput type='radio' name='{{color}}' value='blue'\n blue\n/label\n\n\np\nThe selected colour is \nspan style='color: {{color}};'\n{{color}}\n/span\n.\n/p\n\n\n\n\n\nHere, because we've set the \nname\n attribute to \n{{color}}\n, the value of \ncolor\n is set to the \nvalue\n attribute of whichever radio button is currently checked. (If you need to read that sentence a couple of times, I don't blame you.) Notice that the value is initialised to \nred\n, because that option is initially checked.\n\n\nAdd \nname='{{color}}'\n to each of the options in the template and run the code.\n\n\n\n\nFront-end \u00fcber nerds will notice that this isn't how these attributes normally work. For example, a checkbox with checked='false' is the same as one with checked='true', because it's a boolean attribute which either exists on the element or doesn't \u2013 its value is completely irrelevant.\n\n\nFurthermore, once you've interacted with a checkbox, its checked attribute becomes irrelevant! You can only change the value programmatically by doing element.checked = true rather than  element.setAttribute( 'checked' ).\n\n\nCombine all that with cross-browser quirks (e.g. IE8 and below only fire  change events on blur), and we're in some seriously confusing territory.\n\n\nSo Ractive.js makes no apology for using checked='{{checked}}' to mean 'checked if checked is true, unchecked if it's false'. We're bringing sanity to the process of gathering user input.\n\n\n\n\nNeedless to say, you can continue to interact with the values programmatically:\n\n\nractive.set( 'checked', true );\nractive.set( 'color', 'green' );\n\n\n\n\nThis is as good a time as any to introduce the \nractive.toggle()\n method:\n\n\nractive.toggle( 'checked' );\n\n// Equivalent to:\n//   var checked = ractive.get( 'checked' );\n//   ractive.set( 'checked', !checked );\n\n\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nAs well as \ninput\n elements (and \ntextarea\ns, which work similarly), two-way binding works with \nselect\n menus. Let's replace the radio group from the previous step with a \nselect\n:\n\n\nselect value='{{color}}'\n\n  \noption\nred\n/option\n\n  \noption\ngreen\n/option\n\n  \noption selected\nblue\n/option\n\n\n/select\n\n\n\n\n\n\n\nI apologise to my fellow Brits, and other English-speaking non-Americans, for the repeated use of color instead of colour. Occupational hazard.\n\n\n\n\nRe-render the ractive. Notice that once again, the data is initialised to the value of the selected \noption\n \u2013 in this case, blue. (You can explicity set a \nvalue\n attribute, but if you don't, the text content of the \noption\n is used instead.)\n\n\nThat's good, but we can go one better \u2013 rather than hard-coding our colours into the template, let's do it properly:\n\n\nselect value='{{color}}'\n\n  {{#each colors}}\n    \noption\n{{this}}\n/option\n\n  {{/each}}\n\n/select\n\n\n\n\n\n\n\nWe haven't seen \n{{this}}\n before \u2013 it simply means 'the current context'. Previously, whenever we've used lists, they've been lists of objects, so we've been able to use a property of the object (like \n{{name}}\n). Using this allows us to use lists of primitives (in this case, strings) instead.\n\n\nIf you prefer, you can use \n{{.}}\n instead of \n{{this}}\n.\n\n\nYou can also set up an alias to \nthis\n for a slightly more human friendly template in many circumstances. Within \n{{#each users as user}}...{{/each}}\n, \nuser\n will resolve to the current iteration. You can still use index names too e.g. \n{{#each users as user: i}}...{{/each}}\n.\n\n\n\n\nAnd add some data to our view:\n\n\nvar ractive = new Ractive({\n  el: output,\n  template: template,\n  data: {\n    colors: [ 'red', 'green', 'blue' ],\n    color: 'green'\n  }\n});\n\n\n\n\n\n\nThe template no longer has an \noption\n with a \nselected\n attribute, so we need to specify an initial value of \ncolor\n.\nExecute this code. For extra credit, add more colours:\n\n\n\n\nractive.push( 'colors', 'purple' );\n\n\n\n\nStep 4\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIn some situations you need to make it possible to select several values simultaneously. HTML has us covered \u2013 we use the \nmultiple\n attribute with a \nselect\n.\n\n\nUnfortunately that's as helpful as it gets \u2013 \nselectElement.value\n returns the value of the \nmost recently selected\n option, which is just mad, frankly. In almost all cases, if you're using a select element with the \nmultiple\n attribute, what you really want is an array of the selected values. This is what Ractive.js provides.\n\n\nTry adding the \nmultiple\n attribute to the template:\n\n\nselect value='{{selectedColors}}' multiple\n\n\n\n\n\nExecute, then try making multiple selections. And, of course, it works the other way round:\n\n\n\n\n\nractive.set( 'selectedColors', [ 'green', 'purple' ]);", 
            "title": "Two-way Binding"
        }, 
        {
            "location": "/get-started/tutorials/two-way-binding/#two-way-binding", 
            "text": "HTML forms are a very important part of many web applications. Most data-binding in a template only goes in one direction - from the model to the view, but form elements provide a point at which the view could update the model. To that end, Ractive.js provides special bindings for form elements that go both ways - from the model to the view and from the view to the model - or two-way bindings.", 
            "title": "Two-way Binding"
        }, 
        {
            "location": "/get-started/tutorials/two-way-binding/#step-1", 
            "text": "Start \n   Fix Code   The 'Hello, world!' of two-way data binding looks like this:  label \n  Enter your name:\n   input value='{{name}}'  /label  p Hello, {{name}}! /p   Update the template and re-render it, then type your name in the box.   Internally, we're binding to  input  events (and  keyup  for IE, since it doesn't fire  input  correctly) alongside  change  and  blur  events \u2013 this ensures instantaneous feedback for a slick experience.  If you'd rather the updates only happened on  change  and  blur , pass in  lazy: true  as an initialisation option.  If you'd rather disable two-way binding altogether, you can do so with  twoway: false .  You can also control two-way bindings and laziness on a per-element basis using the  twoway  and  lazy  directives. The  lazy  directive may be boolean, or if you'd like to get updates without a blur, you can pass it a number of milliseconds to wait after the last  input  event to trigger the update.   That's a cute demo, but it doesn't have much real world use. In all likelihood we want to do something with the data when it changes. For that, we use  ractive.observe() :  ractive.observe( 'name', function ( newValue, oldValue ) {\n  doSomethingWith( newValue );\n});", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/two-way-binding/#step-2", 
            "text": "Start \n   Fix Code   You can control whether checkboxes are checked or not like so:  label \n   input type='checkbox' checked='{{checked}}' \n  {{#if checked}}checked!{{else}}not checked{{/if}} /label   Update the template and try toggling the checkbox.  If you have a group of radio buttons, whose values are mutually exclusive, you can do this:  label input type='radio' name='{{color}}' value='red' checked  red /label  label input type='radio' name='{{color}}' value='green'  green /label  label input type='radio' name='{{color}}' value='blue'  blue /label  p The selected colour is  span style='color: {{color}};' {{color}} /span . /p   Here, because we've set the  name  attribute to  {{color}} , the value of  color  is set to the  value  attribute of whichever radio button is currently checked. (If you need to read that sentence a couple of times, I don't blame you.) Notice that the value is initialised to  red , because that option is initially checked.  Add  name='{{color}}'  to each of the options in the template and run the code.   Front-end \u00fcber nerds will notice that this isn't how these attributes normally work. For example, a checkbox with checked='false' is the same as one with checked='true', because it's a boolean attribute which either exists on the element or doesn't \u2013 its value is completely irrelevant.  Furthermore, once you've interacted with a checkbox, its checked attribute becomes irrelevant! You can only change the value programmatically by doing element.checked = true rather than  element.setAttribute( 'checked' ).  Combine all that with cross-browser quirks (e.g. IE8 and below only fire  change events on blur), and we're in some seriously confusing territory.  So Ractive.js makes no apology for using checked='{{checked}}' to mean 'checked if checked is true, unchecked if it's false'. We're bringing sanity to the process of gathering user input.   Needless to say, you can continue to interact with the values programmatically:  ractive.set( 'checked', true );\nractive.set( 'color', 'green' );  This is as good a time as any to introduce the  ractive.toggle()  method:  ractive.toggle( 'checked' );\n\n// Equivalent to:\n//   var checked = ractive.get( 'checked' );\n//   ractive.set( 'checked', !checked );", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/two-way-binding/#step-3", 
            "text": "Start \n   Fix Code   As well as  input  elements (and  textarea s, which work similarly), two-way binding works with  select  menus. Let's replace the radio group from the previous step with a  select :  select value='{{color}}' \n   option red /option \n   option green /option \n   option selected blue /option  /select    I apologise to my fellow Brits, and other English-speaking non-Americans, for the repeated use of color instead of colour. Occupational hazard.   Re-render the ractive. Notice that once again, the data is initialised to the value of the selected  option  \u2013 in this case, blue. (You can explicity set a  value  attribute, but if you don't, the text content of the  option  is used instead.)  That's good, but we can go one better \u2013 rather than hard-coding our colours into the template, let's do it properly:  select value='{{color}}' \n  {{#each colors}}\n     option {{this}} /option \n  {{/each}} /select    We haven't seen  {{this}}  before \u2013 it simply means 'the current context'. Previously, whenever we've used lists, they've been lists of objects, so we've been able to use a property of the object (like  {{name}} ). Using this allows us to use lists of primitives (in this case, strings) instead.  If you prefer, you can use  {{.}}  instead of  {{this}} .  You can also set up an alias to  this  for a slightly more human friendly template in many circumstances. Within  {{#each users as user}}...{{/each}} ,  user  will resolve to the current iteration. You can still use index names too e.g.  {{#each users as user: i}}...{{/each}} .   And add some data to our view:  var ractive = new Ractive({\n  el: output,\n  template: template,\n  data: {\n    colors: [ 'red', 'green', 'blue' ],\n    color: 'green'\n  }\n});   The template no longer has an  option  with a  selected  attribute, so we need to specify an initial value of  color .\nExecute this code. For extra credit, add more colours:   ractive.push( 'colors', 'purple' );", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/two-way-binding/#step-4", 
            "text": "Start \n   Fix Code   In some situations you need to make it possible to select several values simultaneously. HTML has us covered \u2013 we use the  multiple  attribute with a  select .  Unfortunately that's as helpful as it gets \u2013  selectElement.value  returns the value of the  most recently selected  option, which is just mad, frankly. In almost all cases, if you're using a select element with the  multiple  attribute, what you really want is an array of the selected values. This is what Ractive.js provides.  Try adding the  multiple  attribute to the template:  select value='{{selectedColors}}' multiple   Execute, then try making multiple selections. And, of course, it works the other way round:   ractive.set( 'selectedColors', [ 'green', 'purple' ]);", 
            "title": "Step 4"
        }, 
        {
            "location": "/get-started/tutorials/partials/", 
            "text": "Partials\n\n\nPartials are a good way to split complex templates up into several more manageable chunks. They also allow re-use of bits of template without having to repeat the template.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nTake this todo list, for example. It's not too bad, but the template would look neater if we could separate out the code for an individual item. Well, we can. Add this above the rest of the JavaScript:\n\n\nvar item = \nli class-done='.done'\n +\n           \n   \ninput type='checkbox' checked='{{.done}}'\n +\n           \n   \nspan class='description' on-click=\\\nedit\\\n +\n           \n   {{.description}}\n +\n           \n   {{#if .editing}}\n +\n           \n     \ninput class='edit'\n +\n           \n              value='{{.description}}'\n +\n           \n              on-blur='@context.toggle( \\\n.editing\\\n ), false'\n +\n           \n              on-keydown=\\\n@.enterExit( @event, @context )\\\n +\n           \n   {{/if}}\n +\n           \n   \n/span\n +\n           \n   \nbutton class='button' on-click='@context.splice( \\\n../\\\n, @index, 1 )'\n\u00d7\n/button\n +\n           \n \n/li\n;\n\n\n\n\nThen, in the main template we replace all that with a partial, which looks like a regular mustache but with a \n character:\n\n\nul class='todos'\n\n  {{#each items: i}}\n    {{\nitem}}\n  {{/each}}\n\n/ul\n\n\n\n\n\nFinally, we need to add the partial when we initialize out instance:\n\n\nvar ractive = new Ractive({\n  target: '#target',\n  template: '#template',\n\n  partials: { item: item },\n  // etc...\n});\n\n\n\n\nExecute this code.\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nFine, except that multiline string was fugly. It's good to know that you can pass partials in as strings, but unless you're loading those strings from a template file with AJAX, you'd probably prefer a neater way.\n\n\nThere are two. Firstly, you can add partials as \nscript\n tags on the page:\n\n\nscript id=\nitem\n type=\ntext/html\n\n  \nli class-done='.done'\n\n    \ninput type='checkbox' checked='{{.done}}'\n\n    \nspan class='description' on-click=\nedit\n\n      {{.description}}\n\n      {{#if .editing}}\n        \ninput class='edit'\n               value='{{.description}}'\n               on-blur='@context.toggle( \n.editing\n ), false'\n               on-keydown=\n@.enterExit( @event, @context )\n\n      {{/if}}\n    \n/span\n\n    \nbutton class='button' on-click='@context.splice( \n../\n, @index, 1 )'\n\u00d7\n/button\n\n  \n/li\n\n\n/script\n\n\n\n\n\n\n\nNote that the \nid\n attribute is the name of the partial, and that the \ntype\n attribute is \ntext/html\n (though it could be anything, as long as it's not \ntext/javascript\n). This is a convenient way to quickly test ideas out on a blank page (you can use these script tags as main templates as well as partials - just reference them as e.g. \n'#myTemplate'\n in your initialisation options).\n\n\n\n\nOr, you can use an \ninline partial\n. Inline partials are declared within your template, using the \n{{#partial myPartialName}}\n syntax:\n\n\n{{#partial item}}\n  \nli class-done='.done'\n\n    \ninput type='checkbox' checked='{{.done}}'\n\n    \nspan class='description' on-click=\nedit\n\n      {{.description}}\n\n      {{#if .editing}}\n        \ninput class='edit'\n               value='{{.description}}'\n               on-blur='@context.toggle( \n.editing\n ), false'\n               on-keydown=\n@.enterExit( @event, @context )\n\n      {{/if}}\n    \n/span\n\n    \nbutton class='button' on-click='@context.splice( \n../\n, @index, 1 )'\n\u00d7\n/button\n\n  \n/li\n\n{{/partial}}\n\n\n\n\nAdd the partial to the template, and remove it (and the \nvar item = ...\n bit) from the javascript code.\n\n\n\n\nIn addition to supporting partial strings, Ractive.js will accept a pre-parsed template in the \npartials\n map, or as the \ntemplate\n option, for that matter. Pre-parsed partials have the benefit of not requiring the parser at runtime, which means rendering can happen a bit faster - and you can ship a lighter-weight version of Ractive.js to the browser (see the runtime-only build).\n\n\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nThat covers breaking templates into more manageable or logical chunks, so moving on to reuse, we'll grab our handy bag of contrivances and pull out... a formatted name. It's a bit simple, but it should suffice.\n\n\nSuppose we have a webapp that deals with people, businesses, and the yachts that they own. All three of those happen to have names that we'll say are broken down in slightly different ways. A yacht just has a name. A business has a name and a potential classifier, like LLC. A person has a given name, a family name, any number of middle names, and a potential suffix. A yacht is also owned by a business or a person, which, as we've established, both have names. (We're gonna go ahead and pretend that most yacht owners don't have a corporate entity to hold their yachts.)\n\n\nWhat we want to do is take our list of yachts with their various owners and display them in the table. Here's a partial that would work with each type of entity:\n\n\n{{#if .type === 'business'}}\n  {{.name}}{{.classifier ? `, ${.classifier}` : ''}}\n{{elseif .type === 'yacht'}}\n  {{name}}\n{{else}}\n  {{.familyName}}, {{.givenName}}{{.suffix ? ` ${.suffix}` : ''}}\n{{/if}}\n\n\n\n\nNow we want to use the partial for both the yacht and the owner, but the owner is a property of the yacht. We could use a \n#with\n block to set the context for the owner partial. It turns out that's a pretty common thing to need when working with complex apps with lots of partials, so Ractive.js has a sugared version of a partial that accepts a context after the partial name:\n\n\n{{\nname .owner}}\n\n\n\n\n\n\nThis is roughly equivalent to \n{{#with .owner}}{{\nname}}{{/with}}\n, but not quite exactly the same. For reasons that will become clear in the next step, the \n#with\n portion of the partial with context is wrapped around the template of the partial and not the partial mustache itself.\n\n\nIf no context is supplied to a partial, then it inherits its context from its parent.\n\n\nPartials may also set aliases instead of passing a context, which is convenient if there's more than one bit of data that needs to be uniform going into the partial. For instance \n{{\nuser .homePhone as phone, .workEmail as email}}\n lets the caller of the partial specify what \n{{phone}}\n and \n{{email}}\n should mean inside the partial. Again, this is the rough equivalent of the similar \n#with\n construct, \n{{#with .homePhone as phone, .workEmail as email}}{{\nuser}}{{/with}}\n.\n\n\n\n\nStep 4\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nThat last contrivance was a bit stretched, so let's stretch it a bit further and see if it breaks. We want to future-proof our webapp in case some other type of entity should arise to be involved with our yachts. So we decide that we want to create a specific partial for each type of entity:\n\n\n{{#if .type === 'business'}}\n  {{\nbusiness-name}}\n{{elseif .type === 'yacht'}}\n  {{\nyacht-name}}\n{{else}}\n  {{\nperson-name}}\n{{/if}}\n\n\n\n\nPerhaps that's a bit better, but it's not very expandable \nor\n pretty. As it turns out, the name given to a partial mustache may also be an expression that evaluates to a string. So we can go ahead and replace our wrapper-partial with something simple:\n\n\n{{\n `${.type}-name`}}\n\n\n\n\n\n\nWhen the expression evaluates, it will return a string, which will then be used to look up the appropriate partial in the registry. Partials check for a matching name before evaluating as an expression, so if you an expression that could also be a valid partial name, the partial name will be picked rather that the result of evaluating the expression. For example with partials named \nuser\n and \nlarry\n and a property \nuser: 'larry'\n, \n{{\nuser}}\n will use the \nuser\n partial rather than the \nlarry\n partial.\n\n\n\n\nNow when it turns out that we need to also keep up with buildings, that for our purposes include a street address in their name, we can do so easily by adding a new partial named \nbuilding-name\n:\n\n\n{{.name}}, {{.address}}\n\n\n\n\nI think that contrivance has snapped, possibly in more than one place, but hopefully it was served its purpose.", 
            "title": "Partials"
        }, 
        {
            "location": "/get-started/tutorials/partials/#partials", 
            "text": "Partials are a good way to split complex templates up into several more manageable chunks. They also allow re-use of bits of template without having to repeat the template.", 
            "title": "Partials"
        }, 
        {
            "location": "/get-started/tutorials/partials/#step-1", 
            "text": "Start \n   Fix Code   Take this todo list, for example. It's not too bad, but the template would look neater if we could separate out the code for an individual item. Well, we can. Add this above the rest of the JavaScript:  var item =  li class-done='.done'  +\n                input type='checkbox' checked='{{.done}}'  +\n                span class='description' on-click=\\ edit\\  +\n               {{.description}}  +\n               {{#if .editing}}  +\n                  input class='edit'  +\n                          value='{{.description}}'  +\n                          on-blur='@context.toggle( \\ .editing\\  ), false'  +\n                          on-keydown=\\ @.enterExit( @event, @context )\\  +\n               {{/if}}  +\n                /span  +\n                button class='button' on-click='@context.splice( \\ ../\\ , @index, 1 )' \u00d7 /button  +\n              /li ;  Then, in the main template we replace all that with a partial, which looks like a regular mustache but with a   character:  ul class='todos' \n  {{#each items: i}}\n    {{ item}}\n  {{/each}} /ul   Finally, we need to add the partial when we initialize out instance:  var ractive = new Ractive({\n  target: '#target',\n  template: '#template',\n\n  partials: { item: item },\n  // etc...\n});  Execute this code.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/partials/#step-2", 
            "text": "Start \n   Fix Code   Fine, except that multiline string was fugly. It's good to know that you can pass partials in as strings, but unless you're loading those strings from a template file with AJAX, you'd probably prefer a neater way.  There are two. Firstly, you can add partials as  script  tags on the page:  script id= item  type= text/html \n   li class-done='.done' \n     input type='checkbox' checked='{{.done}}' \n     span class='description' on-click= edit \n      {{.description}}\n\n      {{#if .editing}}\n         input class='edit'\n               value='{{.description}}'\n               on-blur='@context.toggle(  .editing  ), false'\n               on-keydown= @.enterExit( @event, @context ) \n      {{/if}}\n     /span \n     button class='button' on-click='@context.splice(  ../ , @index, 1 )' \u00d7 /button \n   /li  /script    Note that the  id  attribute is the name of the partial, and that the  type  attribute is  text/html  (though it could be anything, as long as it's not  text/javascript ). This is a convenient way to quickly test ideas out on a blank page (you can use these script tags as main templates as well as partials - just reference them as e.g.  '#myTemplate'  in your initialisation options).   Or, you can use an  inline partial . Inline partials are declared within your template, using the  {{#partial myPartialName}}  syntax:  {{#partial item}}\n   li class-done='.done' \n     input type='checkbox' checked='{{.done}}' \n     span class='description' on-click= edit \n      {{.description}}\n\n      {{#if .editing}}\n         input class='edit'\n               value='{{.description}}'\n               on-blur='@context.toggle(  .editing  ), false'\n               on-keydown= @.enterExit( @event, @context ) \n      {{/if}}\n     /span \n     button class='button' on-click='@context.splice(  ../ , @index, 1 )' \u00d7 /button \n   /li \n{{/partial}}  Add the partial to the template, and remove it (and the  var item = ...  bit) from the javascript code.   In addition to supporting partial strings, Ractive.js will accept a pre-parsed template in the  partials  map, or as the  template  option, for that matter. Pre-parsed partials have the benefit of not requiring the parser at runtime, which means rendering can happen a bit faster - and you can ship a lighter-weight version of Ractive.js to the browser (see the runtime-only build).", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/partials/#step-3", 
            "text": "Start \n   Fix Code   That covers breaking templates into more manageable or logical chunks, so moving on to reuse, we'll grab our handy bag of contrivances and pull out... a formatted name. It's a bit simple, but it should suffice.  Suppose we have a webapp that deals with people, businesses, and the yachts that they own. All three of those happen to have names that we'll say are broken down in slightly different ways. A yacht just has a name. A business has a name and a potential classifier, like LLC. A person has a given name, a family name, any number of middle names, and a potential suffix. A yacht is also owned by a business or a person, which, as we've established, both have names. (We're gonna go ahead and pretend that most yacht owners don't have a corporate entity to hold their yachts.)  What we want to do is take our list of yachts with their various owners and display them in the table. Here's a partial that would work with each type of entity:  {{#if .type === 'business'}}\n  {{.name}}{{.classifier ? `, ${.classifier}` : ''}}\n{{elseif .type === 'yacht'}}\n  {{name}}\n{{else}}\n  {{.familyName}}, {{.givenName}}{{.suffix ? ` ${.suffix}` : ''}}\n{{/if}}  Now we want to use the partial for both the yacht and the owner, but the owner is a property of the yacht. We could use a  #with  block to set the context for the owner partial. It turns out that's a pretty common thing to need when working with complex apps with lots of partials, so Ractive.js has a sugared version of a partial that accepts a context after the partial name:  {{ name .owner}}   This is roughly equivalent to  {{#with .owner}}{{ name}}{{/with}} , but not quite exactly the same. For reasons that will become clear in the next step, the  #with  portion of the partial with context is wrapped around the template of the partial and not the partial mustache itself.  If no context is supplied to a partial, then it inherits its context from its parent.  Partials may also set aliases instead of passing a context, which is convenient if there's more than one bit of data that needs to be uniform going into the partial. For instance  {{ user .homePhone as phone, .workEmail as email}}  lets the caller of the partial specify what  {{phone}}  and  {{email}}  should mean inside the partial. Again, this is the rough equivalent of the similar  #with  construct,  {{#with .homePhone as phone, .workEmail as email}}{{ user}}{{/with}} .", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/partials/#step-4", 
            "text": "Start \n   Fix Code   That last contrivance was a bit stretched, so let's stretch it a bit further and see if it breaks. We want to future-proof our webapp in case some other type of entity should arise to be involved with our yachts. So we decide that we want to create a specific partial for each type of entity:  {{#if .type === 'business'}}\n  {{ business-name}}\n{{elseif .type === 'yacht'}}\n  {{ yacht-name}}\n{{else}}\n  {{ person-name}}\n{{/if}}  Perhaps that's a bit better, but it's not very expandable  or  pretty. As it turns out, the name given to a partial mustache may also be an expression that evaluates to a string. So we can go ahead and replace our wrapper-partial with something simple:  {{  `${.type}-name`}}   When the expression evaluates, it will return a string, which will then be used to look up the appropriate partial in the registry. Partials check for a matching name before evaluating as an expression, so if you an expression that could also be a valid partial name, the partial name will be picked rather that the result of evaluating the expression. For example with partials named  user  and  larry  and a property  user: 'larry' ,  {{ user}}  will use the  user  partial rather than the  larry  partial.   Now when it turns out that we need to also keep up with buildings, that for our purposes include a street address in their name, we can do so easily by adding a new partial named  building-name :  {{.name}}, {{.address}}  I think that contrivance has snapped, possibly in more than one place, but hopefully it was served its purpose.", 
            "title": "Step 4"
        }, 
        {
            "location": "/get-started/tutorials/triples-embedded-html/", 
            "text": "Triples (Embedded HTML)\n\n\nOrdinarily in a template, mustaches stand in for data, which is HTML escaped for sanitary purposes. But occasionally you need to insert chunks of HTML into your view \u2013 for that, we have the triple-stache: \n{{{content}}}\n.\n\n\nStep 1\n\n\n\n  \nStart\n\n\n\n\nTry running this code:\n\n\nractive.set( 'content', '\na href=\nhttp://bit.ly/QOyWC1\nimg src=\n/gifs/image.gif\n/\n/a\n' );\n\n\n\n\n\n\nThat was a short tutorial! When using triples, bear in mind that when their data changes, the nodes they represent must be removed from the DOM before being re-rendered and reinserted. For that reason, you shouldn't use triples where regular mustaches will do the same job \u2013 Ractive.js is able to operate more efficiently with mustaches.", 
            "title": "Triples (Embedded HTML)"
        }, 
        {
            "location": "/get-started/tutorials/triples-embedded-html/#triples-embedded-html", 
            "text": "Ordinarily in a template, mustaches stand in for data, which is HTML escaped for sanitary purposes. But occasionally you need to insert chunks of HTML into your view \u2013 for that, we have the triple-stache:  {{{content}}} .", 
            "title": "Triples (Embedded HTML)"
        }, 
        {
            "location": "/get-started/tutorials/triples-embedded-html/#step-1", 
            "text": "Start   Try running this code:  ractive.set( 'content', ' a href= http://bit.ly/QOyWC1 img src= /gifs/image.gif / /a ' );   That was a short tutorial! When using triples, bear in mind that when their data changes, the nodes they represent must be removed from the DOM before being re-rendered and reinserted. For that reason, you shouldn't use triples where regular mustaches will do the same job \u2013 Ractive.js is able to operate more efficiently with mustaches.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/components/", 
            "text": "Components\n\n\nIf you've used Backbone Views in the past, you'll be familiar with the basic concept of \nextending\n the \nbase class\n to create a new \nsubclass\n with default data and additional methods.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIn this tutorial we're first going to learn about Ractive.extend and use it to create an image slideshow, using gifs from \ndevopsreactions.tumblr.com\n.\n\n\nWe've got our basic template set up \u2013 we just need to make a few additions. First, we need to add a mustache for the image URL:\n\n\ndiv class='main-image'\n     style='background-image: url(\n{{image.src}}\n);'\n\n\n/div\n\n\n\n\n\nWe're using a CSS background rather than an \nimg\n element for this example, because you can use the \nbackground-size: contain\n CSS rule to ensure that the image is shown at maximum size without distorting the aspect ratio.\n\n\nThen, we need to add a mustache for the image caption:\n\n\ndiv class='caption'\n\n  \np\n{{image.caption}}\n/p\n\n\n/div\n\n\n\n\n\nFinally, let's add some event expressions that we can fill in later:\n\n\na class='prev' on-click='@.goto(current - 1)'\nspan\nlaquo;\n/span\n/a\n\n\n!-- ... --\n\n\na class='next' on-click='@.goto(current + 1)'\nspan\nraquo;\n/span\n/a\n\n\n\n\n\nExecute the JavaScript to redraw the view, with the placeholder data that's already there.\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nTime to create our \nSlideshow\n class:\n\n\nvar Slideshow = Ractive.extend({\n  // this will be applied to all Slideshow instances\n  template: '#slideshow',\n\n  // method for changing the currently displayed image\n  goto: function ( imageNum ) {\n    // goto method goes here...\n  },\n\n  // default data\n  oninit: function () {\n    // return the default data for the component here\n  }\n});\n\n\n\n\nEach \nSlideshow\n instance will have a \ngoto\n method in addition to the normal \nRactive\n instance methods. We'll also provide default data for the component, notably to start with the \ncurrent\n index as \n0\n.\n\n\n\n\nWhen providing data for components, you should always use a data function that returns a data dictionary. If you return the same object from each invocation, then all of your component instances will share the same underlying data, but the properties won't necessarily be kept up-to-date across instances.\n\n\nComponent data and instance data is combined into the final instance's data dictionary starting with Ractive default data, moving through the component hierarchy, and ending with the data supplied to the instance constructor.\n\n\n\n\nLet's write our \ngoto\n method:\n\n\nfunction ( index ) {\n  var images = this.get( 'images' );\n\n  // handle wrap around\n  var num = ( index + images.length ) % images.length;\n\n  this.set( 'current', num );\n}\n\n\n\n\nLet's add some code to instantiate the slideshow with our gifs. There's a ready-made images variable you can use for this step:\n\n\nvar slideshow = new Slideshow({\n  target: '#target',\n  data: { images: images }\n});\n\n\n\n\nGo ahead and execute the code \u2013 you should now have a working slideshow.\n\n\n\n\nNeedless to say, you could add as many bells and whistles as you wanted \u2013 fading or sliding transitions, image preloading, thumbnails, touchscreen gesture controls, and so on.\n\n\nYou could, of course, just use an existing image slideshow library. But then you would have to learn that library, and potentially submit to its design philosophy.\n\n\nRactive.js is all about flexibility. If you want to change the design or behaviour of a component (say, adding a class name to a particular element), the power to do so is in your hands \u2013 the template is easy to understand and tweak because it's basically just HTML, and the view logic is straightforward.\n\n\nIt's better to be able to build your own solution than to rely on developers maintaining high quality and up-to-date documentation.\n\n\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nNow we have our lovely slideshow component, but suppose we want to use it in our Ractive.js app rather than mounting it directly on an element. It turns out that that is a pretty simple thing to accomplish. We can register our component with either globally or with our main Ractive.js instance, and anywhere that the template has a \nslideshow /\n element, Ractive.js will create an instance of \nSlideshow\n and mount it inline.\n\n\nRactive.components.slideshow = Slideshow;\n\n// or\nvar ractive = new Ractive({\n    // ...\n\n  components: {\n    slideshow: Slideshow\n  },\n\n  // ...\n});\n\n\n\n\nNow in the template, we just reference the component as if it were a custom element:\n\n\ndiv style-height=\n40vh\n\n  \nslideshow /\n\n\n/div\n\n\n\n\n\nWe \nwere\n passing the list of pictures to the instance as it was being initialized, but since Ractive.js is now managing the instance, how do we get the list of pictures to the component instance? Well, we create a mapping from the data in the host instance to the \nimages\n keypath in the component by using an attribute:\n\n\ndiv style-height=\n40vh\n\n  \nslideshow images=\n{{devopsImages}}\n /\n\n\n/div\n\n\n\n\n\nUpdate the code with another images array and put two \nslideshow\n components in the main instance.\n\n\n\n\nMappings are automatically managed cross-instance \nlink\ns. A link is a bit like a filesystem symlink in that the data isn't copied anywhere - it just gets a new path that points to it. Changing the data in either place is effectively the same as changing it everywhere at once.\n\n\n\n\nStep 4\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nWe have our image slideshow usable from any app now, but what if we wanted to make it slightly more customizable? Perhaps we could allow the user to have a bit more control over the template by, say, letting them include some sort of disclaimer on all of the slides. We could hard-code the disclaimer in a special version for each client, but that sounds like it would be awful to maintain.\n\n\nFortunately, Ractive.js allows you to use the content of a component tag to pass partials to the component instance. Any content not within a \n{{#patial}}\n tag is collected up and exposed to the component as a partial named \ncontent\n. Any \n{{#partial}}\ns are supplied to the component instance with the names they are given in the \n{{#partial}}\n tag. We'll use a disclaimer partial for our component:\n\n\nslideshow\n\n  {{#partial disclaimer}}\ndiv class=\ndisclaimer\nI don't know what we're disclaiming, but we're disclaiming it \na on-click=\n@.disclaim(), false\n href=\n#\nhere\n/a\n.\n/div\n{{/partial}}\n\n/slideshow\n\n\n\n\n\nWe can add a reference to the partial in the \nSlideshow\n component template:\n\n\n{{\ndisclaimer}}\n\n\n\n\n\n\nIt's not a bad idea to supply a default partial with the component, so that Ractive.js doesn't emit any warnings about missing partials. Any partials passed to the component will override any supplied to \nextend\n.\n\n\n\n\nNow what will happen when you click the \"here\" link? Partials exist completely in the context of the instance in which they are used, and there is no \ndisclaim\n method on the \nSlideshow\n component, so nothing will happen (except an error will be logged to the console). If you want a passed-in partial to render in the context from which it was passed, you can \n{{yield}}\n it.\n\n\n{{yield disclaimer}}\n\n\n\n\nAdd a \ndisclaim\n method to the main instance, update the \nSlideshow\n component, and run the code to see it all in action.\n\n\n\n\nSince \nyield\n puts the partial in the context of the caller, there's not much point in using it within an \n#each\n block because the array being iterated is unreachable from the \nyield\n. \nyield\ns can also supply aliases to data local to the component e.g. \n{{yield disclaimer with current as currentImage}}\n. \nyield\ning the \ncontent\n partial just requires dropping the name.\n\n\n\n\nStep 5\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nNow suppose we wanted to do something to each of our component instances as they're created, like validate that they have certain parameters provided and issue a warning if they don't. Ractive.js components actually have a pretty complete set of lifecycle events that allow component authors to hook into just about every stage of a component's lifecycle - from \nconstruct\nion to \ndestruct\nion hitting \ninit\n, \nrender\n, \nunrender\n, \nteardown\n, \ncomplete\n (\nrender\n complete along with any transitions) and a few others in between. Each lifecycle event also happens to be an instance event.\n\n\nLets add our check to make sure the \nSlideshow\n component receives an \nimage\n parameter. There are a few ways to do this, including using \non\n and providing an \noninit\n function as an initialization parameter.\n\n\nvar ractive = new Ractive({\n  // ...\n  on: {\n    init: function () {}\n  },\n  // ...\n});\n\n// or\n\nvar ractive = new Ractive({\n  // ...\n  oninit: function () {},\n  // ...\n});\n\n// for other lifecycle events, you can attach after init\n\nractive.on( 'render', function () {} );\n\n\n\n\nAdd an \ninit\n event handler that checks to see if there are no images and issues a warning if there are none.\n\n\nStep 6\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nWhen we started out with our slideshow, we were rendering it directly to a target element rather than as a component in another Ractive.js instance. It turns out that having self-contained components like that is a pretty convenient pattern for managing complexity in a larger app. All of the related functionality for a feature or group of features can be grouped into one Ractive.js extension known as a \nview\n. Each individual view can then be loaded and/or rendered independently.\n\n\nIn order do use views with a main instance controlling the overall app, you would have to have some sort of big \n#if\n/\nelse\n block with each view included as a branch. You could also resort to some sort of partial generation scheme. There's an easier way though.\n\n\nRactive.js will allow you to attach one independent instance to another using \nattachChild\n, optionally specifying a \ntarget\n. If you don't specify a target, then the child instance will not be rendered, but if you \ndo\n specify a target, then the instance will be rendered into the first available matching \nanchor\n. An anchor looks like a component or element, but its name always starts with a \n#\n. You may have as many anchors as you like, and they may each have the same or different names.\n\n\n#anchor /\n\n\n#ICallThisOneStan\n\n  Stan has a content partial.\n  {{#partial name}}He also has a name partial.{{/partial}}\n\n/ICallThisOneStan\n\n\n\n\n\nGo ahead and fill out the two provided views as you like, add anchors to the main instance template, and attach an instance of each view to an anchor on the main instance.\n\n\n\n\nYou can detach a child using the conveniently named \ndetachChild\n method.\n\n\nChild instances can be attached in \nprepend\n, \ninsertAt\n, or \nappend\n (the default) mode. Ractive.js will try to find a matching anchor for each child starting with the first. If there aren't enough anchors, some instances will not be rendered. Each time a child is attached or detached, Ractive.js will adjust any affected anchors so all instances that can be rendered are rendered.\n\n\nEach anchor has its own list of children associated with it, which is what the attachment modes are referreing to - \nprepend\n will insert a child at the front, \nappend\n at the end, and \ninsertAt\n at the specified index. The list of children for a particular anchor, say \n#main /\n, os kept up to date in an observable way so that you can automatically generate anchors as components are attached using \n{{#each @.children.byName.main}}\n#main /\n{{/each}}\n.\n\n\nAn anchored attached child is effectively a component that the host instance doesn't control.", 
            "title": "Components"
        }, 
        {
            "location": "/get-started/tutorials/components/#components", 
            "text": "If you've used Backbone Views in the past, you'll be familiar with the basic concept of  extending  the  base class  to create a new  subclass  with default data and additional methods.", 
            "title": "Components"
        }, 
        {
            "location": "/get-started/tutorials/components/#step-1", 
            "text": "Start \n   Fix Code   In this tutorial we're first going to learn about Ractive.extend and use it to create an image slideshow, using gifs from  devopsreactions.tumblr.com .  We've got our basic template set up \u2013 we just need to make a few additions. First, we need to add a mustache for the image URL:  div class='main-image'\n     style='background-image: url( {{image.src}} );'  /div   We're using a CSS background rather than an  img  element for this example, because you can use the  background-size: contain  CSS rule to ensure that the image is shown at maximum size without distorting the aspect ratio.  Then, we need to add a mustache for the image caption:  div class='caption' \n   p {{image.caption}} /p  /div   Finally, let's add some event expressions that we can fill in later:  a class='prev' on-click='@.goto(current - 1)' span laquo; /span /a  !-- ... --  a class='next' on-click='@.goto(current + 1)' span raquo; /span /a   Execute the JavaScript to redraw the view, with the placeholder data that's already there.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/components/#step-2", 
            "text": "Start \n   Fix Code   Time to create our  Slideshow  class:  var Slideshow = Ractive.extend({\n  // this will be applied to all Slideshow instances\n  template: '#slideshow',\n\n  // method for changing the currently displayed image\n  goto: function ( imageNum ) {\n    // goto method goes here...\n  },\n\n  // default data\n  oninit: function () {\n    // return the default data for the component here\n  }\n});  Each  Slideshow  instance will have a  goto  method in addition to the normal  Ractive  instance methods. We'll also provide default data for the component, notably to start with the  current  index as  0 .   When providing data for components, you should always use a data function that returns a data dictionary. If you return the same object from each invocation, then all of your component instances will share the same underlying data, but the properties won't necessarily be kept up-to-date across instances.  Component data and instance data is combined into the final instance's data dictionary starting with Ractive default data, moving through the component hierarchy, and ending with the data supplied to the instance constructor.   Let's write our  goto  method:  function ( index ) {\n  var images = this.get( 'images' );\n\n  // handle wrap around\n  var num = ( index + images.length ) % images.length;\n\n  this.set( 'current', num );\n}  Let's add some code to instantiate the slideshow with our gifs. There's a ready-made images variable you can use for this step:  var slideshow = new Slideshow({\n  target: '#target',\n  data: { images: images }\n});  Go ahead and execute the code \u2013 you should now have a working slideshow.   Needless to say, you could add as many bells and whistles as you wanted \u2013 fading or sliding transitions, image preloading, thumbnails, touchscreen gesture controls, and so on.  You could, of course, just use an existing image slideshow library. But then you would have to learn that library, and potentially submit to its design philosophy.  Ractive.js is all about flexibility. If you want to change the design or behaviour of a component (say, adding a class name to a particular element), the power to do so is in your hands \u2013 the template is easy to understand and tweak because it's basically just HTML, and the view logic is straightforward.  It's better to be able to build your own solution than to rely on developers maintaining high quality and up-to-date documentation.", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/components/#step-3", 
            "text": "Start \n   Fix Code   Now we have our lovely slideshow component, but suppose we want to use it in our Ractive.js app rather than mounting it directly on an element. It turns out that that is a pretty simple thing to accomplish. We can register our component with either globally or with our main Ractive.js instance, and anywhere that the template has a  slideshow /  element, Ractive.js will create an instance of  Slideshow  and mount it inline.  Ractive.components.slideshow = Slideshow;\n\n// or\nvar ractive = new Ractive({\n    // ...\n\n  components: {\n    slideshow: Slideshow\n  },\n\n  // ...\n});  Now in the template, we just reference the component as if it were a custom element:  div style-height= 40vh \n   slideshow /  /div   We  were  passing the list of pictures to the instance as it was being initialized, but since Ractive.js is now managing the instance, how do we get the list of pictures to the component instance? Well, we create a mapping from the data in the host instance to the  images  keypath in the component by using an attribute:  div style-height= 40vh \n   slideshow images= {{devopsImages}}  /  /div   Update the code with another images array and put two  slideshow  components in the main instance.   Mappings are automatically managed cross-instance  link s. A link is a bit like a filesystem symlink in that the data isn't copied anywhere - it just gets a new path that points to it. Changing the data in either place is effectively the same as changing it everywhere at once.", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/components/#step-4", 
            "text": "Start \n   Fix Code   We have our image slideshow usable from any app now, but what if we wanted to make it slightly more customizable? Perhaps we could allow the user to have a bit more control over the template by, say, letting them include some sort of disclaimer on all of the slides. We could hard-code the disclaimer in a special version for each client, but that sounds like it would be awful to maintain.  Fortunately, Ractive.js allows you to use the content of a component tag to pass partials to the component instance. Any content not within a  {{#patial}}  tag is collected up and exposed to the component as a partial named  content . Any  {{#partial}} s are supplied to the component instance with the names they are given in the  {{#partial}}  tag. We'll use a disclaimer partial for our component:  slideshow \n  {{#partial disclaimer}} div class= disclaimer I don't know what we're disclaiming, but we're disclaiming it  a on-click= @.disclaim(), false  href= # here /a . /div {{/partial}} /slideshow   We can add a reference to the partial in the  Slideshow  component template:  {{ disclaimer}}   It's not a bad idea to supply a default partial with the component, so that Ractive.js doesn't emit any warnings about missing partials. Any partials passed to the component will override any supplied to  extend .   Now what will happen when you click the \"here\" link? Partials exist completely in the context of the instance in which they are used, and there is no  disclaim  method on the  Slideshow  component, so nothing will happen (except an error will be logged to the console). If you want a passed-in partial to render in the context from which it was passed, you can  {{yield}}  it.  {{yield disclaimer}}  Add a  disclaim  method to the main instance, update the  Slideshow  component, and run the code to see it all in action.   Since  yield  puts the partial in the context of the caller, there's not much point in using it within an  #each  block because the array being iterated is unreachable from the  yield .  yield s can also supply aliases to data local to the component e.g.  {{yield disclaimer with current as currentImage}} .  yield ing the  content  partial just requires dropping the name.", 
            "title": "Step 4"
        }, 
        {
            "location": "/get-started/tutorials/components/#step-5", 
            "text": "Start \n   Fix Code   Now suppose we wanted to do something to each of our component instances as they're created, like validate that they have certain parameters provided and issue a warning if they don't. Ractive.js components actually have a pretty complete set of lifecycle events that allow component authors to hook into just about every stage of a component's lifecycle - from  construct ion to  destruct ion hitting  init ,  render ,  unrender ,  teardown ,  complete  ( render  complete along with any transitions) and a few others in between. Each lifecycle event also happens to be an instance event.  Lets add our check to make sure the  Slideshow  component receives an  image  parameter. There are a few ways to do this, including using  on  and providing an  oninit  function as an initialization parameter.  var ractive = new Ractive({\n  // ...\n  on: {\n    init: function () {}\n  },\n  // ...\n});\n\n// or\n\nvar ractive = new Ractive({\n  // ...\n  oninit: function () {},\n  // ...\n});\n\n// for other lifecycle events, you can attach after init\n\nractive.on( 'render', function () {} );  Add an  init  event handler that checks to see if there are no images and issues a warning if there are none.", 
            "title": "Step 5"
        }, 
        {
            "location": "/get-started/tutorials/components/#step-6", 
            "text": "Start \n   Fix Code   When we started out with our slideshow, we were rendering it directly to a target element rather than as a component in another Ractive.js instance. It turns out that having self-contained components like that is a pretty convenient pattern for managing complexity in a larger app. All of the related functionality for a feature or group of features can be grouped into one Ractive.js extension known as a  view . Each individual view can then be loaded and/or rendered independently.  In order do use views with a main instance controlling the overall app, you would have to have some sort of big  #if / else  block with each view included as a branch. You could also resort to some sort of partial generation scheme. There's an easier way though.  Ractive.js will allow you to attach one independent instance to another using  attachChild , optionally specifying a  target . If you don't specify a target, then the child instance will not be rendered, but if you  do  specify a target, then the instance will be rendered into the first available matching  anchor . An anchor looks like a component or element, but its name always starts with a  # . You may have as many anchors as you like, and they may each have the same or different names.  #anchor /  #ICallThisOneStan \n  Stan has a content partial.\n  {{#partial name}}He also has a name partial.{{/partial}} /ICallThisOneStan   Go ahead and fill out the two provided views as you like, add anchors to the main instance template, and attach an instance of each view to an anchor on the main instance.   You can detach a child using the conveniently named  detachChild  method.  Child instances can be attached in  prepend ,  insertAt , or  append  (the default) mode. Ractive.js will try to find a matching anchor for each child starting with the first. If there aren't enough anchors, some instances will not be rendered. Each time a child is attached or detached, Ractive.js will adjust any affected anchors so all instances that can be rendered are rendered.  Each anchor has its own list of children associated with it, which is what the attachment modes are referreing to -  prepend  will insert a child at the front,  append  at the end, and  insertAt  at the specified index. The list of children for a particular anchor, say  #main / , os kept up to date in an observable way so that you can automatically generate anchors as components are attached using  {{#each @.children.byName.main}} #main / {{/each}} .  An anchored attached child is effectively a component that the host instance doesn't control.", 
            "title": "Step 6"
        }, 
        {
            "location": "/get-started/tutorials/animation/", 
            "text": "Animation\n\n\nAnimation can play an important role in communicating changing states of your webapp. In this tutorial we'll learn about using \nractive.animate()\n.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nHere, we've got a bar chart showing average temperatures throughout the year. We want there to be a smooth transition when the user changes the city using the dropdown menu.\n\n\nFind the code that changes the data in the bar chart when the user makes a selection from the dropdown. Change \nthis.set\n to \nthis.animate\n...\n\n\n...and that's it! We now have a smooth transition between cities \u2013 not just the bar height, but the labels and colours as well.\n\n\n\n\nRactive.js is efficient about how it handles animations. Even though there are a total of 72 properties being animated each time (height, colour and label text for two bars for each of twelve months), there is a single animation loop which uses \nrequestAnimationFrame\n where possible, and which runs as long as there are one or more sets of animations in progress.\n\n\nIf a second animation on a keypath were to start before the first had completed, the first would be cancelled.\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nThat's good, but it looks a bit... robotic. That's because the animation is following a linear path. We can make the whole thing look much slicker with an \neasing function\n. Find the existing animation code and update it:\n\n\nthis.animate( 'selectedCity', cities[ index ], {\n  easing: 'easeOut'\n});\n\n\n\n\nExecute this code, then try changing the city via the drop-down.\n\n\n\n\nRactive.js has four easing functions built in \u2013 \nlinear\n (the default), \neaseIn\n, \neaseOut\n and \neaseInOut\n. I personally find \neaseOut\n and \neaseInOut\n meet 95% of my needs.\n\n\nHowever you can add more easing functions to \nRactive.easing\n, and they will become globally available. Here's an elastic easing function, for example:\n\n\nRactive.easing.elastic = function( pos ) {\n  return -1 * Math.pow(4,-8*pos) * Math.sin((pos*6-1)*(2*Math.PI)/2) + 1;\n};\n\n\n\nThis was taken from \ndanro's easing.js\n, which contains just about every easing function you could imagine. Or you could create your own \u2013 all it is is a function that takes an x value between 0 (animation start) and 1 (animation end) and returns a y value (usually between 0 and 1, but sometimes just outside as in the \nelastic\n example).\n\n\nAs an alternative to making easing functions globally available, you can pass a function in as the \neasing\n parameter rather than a string.\n\n\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nAlongside \neasing\n, there are several other options you can pass in when creating an animation:\n\n\nthis.animate( 'selectedCity', cities[ index ], {\n  easing: 'easeOut',\n  duration: 300, // in milliseconds - default 400\n  step: function ( t, value ) {\n    // function that will be called immediately after\n    // each step of the animation loop.\n    //\n    // `t` is a value between 0 (start) and 1 (end),\n    // as determined by the easing function.\n    //\n    // `value` is the intermediate value\n  }\n}).then( function () {\n  // .animate() returns a promise that fulfils\n  // when the animation completes\n});\n\n\n\n\nTry using \nractive.animate()\n to cycle the bar chart through a loop \u2013 each city's data is displayed for a couple of seconds before transitioning to the next one. To make it simple, the \nselect\n has been removed. If you get stuck, use the 'Fix Code' button to see one possible solution.\n\n\n\n\nYou can animate between numerical properties, and arrays or objects that contain numerical properties (nested however deep \u2013 though be aware that Ractive.js doesn't check for cyclical data structures which will cause infinite loops!).\n\n\nStrings, such as the city's \nname\n in this example, are ignored, or rather set immediately on the first animation tick. (Future versions may include clever string interpolators \u00e0 la \nD3\n.)", 
            "title": "Animations"
        }, 
        {
            "location": "/get-started/tutorials/animation/#animation", 
            "text": "Animation can play an important role in communicating changing states of your webapp. In this tutorial we'll learn about using  ractive.animate() .", 
            "title": "Animation"
        }, 
        {
            "location": "/get-started/tutorials/animation/#step-1", 
            "text": "Start \n   Fix Code   Here, we've got a bar chart showing average temperatures throughout the year. We want there to be a smooth transition when the user changes the city using the dropdown menu.  Find the code that changes the data in the bar chart when the user makes a selection from the dropdown. Change  this.set  to  this.animate ...  ...and that's it! We now have a smooth transition between cities \u2013 not just the bar height, but the labels and colours as well.   Ractive.js is efficient about how it handles animations. Even though there are a total of 72 properties being animated each time (height, colour and label text for two bars for each of twelve months), there is a single animation loop which uses  requestAnimationFrame  where possible, and which runs as long as there are one or more sets of animations in progress.  If a second animation on a keypath were to start before the first had completed, the first would be cancelled.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/animation/#step-2", 
            "text": "Start \n   Fix Code   That's good, but it looks a bit... robotic. That's because the animation is following a linear path. We can make the whole thing look much slicker with an  easing function . Find the existing animation code and update it:  this.animate( 'selectedCity', cities[ index ], {\n  easing: 'easeOut'\n});  Execute this code, then try changing the city via the drop-down.   Ractive.js has four easing functions built in \u2013  linear  (the default),  easeIn ,  easeOut  and  easeInOut . I personally find  easeOut  and  easeInOut  meet 95% of my needs.  However you can add more easing functions to  Ractive.easing , and they will become globally available. Here's an elastic easing function, for example:  Ractive.easing.elastic = function( pos ) {\n  return -1 * Math.pow(4,-8*pos) * Math.sin((pos*6-1)*(2*Math.PI)/2) + 1;\n};  This was taken from  danro's easing.js , which contains just about every easing function you could imagine. Or you could create your own \u2013 all it is is a function that takes an x value between 0 (animation start) and 1 (animation end) and returns a y value (usually between 0 and 1, but sometimes just outside as in the  elastic  example).  As an alternative to making easing functions globally available, you can pass a function in as the  easing  parameter rather than a string.", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/animation/#step-3", 
            "text": "Start \n   Fix Code   Alongside  easing , there are several other options you can pass in when creating an animation:  this.animate( 'selectedCity', cities[ index ], {\n  easing: 'easeOut',\n  duration: 300, // in milliseconds - default 400\n  step: function ( t, value ) {\n    // function that will be called immediately after\n    // each step of the animation loop.\n    //\n    // `t` is a value between 0 (start) and 1 (end),\n    // as determined by the easing function.\n    //\n    // `value` is the intermediate value\n  }\n}).then( function () {\n  // .animate() returns a promise that fulfils\n  // when the animation completes\n});  Try using  ractive.animate()  to cycle the bar chart through a loop \u2013 each city's data is displayed for a couple of seconds before transitioning to the next one. To make it simple, the  select  has been removed. If you get stuck, use the 'Fix Code' button to see one possible solution.   You can animate between numerical properties, and arrays or objects that contain numerical properties (nested however deep \u2013 though be aware that Ractive.js doesn't check for cyclical data structures which will cause infinite loops!).  Strings, such as the city's  name  in this example, are ignored, or rather set immediately on the first animation tick. (Future versions may include clever string interpolators \u00e0 la  D3 .)", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/svg/", 
            "text": "SVG\n\n\nRactive.js works with SVG just as easily as with HTML. This makes it possible to create data-driven graphics using the same declarative structure as we use with the rest of the web.\n\n\nStep 1\n\n\n\n    \nStart\n\n\n\n\nIn the template, we've got some hard-coded values. Let's replace them with mustaches:\n\n\n!-- the rectangle --\n\n\nrect width='{{width}}' height='{{height}}'/\n\n\n\n\n\nWe can use expressions to replace the other hard-coded values:\n\n\n!-- the area of the rectangle --\n\n\ntext class='area' x='{{ width / 2 }}' y='{{ height / 2 }}'\n\n  {{ Math.round( width * height ) }} px\u00b2\n\n/text\n\n\n\n\n\nNote that we're using \nMath.round()\n to make the end result cleaner.\n\n\nApply similar changes to the labels, then add some data:\n\n\nvar ractive = new Ractive({\n  el: output,\n  template: template,\n  data: { width: 100, height: 100 }\n});\n``\n\nExecute this code. Now we can have some fun:\n\n```js\nvar ractive.animate({ width: 300, height: 200 }, {\n  easing: 'easeOut',\n  duration: 800\n});\n\n\n\n\n\n\nSVG is a big topic; bigger than can be accommodated here. It's well worth learning how to use it though. Unfortunately, the web is littered with bad SVG tutorials, but once you get your head round the basics it all makes a lot of sense.\n\n\nSince you're a better (and more charismatic) developer than most, I predict you'll pick it up easily.\n\n\n\n\nStep 2\n\n\n\n    \nStart\n\n\n\n\nIn this example, we're using the same data as in the previous tutorial to draw a combination area range and line chart. It's more of a demo than a lesson.\n\n\nThere are some points worth noting here. Firstly, we're mixing HTML and SVG together in the same ractive - the two languages are treated as equals.\n\n\nSecondly, we haven't had to write a \nrender\n or \nupdate\n function \u2013 our intentions are expressed \ndeclaratively\n. There's some custom logic to create the shape of the temperature band polygon, for example, but we don't need to specify when that logic should be invoked \u2013 the system simply reacts to new data and internal changes in state. The temperature labels don't need an event handler to tell them when to switch from \u00b0C to \u00b0F.\n\n\nThirdly, because this is based on a template, it's much easier to understand and extend than we've come to expect data visualisations to be. Ordinarily, you'd have to maintain a complex mental model of the \nflow\n of your application in order to understand which bits of code affected the result in which ways \u2013 here, the link between code and result is much more obvious.\n\n\nStep 3\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nSince SVG gets along with the regular DOM pretty well, you can also interact with stuff \ninside\n an SVG just like you would with HTML. Using our simple square example from above, add a click event handler to the rectangle that makes it toggle back and forth between 100px sides and 140px by 160px sides.\n\n\nrect on-click=\n@.animate('width', 140, { easing: 'easeOut' })\n /\n\n\n\n\n\nIf you like, you can add separate \nanimate\n calls for width and height with different easings. Then your square will rectangle in an elastic-y way.", 
            "title": "SVG"
        }, 
        {
            "location": "/get-started/tutorials/svg/#svg", 
            "text": "Ractive.js works with SVG just as easily as with HTML. This makes it possible to create data-driven graphics using the same declarative structure as we use with the rest of the web.", 
            "title": "SVG"
        }, 
        {
            "location": "/get-started/tutorials/svg/#step-1", 
            "text": "Start   In the template, we've got some hard-coded values. Let's replace them with mustaches:  !-- the rectangle --  rect width='{{width}}' height='{{height}}'/   We can use expressions to replace the other hard-coded values:  !-- the area of the rectangle --  text class='area' x='{{ width / 2 }}' y='{{ height / 2 }}' \n  {{ Math.round( width * height ) }} px\u00b2 /text   Note that we're using  Math.round()  to make the end result cleaner.  Apply similar changes to the labels, then add some data:  var ractive = new Ractive({\n  el: output,\n  template: template,\n  data: { width: 100, height: 100 }\n});\n``\n\nExecute this code. Now we can have some fun:\n\n```js\nvar ractive.animate({ width: 300, height: 200 }, {\n  easing: 'easeOut',\n  duration: 800\n});   SVG is a big topic; bigger than can be accommodated here. It's well worth learning how to use it though. Unfortunately, the web is littered with bad SVG tutorials, but once you get your head round the basics it all makes a lot of sense.  Since you're a better (and more charismatic) developer than most, I predict you'll pick it up easily.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/svg/#step-2", 
            "text": "Start   In this example, we're using the same data as in the previous tutorial to draw a combination area range and line chart. It's more of a demo than a lesson.  There are some points worth noting here. Firstly, we're mixing HTML and SVG together in the same ractive - the two languages are treated as equals.  Secondly, we haven't had to write a  render  or  update  function \u2013 our intentions are expressed  declaratively . There's some custom logic to create the shape of the temperature band polygon, for example, but we don't need to specify when that logic should be invoked \u2013 the system simply reacts to new data and internal changes in state. The temperature labels don't need an event handler to tell them when to switch from \u00b0C to \u00b0F.  Thirdly, because this is based on a template, it's much easier to understand and extend than we've come to expect data visualisations to be. Ordinarily, you'd have to maintain a complex mental model of the  flow  of your application in order to understand which bits of code affected the result in which ways \u2013 here, the link between code and result is much more obvious.", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/svg/#step-3", 
            "text": "Start \n     Fix Code   Since SVG gets along with the regular DOM pretty well, you can also interact with stuff  inside  an SVG just like you would with HTML. Using our simple square example from above, add a click event handler to the rectangle that makes it toggle back and forth between 100px sides and 140px by 160px sides.  rect on-click= @.animate('width', 140, { easing: 'easeOut' })  /   If you like, you can add separate  animate  calls for width and height with different easings. Then your square will rectangle in an elastic-y way.", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/transitions/", 
            "text": "Transitions\n\n\nNormally, when an element is rendered, it just sort of gets plonked on the page. With Ractive you have more control.\n\n\nStep 1\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\n\nYou can specify intro transitions:\n\n\ndiv fade-in\n\n  This div will fade into view\n\n/div\n\n\n\n\n\nTry adding intros to the three buttons in the template, choosing from \nfade\n, \nslide\n and \nfly\n, which have been included on this page.\n\n\n\n\nAs with custom events, transitions are distributed as plugins, \nwhich you can download here\n to use in your project. You can \ncreate your own transitions\n.\n\n\nWhere possible, Ractive uses CSS transitions, but in older browsers it will fall back to timer-based animation.\n\n\n\n\nStep 2\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nSimilarly, we can specify outro transitions. When an element is no longer needed on the page, it will exit gracefully.\n\n\nTry adding outro transitions to the three buttons;\n\n\nbutton fade-in fly-out on-click='[\nshow\n, 2]'\n\n  Click me!\n\n/button\n\n\n\n\n\nExecute the code. Aaargh! It looks horrible!\n\n\nThat's because new elements are being rendered before the old ones get removed from the DOM. What we need to do is \nchain\n the transitions \u2013 trigger the removal, wait, and then trigger rendering of the new element.\n\n\nCalling \nractive.set()\n returns a \nPromise\n, which resolves on completion of any transitions that are caused by the change. So you can do this:\n\n\nractive.on({\n  show: function ( event, which ) {\n    ractive.set( 'visible', null ).then( function () {\n      ractive.set( 'visible', which );\n    });\n  }\n});\n\n\n\n\n\n\nSeveral methods return a promise, not just \nractive.set()\n \u2013 \nractive.update()\n, \nractive.teardown()\n, \nractive.render()\n, and all of the array methods such as \nractive.push()\n.\n\n\n\n\nStep 3\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nYou can pass in parameters to add fine-grained control over transitions:\n\n\nbutton intro='fade:{duration:2000}'\n        outro='fly'\n        on-tap='show:2'\n\n  Click me!\n\n/button\n\n\n\n\n\nThe transition function will receive an argument corresponding to these parameters. In this case, the default \nduration\n property will be overridden, so the \nfade\n transition will take 2000 milliseconds (more popularly known as '2 seconds').\n\n\nBy convention, if you pass in a number, it will be treated as the duration property:\n\n\nbutton fade-in=\n2000\n\n        fly-out\n        on-click=\n['show', 2]\n\n  Click me!\n\n/button\n\n\n\n\n\nIn place of a number, you can use \nfast\n (200 milliseconds) or \nslow\n (600 milliseconds), just like jQuery.\n\n\nThe parameters available to you depend on the transition. Visit the \nplugins page\n to see which transitions are available or \ncreate your own\n.", 
            "title": "Transitions"
        }, 
        {
            "location": "/get-started/tutorials/transitions/#transitions", 
            "text": "Normally, when an element is rendered, it just sort of gets plonked on the page. With Ractive you have more control.", 
            "title": "Transitions"
        }, 
        {
            "location": "/get-started/tutorials/transitions/#step-1", 
            "text": "Start \n     Fix Code   You can specify intro transitions:  div fade-in \n  This div will fade into view /div   Try adding intros to the three buttons in the template, choosing from  fade ,  slide  and  fly , which have been included on this page.   As with custom events, transitions are distributed as plugins,  which you can download here  to use in your project. You can  create your own transitions .  Where possible, Ractive uses CSS transitions, but in older browsers it will fall back to timer-based animation.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/transitions/#step-2", 
            "text": "Start \n     Fix Code   Similarly, we can specify outro transitions. When an element is no longer needed on the page, it will exit gracefully.  Try adding outro transitions to the three buttons;  button fade-in fly-out on-click='[ show , 2]' \n  Click me! /button   Execute the code. Aaargh! It looks horrible!  That's because new elements are being rendered before the old ones get removed from the DOM. What we need to do is  chain  the transitions \u2013 trigger the removal, wait, and then trigger rendering of the new element.  Calling  ractive.set()  returns a  Promise , which resolves on completion of any transitions that are caused by the change. So you can do this:  ractive.on({\n  show: function ( event, which ) {\n    ractive.set( 'visible', null ).then( function () {\n      ractive.set( 'visible', which );\n    });\n  }\n});   Several methods return a promise, not just  ractive.set()  \u2013  ractive.update() ,  ractive.teardown() ,  ractive.render() , and all of the array methods such as  ractive.push() .", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/tutorials/transitions/#step-3", 
            "text": "Start \n     Fix Code   You can pass in parameters to add fine-grained control over transitions:  button intro='fade:{duration:2000}'\n        outro='fly'\n        on-tap='show:2' \n  Click me! /button   The transition function will receive an argument corresponding to these parameters. In this case, the default  duration  property will be overridden, so the  fade  transition will take 2000 milliseconds (more popularly known as '2 seconds').  By convention, if you pass in a number, it will be treated as the duration property:  button fade-in= 2000 \n        fly-out\n        on-click= ['show', 2] \n  Click me! /button   In place of a number, you can use  fast  (200 milliseconds) or  slow  (600 milliseconds), just like jQuery.  The parameters available to you depend on the transition. Visit the  plugins page  to see which transitions are available or  create your own .", 
            "title": "Step 3"
        }, 
        {
            "location": "/get-started/tutorials/decorators/", 
            "text": "Decorators\n\n\nIf you've worked through the tutorials in order to this point, you may have wondered if there's some sort of hook to let you modify an element as it's created. Well, wonder no more!\n\n\nDecorators are plugins, somewhat like custom events and transitions, that are attached to individual elements using a decorator directive. A decorator typically adds some sort of behavior to an element - makes it act like something - the decorator directive begins with \nas-\n and the decorator name.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nStarting with something simple, let's make a decorator that tracks certain nodes to which we want a direct reference. First, here's what a decorator looks like:\n\n\nfunction tracked ( node, ...args ) {\n  // do stuff with node\n  // `this` is the Ractive instance\n\n  // return a control handle\n  return {\n    // called when decorator args change\n    function update () {},\n\n    // undo stuff with node\n    function teardown () {}\n  }\n}\n\n\n\n\nThere's not a \nwhole lot\n going on there. When the decorator is called, it can do whatever it needs to with the node and return a control handle that lets Ractive tell it when arguments change or tear it down when the node is being unrendered. All we need to do is take an \nid\n argument, create a \nnodes\n hash on the Ractive instance if there's not already once there, and store the \nnode\n at the given \nid\n. Fill in the missing code and then add decorator directive to the second \ndiv\n.\n\n\ndiv as-tracked=\n'special-div'\nI am the special div.\n/div\n\n\n\n\n\nThen throw a manual style setting at the end of the script just to show everything worked:\n\n\nractive.node['special-div'].style.color = 'blue';\n\n\n\n\nWhile that example is a bit contrived, you can probably see the benefit of using decorators when integrating with third party libraries that focus on adding functionality to a single node, like CodeMirror and Ace editor - in fact, the editors in the playground are handled by an Ace editor decorator.\n\n\nStep 2\n\n\n// TODO: formatting decorator", 
            "title": "Decorators"
        }, 
        {
            "location": "/get-started/tutorials/decorators/#decorators", 
            "text": "If you've worked through the tutorials in order to this point, you may have wondered if there's some sort of hook to let you modify an element as it's created. Well, wonder no more!  Decorators are plugins, somewhat like custom events and transitions, that are attached to individual elements using a decorator directive. A decorator typically adds some sort of behavior to an element - makes it act like something - the decorator directive begins with  as-  and the decorator name.", 
            "title": "Decorators"
        }, 
        {
            "location": "/get-started/tutorials/decorators/#step-1", 
            "text": "Start \n   Fix Code   Starting with something simple, let's make a decorator that tracks certain nodes to which we want a direct reference. First, here's what a decorator looks like:  function tracked ( node, ...args ) {\n  // do stuff with node\n  // `this` is the Ractive instance\n\n  // return a control handle\n  return {\n    // called when decorator args change\n    function update () {},\n\n    // undo stuff with node\n    function teardown () {}\n  }\n}  There's not a  whole lot  going on there. When the decorator is called, it can do whatever it needs to with the node and return a control handle that lets Ractive tell it when arguments change or tear it down when the node is being unrendered. All we need to do is take an  id  argument, create a  nodes  hash on the Ractive instance if there's not already once there, and store the  node  at the given  id . Fill in the missing code and then add decorator directive to the second  div .  div as-tracked= 'special-div' I am the special div. /div   Then throw a manual style setting at the end of the script just to show everything worked:  ractive.node['special-div'].style.color = 'blue';  While that example is a bit contrived, you can probably see the benefit of using decorators when integrating with third party libraries that focus on adding functionality to a single node, like CodeMirror and Ace editor - in fact, the editors in the playground are handled by an Ace editor decorator.", 
            "title": "Step 1"
        }, 
        {
            "location": "/get-started/tutorials/decorators/#step-2", 
            "text": "// TODO: formatting decorator", 
            "title": "Step 2"
        }, 
        {
            "location": "/get-started/support/", 
            "text": "Support\n\n\nGetting in touch\n\n\nThere are a lot of places to find help if you get stuck with Ractive:\n\n\n\n\nStackOverflow\n\n\nGoogle Groups\n\n\nGitHub\n\n\nTwitter\n\n\nGitter\n\n\n\n\nLegacy versions\n\n\nThe current site only documents the latest version of Ractive. Legacy versions are \ncurrently stored in Github\n.\n\n\nLegacy browsers\n\n\nThe core Ractive library requires the following APIs need to be present:\n\n\n\n\nArray.isArray\n\n\nArray.prototype.every\n\n\nArray.prototype.filter\n\n\nArray.prototype.forEach\n\n\nArray.prototype.indexOf\n\n\nArray.prototype.map\n\n\nArray.prototype.reduce\n\n\nDate.now\n\n\nFunction.prototype.bind\n\n\nNode.prototype.contains\n\n\nObject.create\n\n\nObject.defineProperty\n\n\nObject.freeze\n\n\nObject.keys\n\n\nPromise\n\n\nrequestAnimationFrame\n\n\nString.prototype.trim\n\n\nwindow.addEventListener\n\n\nwindow.getComputedStyle\n\n\n\n\nMost \nmodern\n browsers already support these APIs\n. Should you want to serve your app on older browsers, Ractive comes with an optional file called \npolyfills.js\n containing these specific polyfills. That way, you can still enjoy the full Ractive experience without lugging in a huge polyfill library. Simply load it up before Ractive.\n\n\nSVGs\n\n\nRactive doesn't mind whether you're rendering HTML or SVG - it treats both the same way. Unfortunately, some browsers (notably IE8 and below, and Android 2.3 and below) \ndo\n care.\n\n\n\n\nThis browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See https://github.com/RactiveJS/Ractive/wiki/SVG-and-older-browsers for more information\n\n\n\n\nIf your template includes SVG and these browsers throw an error along those lines, \nthe only winning move is not to play\n. You will need to provide an alternate fallback when SVG isn't supported. Ractive provides \nRactive.svg\n to indicate if the browser handles SVGs properly.\n\n\nnew Ractive({\n  el: 'container',\n  template: Ractive.svg ? awesomeVectorGraphicsContent : highResolutionImageContent\n});", 
            "title": "Support"
        }, 
        {
            "location": "/get-started/support/#support", 
            "text": "", 
            "title": "Support"
        }, 
        {
            "location": "/get-started/support/#getting-in-touch", 
            "text": "There are a lot of places to find help if you get stuck with Ractive:   StackOverflow  Google Groups  GitHub  Twitter  Gitter", 
            "title": "Getting in touch"
        }, 
        {
            "location": "/get-started/support/#legacy-versions", 
            "text": "The current site only documents the latest version of Ractive. Legacy versions are  currently stored in Github .", 
            "title": "Legacy versions"
        }, 
        {
            "location": "/get-started/support/#legacy-browsers", 
            "text": "The core Ractive library requires the following APIs need to be present:   Array.isArray  Array.prototype.every  Array.prototype.filter  Array.prototype.forEach  Array.prototype.indexOf  Array.prototype.map  Array.prototype.reduce  Date.now  Function.prototype.bind  Node.prototype.contains  Object.create  Object.defineProperty  Object.freeze  Object.keys  Promise  requestAnimationFrame  String.prototype.trim  window.addEventListener  window.getComputedStyle   Most  modern  browsers already support these APIs . Should you want to serve your app on older browsers, Ractive comes with an optional file called  polyfills.js  containing these specific polyfills. That way, you can still enjoy the full Ractive experience without lugging in a huge polyfill library. Simply load it up before Ractive.", 
            "title": "Legacy browsers"
        }, 
        {
            "location": "/get-started/support/#svgs", 
            "text": "Ractive doesn't mind whether you're rendering HTML or SVG - it treats both the same way. Unfortunately, some browsers (notably IE8 and below, and Android 2.3 and below)  do  care.   This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See https://github.com/RactiveJS/Ractive/wiki/SVG-and-older-browsers for more information   If your template includes SVG and these browsers throw an error along those lines,  the only winning move is not to play . You will need to provide an alternate fallback when SVG isn't supported. Ractive provides  Ractive.svg  to indicate if the browser handles SVGs properly.  new Ractive({\n  el: 'container',\n  template: Ractive.svg ? awesomeVectorGraphicsContent : highResolutionImageContent\n});", 
            "title": "SVGs"
        }, 
        {
            "location": "/get-started/migrating/", 
            "text": "Migrating from previous versions\n\n\nThese are notes to help you migrate from an older version of Ractive.js to a newer one, mostly centered on breaking changes between versions. If you'd like to find out more about new features, you can check out the \nchangelog\n.\n\n\n0.8 to 0.9\n\n\nRemoved deprecations\n\n\n0.9 removes any of the remaining deprecations from 0.8, including:\n\n\n\n\ndecorator=\"name:{{arg1}},{{arg2}}\n directives, to be replaced with \nas-name=\"arg1, arg2\"\n\n\nintro=\"name:{{ { arg1: arg1, arg2, arg2 } }}\"\n and the same forms of \noutro\n and \nintro-outro\n to be replaced with \nname-in=\"{ arg1, arg2 }\"\n and the same forms of \nname-out\n and \nname-in-out\n\n\nThe \nractive.data\n getter, to be replaced with \nractive.get()\n, which returns a computed object tree containing virtual keys like mappings, links, and computations. The optional form \nractive.get({ virtual: false })\n will return the raw root object without any virtual keys.\n\n\nLifecycle methods \ninit\n and \nbeforeInit\n, to be replaced with lifecycle events or equivalent instance methods. \nbeforeInit\n corresponds to the \nconstruct\n lifecycle event.\n\n\nPartial comments in the form of \n!-- {{\nmyPartial}} --\n...\n!-- {{/myPartial}} --\n, to be replaced with partial blocks \n{{#partial myPartial}}...{{/partial}}\n\n\n\n\nTemplate format\n\n\nThe template format produced by \nRactive.parse\n has changed, making it incompatible with previous versions of Ractive.js and their template formats. You will need to re-parse any pre-parsed templates for use with 0.9.\n\n\nPartial context\n\n\nAny context provided to a partial \n{{\nmy-partial context}}\n is no longer wrapped around the partial but is instead wrapped around the \ncontent\n of the partial. It's a subtle difference that only shows up when the partial name is an expression e.g. \n{{\n.type ~/external.item}}\n. Before this break, the \n.type\n would resolve to \n~/external.item.type\n, and now it will resolve to \n.type\n on the context in which the partial appears.\n\n\nYielding\n\n\nYielding is no longer restricted to inline partials, and each partial may be yielded more than once. You will no longer get a warning if you try to yield an instance or dynamic partial or if you yield the same partial multiple times.\n\n\nnoIntro\n inheritance\n\n\nThe \nnoIntro\n setting of an instance that contains components will now apply to the components too, unless those components have their own \nnoIntro\n setting.\n\n\nPolyfills\n\n\nThere is no longer a \nlegacy\n build of Ractive.js available. Instead, a separate \npolyfills\n library is available that can be included before Ractive.js is loaded, or you can supply your own polyfills, shims, or shams.\n\n\nNode registry\n\n\nElements with an \nid\n attribute are no longer collected into a \nnodes\n map on the Ractive.js instance. If you require similar functionality, it can be achieved in a much more flexible way with a decorator.\n\n\nUnresolved references\n\n\nReferences that don't resolve are no longer kept in an unresolved state, waiting on an appropriate keypath to pop into existence somewhere in the context hierarchy. Instead, references that don't resolve are immediately resolved in the current context, which tends to be the desired behavior in most circumstances.\n\n\nLive queries\n\n\nElement and component queries no longer support automatically keeping the resulting array up to date as new matching elements or components are rendered. If you require similar functionality, it can be achieved with a decorator for elements or bubbled lifecycle events for components.\n\n\nchange\n event\n\n\nThe \nchange\n event has been removed and replaced by recursive observers, which are strictly opt-in and can be scoped to a deeper keypath than the root.\n\n\nevent\n reference\n\n\nThe \nevent\n special reference available to event directives has been deprecated and replaced with three special references:\n\n\n\n\n@context\n, which is roughly equivalent to \nevent\n, but with both an \nevent\n and \noriginal\n key that point to the original event object. This is a \ncontext object\n.\n\n\n@event\n, which is resolves to the original event that triggered the directive.\n\n\n@node\n, which resolves to the element to which the event directive is attached.\n\n\n\n\nractive.merge\n\n\nractive.merge\n has been removed and replaced by an option on \nractive.set\n, \n{ shuffle: true }\n, which more accurately reflects what actually happens. \nmerge\n did not merge data, but instead re-arranged any DOM associated with the elements in the given array to match the order of the array - hence \nshuffle\n rather than \nmerge\n.\n\n\nIsolation\n\n\nComponents are now \nisolated\n by default. If you need non-\nisolated\n components in order to create implicit mappings as data is accessed, you can pass \nisolated: false\n to \nextend\n when creating the component. If you prefer all components to be non-\nisolated\n by default, you can set \nRactive.defaults.isolated = false\n.\n\n\nFurther, non-\nisolated\n components will now create implicit mappings when necessary for \nset\n operations, including \nadd\n, \nsubtract\n, etc, in addition to \nget\n operations. To avoid creating an implicit mapping with a \nset\n operation from a non-\nisolated\n component, pass \n{ isolated: true }\n as an option to the \nset\n method.\n\n\nMagic and array adaptors\n\n\nThe magic and array adaptors are no longer part of Ractive.js core. They may be reappear as independent plugins at some point in the future.\n\n\nclass-\n directives\n\n\nclass-\n directives are now parsed in an expression context like decorator, transition, and event directives, rather than in a string context like attributes and \nstyle-\n directives. This means that mustaches are no longer required for \nclass-\n directive values, so you should use \nclass-selected=\".selected\"\n rather than \nclass-selected=\"{{.selected}}\"\n.\n\n\ngetNodeInfo\n\n\nractive.getNodeInfo\n has been renamed to \nractive.getContext\n, as has the static version of the function, to more accurately reflect its function. The \ngetNodeInfo\n alias is deprecated and will be removed in a future version.\n\n\nMultiple inheritance\n\n\nComponents can no longer inherit from multiple other components at the same level, meaning that \nRactive.extend(FirstComponent, SecondComponent)\n is no longer possible. You can still set up an inheritance hierachy multiple levels deep with \nRactive.extend(FirstComponent).extend(SecondComponent)\n.\n\n\n0.7 to 0.8\n\n\nTemplate format\n\n\nThe template format produced by \nRactive.parse\n has changed, making it incompatible with previous versions of Ractive.js and their template formats. You will need to re-parse any pre-parsed templates for use with 0.8.\n\n\nIE8\n\n\nIE8 is no longer supported. If you still need to support IE8, well, we're very, very sorry...\n\n\nExpressions and binding\n\n\nTwo-way bindings are no longer supported in computed contexts that don't have a \nset\nter, including template expression contexts. This means that \n{{#each filter(list)}}\ninput value=\"{{.name}}\" /\n{{/each}}\n is no longer possible. The reasoning behind this change is that the original \nlist.${index}.name\n is not updated when the binding within the computed context in the \neach\n expression is changed. 0.9 adds an instance flag \nsyncComputedChildren\n that can address this.\n\n\nRelaxed partial names\n\n\nPartial names can now include \n\\\n characters, which can be problematic if you happen to use division with no spaces arount the \n/\n in a partial expression.\n\n\nInteger references\n\n\nIntegers are no longer considered references, even in an array context, meaning that in \n{{#with [1, 2, 3]}}{{0}}{{/with}}\n will no longer result in \n1\n being rendered. Integers are now stricly considered to integer literals. If you need to reference a specific index in an array context, you can do so with a context specific reference like \n{{this.0}}\n.\n\n\nArray modification\n\n\nmodifyArrays\n now defaults to \nfalse\n, so the array adaptor is not applied to arrays automatically as they are added to the instance data. The preferred method of performing array operations is using the \nsplice\n, \npush\n, \npop\n, etc methods on the Ractive.js instance.", 
            "title": "Migrating"
        }, 
        {
            "location": "/get-started/migrating/#migrating-from-previous-versions", 
            "text": "These are notes to help you migrate from an older version of Ractive.js to a newer one, mostly centered on breaking changes between versions. If you'd like to find out more about new features, you can check out the  changelog .", 
            "title": "Migrating from previous versions"
        }, 
        {
            "location": "/get-started/migrating/#08-to-09", 
            "text": "", 
            "title": "0.8 to 0.9"
        }, 
        {
            "location": "/get-started/migrating/#removed-deprecations", 
            "text": "0.9 removes any of the remaining deprecations from 0.8, including:   decorator=\"name:{{arg1}},{{arg2}}  directives, to be replaced with  as-name=\"arg1, arg2\"  intro=\"name:{{ { arg1: arg1, arg2, arg2 } }}\"  and the same forms of  outro  and  intro-outro  to be replaced with  name-in=\"{ arg1, arg2 }\"  and the same forms of  name-out  and  name-in-out  The  ractive.data  getter, to be replaced with  ractive.get() , which returns a computed object tree containing virtual keys like mappings, links, and computations. The optional form  ractive.get({ virtual: false })  will return the raw root object without any virtual keys.  Lifecycle methods  init  and  beforeInit , to be replaced with lifecycle events or equivalent instance methods.  beforeInit  corresponds to the  construct  lifecycle event.  Partial comments in the form of  !-- {{ myPartial}} -- ... !-- {{/myPartial}} -- , to be replaced with partial blocks  {{#partial myPartial}}...{{/partial}}", 
            "title": "Removed deprecations"
        }, 
        {
            "location": "/get-started/migrating/#template-format", 
            "text": "The template format produced by  Ractive.parse  has changed, making it incompatible with previous versions of Ractive.js and their template formats. You will need to re-parse any pre-parsed templates for use with 0.9.", 
            "title": "Template format"
        }, 
        {
            "location": "/get-started/migrating/#partial-context", 
            "text": "Any context provided to a partial  {{ my-partial context}}  is no longer wrapped around the partial but is instead wrapped around the  content  of the partial. It's a subtle difference that only shows up when the partial name is an expression e.g.  {{ .type ~/external.item}} . Before this break, the  .type  would resolve to  ~/external.item.type , and now it will resolve to  .type  on the context in which the partial appears.", 
            "title": "Partial context"
        }, 
        {
            "location": "/get-started/migrating/#yielding", 
            "text": "Yielding is no longer restricted to inline partials, and each partial may be yielded more than once. You will no longer get a warning if you try to yield an instance or dynamic partial or if you yield the same partial multiple times.", 
            "title": "Yielding"
        }, 
        {
            "location": "/get-started/migrating/#nointro-inheritance", 
            "text": "The  noIntro  setting of an instance that contains components will now apply to the components too, unless those components have their own  noIntro  setting.", 
            "title": "noIntro inheritance"
        }, 
        {
            "location": "/get-started/migrating/#polyfills", 
            "text": "There is no longer a  legacy  build of Ractive.js available. Instead, a separate  polyfills  library is available that can be included before Ractive.js is loaded, or you can supply your own polyfills, shims, or shams.", 
            "title": "Polyfills"
        }, 
        {
            "location": "/get-started/migrating/#node-registry", 
            "text": "Elements with an  id  attribute are no longer collected into a  nodes  map on the Ractive.js instance. If you require similar functionality, it can be achieved in a much more flexible way with a decorator.", 
            "title": "Node registry"
        }, 
        {
            "location": "/get-started/migrating/#unresolved-references", 
            "text": "References that don't resolve are no longer kept in an unresolved state, waiting on an appropriate keypath to pop into existence somewhere in the context hierarchy. Instead, references that don't resolve are immediately resolved in the current context, which tends to be the desired behavior in most circumstances.", 
            "title": "Unresolved references"
        }, 
        {
            "location": "/get-started/migrating/#live-queries", 
            "text": "Element and component queries no longer support automatically keeping the resulting array up to date as new matching elements or components are rendered. If you require similar functionality, it can be achieved with a decorator for elements or bubbled lifecycle events for components.", 
            "title": "Live queries"
        }, 
        {
            "location": "/get-started/migrating/#change-event", 
            "text": "The  change  event has been removed and replaced by recursive observers, which are strictly opt-in and can be scoped to a deeper keypath than the root.", 
            "title": "change event"
        }, 
        {
            "location": "/get-started/migrating/#event-reference", 
            "text": "The  event  special reference available to event directives has been deprecated and replaced with three special references:   @context , which is roughly equivalent to  event , but with both an  event  and  original  key that point to the original event object. This is a  context object .  @event , which is resolves to the original event that triggered the directive.  @node , which resolves to the element to which the event directive is attached.", 
            "title": "event reference"
        }, 
        {
            "location": "/get-started/migrating/#ractivemerge", 
            "text": "ractive.merge  has been removed and replaced by an option on  ractive.set ,  { shuffle: true } , which more accurately reflects what actually happens.  merge  did not merge data, but instead re-arranged any DOM associated with the elements in the given array to match the order of the array - hence  shuffle  rather than  merge .", 
            "title": "ractive.merge"
        }, 
        {
            "location": "/get-started/migrating/#isolation", 
            "text": "Components are now  isolated  by default. If you need non- isolated  components in order to create implicit mappings as data is accessed, you can pass  isolated: false  to  extend  when creating the component. If you prefer all components to be non- isolated  by default, you can set  Ractive.defaults.isolated = false .  Further, non- isolated  components will now create implicit mappings when necessary for  set  operations, including  add ,  subtract , etc, in addition to  get  operations. To avoid creating an implicit mapping with a  set  operation from a non- isolated  component, pass  { isolated: true }  as an option to the  set  method.", 
            "title": "Isolation"
        }, 
        {
            "location": "/get-started/migrating/#magic-and-array-adaptors", 
            "text": "The magic and array adaptors are no longer part of Ractive.js core. They may be reappear as independent plugins at some point in the future.", 
            "title": "Magic and array adaptors"
        }, 
        {
            "location": "/get-started/migrating/#class-directives", 
            "text": "class-  directives are now parsed in an expression context like decorator, transition, and event directives, rather than in a string context like attributes and  style-  directives. This means that mustaches are no longer required for  class-  directive values, so you should use  class-selected=\".selected\"  rather than  class-selected=\"{{.selected}}\" .", 
            "title": "class- directives"
        }, 
        {
            "location": "/get-started/migrating/#getnodeinfo", 
            "text": "ractive.getNodeInfo  has been renamed to  ractive.getContext , as has the static version of the function, to more accurately reflect its function. The  getNodeInfo  alias is deprecated and will be removed in a future version.", 
            "title": "getNodeInfo"
        }, 
        {
            "location": "/get-started/migrating/#multiple-inheritance", 
            "text": "Components can no longer inherit from multiple other components at the same level, meaning that  Ractive.extend(FirstComponent, SecondComponent)  is no longer possible. You can still set up an inheritance hierachy multiple levels deep with  Ractive.extend(FirstComponent).extend(SecondComponent) .", 
            "title": "Multiple inheritance"
        }, 
        {
            "location": "/get-started/migrating/#07-to-08", 
            "text": "", 
            "title": "0.7 to 0.8"
        }, 
        {
            "location": "/get-started/migrating/#template-format_1", 
            "text": "The template format produced by  Ractive.parse  has changed, making it incompatible with previous versions of Ractive.js and their template formats. You will need to re-parse any pre-parsed templates for use with 0.8.", 
            "title": "Template format"
        }, 
        {
            "location": "/get-started/migrating/#ie8", 
            "text": "IE8 is no longer supported. If you still need to support IE8, well, we're very, very sorry...", 
            "title": "IE8"
        }, 
        {
            "location": "/get-started/migrating/#expressions-and-binding", 
            "text": "Two-way bindings are no longer supported in computed contexts that don't have a  set ter, including template expression contexts. This means that  {{#each filter(list)}} input value=\"{{.name}}\" / {{/each}}  is no longer possible. The reasoning behind this change is that the original  list.${index}.name  is not updated when the binding within the computed context in the  each  expression is changed. 0.9 adds an instance flag  syncComputedChildren  that can address this.", 
            "title": "Expressions and binding"
        }, 
        {
            "location": "/get-started/migrating/#relaxed-partial-names", 
            "text": "Partial names can now include  \\  characters, which can be problematic if you happen to use division with no spaces arount the  /  in a partial expression.", 
            "title": "Relaxed partial names"
        }, 
        {
            "location": "/get-started/migrating/#integer-references", 
            "text": "Integers are no longer considered references, even in an array context, meaning that in  {{#with [1, 2, 3]}}{{0}}{{/with}}  will no longer result in  1  being rendered. Integers are now stricly considered to integer literals. If you need to reference a specific index in an array context, you can do so with a context specific reference like  {{this.0}} .", 
            "title": "Integer references"
        }, 
        {
            "location": "/get-started/migrating/#array-modification", 
            "text": "modifyArrays  now defaults to  false , so the array adaptor is not applied to arrays automatically as they are added to the instance data. The preferred method of performing array operations is using the  splice ,  push ,  pop , etc methods on the Ractive.js instance.", 
            "title": "Array modification"
        }, 
        {
            "location": "/api/initialization-options/", 
            "text": "Initialization Options\n\n\nThe following is an exhaustive list of initialisation options that you can pass to \nnew Ractive()\n and \nRactive.extend()\n. Extra properties passed as options that are not initialization options are added as properties or methods of the instance.\n\n\nvar ractive = new Ractive({\n  myMethod: function () {\n    alert( 'my method was called' );\n  }\n});\n\nractive.myMethod(); // triggers the alert\n\n\n\n\n\n\nadapt\n\n\n(Array\nstring|Object\n)\n\n\nAn array of \nadaptors\n to use. Values can either be names of registered adaptors or an adaptor definition.\n\n\nadapt: [ 'MyAdaptor', AdaptorDefinition ]\n\n\n\n\nadapt\n is not required if you registered adaptors via the \nadaptors\n initialization property. The adaptors registered via \nadaptors\n initialization property are automatically used as if they were set with \nadapt\n.\n\n\nconst instance = new Ractive({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n});\n\nconst Component = Ractive.extend({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n});\n\nnew Component({\n  // No need to use adapt\n});\n\n\n\n\n\n\nadaptors\n\n\n(Object\nstring, Object\n)\n\n\nA map of \nadaptors\n where the key is the adaptor name and the value is an adaptor definition.\n\n\nadaptors: {\n  MyAdaptor: AdaptorDefinition\n}\n\n\n\n\nRegistering an adaptor via \nadaptors\n is not required if you directly specified the adaptor definition via \nadapt\n.\n\n\nconst Adaptor = { ... };\n\nconst instance = new Ractive({\n  adapt: [ AdaptorDefinition ]\n  // No need to use adaptors\n});\n\n\n\n\n\n\nappend\n\n\n(boolean|string|HTMLElement|array-like)\n\n\nControls how the instance is attached to \nel\n. Defaults to \nfalse\n.\n\n\nfalse\n replaces the contents of \nel\n.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: false,\ntemplate: '\np\nnew content\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nnew content\n/p\n\n\n/div\n\n\n\n\n\ntrue\n appends the instance to \nel\n.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: true,\ntemplate: '\np\nnew content\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n  \np\nnew content\n/p\n\n\n/div\n\n\n\n\n\nAn \nid\n of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element, which is a child of \nel\n will render the instance before that element.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nred\n/p\n\n  \np\norange\n/p\n\n  \np\nyellow\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: document.querySelector('p:nth-child(2)'),\ntemplate: '\np\ngrey\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nred\n/p\n\n  \np\ngrey\n/p\n\n  \np\norange\n/p\n\n  \np\nyellow\n/p\n\n\n/div\n\n\n\n\n\n\n\nattributes\n\n\n(Object\nstring, [string]|Object\nstring, [string]\n)\n\n\nAn array of optional attributes or a map of optional and required attributes. Defaults to \nundefined\n.\n\n\nYou can supply a list of optional attributes using an array. You can also supply an object with an \noptional\n array of attribute names and a \nrequired\n array of attribute names. At runtime, if a component is created missing a required attribute, Ractive will issue a warning about missing required attributes. Any attributes that are passed to the component that are \nnot\n included in either of the \noptional\n or \nrequired\n lists of attributes will be collected into a partial named \nextra-attributes\n so that they can be included on a top-level element in the component template or split apart to be used in a component \ninit\n event.\n\n\nconst Component = Ractive.extend({\n  template: `\ndiv class-component-wrapper {{yield extra-attributes}}\nFancy component doing something with list and type\n/div\n`,\n  attributes: {\n    required: [ 'list' ],\n    optional: [ 'type' ]\n  }\n});\n\n// \nComponent type=\nfoo\n /\n will issue a warning about missing list\n// \nComponent list=\n{{things}}\n style-color=\ngreen\n /\n will not warn, but will include the style-color=\ngreen\n on the wrapper div\n\n\n\n\nThe extra attributes passed to a component are not limited to simple attributes - they can also include directives, but any mustache sections will not have their contents checked. By default, the \nextra-attributes\n will \nnot\n be mapped, meaning that the values won't be available with \nget\n from the component, so the partial should be yielded. If you need the extra attributes to be mapped, include an additional setting in the attributes map \nmapAll: true\n.\n\n\n\n\ncomponents\n\n\n(Object\nstring, Function\n)\n\n\nA map of \ncomponents\n where the key is the component name the value is either a component definition or a function that returns either a name of a registered component or a component definition. The function form receives processed \ndata\n as first argument.\n\n\ncomponents: {\n  StaticComponent: ComponentDefinition,\n  DynamicComponent: function(data){\n    return data.foo ? 'MyGlobalComponent' : ComponentDefinition;\n  }\n}\n\n\n\n\nDuring a \nractive.reset()\n, components registered using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\n\n\ncomputed\n\n\n(Object\nstring, function|Object\n)\n\n\nA map of \ncomputed properties\n where the key is the name of the computed property and the value is either a computed property expression, a function that returns a value, or an object that has \nget\n and \nset\n functions.\n\n\n// Imagine a square...\ncomputed: {\n  // Computed property expression\n  diagonal: '${side} * Math.sqrt(2)',\n\n  // A function\n  perimeter: function(){\n    return 4 * this.get('side');\n  },\n\n  // An object with get and set functions\n  area: {\n    get: function(){\n      return Math.pow(this.get('side'), 2);\n    },\n    set: function(value){\n      this.set('side', Math.sqrt(value));\n    }\n  },\n}\n\n\n\n\n\n\ncsp\n\n\n(boolean)\n\n\nWhether or not to add inline functions for expressions after parsing. Defaults to \nfalse\n.\n\n\nThis can effectively eliminate \neval\n caused by expressions in templates. It also makes the resulting template no longer JSON compatible, so the template will have to be served via \nscript\n tag.\n\n\n\n\ncss\n\n\n(string)\n\n\nScoped CSS for a component and its descendants.\n\n\ncss: `\n  .bold { font-weight: bold }\n`\n\n\n\n\nAt the moment, only applies to components.\n\n\n// This works\nconst Component = Ractive.extend({\n  css: '...'\n});\n\n// This will not work\nnew Ractive({\n  css: '...'\n});\n\n\n\n\n\n\ndata\n\n\n(Object\nstring, any\n|Function)\n\n\nThe data for an instance, or default data for a component. Can either be an object or a function that returns an object.\n\n\n// Object form\ndata: {\n  foo: 'bar'\n}\n\n// Function form\ndata: function() {\n  return { foo: 'bar' };\n}\n\n// Function form using arrow function for less verbosity\ndata: () =\n ({\n  foo: 'bar'\n})\n\n\n\n\nWhen using the object form, the data is attached to the component's prototype. Standard prototype rules apply.\n\n\nconst Component = Ractive.extend({\n  data: {\n    foo: { bar: 42 }\n  }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 12\n\n\n\n\nWhen using the function form, the function is executed to give each instance a copy of the data. Standard prototype rules apply.\n\n\nconst Component = Ractive.extend({\n  data: function () {\n    return {\n      foo: { bar: 42 }\n    };\n  }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 42\n\n\n\n\nWhen extending from a constructor, data from the parent constructor will be shallow-copied over to the child data. Child data takes precedence in the event of collisions.\n\n\nconst Parent = Ractive.extend({\n  data: {\n    foo: 'Hello',\n    bar: 'World'\n  }\n});\n\nconst Child = Parent.extend({\n  data: {\n    foo: 'Goodbye'\n  }\n});\n\nParent().get(); // { foo: 'Hello', bar: 'World' }\nChild().get();  // { foo: 'Goodbye', bar: 'World' }\n\n\n\n\n\n\ndecorators\n\n\n(Object\nstring, Function\n)\n\n\nA map of \ndecorators\n where the key is the decorator name and the value is a decorator definition.\n\n\ndecorators: {\n  MyDecorator: DecoratorDefinition\n}\n\n\n\n\n\n\ndelegate\n\n\n(boolean)\n\n\nWhether or not to enable automatic event delegation for iterative sections within an element. Defaults to \ntrue\n.\n\n\nWhen enabled, DOM events subscribed within iterative sections will not add a DOM event listener to each element. Instead, a single listener will be installed on the element containing the iterative section, and that listener will find appropriate event directives starting from the target element and working back to the containing element with the listener.\n\n\n\n\ndelimiters\n\n\n(Array[string])\n\n\nSets the template delimiters. Defaults to \n[ '{{', '}}' ]\n.\n\n\ndelimiters: [ '\n%=', '%\n' ],\ntemplate: 'hello \n%= world %\n',\ndata: { world: 'earth' }\n\n// result:\n// hello earth\n\n\n\n\n\n\neasing\n\n\n(Object\nstring, Function\n)\n\n\nA map of \neasing functions\n where the key is the easing function name and the value is the easing function.\n\n\neasing: {\n  MyEasing: EasingDefinition\n}\n\n\n\n\n\n\nel\n\n\n(string|HTMLElement|array-like)\n\n\nThe element to render an instance to. Can either be an \nid\n of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element.\n\n\nel: 'container'\nel: '#container'\nel: document.getElementById('container')\nel: jQuery('#container')\n\n\n\n\n\n\nenhance\n\n\n(boolean)\n\n\nWhether or not to apply progressive enhancement by inspecting the contents of \nel\n and try to reuse as much of the existing tree as possible. Defaults to \nfalse\n.\n\n\nThere are a few limitations to this feature:\n\n\n\n\n\n\nThis option cannot be used with \nappend\n.\n\n\n\n\n\n\nUnescaped HTML mustaches (triples) don't play nicely with enhance because there's no easy way to match up the string content to the target DOM nodes.\n\n\n\n\n\n\nAll matching elements will be reused, except for a few cases regarding text nodes.\n\n\ndiv\nleft text {{#if foo}} middle text {{/if}} right text\n/div\n\n\nHTML does not have markup representation for adjacent text nodes. Rendering the snippet above from the server, regardless of \nfoo\n's value, the browser creates one contiguous text node. However, Ractive will need \nthree\n adjacent text nodes to represent it: One for \nouter text\n, another for \nright text\n and another for \nmiddle text\n when \nfoo\n becomes truthy.\n\n\nIt has been suggested that Ractive could deal with merged text nodes, but that would lead to extra complexity as there are certain scenarios where the text node would have to split and rejoin. When \nfoo\n is falsey, \nleft text\n and \nright text\n could be merged. But when \nfoo\n becomes truthy, that text node would have to split in order to accomodate \nmiddle text\n.\n\n\n\n\n\n\n\n\nevents\n\n\n(Object\nstring, Function\n)\n\n\nA map of \nevents\n where the key is the event name and value is an event definition.\n\n\nevents: {\n  MyEvent: EventDefinition\n}\n\n\n\n\n\n\ninterpolators\n\n\n(Object\nstring, Function\n)\n\n\nA map of \ninterpolators\n where the key is the interpolator name and the value is an interpolator definition.\n\n\ninterpolators: {\n  MyInterpolator: InterpolatorDefinition\n}\n\n\n\n\n\n\nisolated\n\n\n(boolean)\n\n\nControls whether the component will try to \nresolve data and plugins on its ancestors\n. Defaults to \ntrue\n.\n\n\nRelevant only to \nComponents\n.\n\n\n\n\nlazy\n\n\n(boolean)\n\n\nWhether or not to update data using late-firing DOM events (i.e. \nchange\n, \nblur\n) instead of events that fire immediately on interaction (i.e. \nkeyup\n, \nkeydown\n). Defaults to \nfalse\n.\n\n\nOnly applicable if \ntwoway\n is \ntrue\n.\n\n\nvar ractive = new Ractive({\n  template: '\ninput value=\n{{foo}}\n',\n  data: { foo: 'bar' },\n  lazy: true\n});\n\n// Only fires when input loses focus.\nractive.on('change', function(){\n  console.log('changed!')\n})\n\n\n\n\n\n\nnestedTransitions\n\n\n(boolean)\n\n\nWhether or not to allow transitions to fire if they are already downstream from a transitioning element. Defaults to \ntrue\n.\n\n\n{{#if outer}}\n  \ndiv fade-in='slow'\n\n    Outer text.\n    {{#if inner}}\n      \ndiv fly-in=\nfast\nInner text.\n/div\n\n    {{/if}}\n  \n/div\n\n{{/if}}\n\n\n\n\nIn this example, if \ninner\n is \ntrue\n when \nouter\n becomes \ntrue\n, then all of the \ndiv\ns will render at the same time. If \nnestedTransitions\n is disabled, then the \nfly\n transition on inner \ndiv\n will not be run, since the \nfade\n will already be running on the outer \ndiv\n.\n\n\nThis can also be controlled per transition using the \nnested\n boolean parameter for transitions:\n\n\ndiv fade-in=\n{ duration: 'slow', nested: false }\n...\n/div\n\n\n\n\n\n\n\nnoCSSTransform\n\n\n(boolean)\n\n\nPrevents component CSS from being transformed with scoping guids. Defaults to \nfalse\n.\n\n\n\n\nnoIntro\n\n\n(boolean)\n\n\nWhether or not to skip intro transitions on initial render. Defaults to \nfalse\n.\n\n\nvar ractive = new Ractive({\n  template: '\nul\n{{#items}}\nli fade-in\n{{.}}\n/li\n{{/items}}\n/ul\n',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: { fade: function ( t, params ) {...} },\n  noIntro: true\n});\n// 'red' and 'blue' list items do not fade in\n\nractive.push( 'items', 'green' );\n// 'green' list item will fade in\n\n\n\n\n\n\nnoOutro\n\n\n(boolean)\n\n\nWhether or not to skip outro transitions during an instance unrender. Defaults to \nfalse\n.\n\n\nvar ractive = new Ractive({\n  template: '\nul\n{{#items}}\nli fade-out\n{{.}}\n/li\n{{/items}}\n/ul\n',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: { fade: function ( t, params ) {...} },\n  noOutro: true\n});\n\nractive.pop( 'items' );\n// 'blue' list item will fade out\n\nractive.unrender();\n// 'red' list item will not fade out\n\n\n\n\n\n\nobserve\n\n\n(Object\nstring, Function|Object\n)\n\n\nA hash of observers to subscribe during initialization and unsubscribe during teardown. Defaults to \nundefined\n.\n\n\nThe keys of the hash may be any string that is accepted by \nractive.observe()\n, and the values may be either callback functions, as would be passed to \nractive.observe()\n, or objects with a \nhandler\n property that is a callback function. The object form also takes other options that control the behavior of the observer.\n\n\nnew Ractive({\n  // ..\n  observe: {\n    show ( value ) {\n      console.log( `show changed to '${value}'` );\n    },\n    'users.*.name people.*.name': {\n      handler ( value, old, path, idx ) {\n        console.log( `${path} changed to '${value}' );\n      },\n      init: false,\n      strict: true\n    }\n  }\n});\n\n\n\n\nThe options that may be specified in the object form are (see the \nractive.observe()\n docs\n for more detailed option descriptions):\n\n\n\n\nhandler (Function)\n: The callback function for the observer.\n\n\nonce (boolean)\n: Use \nractive.observeOnce()\n rather than \nractive.observe()\n to install the observer, meaning the observer is implicitly \ninit: false\n, will only fire for the first change to the observed path, and will by removed after the first change.\n\n\nstrict (boolean)\n: Use strict equality when determining whether or not a value has changed.\n\n\narray (boolean)\n: Use an array observer rather than a plain observer.\n\n\ndefer (boolean)\n: Defer the observer until after the DOM is settled.\n\n\ninit (boolean)\n: Whether or not to fire an initial change event.\n\n\nlinks (boolean)\n: Whether or not to follow links.\n\n\ncontext (any)\n: Context for the callback function.\n\n\nold (Function)\n: Modifier function for the \nold\n value passed to the callback function.\n\n\n\n\nWhen a sublcass created with \nRactive.extend()\n is passed an \nobserve\n hash, then any further subclasses or instances created with an \nobserve\n hash will be combined. Any superclass observers are installed first following the inheritance hierarchy, and finally, any instance observers are installed.\n\n\n\n\non\n\n\n(Object\nstring, Function|Object\n)\n\n\nA hash of event listeners to subscribe during initialization and unsubscribe during teardown. Defaults to \nundefined\n.\n\n\nThe keys of the hash may be any string that is accepted by \nractive.on()\n, and the values may be either callback functions, as would be passed to \nractive.on()\n, or objects with a \nhandler\n property that is a callback function. The object form also takes other options that control the behavior of the event handler.\n\n\nnew Ractive({\n  // ...\n  on: {\n    init () {\n      console.log('I will print during init');\n    },\n    '*.somethingHappened': {\n      handler ( ctx ) {\n        console.log('I will fire when this instance or any child component fires an instance event named \nsomethingHappened\n');\n      },\n      once: true\n    }\n  },\n  // ...\n});\n\n\n\n\nThe options that may be specified in the object form are:\n\n\n\n\nhandler (Function)\n: The callback function for the event.\n\n\nonce (boolean)\n: Use \nractive.once()\n rather than \nractive.on()\n to subscribe the listener, meaning that the handler will only be called the first time the event is fired and then it will be unsubscribed.\n\n\n\n\non\n event listeners may subscribe to any instance event, including lifecycle events \nafter\n \nconstruct\n. When a sublcass created with \nRactive.extend()\n is passed an \non\n hash, then any further subclasses or instances created with an \non\n hash will be combined. Any superclass event handlers are installed first following the inheritance hierarchy, and finally, any instance event handlers are installed.\n\n\n\n\noncomplete\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is rendered and all the transitions have completed.\n\n\n\n\nonconfig\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed and all initialization options have been processed.\n\n\n\n\nonconstruct\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed but before any initialization option has been processed.\n\n\nAccepts the instance's initialization options as argument.\n\n\n\n\nondetach\n\n\n(Function)\n\n\nA lifecycle event that is called whenever \nractive.detach()\n is called.\n\n\nNote that \nractive.insert()\n implicitly calls \nractive.detach()\n if needed.\n\n\n\n\noninit\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed and is ready to be rendered.\n\n\n\n\noninsert\n\n\n(Function)\n\n\nA lifecycle event that is called when \nractive.insert()\n is called.\n\n\n\n\nonrender\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is rendered but \nbefore\n transitions start.\n\n\n\n\nonteardown\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is being torn down.\n\n\n\n\nonunrender\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is being undrendered.\n\n\n\n\nonupdate\n\n\n(Function)\n\n\nA lifecycle event that is called when \nractive.update()\n is called.\n\n\n\n\npartials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nA map of \npartials\n where the key is the partial name and the value is either a template string, a parsed template object or a function that returns any of the previous options. The function form accepts processed \ndata\n and  \nParse Object\n as arguments.\n\n\npartials: {\n  stringPartial: '\np\n{{greeting}} world!\n/p\n',\n  parsedPartial: {\nv\n:3,\nt\n:[{\nt\n:7,\ne\n:\np\n,\nf\n:[{\nt\n:2,\nr\n:\ngreeting\n},\n world!\n]}]},\n  functionPartial: function(data, p){\n    return data.condition ? '\np\nhello world\n/p\n' : '\ndiv\nyes, we have no foo\n/div\n';\n  }\n}\n\n\n\n\nDuring a \nractive.reset()\n, function partials are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\n\n\npreserveWhitespace\n\n\n(boolean)\n\n\nWhether or not to preserve whitespace in templates when parsing. Defaults to \nfalse\n.\n\n\nWhitespace in \npre\n elements is always preserved. The browser will still deal with whitespace in the normal fashion.\n\n\nvar ractive = new Ractive({\n  template: '\np\nhello\\n\\n  \\tworld   \n/p\n',\n  preserveWhitespace: false //default\n});\n\nconsole.log( ractive.toHTML() );\n// \np\nhello world\n/p\n\n\nvar ractive = new Ractive({\n  template: '\np\nhello\\n\\n  \\tworld   \n/p\n',\n  preserveWhitespace: true\n});\n\nconsole.log( ractive.toHTML() );\n//\np\nhello\n//\n//  world   \n/p\n\n\n\n\n\n\n\nresolveInstanceMembers\n\n\n(boolean)\n\n\nWhether or not to include members of the Ractive instance at the end of the reference resolution process. Defaults to \ntrue\n.\n\n\nbutton on-click=\ntoggle('show')\nToggle\n/button\n\n\n\n\n\nIf there is no data member \ntoggle\n in the context of the template, with \nresolveInstanceMembers\n enabled, the reference will resolve to the \nractive.toggle()\n method of the instance.\n\n\n\n\nsanitize\n\n\n(boolean|Object)\n\n\nWhether or not certain elements will be stripped from the template during parsing.  Defaults to \nfalse\n.\n\n\ntrue\n strips out blacklisted elements and event attributes. See \nRactive.parse()\n for the default list of blacklisted elements.\n\n\ntemplate: `\n  \np\nsome content\n/p\n\n  \nframe\nAm I a bad element or just misunderstood?\n/frame\n\n`,\nsanitize: true\n\n// result:\n// \np\nsome content\n/p\n\n\n\n\n\nThe object form should have \nelements\n which is an array of blacklisted elements and \neventAttributes\n boolean which, when \ntrue\n, also strips out event attributes.\n\n\ntemplate: `\n  \np\nsome content\n/p\n\n  \ndiv onclick=\ndoEvil()\nthe good stuff\n/div\n\n`,\nsanitize: {\n  elements: [ 'p' ],\n  eventAttributes: true\n}\n\n// result:\n// \ndiv\nthe good stuff\n/div\n\n\n\n\n\n\n\nstaticDelimiters\n\n\n(Array[string])\n\n\nSets the static (one-time binding) delimiters. Defaults to \n[ '[[', ']]' ]\n.\n\n\nvar ractive = new Ractive({\n  template: 'hello [[foo]]',\n  staticDelimiters: [ '[[', ']]' ], //default\n  data: { foo: 'world' }\n});\n// result: \nhello world\n\n\nractive.set( 'foo', 'mars' );\n// still is: \nhello world\n\n\n\n\n\n\n\nstaticTripleDelimiters\n\n\n(Array\nstring\n)\n\n\nSets the static (one-time binding) triple delimiters. Defaults to \n[ '[[[', ']]]' ]\n.\n\n\nvar ractive = new Ractive({\n  template: 'hello [[[html]]]',\n  staticTripleDelimiters: [ '[[[', ']]]' ], //default\n  data: { html: '\nspan\nworld\n/span\n' }\n});\n// result: \nhello \nspan\nworld\n/span\n\n\nractive.set( 'html', '\nspan\nmars\n/span\n' );\n// still is: \nhello world\n\n\n\n\n\n\n\nstripComments\n\n\n(boolean)\n\n\nWhether or not to remove comments in templates when parsing. Defaults to \ntrue\n.\n\n\ntemplate: '\n!-- html comment --\nhello world',\nstripComments: false\n\n// result:\n// \n!-- html comment --\nhello world\n\n\n\n\n\n\nsyncComputedChildren\n\n\n(boolean)\n\n\nWhether or not to invalidate the dependencies of an expression when child keypaths of the expression are updated. Defaults to \nfalse\n. \nNote\n: setting this to \ntrue\n may cause performance issues for complex expressions involving large arrays.\n\n\ninput value=\n{{pattern}}\n /\n\n{{#each filter(users, pattern)}}\n  \ninput value=\n{{.name}}\n /\n\n{{/each}}\n\n\n\n\nIn this example, the \ninput\n inside the iteration is bound to a computation e.g. \nfilter(users, pattern).0.name\n that isn't actually an addressable model. With \nsyncComputedChildren\n enabled, when that virtual keypath is updated by a user changing the \ninput\n, the expression will invalidate its dependencies (\nfilter\n, \nusers\n, and \npattern\n), which will cause any other references to the \nuser\n that happens to coincide with result of the expression to also update.\n\n\n\n\ntarget\n\n\n(string|HTMLElement|array-like)\n\n\nAlias for \nel\n.\n\n\n\n\ntemplate\n\n\n(string|array|object|function)\n\n\nThe \ntemplate\n to use. Must either be a CSS selector string pointing to an element on the page containing the template, an HTML string, an object resulting from \nRactive.parse()\n or a function that returns any of the previous options. The function form accepts processed \ndata\n and a \nParse Object\n.\n\n\n// Selector\ntemplate: '#my-template',\n\n// HTML\ntemplate: '\np\n{{greeting}} world!\n/p\n',\n\n// Template AST\ntemplate: {\nv\n:3,\nt\n:[{\nt\n:7,\ne\n:\np\n,\nf\n:[{\nt\n:2,\nr\n:\ngreeting\n},\n world!\n]}]},\n\n// Function\ntemplate: function(data, p){\n  return '\np\n{{greeting}} world!\n/p\n';\n},\n\n\n\n\nDuring a \nractive.reset()\n, templates provided using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\n\n\ntransitions\n\n\n(Object\nstring, Function\n)\n\n\nA map of \ntransitions\n where the key is the name of the transition and the value is a transition definition.\n\n\n\n\ntransitionsEnabled\n\n\n(boolean)\n\n\nWhether or not transitions are enabled. Defaults to \ntrue\n.\n\n\n\n\ntripleDelimiters\n\n\n(Array[string])\n\n\nSets the triple delimiters. Defaults to \n[ '{{{', '}}}' ]\n.\n\n\ntemplate: 'hello @html@',\ntripleDelimiters: [ '@', '@' ],\ndata: { html: '\nspan\nworld\n/span\n' }\n\n// result:\n// hello \nspan\nworld\n/span\n\n\n\n\n\n\n\ntwoway\n\n\n(boolean)\n\n\nWhether or not \ntwo-way binding\n is enabled. Defaults to \ntrue\n.\n\n\nvar ractive = new Ractive({\n  template: '\ninput value=\n{{foo}}\n',\n  data: { foo: 'bar' },\n  twoway: false\n});\n\n// user types \nfizz\n into \ninput\n, but data value is not changed:\n\nconsole.log( ractive.get( 'foo' ) ); //logs \nbar\n\n\n// updates from the model are still pushed to the view\n\nractive.set( 'foo', 'fizz' );\n\n// input now displays \nfizz\n\n\n\n\n\n\n\nwarnAboutAmbiguity\n\n\n(boolean)\n\n\nWhether or not to warn about references that don't resolve to their immediate context. Defaults to \nfalse\n.\n\n\nAmbiguous references can be the cause of some strange behavior when your data changes structure slightly. With \nwarnAboutAmbiguity\n enabled, Ractive will warn you any time a reference isn't scoped and resolves in a context above the immediate context of the reference.", 
            "title": "Initialization Options"
        }, 
        {
            "location": "/api/initialization-options/#initialization-options", 
            "text": "The following is an exhaustive list of initialisation options that you can pass to  new Ractive()  and  Ractive.extend() . Extra properties passed as options that are not initialization options are added as properties or methods of the instance.  var ractive = new Ractive({\n  myMethod: function () {\n    alert( 'my method was called' );\n  }\n});\n\nractive.myMethod(); // triggers the alert", 
            "title": "Initialization Options"
        }, 
        {
            "location": "/api/initialization-options/#adapt", 
            "text": "(Array string|Object )  An array of  adaptors  to use. Values can either be names of registered adaptors or an adaptor definition.  adapt: [ 'MyAdaptor', AdaptorDefinition ]  adapt  is not required if you registered adaptors via the  adaptors  initialization property. The adaptors registered via  adaptors  initialization property are automatically used as if they were set with  adapt .  const instance = new Ractive({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n});\n\nconst Component = Ractive.extend({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n});\n\nnew Component({\n  // No need to use adapt\n});", 
            "title": "adapt"
        }, 
        {
            "location": "/api/initialization-options/#adaptors", 
            "text": "(Object string, Object )  A map of  adaptors  where the key is the adaptor name and the value is an adaptor definition.  adaptors: {\n  MyAdaptor: AdaptorDefinition\n}  Registering an adaptor via  adaptors  is not required if you directly specified the adaptor definition via  adapt .  const Adaptor = { ... };\n\nconst instance = new Ractive({\n  adapt: [ AdaptorDefinition ]\n  // No need to use adaptors\n});", 
            "title": "adaptors"
        }, 
        {
            "location": "/api/initialization-options/#append", 
            "text": "(boolean|string|HTMLElement|array-like)  Controls how the instance is attached to  el . Defaults to  false .  false  replaces the contents of  el .  !-- before --  div id='container' \n   p existing content /p  /div   el: '#container',\nappend: false,\ntemplate: ' p new content /p '  !-- after --  div id='container' \n   p new content /p  /div   true  appends the instance to  el .  !-- before --  div id='container' \n   p existing content /p  /div   el: '#container',\nappend: true,\ntemplate: ' p new content /p '  !-- after --  div id='container' \n   p existing content /p \n   p new content /p  /div   An  id  of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element, which is a child of  el  will render the instance before that element.  !-- before --  div id='container' \n   p red /p \n   p orange /p \n   p yellow /p  /div   el: '#container',\nappend: document.querySelector('p:nth-child(2)'),\ntemplate: ' p grey /p '  !-- after --  div id='container' \n   p red /p \n   p grey /p \n   p orange /p \n   p yellow /p  /div", 
            "title": "append"
        }, 
        {
            "location": "/api/initialization-options/#attributes", 
            "text": "(Object string, [string]|Object string, [string] )  An array of optional attributes or a map of optional and required attributes. Defaults to  undefined .  You can supply a list of optional attributes using an array. You can also supply an object with an  optional  array of attribute names and a  required  array of attribute names. At runtime, if a component is created missing a required attribute, Ractive will issue a warning about missing required attributes. Any attributes that are passed to the component that are  not  included in either of the  optional  or  required  lists of attributes will be collected into a partial named  extra-attributes  so that they can be included on a top-level element in the component template or split apart to be used in a component  init  event.  const Component = Ractive.extend({\n  template: ` div class-component-wrapper {{yield extra-attributes}} Fancy component doing something with list and type /div `,\n  attributes: {\n    required: [ 'list' ],\n    optional: [ 'type' ]\n  }\n});\n\n//  Component type= foo  /  will issue a warning about missing list\n//  Component list= {{things}}  style-color= green  /  will not warn, but will include the style-color= green  on the wrapper div  The extra attributes passed to a component are not limited to simple attributes - they can also include directives, but any mustache sections will not have their contents checked. By default, the  extra-attributes  will  not  be mapped, meaning that the values won't be available with  get  from the component, so the partial should be yielded. If you need the extra attributes to be mapped, include an additional setting in the attributes map  mapAll: true .", 
            "title": "attributes"
        }, 
        {
            "location": "/api/initialization-options/#components", 
            "text": "(Object string, Function )  A map of  components  where the key is the component name the value is either a component definition or a function that returns either a name of a registered component or a component definition. The function form receives processed  data  as first argument.  components: {\n  StaticComponent: ComponentDefinition,\n  DynamicComponent: function(data){\n    return data.foo ? 'MyGlobalComponent' : ComponentDefinition;\n  }\n}  During a  ractive.reset() , components registered using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "components"
        }, 
        {
            "location": "/api/initialization-options/#computed", 
            "text": "(Object string, function|Object )  A map of  computed properties  where the key is the name of the computed property and the value is either a computed property expression, a function that returns a value, or an object that has  get  and  set  functions.  // Imagine a square...\ncomputed: {\n  // Computed property expression\n  diagonal: '${side} * Math.sqrt(2)',\n\n  // A function\n  perimeter: function(){\n    return 4 * this.get('side');\n  },\n\n  // An object with get and set functions\n  area: {\n    get: function(){\n      return Math.pow(this.get('side'), 2);\n    },\n    set: function(value){\n      this.set('side', Math.sqrt(value));\n    }\n  },\n}", 
            "title": "computed"
        }, 
        {
            "location": "/api/initialization-options/#csp", 
            "text": "(boolean)  Whether or not to add inline functions for expressions after parsing. Defaults to  false .  This can effectively eliminate  eval  caused by expressions in templates. It also makes the resulting template no longer JSON compatible, so the template will have to be served via  script  tag.", 
            "title": "csp"
        }, 
        {
            "location": "/api/initialization-options/#css", 
            "text": "(string)  Scoped CSS for a component and its descendants.  css: `\n  .bold { font-weight: bold }\n`  At the moment, only applies to components.  // This works\nconst Component = Ractive.extend({\n  css: '...'\n});\n\n// This will not work\nnew Ractive({\n  css: '...'\n});", 
            "title": "css"
        }, 
        {
            "location": "/api/initialization-options/#data", 
            "text": "(Object string, any |Function)  The data for an instance, or default data for a component. Can either be an object or a function that returns an object.  // Object form\ndata: {\n  foo: 'bar'\n}\n\n// Function form\ndata: function() {\n  return { foo: 'bar' };\n}\n\n// Function form using arrow function for less verbosity\ndata: () =  ({\n  foo: 'bar'\n})  When using the object form, the data is attached to the component's prototype. Standard prototype rules apply.  const Component = Ractive.extend({\n  data: {\n    foo: { bar: 42 }\n  }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 12  When using the function form, the function is executed to give each instance a copy of the data. Standard prototype rules apply.  const Component = Ractive.extend({\n  data: function () {\n    return {\n      foo: { bar: 42 }\n    };\n  }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 42  When extending from a constructor, data from the parent constructor will be shallow-copied over to the child data. Child data takes precedence in the event of collisions.  const Parent = Ractive.extend({\n  data: {\n    foo: 'Hello',\n    bar: 'World'\n  }\n});\n\nconst Child = Parent.extend({\n  data: {\n    foo: 'Goodbye'\n  }\n});\n\nParent().get(); // { foo: 'Hello', bar: 'World' }\nChild().get();  // { foo: 'Goodbye', bar: 'World' }", 
            "title": "data"
        }, 
        {
            "location": "/api/initialization-options/#decorators", 
            "text": "(Object string, Function )  A map of  decorators  where the key is the decorator name and the value is a decorator definition.  decorators: {\n  MyDecorator: DecoratorDefinition\n}", 
            "title": "decorators"
        }, 
        {
            "location": "/api/initialization-options/#delegate", 
            "text": "(boolean)  Whether or not to enable automatic event delegation for iterative sections within an element. Defaults to  true .  When enabled, DOM events subscribed within iterative sections will not add a DOM event listener to each element. Instead, a single listener will be installed on the element containing the iterative section, and that listener will find appropriate event directives starting from the target element and working back to the containing element with the listener.", 
            "title": "delegate"
        }, 
        {
            "location": "/api/initialization-options/#delimiters", 
            "text": "(Array[string])  Sets the template delimiters. Defaults to  [ '{{', '}}' ] .  delimiters: [ ' %=', '% ' ],\ntemplate: 'hello  %= world % ',\ndata: { world: 'earth' }\n\n// result:\n// hello earth", 
            "title": "delimiters"
        }, 
        {
            "location": "/api/initialization-options/#easing", 
            "text": "(Object string, Function )  A map of  easing functions  where the key is the easing function name and the value is the easing function.  easing: {\n  MyEasing: EasingDefinition\n}", 
            "title": "easing"
        }, 
        {
            "location": "/api/initialization-options/#el", 
            "text": "(string|HTMLElement|array-like)  The element to render an instance to. Can either be an  id  of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element.  el: 'container'\nel: '#container'\nel: document.getElementById('container')\nel: jQuery('#container')", 
            "title": "el"
        }, 
        {
            "location": "/api/initialization-options/#enhance", 
            "text": "(boolean)  Whether or not to apply progressive enhancement by inspecting the contents of  el  and try to reuse as much of the existing tree as possible. Defaults to  false .  There are a few limitations to this feature:    This option cannot be used with  append .    Unescaped HTML mustaches (triples) don't play nicely with enhance because there's no easy way to match up the string content to the target DOM nodes.    All matching elements will be reused, except for a few cases regarding text nodes.  div left text {{#if foo}} middle text {{/if}} right text /div  HTML does not have markup representation for adjacent text nodes. Rendering the snippet above from the server, regardless of  foo 's value, the browser creates one contiguous text node. However, Ractive will need  three  adjacent text nodes to represent it: One for  outer text , another for  right text  and another for  middle text  when  foo  becomes truthy.  It has been suggested that Ractive could deal with merged text nodes, but that would lead to extra complexity as there are certain scenarios where the text node would have to split and rejoin. When  foo  is falsey,  left text  and  right text  could be merged. But when  foo  becomes truthy, that text node would have to split in order to accomodate  middle text .", 
            "title": "enhance"
        }, 
        {
            "location": "/api/initialization-options/#events", 
            "text": "(Object string, Function )  A map of  events  where the key is the event name and value is an event definition.  events: {\n  MyEvent: EventDefinition\n}", 
            "title": "events"
        }, 
        {
            "location": "/api/initialization-options/#interpolators", 
            "text": "(Object string, Function )  A map of  interpolators  where the key is the interpolator name and the value is an interpolator definition.  interpolators: {\n  MyInterpolator: InterpolatorDefinition\n}", 
            "title": "interpolators"
        }, 
        {
            "location": "/api/initialization-options/#isolated", 
            "text": "(boolean)  Controls whether the component will try to  resolve data and plugins on its ancestors . Defaults to  true .  Relevant only to  Components .", 
            "title": "isolated"
        }, 
        {
            "location": "/api/initialization-options/#lazy", 
            "text": "(boolean)  Whether or not to update data using late-firing DOM events (i.e.  change ,  blur ) instead of events that fire immediately on interaction (i.e.  keyup ,  keydown ). Defaults to  false .  Only applicable if  twoway  is  true .  var ractive = new Ractive({\n  template: ' input value= {{foo}} ',\n  data: { foo: 'bar' },\n  lazy: true\n});\n\n// Only fires when input loses focus.\nractive.on('change', function(){\n  console.log('changed!')\n})", 
            "title": "lazy"
        }, 
        {
            "location": "/api/initialization-options/#nestedtransitions", 
            "text": "(boolean)  Whether or not to allow transitions to fire if they are already downstream from a transitioning element. Defaults to  true .  {{#if outer}}\n   div fade-in='slow' \n    Outer text.\n    {{#if inner}}\n       div fly-in= fast Inner text. /div \n    {{/if}}\n   /div \n{{/if}}  In this example, if  inner  is  true  when  outer  becomes  true , then all of the  div s will render at the same time. If  nestedTransitions  is disabled, then the  fly  transition on inner  div  will not be run, since the  fade  will already be running on the outer  div .  This can also be controlled per transition using the  nested  boolean parameter for transitions:  div fade-in= { duration: 'slow', nested: false } ... /div", 
            "title": "nestedTransitions"
        }, 
        {
            "location": "/api/initialization-options/#nocsstransform", 
            "text": "(boolean)  Prevents component CSS from being transformed with scoping guids. Defaults to  false .", 
            "title": "noCSSTransform"
        }, 
        {
            "location": "/api/initialization-options/#nointro", 
            "text": "(boolean)  Whether or not to skip intro transitions on initial render. Defaults to  false .  var ractive = new Ractive({\n  template: ' ul {{#items}} li fade-in {{.}} /li {{/items}} /ul ',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: { fade: function ( t, params ) {...} },\n  noIntro: true\n});\n// 'red' and 'blue' list items do not fade in\n\nractive.push( 'items', 'green' );\n// 'green' list item will fade in", 
            "title": "noIntro"
        }, 
        {
            "location": "/api/initialization-options/#nooutro", 
            "text": "(boolean)  Whether or not to skip outro transitions during an instance unrender. Defaults to  false .  var ractive = new Ractive({\n  template: ' ul {{#items}} li fade-out {{.}} /li {{/items}} /ul ',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: { fade: function ( t, params ) {...} },\n  noOutro: true\n});\n\nractive.pop( 'items' );\n// 'blue' list item will fade out\n\nractive.unrender();\n// 'red' list item will not fade out", 
            "title": "noOutro"
        }, 
        {
            "location": "/api/initialization-options/#observe", 
            "text": "(Object string, Function|Object )  A hash of observers to subscribe during initialization and unsubscribe during teardown. Defaults to  undefined .  The keys of the hash may be any string that is accepted by  ractive.observe() , and the values may be either callback functions, as would be passed to  ractive.observe() , or objects with a  handler  property that is a callback function. The object form also takes other options that control the behavior of the observer.  new Ractive({\n  // ..\n  observe: {\n    show ( value ) {\n      console.log( `show changed to '${value}'` );\n    },\n    'users.*.name people.*.name': {\n      handler ( value, old, path, idx ) {\n        console.log( `${path} changed to '${value}' );\n      },\n      init: false,\n      strict: true\n    }\n  }\n});  The options that may be specified in the object form are (see the  ractive.observe()  docs  for more detailed option descriptions):   handler (Function) : The callback function for the observer.  once (boolean) : Use  ractive.observeOnce()  rather than  ractive.observe()  to install the observer, meaning the observer is implicitly  init: false , will only fire for the first change to the observed path, and will by removed after the first change.  strict (boolean) : Use strict equality when determining whether or not a value has changed.  array (boolean) : Use an array observer rather than a plain observer.  defer (boolean) : Defer the observer until after the DOM is settled.  init (boolean) : Whether or not to fire an initial change event.  links (boolean) : Whether or not to follow links.  context (any) : Context for the callback function.  old (Function) : Modifier function for the  old  value passed to the callback function.   When a sublcass created with  Ractive.extend()  is passed an  observe  hash, then any further subclasses or instances created with an  observe  hash will be combined. Any superclass observers are installed first following the inheritance hierarchy, and finally, any instance observers are installed.", 
            "title": "observe"
        }, 
        {
            "location": "/api/initialization-options/#on", 
            "text": "(Object string, Function|Object )  A hash of event listeners to subscribe during initialization and unsubscribe during teardown. Defaults to  undefined .  The keys of the hash may be any string that is accepted by  ractive.on() , and the values may be either callback functions, as would be passed to  ractive.on() , or objects with a  handler  property that is a callback function. The object form also takes other options that control the behavior of the event handler.  new Ractive({\n  // ...\n  on: {\n    init () {\n      console.log('I will print during init');\n    },\n    '*.somethingHappened': {\n      handler ( ctx ) {\n        console.log('I will fire when this instance or any child component fires an instance event named  somethingHappened ');\n      },\n      once: true\n    }\n  },\n  // ...\n});  The options that may be specified in the object form are:   handler (Function) : The callback function for the event.  once (boolean) : Use  ractive.once()  rather than  ractive.on()  to subscribe the listener, meaning that the handler will only be called the first time the event is fired and then it will be unsubscribed.   on  event listeners may subscribe to any instance event, including lifecycle events  after   construct . When a sublcass created with  Ractive.extend()  is passed an  on  hash, then any further subclasses or instances created with an  on  hash will be combined. Any superclass event handlers are installed first following the inheritance hierarchy, and finally, any instance event handlers are installed.", 
            "title": "on"
        }, 
        {
            "location": "/api/initialization-options/#oncomplete", 
            "text": "(Function)  A lifecycle event that is called when the instance is rendered and all the transitions have completed.", 
            "title": "oncomplete"
        }, 
        {
            "location": "/api/initialization-options/#onconfig", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed and all initialization options have been processed.", 
            "title": "onconfig"
        }, 
        {
            "location": "/api/initialization-options/#onconstruct", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed but before any initialization option has been processed.  Accepts the instance's initialization options as argument.", 
            "title": "onconstruct"
        }, 
        {
            "location": "/api/initialization-options/#ondetach", 
            "text": "(Function)  A lifecycle event that is called whenever  ractive.detach()  is called.  Note that  ractive.insert()  implicitly calls  ractive.detach()  if needed.", 
            "title": "ondetach"
        }, 
        {
            "location": "/api/initialization-options/#oninit", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed and is ready to be rendered.", 
            "title": "oninit"
        }, 
        {
            "location": "/api/initialization-options/#oninsert", 
            "text": "(Function)  A lifecycle event that is called when  ractive.insert()  is called.", 
            "title": "oninsert"
        }, 
        {
            "location": "/api/initialization-options/#onrender", 
            "text": "(Function)  A lifecycle event that is called when the instance is rendered but  before  transitions start.", 
            "title": "onrender"
        }, 
        {
            "location": "/api/initialization-options/#onteardown", 
            "text": "(Function)  A lifecycle event that is called when the instance is being torn down.", 
            "title": "onteardown"
        }, 
        {
            "location": "/api/initialization-options/#onunrender", 
            "text": "(Function)  A lifecycle event that is called when the instance is being undrendered.", 
            "title": "onunrender"
        }, 
        {
            "location": "/api/initialization-options/#onupdate", 
            "text": "(Function)  A lifecycle event that is called when  ractive.update()  is called.", 
            "title": "onupdate"
        }, 
        {
            "location": "/api/initialization-options/#partials", 
            "text": "(Object string, string|Object|Function )  A map of  partials  where the key is the partial name and the value is either a template string, a parsed template object or a function that returns any of the previous options. The function form accepts processed  data  and   Parse Object  as arguments.  partials: {\n  stringPartial: ' p {{greeting}} world! /p ',\n  parsedPartial: { v :3, t :[{ t :7, e : p , f :[{ t :2, r : greeting },  world! ]}]},\n  functionPartial: function(data, p){\n    return data.condition ? ' p hello world /p ' : ' div yes, we have no foo /div ';\n  }\n}  During a  ractive.reset() , function partials are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "partials"
        }, 
        {
            "location": "/api/initialization-options/#preservewhitespace", 
            "text": "(boolean)  Whether or not to preserve whitespace in templates when parsing. Defaults to  false .  Whitespace in  pre  elements is always preserved. The browser will still deal with whitespace in the normal fashion.  var ractive = new Ractive({\n  template: ' p hello\\n\\n  \\tworld    /p ',\n  preserveWhitespace: false //default\n});\n\nconsole.log( ractive.toHTML() );\n//  p hello world /p \n\nvar ractive = new Ractive({\n  template: ' p hello\\n\\n  \\tworld    /p ',\n  preserveWhitespace: true\n});\n\nconsole.log( ractive.toHTML() );\n// p hello\n//\n//  world    /p", 
            "title": "preserveWhitespace"
        }, 
        {
            "location": "/api/initialization-options/#resolveinstancemembers", 
            "text": "(boolean)  Whether or not to include members of the Ractive instance at the end of the reference resolution process. Defaults to  true .  button on-click= toggle('show') Toggle /button   If there is no data member  toggle  in the context of the template, with  resolveInstanceMembers  enabled, the reference will resolve to the  ractive.toggle()  method of the instance.", 
            "title": "resolveInstanceMembers"
        }, 
        {
            "location": "/api/initialization-options/#sanitize", 
            "text": "(boolean|Object)  Whether or not certain elements will be stripped from the template during parsing.  Defaults to  false .  true  strips out blacklisted elements and event attributes. See  Ractive.parse()  for the default list of blacklisted elements.  template: `\n   p some content /p \n   frame Am I a bad element or just misunderstood? /frame \n`,\nsanitize: true\n\n// result:\n//  p some content /p   The object form should have  elements  which is an array of blacklisted elements and  eventAttributes  boolean which, when  true , also strips out event attributes.  template: `\n   p some content /p \n   div onclick= doEvil() the good stuff /div \n`,\nsanitize: {\n  elements: [ 'p' ],\n  eventAttributes: true\n}\n\n// result:\n//  div the good stuff /div", 
            "title": "sanitize"
        }, 
        {
            "location": "/api/initialization-options/#staticdelimiters", 
            "text": "(Array[string])  Sets the static (one-time binding) delimiters. Defaults to  [ '[[', ']]' ] .  var ractive = new Ractive({\n  template: 'hello [[foo]]',\n  staticDelimiters: [ '[[', ']]' ], //default\n  data: { foo: 'world' }\n});\n// result:  hello world \n\nractive.set( 'foo', 'mars' );\n// still is:  hello world", 
            "title": "staticDelimiters"
        }, 
        {
            "location": "/api/initialization-options/#statictripledelimiters", 
            "text": "(Array string )  Sets the static (one-time binding) triple delimiters. Defaults to  [ '[[[', ']]]' ] .  var ractive = new Ractive({\n  template: 'hello [[[html]]]',\n  staticTripleDelimiters: [ '[[[', ']]]' ], //default\n  data: { html: ' span world /span ' }\n});\n// result:  hello  span world /span \n\nractive.set( 'html', ' span mars /span ' );\n// still is:  hello world", 
            "title": "staticTripleDelimiters"
        }, 
        {
            "location": "/api/initialization-options/#stripcomments", 
            "text": "(boolean)  Whether or not to remove comments in templates when parsing. Defaults to  true .  template: ' !-- html comment -- hello world',\nstripComments: false\n\n// result:\n//  !-- html comment -- hello world", 
            "title": "stripComments"
        }, 
        {
            "location": "/api/initialization-options/#synccomputedchildren", 
            "text": "(boolean)  Whether or not to invalidate the dependencies of an expression when child keypaths of the expression are updated. Defaults to  false .  Note : setting this to  true  may cause performance issues for complex expressions involving large arrays.  input value= {{pattern}}  / \n{{#each filter(users, pattern)}}\n   input value= {{.name}}  / \n{{/each}}  In this example, the  input  inside the iteration is bound to a computation e.g.  filter(users, pattern).0.name  that isn't actually an addressable model. With  syncComputedChildren  enabled, when that virtual keypath is updated by a user changing the  input , the expression will invalidate its dependencies ( filter ,  users , and  pattern ), which will cause any other references to the  user  that happens to coincide with result of the expression to also update.", 
            "title": "syncComputedChildren"
        }, 
        {
            "location": "/api/initialization-options/#target", 
            "text": "(string|HTMLElement|array-like)  Alias for  el .", 
            "title": "target"
        }, 
        {
            "location": "/api/initialization-options/#template", 
            "text": "(string|array|object|function)  The  template  to use. Must either be a CSS selector string pointing to an element on the page containing the template, an HTML string, an object resulting from  Ractive.parse()  or a function that returns any of the previous options. The function form accepts processed  data  and a  Parse Object .  // Selector\ntemplate: '#my-template',\n\n// HTML\ntemplate: ' p {{greeting}} world! /p ',\n\n// Template AST\ntemplate: { v :3, t :[{ t :7, e : p , f :[{ t :2, r : greeting },  world! ]}]},\n\n// Function\ntemplate: function(data, p){\n  return ' p {{greeting}} world! /p ';\n},  During a  ractive.reset() , templates provided using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "template"
        }, 
        {
            "location": "/api/initialization-options/#transitions", 
            "text": "(Object string, Function )  A map of  transitions  where the key is the name of the transition and the value is a transition definition.", 
            "title": "transitions"
        }, 
        {
            "location": "/api/initialization-options/#transitionsenabled", 
            "text": "(boolean)  Whether or not transitions are enabled. Defaults to  true .", 
            "title": "transitionsEnabled"
        }, 
        {
            "location": "/api/initialization-options/#tripledelimiters", 
            "text": "(Array[string])  Sets the triple delimiters. Defaults to  [ '{{{', '}}}' ] .  template: 'hello @html@',\ntripleDelimiters: [ '@', '@' ],\ndata: { html: ' span world /span ' }\n\n// result:\n// hello  span world /span", 
            "title": "tripleDelimiters"
        }, 
        {
            "location": "/api/initialization-options/#twoway", 
            "text": "(boolean)  Whether or not  two-way binding  is enabled. Defaults to  true .  var ractive = new Ractive({\n  template: ' input value= {{foo}} ',\n  data: { foo: 'bar' },\n  twoway: false\n});\n\n// user types  fizz  into  input , but data value is not changed:\n\nconsole.log( ractive.get( 'foo' ) ); //logs  bar \n\n// updates from the model are still pushed to the view\n\nractive.set( 'foo', 'fizz' );\n\n// input now displays  fizz", 
            "title": "twoway"
        }, 
        {
            "location": "/api/initialization-options/#warnaboutambiguity", 
            "text": "(boolean)  Whether or not to warn about references that don't resolve to their immediate context. Defaults to  false .  Ambiguous references can be the cause of some strange behavior when your data changes structure slightly. With  warnAboutAmbiguity  enabled, Ractive will warn you any time a reference isn't scoped and resolves in a context above the immediate context of the reference.", 
            "title": "warnAboutAmbiguity"
        }, 
        {
            "location": "/api/static-properties/", 
            "text": "Static Properties\n\n\nRactive.adaptors\n\n\n(Object\nstring, Object\n)\n\n\nThe registry of globally available \nadaptors\n.\n\n\n\n\nRactive.components\n\n\n(Object\nstring, Function\n)\n\n\nThe registry of globally available \ncomponent definitions\n.\n\n\n\n\nRactive.DEBUG\n\n\n(boolean)\n\n\nTells Ractive if it's in debug mode or not. When set to \ntrue\n, non-fatal errors are logged. When set to \nfalse\n, non-fatal errors are suppressed. By default, this is set to \ntrue\n.\n\n\n\n\nRactive.DEBUG_PROMISES\n\n\n(boolean)\n\n\nTells Ractive to log errors thrown inside promises. When set to \ntrue\n, errors thrown in promises are logged. When set to \nfalse\n, errors inside promises are suppressed. By default, this is set to \ntrue\n.\n\n\n\n\nRactive.decorators\n\n\n(Object\nstring, Function\n)\n\n\nThe registry of globally available \ndecorators\n.\n\n\n\n\nRactive.defaults\n\n\n(Object\nstring, any\n)\n\n\nGlobal defaults for \ninitialisation options\n with the exception of \nplugin registries\n.\n\n\n// Change the default mustache delimiters to [[ ]] globally\nRactive.defaults.delimiters = [ '[[', ']]' ];\n\n// Future instances now use [[ ]]\nractive1 = new Ractive({\n    template: 'hello [[world]]'\n});\n\n\n\n\nDefaults can be specified for a subclass of Ractive, overriding global defaults.\n\n\nvar MyRactive = Ractive.extend();\n\nMyRactive.defaults.el = document.body;\n\n\n\n\nConfiguration on the instance overrides subclass and global defaults.\n\n\nRactive.defaults.delimiters = [ '[[', ']]' ];\n\n// Uses the delimiters specified above\nnew Ractive({\n    template: 'hello [[world]]'\n});\n\n// Uses the delimiters specified in the init options\nnew Ractive({\n    template: 'hello //world\\\\',\n    delimiters: [ '//', '\\\\' ]\n});\n\n\n\n\n\n\nRactive.easing\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of \neasing functions\n.\n\n\nThe easing functions are used by the \nractive.animate\n method and by \ntransitions\n. Four are included by default: \nlinear\n, \neaseIn\n, \neaseOut\n and \neaseInOut\n.\n\n\n\n\nRactive.events\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of custom \nevent\n plugins.\n\n\n\n\nRactive.interpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n or non-CSS transitions.\n\n\n\n\nRactive.partials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nThe global registry of \npartial templates\n.\n\n\nLike \ntemplates\n, partials are \nparsed\n at the point of use. The parsed output is cached and utilized for future use.\n\n\n\n\nRactive.svg\n\n\n(boolean)\n\n\nIndicates whether or not the browser supports SVG.\n\n\n\n\nRactive.transitions\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of \ntransition functions\n.\n\n\n\n\nRactive.VERSION\n\n\n(string)\n\n\nThe version of the currently loaded Ractive.", 
            "title": "Static Properties"
        }, 
        {
            "location": "/api/static-properties/#static-properties", 
            "text": "", 
            "title": "Static Properties"
        }, 
        {
            "location": "/api/static-properties/#ractiveadaptors", 
            "text": "(Object string, Object )  The registry of globally available  adaptors .", 
            "title": "Ractive.adaptors"
        }, 
        {
            "location": "/api/static-properties/#ractivecomponents", 
            "text": "(Object string, Function )  The registry of globally available  component definitions .", 
            "title": "Ractive.components"
        }, 
        {
            "location": "/api/static-properties/#ractivedebug", 
            "text": "(boolean)  Tells Ractive if it's in debug mode or not. When set to  true , non-fatal errors are logged. When set to  false , non-fatal errors are suppressed. By default, this is set to  true .", 
            "title": "Ractive.DEBUG"
        }, 
        {
            "location": "/api/static-properties/#ractivedebug_promises", 
            "text": "(boolean)  Tells Ractive to log errors thrown inside promises. When set to  true , errors thrown in promises are logged. When set to  false , errors inside promises are suppressed. By default, this is set to  true .", 
            "title": "Ractive.DEBUG_PROMISES"
        }, 
        {
            "location": "/api/static-properties/#ractivedecorators", 
            "text": "(Object string, Function )  The registry of globally available  decorators .", 
            "title": "Ractive.decorators"
        }, 
        {
            "location": "/api/static-properties/#ractivedefaults", 
            "text": "(Object string, any )  Global defaults for  initialisation options  with the exception of  plugin registries .  // Change the default mustache delimiters to [[ ]] globally\nRactive.defaults.delimiters = [ '[[', ']]' ];\n\n// Future instances now use [[ ]]\nractive1 = new Ractive({\n    template: 'hello [[world]]'\n});  Defaults can be specified for a subclass of Ractive, overriding global defaults.  var MyRactive = Ractive.extend();\n\nMyRactive.defaults.el = document.body;  Configuration on the instance overrides subclass and global defaults.  Ractive.defaults.delimiters = [ '[[', ']]' ];\n\n// Uses the delimiters specified above\nnew Ractive({\n    template: 'hello [[world]]'\n});\n\n// Uses the delimiters specified in the init options\nnew Ractive({\n    template: 'hello //world\\\\',\n    delimiters: [ '//', '\\\\' ]\n});", 
            "title": "Ractive.defaults"
        }, 
        {
            "location": "/api/static-properties/#ractiveeasing", 
            "text": "(Object string, Function )  The global registry of  easing functions .  The easing functions are used by the  ractive.animate  method and by  transitions . Four are included by default:  linear ,  easeIn ,  easeOut  and  easeInOut .", 
            "title": "Ractive.easing"
        }, 
        {
            "location": "/api/static-properties/#ractiveevents", 
            "text": "(Object string, Function )  The global registry of custom  event  plugins.", 
            "title": "Ractive.events"
        }, 
        {
            "location": "/api/static-properties/#ractiveinterpolators", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate()  or non-CSS transitions.", 
            "title": "Ractive.interpolators"
        }, 
        {
            "location": "/api/static-properties/#ractivepartials", 
            "text": "(Object string, string|Object|Function )  The global registry of  partial templates .  Like  templates , partials are  parsed  at the point of use. The parsed output is cached and utilized for future use.", 
            "title": "Ractive.partials"
        }, 
        {
            "location": "/api/static-properties/#ractivesvg", 
            "text": "(boolean)  Indicates whether or not the browser supports SVG.", 
            "title": "Ractive.svg"
        }, 
        {
            "location": "/api/static-properties/#ractivetransitions", 
            "text": "(Object string, Function )  The global registry of  transition functions .", 
            "title": "Ractive.transitions"
        }, 
        {
            "location": "/api/static-properties/#ractiveversion", 
            "text": "(string)  The version of the currently loaded Ractive.", 
            "title": "Ractive.VERSION"
        }, 
        {
            "location": "/api/static-methods/", 
            "text": "Static Methods\n\n\nRactive.escapeKey()\n\n\nEscapes the given key so that it can be concatenated with a keypath string.\n\n\nSyntax\n\n\n\n\nRactive.escapeKey(key)\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: The key to escape.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The escaped key.\n\n\n\n\nExamples\n\n\nRactive.escapeKey('foo.bar'); // foo\\.bar\n\n\n\n\n\n\nRactive.extend()\n\n\nCreates a \"subclass\" of the Ractive constructor or a subclass constructor. See \nComponents\n for an in-depth discussion on the use of \nRactive.extend\n.\n\n\nSyntax\n\n\n\n\nRactive.extend([options[, ...optionsN]])\n\n\n\n\nArguments\n\n\n\n\n[options] (Object)\n: One or more objects that represent the defaults for instances of the subclass, with the latter objects' properties taking precedence over the former. See \nInitialization Options\n for a list of possible options.\n\n\n\n\nReturns\n\n\n\n\n(Function)\n: The subclass constructor function.\n\n\n\n\nExamples\n\n\nconst SubClass = Ractive.extend({\n    template: '\ndiv\n{{message}}\n/div\n',\n    data: {\n        message: 'Hello World!'\n    }\n});\n\n// \ndiv\nHello World!\n/div\n\nconst instance1 = new SubClass({\n    el: '.div1'\n});\n\n// \ndiv\nLorem Ipsum\n/div\n\nconst instance2 = new SubClass({\n    el: '.div2',\n    data: {\n        message: 'Lorem Ipsum'\n    }\n});\n\n\n\n\n\n\nRactive.extendWith()\n\n\nCreates a \"subclass\" of the Ractive constructor or a subclass constructor using an existing constructor. The constructor will be augmented with static methods like \nextend\n, and it will also process the given initialization options.\n\n\nSyntax\n\n\n\n\nRactive.extendWith(constructor[, options])\n\n\n\n\nArguments\n\n\n\n\nconstructor (Function)\n: A class constructor - like an ES6 \nclass\n, a plain JavaScript function with a prototpye, or another similarly constructed function (TypeScript, CoffeeScript, etc).\n\n\noptions (Object)\n: An object with initialization options as properties. See \ninitialization options\n for a list of possible options.\n\n\n\n\nReturns\n\n\n\n\n(Function)\n: The augmented constructor function.\n\n\n\n\nExamples\n\n\nclass Widget {\n  notify ( message ) {\n    this.push( 'messages', message );\n  }\n\n  show () {\n    this.set( 'visible', true );\n  }\n\n  hide () {\n    this.set( 'visible', false );\n  }\n}\n\nRactive.extendWith( Widget, {\n  template: '{{#if visible}}\nul\n{{#each messages}}\nli\n{{.}}\n/li\n{{/each}}\n/ul\n{{/if}}'\n});\n\n\n\n\n\n\nRactive.getCSS()\n\n\nReturns the scoped CSS from Ractive subclasses defined at the time of the call.\n\n\nIf used without arguments, it will return the scoped CSS of all subclasses. If provided an array of scoping IDs, it will return the scoped CSS of all subclasses whose scoping ID is included in the array.\n\n\nSyntax\n\n\n\n\nRactive.getCSS([key])\n\n\n\n\nArguments\n\n\n\n\n[key] (Array\nstring\n)\n: Subclass CSS scoping ID.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The scoped CSS.\n\n\n\n\nExamples\n\n\n// Assuming the generated ID for this subclass is 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.\nconst Subclass1 = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\n// Assuming the generated ID for this subclass is 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy'.\nconst Subclass2 = Ractive.extend({\n    ...\n    css: 'div{ color: green }'\n    ...\n});\n\n// CSS contains the scoped versions of div{ color: red } and div{ color: green }.\nconst css = Ractive.getCSS();\n\n// css contains the scoped version of div{ color: red } only.\nconst css = Ractive.getCSS([ 'xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' ]);\n\n\n\n\n\n\n\nRactive.getContext()\n\n\nAccepts a node and returns a \nContext\n object containing details of the Ractive instance the node is associated to.\n\n\nSyntax\n\n\n\n\nRactive.getContext(node)\n\n\n\n\nArguments\n\n\n\n\nnode (string|Node)\n: The DOM node or a CSS selector of the DOM node for which you wish to retrieve the Ractive instance or view details.\n\n\n\n\nReturns\n\n\n\n\n(Context)\n: A \ncontext\n object.\n\n\n\n\nExamples\n\n\nconst info = Ractive.getContext(document.getElementById('some-node'));\n\nconst info = Ractive.getContext('#some-node');\n\n\n\n\n\n\nRactive.joinKeys()\n\n\nJoins the given keys into a properly escaped keypath.\n\n\nSyntax\n\n\n\n\nRactive.joinKeys(key1 [, ...keyN])\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: One or more strings to join.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: A properly joined and escaped keypath.\n\n\n\n\nExamples\n\n\nRactive.joinKeys( 'foo', 'bar.baz' ); // foo.bar\\.baz\n\n\n\n\n\n\nRactive.parse()\n\n\nParses the template into an abstract syntax tree that Ractive can work on.\n\n\nSyntax\n\n\n\n\nRactive.parse(template[, options])\n\n\n\n\nArguments\n\n\n\n\ntemplate (string)\n: A Ractive-compliant HTML template.\n\n\n[options] (Object)\n: Parser options.\n\n\n[delimiters] ([string])\n: Start and end delimiters for normal mustaches. Defaults to \n['{{', '}}']\n.\n\n\n[tripleDelimiters] ([string])\n: Start and end delimiters for triple mustaches. Defaults to \n['{{{', '}}}']\n.\n\n\n[staticDelimiters] ([string])\n: Start and end delimiters for static mustaches. Defaults to \n['[[', ']]']\n.\n\n\n[staticTripleDelimiters] ([string])\n: Start and end delimiters for static triple mustaches. Defaults to \n['[[[', ']]]']\n.\n\n\n[contextLines] (integer)\n: Additional lines above and below a line with a parse error to include in the error output. Defaults to \n0\n.\n\n\n[interpolate] (Object\nstring, boolean\n)\n: Map of elements that indicates whether or not to read mustaches within the element. Defaults to \n{ script: false, textarea: true, template: false, style: false }\n.\n\n\n[csp]\n(boolean)\n: When\ntrue\nincludes pre-compiled expression functions in the template output so that\neval\nis not needed at runtime. Defaults to\ntrue`.\n\n\n[preserveWhitespace] (boolean)\n: When \ntrue\n, preserves whitespace in templates. Whitespace inside the \npre\n element is preserved regardless of the value of this option. Defaults to \nfalse\n.\n\n\n[stripComments] (boolean)\n: When \nfalse\n will leave comments in the parsed template. Defaults to \ntrue\n.\n\n\n[sanitize] (boolean|Object)\n: When \ntrue\n, strips inline event attributes and certain elements from the markup. Defaults to \nfalse\n.\n\n\n[elements] (Array\nstring\n)\n: An array of element names to blacklist.\n\n\n[eventAttributes] (boolean)\n: When \ntrue\n, strips off inline event attributes.\n\n\n\n\n\n\n[includeLinePositions] (boolean)\n: When \ntrue\n will include line positions on each node of the parser output. Defaults to \nfalse\n.\n\n\n[textOnlyMode] (boolean)\n: When \ntrue\n parses elements as text rather than elements. This is useful for generating raw HTML from a template, more like a plain text templating processor. Defaults to \nfalse\n.\n\n\n[transforms|parserTransforms] ([Function])`: An array of post-parsing transforms to apply to the output parser AST.\n\n\n\n\n\n\n\n\nWhen \nsanitize\n is \ntrue\n, the following elements are stripped:\n\n\n\n\napplet\n\n\nbase\n\n\nbasefont\n\n\nbody\n\n\nframe\n\n\nframeset\n\n\nhead\n\n\nhtml\n\n\nisindex\n\n\nlink\n\n\nmeta\n\n\nnoframes\n\n\nnoscript\n\n\nobject\n\n\nparam\n\n\nscript\n\n\nstyle\n\n\ntitle\n\n\n\n\nReturns\n\n\n\n\n(Object)\n - The object representation of the provided markup.\n\n\n\n\nExamples\n\n\nAssume the following markup.\n\n\ndiv class='gallery'\n\n  {{#each items}}\n    \n!-- comments get stripped out of the template --\n\n    \nfigure on-tap='select' staggered-in\n\n      \nimg class='thumbnail' src='assets/images/{{id}}.jpg'\n\n      \nfigcaption\n{{( @index+1 )}}: {{description}}\n/figcaption\n\n    \n/figure\n\n  {{/each}}\n\n/div\n\n\n\n\n\nRactive.parse( template );\n will yield the following output:\n\n\n{\nv\n:4,\nt\n:[{\nt\n:7,\ne\n:\ndiv\n,\nm\n:[{\nn\n:\nclass\n,\nf\n:\ngallery\n,\nt\n:13}],\nf\n:[{\nt\n:4,\nf\n:[\n \n,{\nt\n:7,\ne\n:\nfigure\n,\nm\n:[{\nn\n:[\ntap\n],\nt\n:70,\nf\n:\nselect\n},{\nn\n:\nstaggered\n,\nt\n:72,\nv\n:\nt1\n}],\nf\n:[{\nt\n:7,\ne\n:\nimg\n,\nm\n:[{\nn\n:\nclass\n,\nf\n:\nthumbnail\n,\nt\n:13},{\nn\n:\nsrc\n,\nf\n:[\nassets/images/\n,{\nt\n:2,\nr\n:\nid\n},\n.jpg\n],\nt\n:13}]},\n \n,{\nt\n:7,\ne\n:\nfigcaption\n,\nf\n:[{\nt\n:2,\nx\n:{\nr\n:[\n@index\n],\ns\n:\n_0+1\n}},\n: \n,{\nt\n:2,\nr\n:\ndescription\n}]}]}],\nn\n:52,\nr\n:\nitems\n}]}],\ne\n:{'_0+1': function(_0) { return _0+1; }}}\n\n\n\n\n\n\nRactive.splitKeypath()\n\n\nSplits the given keypath into an array of unescaped keys.\n\n\nSyntax\n\n\n\n\nRactive.splitKeypath(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to split into keys.\n\n\n\n\nReturns\n\n\n\n\n(Array)\n: Returns an array of unescaped keys.\n\n\n\n\nExamples\n\n\nRactive.splitKeypath( 'foo.bar\\.baz' ); // [ 'foo', 'bar.baz' ]\n\n\n\n\n\n\nRactive.unescapeKey()\n\n\nUnescapes the given key e.g. \nfoo\\.bar\n =\n \nfoo.bar\n.\n\n\nSyntax\n\n\n\n\nRactive.unescapeKey(key)\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: The key to unescape.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The unescaped key.\n\n\n\n\nExamples\n\n\nRactive.unescapeKey('foo\\.bar'); // foo.bar", 
            "title": "Static Methods"
        }, 
        {
            "location": "/api/static-methods/#static-methods", 
            "text": "", 
            "title": "Static Methods"
        }, 
        {
            "location": "/api/static-methods/#ractiveescapekey", 
            "text": "Escapes the given key so that it can be concatenated with a keypath string.  Syntax   Ractive.escapeKey(key)   Arguments   key (string) : The key to escape.   Returns   (string) : The escaped key.   Examples  Ractive.escapeKey('foo.bar'); // foo\\.bar", 
            "title": "Ractive.escapeKey()"
        }, 
        {
            "location": "/api/static-methods/#ractiveextend", 
            "text": "Creates a \"subclass\" of the Ractive constructor or a subclass constructor. See  Components  for an in-depth discussion on the use of  Ractive.extend .  Syntax   Ractive.extend([options[, ...optionsN]])   Arguments   [options] (Object) : One or more objects that represent the defaults for instances of the subclass, with the latter objects' properties taking precedence over the former. See  Initialization Options  for a list of possible options.   Returns   (Function) : The subclass constructor function.   Examples  const SubClass = Ractive.extend({\n    template: ' div {{message}} /div ',\n    data: {\n        message: 'Hello World!'\n    }\n});\n\n//  div Hello World! /div \nconst instance1 = new SubClass({\n    el: '.div1'\n});\n\n//  div Lorem Ipsum /div \nconst instance2 = new SubClass({\n    el: '.div2',\n    data: {\n        message: 'Lorem Ipsum'\n    }\n});", 
            "title": "Ractive.extend()"
        }, 
        {
            "location": "/api/static-methods/#ractiveextendwith", 
            "text": "Creates a \"subclass\" of the Ractive constructor or a subclass constructor using an existing constructor. The constructor will be augmented with static methods like  extend , and it will also process the given initialization options.  Syntax   Ractive.extendWith(constructor[, options])   Arguments   constructor (Function) : A class constructor - like an ES6  class , a plain JavaScript function with a prototpye, or another similarly constructed function (TypeScript, CoffeeScript, etc).  options (Object) : An object with initialization options as properties. See  initialization options  for a list of possible options.   Returns   (Function) : The augmented constructor function.   Examples  class Widget {\n  notify ( message ) {\n    this.push( 'messages', message );\n  }\n\n  show () {\n    this.set( 'visible', true );\n  }\n\n  hide () {\n    this.set( 'visible', false );\n  }\n}\n\nRactive.extendWith( Widget, {\n  template: '{{#if visible}} ul {{#each messages}} li {{.}} /li {{/each}} /ul {{/if}}'\n});", 
            "title": "Ractive.extendWith()"
        }, 
        {
            "location": "/api/static-methods/#ractivegetcss", 
            "text": "Returns the scoped CSS from Ractive subclasses defined at the time of the call.  If used without arguments, it will return the scoped CSS of all subclasses. If provided an array of scoping IDs, it will return the scoped CSS of all subclasses whose scoping ID is included in the array.  Syntax   Ractive.getCSS([key])   Arguments   [key] (Array string ) : Subclass CSS scoping ID.   Returns   (string) : The scoped CSS.   Examples  // Assuming the generated ID for this subclass is 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.\nconst Subclass1 = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\n// Assuming the generated ID for this subclass is 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy'.\nconst Subclass2 = Ractive.extend({\n    ...\n    css: 'div{ color: green }'\n    ...\n});\n\n// CSS contains the scoped versions of div{ color: red } and div{ color: green }.\nconst css = Ractive.getCSS();\n\n// css contains the scoped version of div{ color: red } only.\nconst css = Ractive.getCSS([ 'xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' ]);", 
            "title": "Ractive.getCSS()"
        }, 
        {
            "location": "/api/static-methods/#ractivegetcontext", 
            "text": "Accepts a node and returns a  Context  object containing details of the Ractive instance the node is associated to.  Syntax   Ractive.getContext(node)   Arguments   node (string|Node) : The DOM node or a CSS selector of the DOM node for which you wish to retrieve the Ractive instance or view details.   Returns   (Context) : A  context  object.   Examples  const info = Ractive.getContext(document.getElementById('some-node'));\n\nconst info = Ractive.getContext('#some-node');", 
            "title": "Ractive.getContext()"
        }, 
        {
            "location": "/api/static-methods/#ractivejoinkeys", 
            "text": "Joins the given keys into a properly escaped keypath.  Syntax   Ractive.joinKeys(key1 [, ...keyN])   Arguments   key (string) : One or more strings to join.   Returns   (string) : A properly joined and escaped keypath.   Examples  Ractive.joinKeys( 'foo', 'bar.baz' ); // foo.bar\\.baz", 
            "title": "Ractive.joinKeys()"
        }, 
        {
            "location": "/api/static-methods/#ractiveparse", 
            "text": "Parses the template into an abstract syntax tree that Ractive can work on.  Syntax   Ractive.parse(template[, options])   Arguments   template (string) : A Ractive-compliant HTML template.  [options] (Object) : Parser options.  [delimiters] ([string]) : Start and end delimiters for normal mustaches. Defaults to  ['{{', '}}'] .  [tripleDelimiters] ([string]) : Start and end delimiters for triple mustaches. Defaults to  ['{{{', '}}}'] .  [staticDelimiters] ([string]) : Start and end delimiters for static mustaches. Defaults to  ['[[', ']]'] .  [staticTripleDelimiters] ([string]) : Start and end delimiters for static triple mustaches. Defaults to  ['[[[', ']]]'] .  [contextLines] (integer) : Additional lines above and below a line with a parse error to include in the error output. Defaults to  0 .  [interpolate] (Object string, boolean ) : Map of elements that indicates whether or not to read mustaches within the element. Defaults to  { script: false, textarea: true, template: false, style: false } .  [csp] (boolean) : When true includes pre-compiled expression functions in the template output so that eval is not needed at runtime. Defaults to true`.  [preserveWhitespace] (boolean) : When  true , preserves whitespace in templates. Whitespace inside the  pre  element is preserved regardless of the value of this option. Defaults to  false .  [stripComments] (boolean) : When  false  will leave comments in the parsed template. Defaults to  true .  [sanitize] (boolean|Object) : When  true , strips inline event attributes and certain elements from the markup. Defaults to  false .  [elements] (Array string ) : An array of element names to blacklist.  [eventAttributes] (boolean) : When  true , strips off inline event attributes.    [includeLinePositions] (boolean) : When  true  will include line positions on each node of the parser output. Defaults to  false .  [textOnlyMode] (boolean) : When  true  parses elements as text rather than elements. This is useful for generating raw HTML from a template, more like a plain text templating processor. Defaults to  false .  [transforms|parserTransforms] ([Function])`: An array of post-parsing transforms to apply to the output parser AST.     When  sanitize  is  true , the following elements are stripped:   applet  base  basefont  body  frame  frameset  head  html  isindex  link  meta  noframes  noscript  object  param  script  style  title   Returns   (Object)  - The object representation of the provided markup.   Examples  Assume the following markup.  div class='gallery' \n  {{#each items}}\n     !-- comments get stripped out of the template -- \n     figure on-tap='select' staggered-in \n       img class='thumbnail' src='assets/images/{{id}}.jpg' \n       figcaption {{( @index+1 )}}: {{description}} /figcaption \n     /figure \n  {{/each}} /div   Ractive.parse( template );  will yield the following output:  { v :4, t :[{ t :7, e : div , m :[{ n : class , f : gallery , t :13}], f :[{ t :4, f :[   ,{ t :7, e : figure , m :[{ n :[ tap ], t :70, f : select },{ n : staggered , t :72, v : t1 }], f :[{ t :7, e : img , m :[{ n : class , f : thumbnail , t :13},{ n : src , f :[ assets/images/ ,{ t :2, r : id }, .jpg ], t :13}]},   ,{ t :7, e : figcaption , f :[{ t :2, x :{ r :[ @index ], s : _0+1 }}, :  ,{ t :2, r : description }]}]}], n :52, r : items }]}], e :{'_0+1': function(_0) { return _0+1; }}}", 
            "title": "Ractive.parse()"
        }, 
        {
            "location": "/api/static-methods/#ractivesplitkeypath", 
            "text": "Splits the given keypath into an array of unescaped keys.  Syntax   Ractive.splitKeypath(keypath)   Arguments   keypath (string) : The keypath to split into keys.   Returns   (Array) : Returns an array of unescaped keys.   Examples  Ractive.splitKeypath( 'foo.bar\\.baz' ); // [ 'foo', 'bar.baz' ]", 
            "title": "Ractive.splitKeypath()"
        }, 
        {
            "location": "/api/static-methods/#ractiveunescapekey", 
            "text": "Unescapes the given key e.g.  foo\\.bar  =   foo.bar .  Syntax   Ractive.unescapeKey(key)   Arguments   key (string) : The key to unescape.   Returns   (string) : The unescaped key.   Examples  Ractive.unescapeKey('foo\\.bar'); // foo.bar", 
            "title": "Ractive.unescapeKey()"
        }, 
        {
            "location": "/api/instance-properties/", 
            "text": "Instance Properties\n\n\nractive.adaptors\n\n\n(Object\nstring, Object\n)\n\n\nThe instance-only registry of \nadaptors\n.\n\n\n\n\nractive.components\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \ncomponents\n.\n\n\n\n\nractive.container\n\n\n(Ractive)\n\n\nEach component instance that is in a yielded fragment has a container instance that is accessible using \nthis.container\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nIf \nbar\n \n{{yield}}\ns, then \nbaz\n's container will be the \nfoo\n instance.\n\n\n\n\nractive.decorators\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \ndecorators\n.\n\n\n\n\nractive.easing\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \neasing functions\n.\n\n\n\n\nractive.events\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of custom \nevent\n plugins.\n\n\n\n\nractive.interpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n or non-CSS transitions.\n\n\n\n\nractive.parent\n\n\n(Ractive)\n\n\nEach component instance can access its parent using \nthis.parent\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nbaz\n's parent is the \nbar\n instance, and \nbar\n's parent is the \nfoo\n instance.\n\n\n\n\nractive.partials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nThe instance-only registry of \npartials\n.\n\n\n\n\nractive.root\n\n\n(Ractive)\n\n\nEach component instance can access its root Ractive instance using \nthis.root\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nfoo\n, \nbar\n, and \nbaz\n will all have the Ractive instance with this template as their \nroot\n.\n\n\n\n\nractive.transitions\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \ntransitions\n.", 
            "title": "Instance Properties"
        }, 
        {
            "location": "/api/instance-properties/#instance-properties", 
            "text": "", 
            "title": "Instance Properties"
        }, 
        {
            "location": "/api/instance-properties/#ractiveadaptors", 
            "text": "(Object string, Object )  The instance-only registry of  adaptors .", 
            "title": "ractive.adaptors"
        }, 
        {
            "location": "/api/instance-properties/#ractivecomponents", 
            "text": "(Object string, Function )  The instance-only registry of  components .", 
            "title": "ractive.components"
        }, 
        {
            "location": "/api/instance-properties/#ractivecontainer", 
            "text": "(Ractive)  Each component instance that is in a yielded fragment has a container instance that is accessible using  this.container .  foo \n   bar \n     baz / \n   /bar  /foo   If  bar   {{yield}} s, then  baz 's container will be the  foo  instance.", 
            "title": "ractive.container"
        }, 
        {
            "location": "/api/instance-properties/#ractivedecorators", 
            "text": "(Object string, Function )  The instance-only registry of  decorators .", 
            "title": "ractive.decorators"
        }, 
        {
            "location": "/api/instance-properties/#ractiveeasing", 
            "text": "(Object string, Function )  The instance-only registry of  easing functions .", 
            "title": "ractive.easing"
        }, 
        {
            "location": "/api/instance-properties/#ractiveevents", 
            "text": "(Object string, Function )  The instance-only registry of custom  event  plugins.", 
            "title": "ractive.events"
        }, 
        {
            "location": "/api/instance-properties/#ractiveinterpolators", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate()  or non-CSS transitions.", 
            "title": "ractive.interpolators"
        }, 
        {
            "location": "/api/instance-properties/#ractiveparent", 
            "text": "(Ractive)  Each component instance can access its parent using  this.parent .  foo \n   bar \n     baz / \n   /bar  /foo   baz 's parent is the  bar  instance, and  bar 's parent is the  foo  instance.", 
            "title": "ractive.parent"
        }, 
        {
            "location": "/api/instance-properties/#ractivepartials", 
            "text": "(Object string, string|Object|Function )  The instance-only registry of  partials .", 
            "title": "ractive.partials"
        }, 
        {
            "location": "/api/instance-properties/#ractiveroot", 
            "text": "(Ractive)  Each component instance can access its root Ractive instance using  this.root .  foo \n   bar \n     baz / \n   /bar  /foo   foo ,  bar , and  baz  will all have the Ractive instance with this template as their  root .", 
            "title": "ractive.root"
        }, 
        {
            "location": "/api/instance-properties/#ractivetransitions", 
            "text": "(Object string, Function )  The instance-only registry of  transitions .", 
            "title": "ractive.transitions"
        }, 
        {
            "location": "/api/instance-methods/", 
            "text": "Instance Methods\n\n\nractive._super()\n\n\nCalls the parent method from a child method of the same name.\n\n\nractive._super()\n is not always available. Only when Ractive detects its use does it make this reference to the parent method.\n\n\nSyntax\n\n\n\n\nractive._super([arg[, ...argN]])\n\n\n\n\nArguments\n\n\n\n\n[arg] (any)\n: One or more arguments to pass to the function.\n\n\n\n\nReturns\n\n\n\n\n(any)\n: Depends on the method called.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n    oninit: function() {\n        console.log('super init')\n    }\n});\n\nvar SubComponent = Component.extend({\n    oninit: function() {\n        this._super();\n        console.log('sub init');\n    }\n})\n\nnew SubComponent();\n\n\n\n\n\n\nractive.add()\n\n\nIncrements the selected keypath.\n\n\nSyntax\n\n\n\n\nractive.add(keypath[, number])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the number we're incrementing.\n\n\n[number] (number)\n: The number to increment by. Defaults to \n1\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when any transitions associated with the operation complete.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    r.add('counter');\n    console.log(r.get('counter'));\n}, 1000);\n\nsetTimeout(function() {\n    r.add('counter', 10);\n    console.log(r.get('counter'));\n}, 2000);\n\n\n\n\n\n\nractive.animate()\n\n\nSimilar to \nractive.set()\n, this will update the data and re-render any affected mustaches and notify observers.\n\n\nAll animations are handled by a global timer that is shared between Ractive instances (and which only runs if there are one or more animations still in progress), so you can trigger as many separate animations as you like without worrying about timer congestion. Where possible, \nrequestAnimationFrame\n is used rather than \nsetTimeout\n.\n\n\nNumeric values and strings that can be parsed as numeric values can be interpolated. Objects and arrays containing numeric values (or other objects and arrays which themselves contain numeric values, and so on recursively) are also interpolated.\n\n\nNote that there is currently no mechanism for detecting cyclical structures! Animating to a value that indirectly references itself will cause an infinite loop.\n\n\nFuture versions of Ractive may include string interpolators - e.g. for SVG paths, colours, transformations and so on, a la D3 - and the ability to pass in your own interpolator.\n\n\nIf an animation is started on a keypath which is \nalready\n being animated, the first animation is cancelled. (Currently, there is no mechanism in place to prevent collisions between e.g. \nractive.animate('foo', { bar: 1 })\n and \nractive.animate('foo.bar', 0)\n.)\n\n\nSyntax\n\n\n\n\nractive.animate(keypath, value[, options])\n\n\nractive.animate(map[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to animate.\n\n\nvalue (number|string|Object|Array)\n: The value to animate to.\n\n\nmap (Object)\n: A key-value hash of keypath and value.\n\n\n[options] (Object)\n:\n\n\n[duration] (number)\n: How many milliseconds the animation should run for. Defaults to \n400\n.\n\n\n[easing] (string|Function)\n: The name of an easing function or the easing function itself. Defaults to \nlinear\n.\n\n\n[step] (Function)\n: A function to be called on each step of the animation. Receives \nt\n and \nvalue\n as arguments, where \nt\n is the animation progress (between \n0\n and \n1\n, as determined by the easing function) and \nvalue\n is the intermediate value at \nt\n.\n\n\n[complete] (Function)\n: A function to be called when the animation completes, with the same argument signature as \nstep\n (i.e. \nt\n is \n1\n, and \nvalue\n is the destination value)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a Promise with an additional \nstop\n method, which cancels the animation.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    r.animate('counter', 20, { duration: 2000 });\n}, 1000);\n\n\n\n\n\n\nractive.attachChild()\n\n\nCreates a parent-child relationship between two Ractive instances. The child may be an instance of a component defined by \nRactive.extend()\n, but that is not a requirement, as children may be a plain Ractive instance created with \nnew Ractive()\n.\n\n\nSyntax\n\n\nractive.attachChild( child );\nractive.attachChild( child, options );\n\n\n\n\nArguments\n\n\n\n\nchild (Ractive instance)\n: The child instance to attach.\n\n\n[options] (Object)\n:\n\n\n[target] (string)\n: An anchor name at which to render the instance. See \nComponents\n. If the instance is already rendered, it will be unrendered and re-rendered at an appropriate anchor.\n\n\n[append] (boolean)\n: Default \ntrue\n - add the instance to the end of the list for the targeted anchor.\n\n\n[prepend] (boolean)\n: Add the instance to the beginning of the list for the targeted anchor.\n\n\n[insertAt] (number)\n: Index at which to add the instance in the list for the targeted anchor.\n\n\n\n\n\n\n\n\nWhen a child is attached to a parent, the child's \nparent\n property is updated in an observable way, so any references to \n@this.parent\n in the child will be notified of the change.\n\n\nA child may be targeted to a \nComponents\n when it is attached. If a child has no specified target, then it is responsible for managing its own render cycle. If a child does have a specified target, then the parent will manage rendering and unrendering the child as appropriate in the same way that a regular component has a managed render cycle.\n\n\nWhen a child is attached targeting an anchor, only anchors that belong directly to the parent are considered as hosts. However, any element or component queries on the parent instance, including live queries, will consider the child when trying to match both elements and components. There is also an option on the query methods that allows querying remote, unmanaged instances, so that non-anchored children can also be queried for elements and components.\n\n\nReturns\n\n\n\n\n(Promise)\n: A \nPromise\n that resolves with the child instance when any transitions are complete.\n\n\n\n\nChildren can be detached using \nractive.detachChild()\n.\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.detach()\n\n\nDetaches the instance from the DOM, returning a document fragment. You can reinsert it, possibly in a different place, with \nractive.insert()\n (note that if you are reinserting it immediately you don't need to detach it first - it will happen automatically).\n\n\nSyntax\n\n\n\n\nractive.detach()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(DocumentFragment)\n: A document fragment.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    var div = document.createElement('div');\n    div.appendChild(r.detach());\n    console.log(div.innerHTML);\n}, 1000);\n\n\n\n\n\n\nractive.detachChild()\n\n\nDetaches a child from an instance when it was previously attached with \nractive.attachChild()\n.\n\n\nWhen a child instance that was attached targeting an anchor is detached, its instance is spliced out of the \n@this.children.byName.anchorName\n array so that subsequent children move forward to fill the void.\n\n\nSyntax\n\n\n\n\nractive.detachChild( child )\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A \nPromise\n that resolves with the child instance when any transitions are complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.find()\n\n\nReturns the first element inside a given Ractive instance matching a CSS selector. This is similar to doing \nthis.el.querySelector(selector)\n (though it doesn't actually use \nquerySelector()\n).\n\n\nSyntax\n\n\n\n\nractive.find(selector[, options])\n\n\n\n\nArguments\n\n\n\n\nselector (string)\n: A CSS selector representing the element to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean}\n: Include attached children that are not rendered in anchors when looking for matching elements. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Node)\n: A Node.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl'\n});\n\nsetTimeout(function() {\n    var p = r.find('p.target');\n    console.log(p.outerHTML);\n}, 1000);\n\n\n\n\n\n\nractive.findAll()\n\n\nThis method is similar to [\nractive.find()\n]ractivefind), with an important difference - it returns a list of elements matching the selector, rather than a single node.\n\n\nSyntax\n\n\n\n\nractive.findAll(selector[, options])\n\n\n\n\nArguments\n\n\n\n\nselector (string)\n: A CSS selector representing the elements to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean)\n: Include attached children that are not rendered in anchors when searching for elements. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Array\nNode\n)\n: An array of nodes.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl'\n});\n\nsetTimeout(function() {\n    var ps = r.findAll('p');\n    ps.forEach(function(p) {\n        console.log(p.outerHTML);\n    })\n}, 1000);\n\n\n\n\n\n\nractive.findAllComponents()\n\n\nReturns all components inside a given Ractive instance with the given \nname\n (or all components of any kind if no name is given).\n\n\nSyntax\n\n\n\n\nractive.findAllComponents([name[, options]])\n\n\n\n\nArguments\n\n\n\n\n[name] (string)\n: The name of the component to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean)\n: Include attached children that are not rendered in anchors when searching components. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Array\nractive\n)\n: An array of ractive instances.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n    template: 'Component {{number}}'\n});\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    components: {\n        Component: Component\n    }\n});\n\nsetTimeout(function() {\n    var cs = r.findAllComponents('Component');\n    cs.forEach(function(c) {\n        console.log(c.toHTML());\n    })\n}, 1000);\n\n\n\n\n\n\nractive.findComponent()\n\n\nReturns the first component inside a given Ractive instance with the given \nname\n (or the first component of any kind if no name is given).\n\n\nSyntax\n\n\n\n\nractive.findComponent([name[, options]])\n\n\n\n\nArguments\n\n\n\n\n[name] (string)\n: The name of the component to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean)\n: Include attached children that are not rendered in anchors when searching components. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: A ractive instance.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n    template: 'Component {{number}}'\n});\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    components: {\n        Component: Component\n    }\n});\n\nsetTimeout(function() {\n    var c = r.findComponent('Component');\n    console.log(c.toHTML());\n}, 1000);\n\n\n\n\n\n\nractive.findContainer()\n\n\nReturns the first container of this component instance with the given \nname\n.\n\n\nSyntax\n\n\n\n\nractive.findContainer(name)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the container to find.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the first container of this component with the given \nname\n.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.findParent()\n\n\nReturns the first parent of this component instance with the given \nname\n.\n\n\nSyntax\n\n\n\n\nractive.findParent(name)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the parent to find.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the first parent of this component with the given \nname\n.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.fire()\n\n\nFires an event, which will be received by handlers that were bound using \nractive.on\n. In practical terms, you would mostly likely use this with \nRactive.extend()\n, to allow applications to hook into your subclass.\n\n\nSyntax\n\n\n\n\nractive.fire(eventName[, context [, arg1[, ...argN]]])\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the event.\n\n\n[context] (context|object)\n: A context object to reuse for the event or an object with properties to assign to a new context object. If you need to pass arguments but don't need to provide context, pass an empty object (\n{}\n) before the additional arguments.\n\n\n[arg] (any)\n: The arguments that event handlers will be called with.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive();\n\nr.on('foo', function() {\n  console.log('foo fired');\n});\n\nr.fire('foo');\n\n\n\n\n\n\nractive.get()\n\n\nReturns the value at \nkeypath\n. If the keypath is omitted, returns a shallow copy of all the data in the instance. This data includes mappings introduced by enclosing components, but excludes computed properties.\n\n\nSyntax\n\n\n\n\nractive.get([keypath])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The keypath of the data to retrieve.\n\n\n\n\nReturns\n\n\n\n\n(any)\n: Returns whatever data was on the keypath, or all if no keypath was provided.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = new Ractive({\n    data: {\n        foo: {\n            bar: [ 'baz' ]\n        }\n    }\n});\n\nconsole.log(r.get('foo.bar.0'));\n\n\n\n\n\n\nractive.getContext()\n\n\nThis is an instance specific version of \nRactive.getContext()\n that will only search the local instance DOM for a matching node when a selector is given. If the given value is not a string, then it is passed directly through to the static version of this method.\n\n\nSyntax\n\n\n\n\nractive.getContext(node)\n\n\n\n\nArguments\n\n\n\n\nnode (string|Node)\n: The DOM node or a CSS selector of a target node for which you wish to retrieve the Ractive instance or view details.\n\n\n\n\nReturns\n\n\n\n\n(Context)\n: Returns an \nContext\n object with helper methods to interact with the Ractive instance and context associated with the given node.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.insert()\n\n\nInserts the instance to a different location. If the instance is currently in the DOM, it will be detached first. See also \nractive.detach()\n.\n\n\nSyntax\n\n\n\n\nractive.insert(target[, anchor])\n\n\n\n\nArguments\n\n\n\n\ntarget (string|Node|array-like)\n: The new parent element.\n\n\n[anchor] (string|Node|array-like)\n: The sibling element to insert the instance before. If omitted, the instance will be inserted as the last child of the parent.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.link()\n\n\nCreates a link between two keypaths that keeps them in sync. Since Ractive can't always watch the contents of objects, copying an object to two different keypaths in your data usually leads to one or both of them getting out of sync. \nlink\n creates a sort of symlink between the two paths so that Ractive knows they are actually the same object. This is particularly useful for master/detail scenarios where you have a complex list of data and you want to be able to select an item to edit in a detail form.\n\n\nSyntax\n\n\n\n\nractive.link(source, destination)\n\n\n\n\nArguments\n\n\n\n\nsource (string)\n: The keypath of the source item.\n\n\ndestination (string)\n: The keypath to use as the destination - or where you'd like the data 'copied'.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise.\n\n\n\n\nExamples\n\n\nractive.link( 'some.nested.0.list.25.item', 'current' );\nractive.set( 'current.name', 'Rich' ); // some.nested.0.list.25.item.name is also updated to be 'Rich'\n\n\n\n\nThis can be used to great effect with method events and the \n@keypath\n special ref:\n\n\n{{#each some.nested}}\n  {{#each list}}\n    {{#with item}}\n      {{.name}}\n      \nbutton on-click=\nevent.link('.', 'current')\nSelect\n/button\n\n    {{/with}}\n  {{/each}}\n{{/each}}\n\nName: \ninput value=\n{{~/current.name}}\n /\n\n\n\n\n\nLinks can be removed using \nractive.unlink()\n.\n\n\n\n\nractive.observe()\n\n\nObserves the data at a particular keypath. Unless specified otherwise, the callback will be fired immediately, with \nundefined\n as \noldValue\n. Thereafter it will be called whenever the \nobserved keypath\n changes.\n\n\nSyntax\n\n\n\n\nractive.observe(keypath, callback[, options])\n\n\nractive.observe(map[, options])\n\n\n\n\nArguments\n\n\n\n\n\n\nkeypath (String)\n: The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a \n*\n character, which is treated as a wildcard. A \n**\n means recursive.\n\n\nThe difference between \n*\n and \n**\n is that \n*\n provides your callback function \nvalue\n and \nkeypath\n arguments containing the path of the what actually changed, at any level of the keypath. So instead of getting the same parent value on every change, you get the changed value from whatever arbitrarily deep keypath changed.\n\n\n\n\n\n\ncallback (Function)\n: The function that will be called, with \nnewValue\n, \noldValue\n and \nkeypath\n as arguments (see \nObservers\n for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with \nractive\n as \nthis\n. Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.\n\n\n\n\nmap (Object)\n: A map of keypath-observer pairs.\n\n\n[options] (Object)\n:\n\n\n[init] (boolean)\n: Defaults to \ntrue\n. Whether or not to initialise the observer, i.e. call the function with the current value of \nkeypath\n as the first argument and \nundefined\n as the second.\n\n\n[defer] (boolean)\n: Defaults to \nfalse\n, in which case observers will fire before any DOM changes take place. If \ntrue\n, the observer will fire once the DOM has been updated.\n\n\n[links] (boolean)\n: Defaults to \nfalse\n.  Whether or not the observer should \"follow through\" any links created with \nractive.link()\n.\n\n\n[strict] (boolean)\n: Defaults to \nfalse\n. \nstrict\n uses object identity to determine if there was a change, meaning that unless the primary object changed, it won't trigger the observer. For example with \n{ data: { foo: { bar: 'baz' } } }\n, \nractive.observe('foo', ..., { strict: true })\n will not fire on \nractive.set('foo.bar', 'bat')\n but will on \nractive.set('foo', { bar: 'bip' })\n.\n\n\n[context] (any)\n: Defaults to \nractive\n. The context the observer is called in (i.e. the value of \nthis\n)\n\n\n[array] (boolean)\n: Defaults to \nfalse\n. Whether or not to observe the keypath as an array, meaning that change events will fire with a object containing two lists, \ninserted\n containing added elements, and \ndeleted\n containing removed elements. There is also a \nstart\n integer property indicating the index at which the replacements begin.\n\n\n[old] (function)\n: Defaults to \nundefined\n. A function that can be used to modify the \nold\n value passed to the observer callback. This can be used to freeze the old value, create a deep clone of it for future firings, etc.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: An object with a \ncancel\n method, for cancelling all observers\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nNote that you can observe keypath \npatterns\n...\n\n\nractive.observe( 'items.*.status', function ( newValue, oldValue, keypath) {\n    var index = /items.(\\d+).status/.exec( keypath )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\n...or multiple space-separated keypaths simultaneously:\n\n\nractive.observe( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n    alert( keypath ) + ' changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\nSee \nObservers\n for more detail.\n\n\n\n\nractive.observeOnce()\n\n\nObserves the data at a particular keypath until the first change. After the handler has been called, it will be unsubscribed from any future changes.\n\n\nSyntax\n\n\n\n\nractive.observeOnce(keypath, callback[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a `` character, which is treated as a wildcard.\n\n\ncallback (Function)\n: The function that will be called, with \nnewValue\n, \noldValue\n and \nkeypath\n as arguments (see \nObservers\n for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with \nractive\n as \nthis\n. Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.\n\n\n[options] (Object)\n:\n\n\n[defer] (boolean)\n: Defaults to \nfalse\n, in which case observers will fire before any DOM changes take place. If \ntrue\n, the observer will fire once the DOM has been updated.\n\n\n[context] (any)\n: Defaults to \nractive\n. The context the observer is called in (i.e. the value of \nthis\n)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: An object with a \ncancel\n method, for cancelling the observer.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nNote that you can observe keypath \npatterns\n...\n\n\nractive.observeOnce( 'items.*.status', function ( newValue, oldValue, keypath ) {\n    var index = /items.(\\d+).status/.exec( keypath )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\n...or multiple space-separated keypaths simultaneously:\n\n\nractive.observeOnce( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n    alert( keypath + ' changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\nSee \nObservers\n for more detail.\n\n\n\n\nractive.off()\n\n\nRemoves an event handler, several event handlers, or all event handlers.\n\n\nTo remove a single handler, you must specify both the event name and the handler. If you only specify the event name, all handlers bound to that event name will be removed. If you specify neither event name nor handler, \nall\n event handlers will be removed.\n\n\nAn alternative way to remove event handlers is to use the \ncancel\n method of the return value of a call to \nractive.on()\n.\n\n\nSyntax\n\n\n\n\nractive.off([eventName[, handler]])\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The event name to which this handler is currently bound.\n\n\nhandler (Function)\n: The handler to remove.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the \nractive\n instance to allow this call to be chainable.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.on()\n\n\nSubscribe to \nevents\n.\n\n\nSyntax\n\n\n\n\nractive.on(eventName, handler)\n\n\nractive.on(obj)\n\n\n\n\nArguments\n\n\n\n\neventName (String)\n: The name of the event to subscribe to\n\n\nhandler (Function)\n: The function that will be called, with \nractive\n as \nthis\n. The arguments depend on the event, but the first argument is always a context object. Returning \nfalse\n from the handler will stop propagation and prevent default of DOM events and cancel \nevent bubbling\n.\n\n\nobj (Object)\n: An object with keys named for each event to subscribe to. The value at each key is the handler function for that event.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n - An \nObject\n with a \ncancel\n method, which removes the handler.\n\n\n(Object)\n - An \nObject\n with a \ncancel\n method, which removes all handlers in the passed-in \nobj\n.\n\n\n\n\nExamples\n\n\n// single handler to function\nractive.on( 'activate', function () {...});\n\n// wildcard pattern matching\nractive.on( 'foo.*', function () {...} );\n\n// multiple handlers to one function\nractive.on( 'activate select', function () {...} );\n\n// map of handler/function pairs\nractive.on({\n    activate: function () {...},\n    select: function () {...}\n});\n\n// knock yourself out:\nractive.on({\n    activate: function () {...},\n    'bip bop boop': function () {...},\n    'select foo.* bar': function () {...}\n});\n\n\n\n\n\n\nractive.once()\n\n\nSubscribe to an event for a single firing. This is a convenience function on top of \nractive.on()\n.\n\n\nSyntax\n\n\n\n\nractive.once(eventName, handler)\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The name of the event to subscribe to.\n\n\nhandler (Function)\n: The function that will be called, with \nractive\n as \nthis\n. The arguments depend on the event, but the first argument is always a context object. Returning \nfalse\n from the handler will stop propagation and prevent default of DOM events and cancel \nevent bubbling\n.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: Returns an \nObject\n with a \ncancel\n method, which removes the handler.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.pop()\n\n\nThe Ractive equivalent to \nArray.pop\n that removes an element from the end of the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.pop(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve with the removed element after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.push()\n\n\nThe Ractive equivalent to \nArray.push\n that appends one or more elements to the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.push(keypath, value[, ...valueN])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nvalue (any)\n: The value to append to the end of the array. One or more values may be supplied.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - Returns a Promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.readLink()\n\n\nGets the source keypath and instance for a link.\n\n\nSyntax\n\n\n\n\nractive.readLink(link[, options])\n\n\n\n\nArguments\n\n\n\n\nlink (string)\n: The keypath for the link that you would like to read.\n\n\noptions (Object)\n:\n\n\n[canonical] (boolean)\n: Whether or not to read through any intermediate links too. Pass \ncanonical: true\n to read through links to links all the way to the canonical data keypath. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n:\n\n\nkeypath (string)\n: The source keypath to which the link points.\n\n\nractive (Ractive)\n: The source Ractive instance that contains the keypath to which the link points.\n\n\n\n\n\n\n\n\nExamples\n\n\nconst r = new Ractive({\n  data: {\n    items: [\n      { name: 'Apple' },\n      { name: 'Banana' },\n      { name: 'Orange' }\n    ]\n  }\n});\n\nr.link( 'items.0', 'currentItem' );\n\nr.readLink( 'currentItem' );\n// returns { ractive: r, keypath: 'items.0' }\n\n\n\n\n\n\nractive.render()\n\n\nRenders the component into a DOM element.\n\n\nSyntax\n\n\n\n\nractive.render(target)\n\n\n\n\nArguments\n\n\n\n\ntarget (Node|String|array-like)\n: The DOM element to render to.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when rendering completes or when the instance is already rendered.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.reset()\n\n\nResets the entire \nractive.data\n object and updates the DOM.\n\n\nSyntax\n\n\n\n\nractive.reset(data)\n\n\n\n\nArguments\n\n\n\n\ndata (Object)\n: The data to reset with. Defaults to \n{}\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\nThis differs from \nractive.set()\n in the following way:\n\n\nractive = new Ractive({\n  // ...,\n  data: { foo: 1 }\n});\n\nractive.set({ bar: 2 });\nconsole.log( ractive.get() ); // { foo: 1, bar: 2 }\n\nractive.reset({ bar: 2 });\nconsole.log( ractive.get() ); // { bar: 2 }\n\n\n\n\n\n\nractive.resetPartial()\n\n\nResets a partial and re-renders all of its use-sites, including in any components that have inherited it. If a component has a partial with a same name that is its own, that partial will not be affected.\n\n\nInline partials that don't belong directly to a Ractive instance aren't affected by \nresetPartial\n.\n\n\nSyntax\n\n\n\n\nractive.resetPartial(name, partial)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The partial to reset.\n\n\npartial (string|Object|Function)\n: A template string, pre-parsed template or a function that returns either.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\nractive = new Ractive({\n  // ...,\n  partials: { foo: 'foo' }\n});\n\n// {{\nfoo}} will be replaced with 'foo'\n\nractive.resetPartial('foo', 'bar');\n\n// {{\nfoo}} will be replaced with 'bar'\n\n\n\n\n\n\nractive.reverse()\n\n\nThe Ractive equivalent to \nArray.reverse\n reverses the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.reverse(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (String)\n: The keypath of the array to reverse, e.g. \nlist\n or \norder.items\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - A promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.set()\n\n\nUpdates data and triggers a re-render of any mustaches that are affected (directly or indirectly) by the change. Any observers of affected keypaths will be notified.\n\n\nWhen setting an array value, ractive will reuse the existing DOM nodes for the new array, adding or removing nodes as necessary. This can impact nodes with \ntransitions\n. Use the \nshuffle\n option for setting a new array value while retaining existing nodes corresponding to individual array item values.\n\n\nSyntax\n\n\n\n\nractive.set(keypath, value[, options])\n\n\nractive.set(map[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the data we're changing, e.g. \nuser\n or \nuser.name\n or \nuser.friends[1]\n or \nusers.*.status\n.\n\n\nvalue (any)\n: The value we're changing it to. Can be a primitive or an object (or array), in which case dependants of \ndownstream keypaths\n will also be re-rendered (if they have changed).\n\n\nmap (Object)\n: A map of \nkeypath: value\n pairs, as above.\n\n\n[options] Object\n:\n\n\ndeep (boolean)\n: Whether or not to perform a deep set on with the data at the given keypath. A deep set recursively merges the given data into the data structure at the given keypath. Defaults to \nfalse\n.\n\n\nshuffle (boolean|string|Function)\n: Whether or not to add/move/remove DOM associated with elements rather than just re-using the existing DOM. Defaults to \nfalse\n.\n\n\ntrue\n: Add/move/remove existing items to their new index using a strict equality comparison.\n\n\nstring\n: Add/move/remove existing items to their new index using a property comparison where the property compared is named by the given string.\n\n\nFunction\n: Add/move/remove existing items to their new index using the value returned by the given function for comparison.\n\n\n\n\n\n\nkeep (boolean)\n: Whether or not to keep the virtual DOM that would be disposed by the \nset\n operation. This is useful for hiding components without completely tearing them down and recreating them. It's also a little bit faster, as the virtual DOM doesn't have to be recreated when it would reappear. This \nmay\n try to keep the actual DOM around for reuse at some point in the future. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolved after any transitions associated with the operation are complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nThe \nkeypath\n can also contain wildcards \npattern-observers\n. All matching keypaths will be set with the supplied values:\n\n\nractive.on('selectAll', function(){\n    ractive.set('items.*.selected', true);\n})\n\n\n\n\n\n\nractive.shift()\n\n\nThe Ractive equivalent to \nArray.shift\n that removes an element from the beginning of the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.shift(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that will resolve with the removed element after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.sort()\n\n\nThe Ractive equivalent to \nArray.sort\n sorts the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.sort(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to sort, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.splice()\n\n\nThe Ractive equivalent to \nArray.splice\n that can add new elements to the array while removing existing elements.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.splice(keypath, index, [removeCount[, add]])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nindex (number)\n: The index at which to start the operation.\n\n\n[removeCount] (number)\n: The number of elements to remove starting with the element at *\nindex\n. This may be 0 if you don't want to remove any elements.\n\n\n[add] (any)\n: Any elements to insert into the array starting at *\nindex\n. There can be 0 or more elements passed to add to the array.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve with the removed elements after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.subtract()\n\n\nDecrements the selected keypath.\n\n\nSyntax\n\n\n\n\nractive.subtract(keypath[, number])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the number we're decrementing.\n\n\n[number] (number)\n: Defaults to \n1\n. The number to decrement by.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.teardown()\n\n\nUnrenders this Ractive instance, removing any event handlers that were bound automatically by Ractive.\n\n\nCalling \nractive.teardown()\n causes a \nteardown\n \nevent\n to be fired - this is most useful with \nRactive.extend()\n as it allows you to clean up anything else (event listeners and other bindings) that are part of the subclass.\n\n\nSyntax\n\n\n\n\nractive.teardown()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.toCSS()\n\n\nReturns the scoped CSS of the current instance and its descendants.\n\n\nAt the moment, this will not work on a direct instance of Ractive and will log a warning. You can only use this method on an instance of a subclass.\n\n\nSyntax\n\n\n\n\nractive.toCSS()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The scoped CSS of the instance.\n\n\n\n\nExamples\n\n\nconst Subclass = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\nconst subclassInstance = new Subclass({...});\n\n// Contains the scoped version of div{ color: red }\nsubclassInstance.toCSS();\n\n\n\n\n\n\nractive.toHTML()\n\n\nReturns a chunk of HTML representing the current state of the instance. This is most useful when you're using Ractive in node.js, as it allows you to serve fully-rendered pages (good for SEO and initial pageload performance) to the client.\n\n\nSyntax\n\n\n\n\nractive.toHTML()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The instance HTML.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.toggle()\n\n\nToggles the selected keypath. In other words, if \nfoo\n is \ntruthy\n, then \nractive.toggle('foo')\n will make it \nfalse\n, and vice-versa.\n\n\nSyntax\n\n\n\n\nractive.toggle(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to toggle the value of. If \nkeypath\n is a pattern, then all matching keypaths will be toggled.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.transition()\n\n\nTriggers a transition on a node managed by this Ractive instance.\n\n\nSyntax\n\n\n\n\nractive.transition(transition, node, options)\n\n\n\n\nArguments\n\n\n\n\ntransition (string|Function)\n: A transition function or a name of a transition function.\n\n\nnode (HTMLElement)\n: The node on which to start the transition - optional if called from within a Ractive event handler, as it will be retrieved from the event if not supplied.\n\n\noptions (Object)\n: Options supplied to the transition.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the transition completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.unlink()\n\n\nRemoves a link set up by \nractive.link()\n.\n\n\nSyntax\n\n\n\n\nractive.unlink(destination)\n\n\n\n\nArguments\n\n\n\n\ndestination (string)\n: The destination supplied to [\nractive.link()\n].\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.unrender()\n\n\n\n\nUnrenders this Ractive instance, throwing away any DOM nodes associated with this instance. This is the counterpart to \nractive.render()\n. The rest of the ractive instance is left intact, unlike \nractive.teardown()\n.\n\n\nNote that if the instance happens to be a component that is managed by another instance, the owning instance may veto the call to \nunrender\n. If you need more precise control over component rendering, you should probably use an anchor and \nractive.attachChild()\n instead.\n\n\nSyntax\n\n\n\n\nractive.unrender()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.unshift()\n\n\nThe Ractive equivalent to \nArray.unshift\n that prepends one or more elements to the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.unshift(keypath, value)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nvalue (any)\n: The value to prepend to the beginning of the array. One or more values may be supplied.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.update()\n\n\n\"Dirty checks\" everything that depends directly or indirectly on the specified keypath. If no \nkeypath\n is specified, all keypaths will be checked. Keypaths that involve special references (i.e. \n@global\n) require the keypath to be supplied.\n\n\nThis is useful when manipulating the instance's data without using the built in setter methods (i.e. \nractive.set()\n, \nractive.animate()\n).\n\n\nSyntax\n\n\n\n\nractive.update([keypath][, options])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The keypath to treat as 'dirty'.\n\n\n[options] (Object\nstring, any\n)\n:\n\n\nforce (boolean)\n: Force an update regardless of whether or not the internal change check determines that the keypath has \nactually\n changed. This is useful for forcing all expressions referencing a particular function to recompute.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when any transitions associated with the operation complete.\n\n\n\n\nExamples\n\n\nractive.observe( 'foo', function ( foo ) {\n  alert( foo );\n});\n\nmodel.foo = 'changed';   // Does not cause the instance to update.\nractive.update( 'foo' ); // Informs the instance that foo was changed externally.\n\n\n\n\n\n\nractive.updateModel()\n\n\nIf you programmatically manipulate inputs and other elements that have \ntwo\u2010way binding\n set up, your model can get out of sync. In these cases, we need to force a resync with \nractive.updateModel()\n:\n\n\nSyntax\n\n\n\n\nractive.updateModel([keypath[, cascade]])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to treat as 'dirty'. Any two-way bindings linked to this keypath will be checked to see if the model is out of date\n\n\ncascade (boolean)\n: If true, bindings that are \ndownstream\n of \nkeypath\n will also be checked - e.g. \nractive.updateModel( 'items', true )\n would check \nitems.0.foo\n and \nitems.1.foo\n and so on. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise. If a \nkeypath\n is not specified, all two-way bindings will be checked.\n\n\n\n\nExamples\n\n\nractive = new Ractive({\n  el: 'container',\n  template: '\ninput value=\n{{name}}\n'\n  data: { name: 'Bob' }\n});\n\nractive.find( 'input' ).value = 'Jim';\nalert( ractive.get( 'name' ) ); // alerts 'Bob', not 'Jim'\n\nractive.updateModel();\nalert( ractive.get( 'name' ) ); // alerts 'Jim'", 
            "title": "Instance Methods"
        }, 
        {
            "location": "/api/instance-methods/#instance-methods", 
            "text": "", 
            "title": "Instance Methods"
        }, 
        {
            "location": "/api/instance-methods/#ractive_super", 
            "text": "Calls the parent method from a child method of the same name.  ractive._super()  is not always available. Only when Ractive detects its use does it make this reference to the parent method.  Syntax   ractive._super([arg[, ...argN]])   Arguments   [arg] (any) : One or more arguments to pass to the function.   Returns   (any) : Depends on the method called.   Examples   var Component = Ractive.extend({\n    oninit: function() {\n        console.log('super init')\n    }\n});\n\nvar SubComponent = Component.extend({\n    oninit: function() {\n        this._super();\n        console.log('sub init');\n    }\n})\n\nnew SubComponent();", 
            "title": "ractive._super()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveadd", 
            "text": "Increments the selected keypath.  Syntax   ractive.add(keypath[, number])   Arguments   keypath (string) : The keypath of the number we're incrementing.  [number] (number) : The number to increment by. Defaults to  1 .   Returns   (Promise) : A promise that resolves when any transitions associated with the operation complete.   Examples   var r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    r.add('counter');\n    console.log(r.get('counter'));\n}, 1000);\n\nsetTimeout(function() {\n    r.add('counter', 10);\n    console.log(r.get('counter'));\n}, 2000);", 
            "title": "ractive.add()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveanimate", 
            "text": "Similar to  ractive.set() , this will update the data and re-render any affected mustaches and notify observers.  All animations are handled by a global timer that is shared between Ractive instances (and which only runs if there are one or more animations still in progress), so you can trigger as many separate animations as you like without worrying about timer congestion. Where possible,  requestAnimationFrame  is used rather than  setTimeout .  Numeric values and strings that can be parsed as numeric values can be interpolated. Objects and arrays containing numeric values (or other objects and arrays which themselves contain numeric values, and so on recursively) are also interpolated.  Note that there is currently no mechanism for detecting cyclical structures! Animating to a value that indirectly references itself will cause an infinite loop.  Future versions of Ractive may include string interpolators - e.g. for SVG paths, colours, transformations and so on, a la D3 - and the ability to pass in your own interpolator.  If an animation is started on a keypath which is  already  being animated, the first animation is cancelled. (Currently, there is no mechanism in place to prevent collisions between e.g.  ractive.animate('foo', { bar: 1 })  and  ractive.animate('foo.bar', 0) .)  Syntax   ractive.animate(keypath, value[, options])  ractive.animate(map[, options])   Arguments   keypath (string) : The keypath to animate.  value (number|string|Object|Array) : The value to animate to.  map (Object) : A key-value hash of keypath and value.  [options] (Object) :  [duration] (number) : How many milliseconds the animation should run for. Defaults to  400 .  [easing] (string|Function) : The name of an easing function or the easing function itself. Defaults to  linear .  [step] (Function) : A function to be called on each step of the animation. Receives  t  and  value  as arguments, where  t  is the animation progress (between  0  and  1 , as determined by the easing function) and  value  is the intermediate value at  t .  [complete] (Function) : A function to be called when the animation completes, with the same argument signature as  step  (i.e.  t  is  1 , and  value  is the destination value)     Returns   (Promise) : Returns a Promise with an additional  stop  method, which cancels the animation.   Examples   var r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    r.animate('counter', 20, { duration: 2000 });\n}, 1000);", 
            "title": "ractive.animate()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveattachchild", 
            "text": "Creates a parent-child relationship between two Ractive instances. The child may be an instance of a component defined by  Ractive.extend() , but that is not a requirement, as children may be a plain Ractive instance created with  new Ractive() .  Syntax  ractive.attachChild( child );\nractive.attachChild( child, options );  Arguments   child (Ractive instance) : The child instance to attach.  [options] (Object) :  [target] (string) : An anchor name at which to render the instance. See  Components . If the instance is already rendered, it will be unrendered and re-rendered at an appropriate anchor.  [append] (boolean) : Default  true  - add the instance to the end of the list for the targeted anchor.  [prepend] (boolean) : Add the instance to the beginning of the list for the targeted anchor.  [insertAt] (number) : Index at which to add the instance in the list for the targeted anchor.     When a child is attached to a parent, the child's  parent  property is updated in an observable way, so any references to  @this.parent  in the child will be notified of the change.  A child may be targeted to a  Components  when it is attached. If a child has no specified target, then it is responsible for managing its own render cycle. If a child does have a specified target, then the parent will manage rendering and unrendering the child as appropriate in the same way that a regular component has a managed render cycle.  When a child is attached targeting an anchor, only anchors that belong directly to the parent are considered as hosts. However, any element or component queries on the parent instance, including live queries, will consider the child when trying to match both elements and components. There is also an option on the query methods that allows querying remote, unmanaged instances, so that non-anchored children can also be queried for elements and components.  Returns   (Promise) : A  Promise  that resolves with the child instance when any transitions are complete.   Children can be detached using  ractive.detachChild() .  Examples  // TODO", 
            "title": "ractive.attachChild()"
        }, 
        {
            "location": "/api/instance-methods/#ractivedetach", 
            "text": "Detaches the instance from the DOM, returning a document fragment. You can reinsert it, possibly in a different place, with  ractive.insert()  (note that if you are reinserting it immediately you don't need to detach it first - it will happen automatically).  Syntax   ractive.detach()   Arguments   None   Returns   (DocumentFragment) : A document fragment.   Examples   var r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    data: {\n        counter: 0\n    }\n});\n\nsetTimeout(function() {\n    var div = document.createElement('div');\n    div.appendChild(r.detach());\n    console.log(div.innerHTML);\n}, 1000);", 
            "title": "ractive.detach()"
        }, 
        {
            "location": "/api/instance-methods/#ractivedetachchild", 
            "text": "Detaches a child from an instance when it was previously attached with  ractive.attachChild() .  When a child instance that was attached targeting an anchor is detached, its instance is spliced out of the  @this.children.byName.anchorName  array so that subsequent children move forward to fill the void.  Syntax   ractive.detachChild( child )   Returns   (Promise) : A  Promise  that resolves with the child instance when any transitions are complete.   Examples  // TODO", 
            "title": "ractive.detachChild()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefind", 
            "text": "Returns the first element inside a given Ractive instance matching a CSS selector. This is similar to doing  this.el.querySelector(selector)  (though it doesn't actually use  querySelector() ).  Syntax   ractive.find(selector[, options])   Arguments   selector (string) : A CSS selector representing the element to find.  [options] (Object) :  remote (boolean} : Include attached children that are not rendered in anchors when looking for matching elements. Defaults to  false .     Returns   (Node) : A Node.   Examples   var r = new Ractive({\n    el: '#main',\n    template: '#tpl'\n});\n\nsetTimeout(function() {\n    var p = r.find('p.target');\n    console.log(p.outerHTML);\n}, 1000);", 
            "title": "ractive.find()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefindall", 
            "text": "This method is similar to [ ractive.find() ]ractivefind), with an important difference - it returns a list of elements matching the selector, rather than a single node.  Syntax   ractive.findAll(selector[, options])   Arguments   selector (string) : A CSS selector representing the elements to find.  [options] (Object) :  remote (boolean) : Include attached children that are not rendered in anchors when searching for elements. Defaults to  false .     Returns   (Array Node ) : An array of nodes.   Examples   var r = new Ractive({\n    el: '#main',\n    template: '#tpl'\n});\n\nsetTimeout(function() {\n    var ps = r.findAll('p');\n    ps.forEach(function(p) {\n        console.log(p.outerHTML);\n    })\n}, 1000);", 
            "title": "ractive.findAll()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefindallcomponents", 
            "text": "Returns all components inside a given Ractive instance with the given  name  (or all components of any kind if no name is given).  Syntax   ractive.findAllComponents([name[, options]])   Arguments   [name] (string) : The name of the component to find.  [options] (Object) :  remote (boolean) : Include attached children that are not rendered in anchors when searching components. Defaults to  false .     Returns   (Array ractive ) : An array of ractive instances.   Examples   var Component = Ractive.extend({\n    template: 'Component {{number}}'\n});\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    components: {\n        Component: Component\n    }\n});\n\nsetTimeout(function() {\n    var cs = r.findAllComponents('Component');\n    cs.forEach(function(c) {\n        console.log(c.toHTML());\n    })\n}, 1000);", 
            "title": "ractive.findAllComponents()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefindcomponent", 
            "text": "Returns the first component inside a given Ractive instance with the given  name  (or the first component of any kind if no name is given).  Syntax   ractive.findComponent([name[, options]])   Arguments   [name] (string) : The name of the component to find.  [options] (Object) :  remote (boolean) : Include attached children that are not rendered in anchors when searching components. Defaults to  false .     Returns   (Ractive) : A ractive instance.   Examples   var Component = Ractive.extend({\n    template: 'Component {{number}}'\n});\n\nvar r = new Ractive({\n    el: '#main',\n    template: '#tpl',\n    components: {\n        Component: Component\n    }\n});\n\nsetTimeout(function() {\n    var c = r.findComponent('Component');\n    console.log(c.toHTML());\n}, 1000);", 
            "title": "ractive.findComponent()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefindcontainer", 
            "text": "Returns the first container of this component instance with the given  name .  Syntax   ractive.findContainer(name)   Arguments   name (string) : The name of the container to find.   Returns   (Ractive) : Returns the first container of this component with the given  name .   Examples  // TODO", 
            "title": "ractive.findContainer()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefindparent", 
            "text": "Returns the first parent of this component instance with the given  name .  Syntax   ractive.findParent(name)   Arguments   name (string) : The name of the parent to find.   Returns   (Ractive) : Returns the first parent of this component with the given  name .   Examples  // TODO", 
            "title": "ractive.findParent()"
        }, 
        {
            "location": "/api/instance-methods/#ractivefire", 
            "text": "Fires an event, which will be received by handlers that were bound using  ractive.on . In practical terms, you would mostly likely use this with  Ractive.extend() , to allow applications to hook into your subclass.  Syntax   ractive.fire(eventName[, context [, arg1[, ...argN]]])   Arguments   name (string) : The name of the event.  [context] (context|object) : A context object to reuse for the event or an object with properties to assign to a new context object. If you need to pass arguments but don't need to provide context, pass an empty object ( {} ) before the additional arguments.  [arg] (any) : The arguments that event handlers will be called with.   Returns   (boolean)   Examples   var r = new Ractive();\n\nr.on('foo', function() {\n  console.log('foo fired');\n});\n\nr.fire('foo');", 
            "title": "ractive.fire()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveget", 
            "text": "Returns the value at  keypath . If the keypath is omitted, returns a shallow copy of all the data in the instance. This data includes mappings introduced by enclosing components, but excludes computed properties.  Syntax   ractive.get([keypath])   Arguments   [keypath] (string) : The keypath of the data to retrieve.   Returns   (any) : Returns whatever data was on the keypath, or all if no keypath was provided.   Examples   var r = new Ractive({\n    data: {\n        foo: {\n            bar: [ 'baz' ]\n        }\n    }\n});\n\nconsole.log(r.get('foo.bar.0'));", 
            "title": "ractive.get()"
        }, 
        {
            "location": "/api/instance-methods/#ractivegetcontext", 
            "text": "This is an instance specific version of  Ractive.getContext()  that will only search the local instance DOM for a matching node when a selector is given. If the given value is not a string, then it is passed directly through to the static version of this method.  Syntax   ractive.getContext(node)   Arguments   node (string|Node) : The DOM node or a CSS selector of a target node for which you wish to retrieve the Ractive instance or view details.   Returns   (Context) : Returns an  Context  object with helper methods to interact with the Ractive instance and context associated with the given node.   Examples  // TODO", 
            "title": "ractive.getContext()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveinsert", 
            "text": "Inserts the instance to a different location. If the instance is currently in the DOM, it will be detached first. See also  ractive.detach() .  Syntax   ractive.insert(target[, anchor])   Arguments   target (string|Node|array-like) : The new parent element.  [anchor] (string|Node|array-like) : The sibling element to insert the instance before. If omitted, the instance will be inserted as the last child of the parent.   Returns   (undefined)   Examples  // TODO", 
            "title": "ractive.insert()"
        }, 
        {
            "location": "/api/instance-methods/#ractivelink", 
            "text": "Creates a link between two keypaths that keeps them in sync. Since Ractive can't always watch the contents of objects, copying an object to two different keypaths in your data usually leads to one or both of them getting out of sync.  link  creates a sort of symlink between the two paths so that Ractive knows they are actually the same object. This is particularly useful for master/detail scenarios where you have a complex list of data and you want to be able to select an item to edit in a detail form.  Syntax   ractive.link(source, destination)   Arguments   source (string) : The keypath of the source item.  destination (string) : The keypath to use as the destination - or where you'd like the data 'copied'.   Returns   (Promise) : Returns a promise.   Examples  ractive.link( 'some.nested.0.list.25.item', 'current' );\nractive.set( 'current.name', 'Rich' ); // some.nested.0.list.25.item.name is also updated to be 'Rich'  This can be used to great effect with method events and the  @keypath  special ref:  {{#each some.nested}}\n  {{#each list}}\n    {{#with item}}\n      {{.name}}\n       button on-click= event.link('.', 'current') Select /button \n    {{/with}}\n  {{/each}}\n{{/each}}\n\nName:  input value= {{~/current.name}}  /   Links can be removed using  ractive.unlink() .", 
            "title": "ractive.link()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveobserve", 
            "text": "Observes the data at a particular keypath. Unless specified otherwise, the callback will be fired immediately, with  undefined  as  oldValue . Thereafter it will be called whenever the  observed keypath  changes.  Syntax   ractive.observe(keypath, callback[, options])  ractive.observe(map[, options])   Arguments    keypath (String) : The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a  *  character, which is treated as a wildcard. A  **  means recursive.  The difference between  *  and  **  is that  *  provides your callback function  value  and  keypath  arguments containing the path of the what actually changed, at any level of the keypath. So instead of getting the same parent value on every change, you get the changed value from whatever arbitrarily deep keypath changed.    callback (Function) : The function that will be called, with  newValue ,  oldValue  and  keypath  as arguments (see  Observers  for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with  ractive  as  this . Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.   map (Object) : A map of keypath-observer pairs.  [options] (Object) :  [init] (boolean) : Defaults to  true . Whether or not to initialise the observer, i.e. call the function with the current value of  keypath  as the first argument and  undefined  as the second.  [defer] (boolean) : Defaults to  false , in which case observers will fire before any DOM changes take place. If  true , the observer will fire once the DOM has been updated.  [links] (boolean) : Defaults to  false .  Whether or not the observer should \"follow through\" any links created with  ractive.link() .  [strict] (boolean) : Defaults to  false .  strict  uses object identity to determine if there was a change, meaning that unless the primary object changed, it won't trigger the observer. For example with  { data: { foo: { bar: 'baz' } } } ,  ractive.observe('foo', ..., { strict: true })  will not fire on  ractive.set('foo.bar', 'bat')  but will on  ractive.set('foo', { bar: 'bip' }) .  [context] (any) : Defaults to  ractive . The context the observer is called in (i.e. the value of  this )  [array] (boolean) : Defaults to  false . Whether or not to observe the keypath as an array, meaning that change events will fire with a object containing two lists,  inserted  containing added elements, and  deleted  containing removed elements. There is also a  start  integer property indicating the index at which the replacements begin.  [old] (function) : Defaults to  undefined . A function that can be used to modify the  old  value passed to the observer callback. This can be used to freeze the old value, create a deep clone of it for future firings, etc.     Returns   (Object) : An object with a  cancel  method, for cancelling all observers   Examples  // TODO  Note that you can observe keypath  patterns ...  ractive.observe( 'items.*.status', function ( newValue, oldValue, keypath) {\n    var index = /items.(\\d+).status/.exec( keypath )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});  ...or multiple space-separated keypaths simultaneously:  ractive.observe( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n    alert( keypath ) + ' changed from ' + oldValue + ' to ' + newValue );\n});  See  Observers  for more detail.", 
            "title": "ractive.observe()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveobserveonce", 
            "text": "Observes the data at a particular keypath until the first change. After the handler has been called, it will be unsubscribed from any future changes.  Syntax   ractive.observeOnce(keypath, callback[, options])   Arguments   keypath (string) : The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a `` character, which is treated as a wildcard.  callback (Function) : The function that will be called, with  newValue ,  oldValue  and  keypath  as arguments (see  Observers  for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with  ractive  as  this . Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.  [options] (Object) :  [defer] (boolean) : Defaults to  false , in which case observers will fire before any DOM changes take place. If  true , the observer will fire once the DOM has been updated.  [context] (any) : Defaults to  ractive . The context the observer is called in (i.e. the value of  this )     Returns   (Object) : An object with a  cancel  method, for cancelling the observer.   Examples  // TODO  Note that you can observe keypath  patterns ...  ractive.observeOnce( 'items.*.status', function ( newValue, oldValue, keypath ) {\n    var index = /items.(\\d+).status/.exec( keypath )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});  ...or multiple space-separated keypaths simultaneously:  ractive.observeOnce( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n    alert( keypath + ' changed from ' + oldValue + ' to ' + newValue );\n});  See  Observers  for more detail.", 
            "title": "ractive.observeOnce()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveoff", 
            "text": "Removes an event handler, several event handlers, or all event handlers.  To remove a single handler, you must specify both the event name and the handler. If you only specify the event name, all handlers bound to that event name will be removed. If you specify neither event name nor handler,  all  event handlers will be removed.  An alternative way to remove event handlers is to use the  cancel  method of the return value of a call to  ractive.on() .  Syntax   ractive.off([eventName[, handler]])   Arguments   eventName (string) : The event name to which this handler is currently bound.  handler (Function) : The handler to remove.   Returns   (Ractive) : Returns the  ractive  instance to allow this call to be chainable.   Examples  // TODO", 
            "title": "ractive.off()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveon", 
            "text": "Subscribe to  events .  Syntax   ractive.on(eventName, handler)  ractive.on(obj)   Arguments   eventName (String) : The name of the event to subscribe to  handler (Function) : The function that will be called, with  ractive  as  this . The arguments depend on the event, but the first argument is always a context object. Returning  false  from the handler will stop propagation and prevent default of DOM events and cancel  event bubbling .  obj (Object) : An object with keys named for each event to subscribe to. The value at each key is the handler function for that event.   Returns   (Object)  - An  Object  with a  cancel  method, which removes the handler.  (Object)  - An  Object  with a  cancel  method, which removes all handlers in the passed-in  obj .   Examples  // single handler to function\nractive.on( 'activate', function () {...});\n\n// wildcard pattern matching\nractive.on( 'foo.*', function () {...} );\n\n// multiple handlers to one function\nractive.on( 'activate select', function () {...} );\n\n// map of handler/function pairs\nractive.on({\n    activate: function () {...},\n    select: function () {...}\n});\n\n// knock yourself out:\nractive.on({\n    activate: function () {...},\n    'bip bop boop': function () {...},\n    'select foo.* bar': function () {...}\n});", 
            "title": "ractive.on()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveonce", 
            "text": "Subscribe to an event for a single firing. This is a convenience function on top of  ractive.on() .  Syntax   ractive.once(eventName, handler)   Arguments   eventName (string) : The name of the event to subscribe to.  handler (Function) : The function that will be called, with  ractive  as  this . The arguments depend on the event, but the first argument is always a context object. Returning  false  from the handler will stop propagation and prevent default of DOM events and cancel  event bubbling .   Returns   (Object) : Returns an  Object  with a  cancel  method, which removes the handler.   Examples  // TODO", 
            "title": "ractive.once()"
        }, 
        {
            "location": "/api/instance-methods/#ractivepop", 
            "text": "The Ractive equivalent to  Array.pop  that removes an element from the end of the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.pop(keypath)   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .   Returns   (Promise) : Returns a promise that will resolve with the removed element after the update is complete.   Examples  // TODO", 
            "title": "ractive.pop()"
        }, 
        {
            "location": "/api/instance-methods/#ractivepush", 
            "text": "The Ractive equivalent to  Array.push  that appends one or more elements to the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.push(keypath, value[, ...valueN])   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .  value (any) : The value to append to the end of the array. One or more values may be supplied.   Returns   (Promise)  - Returns a Promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.push()"
        }, 
        {
            "location": "/api/instance-methods/#ractivereadlink", 
            "text": "Gets the source keypath and instance for a link.  Syntax   ractive.readLink(link[, options])   Arguments   link (string) : The keypath for the link that you would like to read.  options (Object) :  [canonical] (boolean) : Whether or not to read through any intermediate links too. Pass  canonical: true  to read through links to links all the way to the canonical data keypath. Defaults to  false .     Returns   (Object) :  keypath (string) : The source keypath to which the link points.  ractive (Ractive) : The source Ractive instance that contains the keypath to which the link points.     Examples  const r = new Ractive({\n  data: {\n    items: [\n      { name: 'Apple' },\n      { name: 'Banana' },\n      { name: 'Orange' }\n    ]\n  }\n});\n\nr.link( 'items.0', 'currentItem' );\n\nr.readLink( 'currentItem' );\n// returns { ractive: r, keypath: 'items.0' }", 
            "title": "ractive.readLink()"
        }, 
        {
            "location": "/api/instance-methods/#ractiverender", 
            "text": "Renders the component into a DOM element.  Syntax   ractive.render(target)   Arguments   target (Node|String|array-like) : The DOM element to render to.   Returns   (Promise) : A promise that resolves when rendering completes or when the instance is already rendered.   Examples  // TODO", 
            "title": "ractive.render()"
        }, 
        {
            "location": "/api/instance-methods/#ractivereset", 
            "text": "Resets the entire  ractive.data  object and updates the DOM.  Syntax   ractive.reset(data)   Arguments   data (Object) : The data to reset with. Defaults to  {} .   Returns   (Promise) : A promise.   Examples  This differs from  ractive.set()  in the following way:  ractive = new Ractive({\n  // ...,\n  data: { foo: 1 }\n});\n\nractive.set({ bar: 2 });\nconsole.log( ractive.get() ); // { foo: 1, bar: 2 }\n\nractive.reset({ bar: 2 });\nconsole.log( ractive.get() ); // { bar: 2 }", 
            "title": "ractive.reset()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveresetpartial", 
            "text": "Resets a partial and re-renders all of its use-sites, including in any components that have inherited it. If a component has a partial with a same name that is its own, that partial will not be affected.  Inline partials that don't belong directly to a Ractive instance aren't affected by  resetPartial .  Syntax   ractive.resetPartial(name, partial)   Arguments   name (string) : The partial to reset.  partial (string|Object|Function) : A template string, pre-parsed template or a function that returns either.   Returns   (Promise) : A promise.   Examples  ractive = new Ractive({\n  // ...,\n  partials: { foo: 'foo' }\n});\n\n// {{ foo}} will be replaced with 'foo'\n\nractive.resetPartial('foo', 'bar');\n\n// {{ foo}} will be replaced with 'bar'", 
            "title": "ractive.resetPartial()"
        }, 
        {
            "location": "/api/instance-methods/#ractivereverse", 
            "text": "The Ractive equivalent to  Array.reverse  reverses the array at the given keypath and triggers an update event.  If the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.reverse(keypath)   Arguments   keypath (String) : The keypath of the array to reverse, e.g.  list  or  order.items   Returns   (Promise)  - A promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.reverse()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveset", 
            "text": "Updates data and triggers a re-render of any mustaches that are affected (directly or indirectly) by the change. Any observers of affected keypaths will be notified.  When setting an array value, ractive will reuse the existing DOM nodes for the new array, adding or removing nodes as necessary. This can impact nodes with  transitions . Use the  shuffle  option for setting a new array value while retaining existing nodes corresponding to individual array item values.  Syntax   ractive.set(keypath, value[, options])  ractive.set(map[, options])   Arguments   keypath (string) : The keypath of the data we're changing, e.g.  user  or  user.name  or  user.friends[1]  or  users.*.status .  value (any) : The value we're changing it to. Can be a primitive or an object (or array), in which case dependants of  downstream keypaths  will also be re-rendered (if they have changed).  map (Object) : A map of  keypath: value  pairs, as above.  [options] Object :  deep (boolean) : Whether or not to perform a deep set on with the data at the given keypath. A deep set recursively merges the given data into the data structure at the given keypath. Defaults to  false .  shuffle (boolean|string|Function) : Whether or not to add/move/remove DOM associated with elements rather than just re-using the existing DOM. Defaults to  false .  true : Add/move/remove existing items to their new index using a strict equality comparison.  string : Add/move/remove existing items to their new index using a property comparison where the property compared is named by the given string.  Function : Add/move/remove existing items to their new index using the value returned by the given function for comparison.    keep (boolean) : Whether or not to keep the virtual DOM that would be disposed by the  set  operation. This is useful for hiding components without completely tearing them down and recreating them. It's also a little bit faster, as the virtual DOM doesn't have to be recreated when it would reappear. This  may  try to keep the actual DOM around for reuse at some point in the future. Defaults to  false .     Returns   (Promise) : Returns a promise that will resolved after any transitions associated with the operation are complete.   Examples  // TODO  The  keypath  can also contain wildcards  pattern-observers . All matching keypaths will be set with the supplied values:  ractive.on('selectAll', function(){\n    ractive.set('items.*.selected', true);\n})", 
            "title": "ractive.set()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveshift", 
            "text": "The Ractive equivalent to  Array.shift  that removes an element from the beginning of the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.shift(keypath)   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .   Returns   (Promise) : A promise that will resolve with the removed element after the update is complete.   Examples  // TODO", 
            "title": "ractive.shift()"
        }, 
        {
            "location": "/api/instance-methods/#ractivesort", 
            "text": "The Ractive equivalent to  Array.sort  sorts the array at the given keypath and triggers an update event.  If the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.sort(keypath)   Arguments   keypath (string) : The keypath of the array to sort, e.g.  list  or  order.items .   Returns   (Promise) : Returns a promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.sort()"
        }, 
        {
            "location": "/api/instance-methods/#ractivesplice", 
            "text": "The Ractive equivalent to  Array.splice  that can add new elements to the array while removing existing elements.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.splice(keypath, index, [removeCount[, add]])   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .  index (number) : The index at which to start the operation.  [removeCount] (number) : The number of elements to remove starting with the element at * index . This may be 0 if you don't want to remove any elements.  [add] (any) : Any elements to insert into the array starting at * index . There can be 0 or more elements passed to add to the array.   Returns   (Promise) : Returns a promise that will resolve with the removed elements after the update is complete.   Examples  // TODO", 
            "title": "ractive.splice()"
        }, 
        {
            "location": "/api/instance-methods/#ractivesubtract", 
            "text": "Decrements the selected keypath.  Syntax   ractive.subtract(keypath[, number])   Arguments   keypath (string) : The keypath of the number we're decrementing.  [number] (number) : Defaults to  1 . The number to decrement by.   Returns   (Promise) : Returns a promise.   Examples  // TODO", 
            "title": "ractive.subtract()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveteardown", 
            "text": "Unrenders this Ractive instance, removing any event handlers that were bound automatically by Ractive.  Calling  ractive.teardown()  causes a  teardown   event  to be fired - this is most useful with  Ractive.extend()  as it allows you to clean up anything else (event listeners and other bindings) that are part of the subclass.  Syntax   ractive.teardown()   Arguments   None   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.teardown()"
        }, 
        {
            "location": "/api/instance-methods/#ractivetocss", 
            "text": "Returns the scoped CSS of the current instance and its descendants.  At the moment, this will not work on a direct instance of Ractive and will log a warning. You can only use this method on an instance of a subclass.  Syntax   ractive.toCSS()   Arguments   None   Returns   (string) : The scoped CSS of the instance.   Examples  const Subclass = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\nconst subclassInstance = new Subclass({...});\n\n// Contains the scoped version of div{ color: red }\nsubclassInstance.toCSS();", 
            "title": "ractive.toCSS()"
        }, 
        {
            "location": "/api/instance-methods/#ractivetohtml", 
            "text": "Returns a chunk of HTML representing the current state of the instance. This is most useful when you're using Ractive in node.js, as it allows you to serve fully-rendered pages (good for SEO and initial pageload performance) to the client.  Syntax   ractive.toHTML()   Arguments   None   Returns   (string) : The instance HTML.   Examples  // TODO", 
            "title": "ractive.toHTML()"
        }, 
        {
            "location": "/api/instance-methods/#ractivetoggle", 
            "text": "Toggles the selected keypath. In other words, if  foo  is  truthy , then  ractive.toggle('foo')  will make it  false , and vice-versa.  Syntax   ractive.toggle(keypath)   Arguments   keypath (string) : The keypath to toggle the value of. If  keypath  is a pattern, then all matching keypaths will be toggled.   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.toggle()"
        }, 
        {
            "location": "/api/instance-methods/#ractivetransition", 
            "text": "Triggers a transition on a node managed by this Ractive instance.  Syntax   ractive.transition(transition, node, options)   Arguments   transition (string|Function) : A transition function or a name of a transition function.  node (HTMLElement) : The node on which to start the transition - optional if called from within a Ractive event handler, as it will be retrieved from the event if not supplied.  options (Object) : Options supplied to the transition.   Returns   (Promise) : A promise that resolves when the transition completes.   Examples  // TODO", 
            "title": "ractive.transition()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveunlink", 
            "text": "Removes a link set up by  ractive.link() .  Syntax   ractive.unlink(destination)   Arguments   destination (string) : The destination supplied to [ ractive.link() ].   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.unlink()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveunrender", 
            "text": "Unrenders this Ractive instance, throwing away any DOM nodes associated with this instance. This is the counterpart to  ractive.render() . The rest of the ractive instance is left intact, unlike  ractive.teardown() .  Note that if the instance happens to be a component that is managed by another instance, the owning instance may veto the call to  unrender . If you need more precise control over component rendering, you should probably use an anchor and  ractive.attachChild()  instead.  Syntax   ractive.unrender()   Arguments   None   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.unrender()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveunshift", 
            "text": "The Ractive equivalent to  Array.unshift  that prepends one or more elements to the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.unshift(keypath, value)   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .  value (any) : The value to prepend to the beginning of the array. One or more values may be supplied.   Returns   (Promise) : Returns a promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.unshift()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveupdate", 
            "text": "\"Dirty checks\" everything that depends directly or indirectly on the specified keypath. If no  keypath  is specified, all keypaths will be checked. Keypaths that involve special references (i.e.  @global ) require the keypath to be supplied.  This is useful when manipulating the instance's data without using the built in setter methods (i.e.  ractive.set() ,  ractive.animate() ).  Syntax   ractive.update([keypath][, options])   Arguments   [keypath] (string) : The keypath to treat as 'dirty'.  [options] (Object string, any ) :  force (boolean) : Force an update regardless of whether or not the internal change check determines that the keypath has  actually  changed. This is useful for forcing all expressions referencing a particular function to recompute.     Returns   (Promise) : A promise that resolves when any transitions associated with the operation complete.   Examples  ractive.observe( 'foo', function ( foo ) {\n  alert( foo );\n});\n\nmodel.foo = 'changed';   // Does not cause the instance to update.\nractive.update( 'foo' ); // Informs the instance that foo was changed externally.", 
            "title": "ractive.update()"
        }, 
        {
            "location": "/api/instance-methods/#ractiveupdatemodel", 
            "text": "If you programmatically manipulate inputs and other elements that have  two\u2010way binding  set up, your model can get out of sync. In these cases, we need to force a resync with  ractive.updateModel() :  Syntax   ractive.updateModel([keypath[, cascade]])   Arguments   keypath (string) : The keypath to treat as 'dirty'. Any two-way bindings linked to this keypath will be checked to see if the model is out of date  cascade (boolean) : If true, bindings that are  downstream  of  keypath  will also be checked - e.g.  ractive.updateModel( 'items', true )  would check  items.0.foo  and  items.1.foo  and so on. Defaults to  false .   Returns   (Promise) : A promise. If a  keypath  is not specified, all two-way bindings will be checked.   Examples  ractive = new Ractive({\n  el: 'container',\n  template: ' input value= {{name}} '\n  data: { name: 'Bob' }\n});\n\nractive.find( 'input' ).value = 'Jim';\nalert( ractive.get( 'name' ) ); // alerts 'Bob', not 'Jim'\n\nractive.updateModel();\nalert( ractive.get( 'name' ) ); // alerts 'Jim'", 
            "title": "ractive.updateModel()"
        }, 
        {
            "location": "/api/attributes/", 
            "text": "Attributes\n\n\nas-*\n\n\nas-*\n attributes augment the element with \ndecorators\n. It accepts an optional, comma-separated list of expressions which are handed over as arguments to the decorator function.\n\n\ndiv as-modal\nDiv appearing as modal\n/div\n\n\ndiv as-modal=\ntrue, true, true, false\nDiv appearing as modal\n/div\n\n\n\n\n\nclass-*\n\n\nclass-*\n attributes toggle individual class names based on the truthiness of its value. The part of the attribute name following \nclass-\n will be used as the class name. \nclass-*\n attribute values are processed as expressions. If there is no expression, the implicit value is \ntrue\n, which is useful for applying multiple classes to an element using component \nextra-attributes\n.\n\n\ndiv class-foo=\nisFoo\nAdds \nfoo\n if isFoo is truthy\n/div\n\n\ndiv class-foo-bar=\nisFooBar\nAdds \nfoo-bar\n if isFooBar is truthy\n/div\n\n\ndiv class-fooBar=\nisFooBar\nAdds \nfooBar\n if isFooBar is truthy\n/div\n\n\ndiv class-baz\nAlways has \nbaz\n/div\n\n\n\n\n\non-*\n\n\non-*\n attributes attach event handlers for both native and \ncustom events\n. They are designed to look similar to regular \non*\n attributes for familiarity, the only difference being the hyphen. \non-*\n can be used in two ways: proxy event syntax and expression syntax.\n\n\nUsing the proxy event syntax, \non-*\n accepts an event name as value. Events are handled by registering a function with \nractive.on\n using the assigned event name.\n\n\nRactive({\n  template: `\n    \nbutton type=\nbutton\n on-click=\nclicked\nPush me!\n/button\n\n  `,\n  oninit(){\n    this.on('clicked', event =\n {\n      console.log('clicked!');\n    });\n  }\n});\n\n\n\n\nUsing the expression syntax, \non-*\n accepts expressions as value. This allows it to appear like regular inline scripts, similar to how it's done in inline event handlers.\n\n\nRactive({\n  template: `\n    \nbutton type=\nbutton\n on-click=\n@this.someMethod()\nPush me!\n/button\n\n  `,\n  someMethod(){\n    console.log('clicked!');\n  }\n});\n\n\n\n\nMultiple events can also be tied to the same handler by separating them with a hyphen:\n\n\nRactive({\n  template: `\n    \nbutton type=\nbutton\n on-hover-click=\n@this.someMethod()\nPush me!\n/button\n\n  `,\n  someMethod(){\n    console.log('Fires on hover and on click!');\n  }\n});\n\n\n\n\n*-in\n, \n*-out\n, \n*-in-out\n\n\n*-in\n, \n*-out\n, and \n*-in-out\n attributes apply \ntransitions\n to the element. \n*-in\n specifies intro-only, \n*-out\n specifies outro-only, and \n*-in-out\n for both intro and outro. All three accept an optional value, an expression in the form of an object which is handed over as arguments to the transition function.\n\n\ndiv fade-in\nFades on render\n/div\n\n\ndiv fade-out\nFades before removal\n/div\n\n\ndiv fade-in-out\nFades on render and before removal\n/div\n\n\ndiv fade-in-out=\n{ duration: 500 }\nFades with 500ms duration\n/div\n\n\n\n\n\nstyle-*\n\n\nstyle-*\n attributes update individual \nstyle\n properties of the element. The part of the attribute following \nstyle-\n will be used as the style property name. There are two forms of the syntax: \nstyle-property-name\n (CSS style) and \nstyle-propertyName\n (JS style). Style property names will be normalized.\n\n\ndiv style-vertical-align=\nmiddle\nApplies style.verticalAlign\n/div\n\n\ndiv style-textAlign=\ncenter\nApplies style.textAlign\n/div\n\n\n\n\n\nstyle-*\n attribute values are processed as strings. Mustaches can also be used to supply the values. When the values are updated, the appropriate style property on the element will update to the new value.\n\n\ndiv style-vertical-align=\n{{ vAlign }}\n style-textAlign=\n{{ tAlign }}\n...\n/div", 
            "title": "Attributes"
        }, 
        {
            "location": "/api/attributes/#attributes", 
            "text": "", 
            "title": "Attributes"
        }, 
        {
            "location": "/api/attributes/#as-", 
            "text": "as-*  attributes augment the element with  decorators . It accepts an optional, comma-separated list of expressions which are handed over as arguments to the decorator function.  div as-modal Div appearing as modal /div  div as-modal= true, true, true, false Div appearing as modal /div", 
            "title": "as-*"
        }, 
        {
            "location": "/api/attributes/#class-", 
            "text": "class-*  attributes toggle individual class names based on the truthiness of its value. The part of the attribute name following  class-  will be used as the class name.  class-*  attribute values are processed as expressions. If there is no expression, the implicit value is  true , which is useful for applying multiple classes to an element using component  extra-attributes .  div class-foo= isFoo Adds  foo  if isFoo is truthy /div  div class-foo-bar= isFooBar Adds  foo-bar  if isFooBar is truthy /div  div class-fooBar= isFooBar Adds  fooBar  if isFooBar is truthy /div  div class-baz Always has  baz /div", 
            "title": "class-*"
        }, 
        {
            "location": "/api/attributes/#on-", 
            "text": "on-*  attributes attach event handlers for both native and  custom events . They are designed to look similar to regular  on*  attributes for familiarity, the only difference being the hyphen.  on-*  can be used in two ways: proxy event syntax and expression syntax.  Using the proxy event syntax,  on-*  accepts an event name as value. Events are handled by registering a function with  ractive.on  using the assigned event name.  Ractive({\n  template: `\n     button type= button  on-click= clicked Push me! /button \n  `,\n  oninit(){\n    this.on('clicked', event =  {\n      console.log('clicked!');\n    });\n  }\n});  Using the expression syntax,  on-*  accepts expressions as value. This allows it to appear like regular inline scripts, similar to how it's done in inline event handlers.  Ractive({\n  template: `\n     button type= button  on-click= @this.someMethod() Push me! /button \n  `,\n  someMethod(){\n    console.log('clicked!');\n  }\n});  Multiple events can also be tied to the same handler by separating them with a hyphen:  Ractive({\n  template: `\n     button type= button  on-hover-click= @this.someMethod() Push me! /button \n  `,\n  someMethod(){\n    console.log('Fires on hover and on click!');\n  }\n});", 
            "title": "on-*"
        }, 
        {
            "location": "/api/attributes/#-in-out-in-out", 
            "text": "*-in ,  *-out , and  *-in-out  attributes apply  transitions  to the element.  *-in  specifies intro-only,  *-out  specifies outro-only, and  *-in-out  for both intro and outro. All three accept an optional value, an expression in the form of an object which is handed over as arguments to the transition function.  div fade-in Fades on render /div  div fade-out Fades before removal /div  div fade-in-out Fades on render and before removal /div  div fade-in-out= { duration: 500 } Fades with 500ms duration /div", 
            "title": "*-in, *-out, *-in-out"
        }, 
        {
            "location": "/api/attributes/#style-", 
            "text": "style-*  attributes update individual  style  properties of the element. The part of the attribute following  style-  will be used as the style property name. There are two forms of the syntax:  style-property-name  (CSS style) and  style-propertyName  (JS style). Style property names will be normalized.  div style-vertical-align= middle Applies style.verticalAlign /div  div style-textAlign= center Applies style.textAlign /div   style-*  attribute values are processed as strings. Mustaches can also be used to supply the values. When the values are updated, the appropriate style property on the element will update to the new value.  div style-vertical-align= {{ vAlign }}  style-textAlign= {{ tAlign }} ... /div", 
            "title": "style-*"
        }, 
        {
            "location": "/api/keypath-prefixes/", 
            "text": "Keypath prefixes\n\n\nNormally, keypaths are resolved following a \ndefined routine\n. But there are times where you want to skip the normal resolution routine and resolve a keypath relative to a specific data context. Keypath prefixes allow you to specify which data context a keypath resolves to, regardless if it resolves to something or not.\n\n\nCurrent context (\n.\n)\n\n\nResolves the keypath relative to the current data context.\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    spoon: 'SPOON',\n    matrix: {\n        agent: 'Smith'\n      // There is no spoon\n    }\n  },\n  template: `\n    \ndiv\nOutside the matrix, you have {{ spoon }}\n/div\n\n    {{# matrix }}\n      \ndiv\nInside the matrix, you think you have {{ spoon }}.\n/div\n\n      \ndiv\nIn reality, there is no {{ ./spoon }}\n/div\n\n    {{/}}\n  `\n});\n\n// Outside the matrix, you have SPOON\n// Inside the matrix, you think you have SPOON.\n// In reality, there is no\n\n\n\n\nParent keypath (\n../\n)\n\n\nResolves the keypath relative to the parent data. This prefix can be used more than once to reference ancestors.\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    id: 'reality',\n    dream: {\n        id: 'dream1',\n        dream: {\n            id: 'dream2',\n            dream: {\n                id: 'dream3',\n            }\n        }\n    }\n  },\n  template: `\n    \ndiv\nYou are in {{ id }}\n/div\n\n    {{# dream }}\n      \ndiv\nYou are in {{ id }}\n/div\n\n      {{# dream }}\n        \ndiv\nYou are in {{ id }}\n/div\n\n        {{# dream }}\n          \ndiv\nYou are in {{ id }}\n/div\n\n\n          \ndiv\nEscaping...\n/div\n\n          \ndiv\nYou are in {{ ../id }}\n/div\n\n          \ndiv\nYou are in {{ ../../id }}\n/div\n\n          \ndiv\nYou are in {{ ../../../id }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// You are in reality\n// You are in dream1\n// You are in dream2\n// You are in dream3\n// Escaping...\n// You are in dream2\n// You are in dream1\n// You are in reality\n\n\n\n\nParent context (\n^^/\n)\n\n\nWhile parent keypaths and parent contexts are often the same thing, there are some scenarios in which they are very, very different. For instance, in this horribly contrived example:\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    homebase: {\n      building1: { name: 'Operations' }\n    },\n    bases: [\n      {\n        building1: { name: 'Mess Hall' }\n      },\n      {\n        building1: { name: 'Medical Tent' }\n      }\n    ]\n  },\n  template: `\n    {{#each bases}}\n      {{#with ~/homebase}}\n        \ndiv\nthe home base bulding1 is {{.building1.name}}\n/div\n\n        \ndiv\nthe current iteration base building1 is {{^^/.building1.name}}\n/div\n\n      {{/with}}\n    {{/each}}\n  `\n});\n\n// the home base bulding1 is Operations\n// the current iteration base building1 is Mess Hall\n// the home base bulding1 is Operations\n// the current iteration base building1 is Medical Tent\n\n\n\n\nInstance root context (\n~/\n)\n\n\nResolves the keypath relative to the instance's root data context.\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    room: '1',\n    portal: {\n        room: '2',\n        portal: {\n            room: '3',\n            portal: {\n                room: '4',\n            }\n        }\n    }\n  },\n  template: `\n    {{# portal }}\n        {{# portal }}\n        {{# portal }}\n                \ndiv\nEntering...\n/div\n\n                \ndiv\nYou are in room {{ ~/room }}\n/div\n\n                \ndiv\nYou are in room {{ ~/portal.room }}\n/div\n\n                \ndiv\nYou are in room {{ ~/portal.portal.room }}\n/div\n\n                \ndiv\nYou are in room {{ ~/portal.portal.portal.room }}\n/div\n\n            {{/}}\n        {{/}}\n    {{/}}\n  `\n});\n\n// Entering...\n// You are in room 1\n// You are in room 2\n// You are in room 3\n// You are in room 4", 
            "title": "Keypath Prefixes"
        }, 
        {
            "location": "/api/keypath-prefixes/#keypath-prefixes", 
            "text": "Normally, keypaths are resolved following a  defined routine . But there are times where you want to skip the normal resolution routine and resolve a keypath relative to a specific data context. Keypath prefixes allow you to specify which data context a keypath resolves to, regardless if it resolves to something or not.", 
            "title": "Keypath prefixes"
        }, 
        {
            "location": "/api/keypath-prefixes/#current-context", 
            "text": "Resolves the keypath relative to the current data context.   Ractive({\n  target: 'body',\n  data: {\n    spoon: 'SPOON',\n    matrix: {\n        agent: 'Smith'\n      // There is no spoon\n    }\n  },\n  template: `\n     div Outside the matrix, you have {{ spoon }} /div \n    {{# matrix }}\n       div Inside the matrix, you think you have {{ spoon }}. /div \n       div In reality, there is no {{ ./spoon }} /div \n    {{/}}\n  `\n});\n\n// Outside the matrix, you have SPOON\n// Inside the matrix, you think you have SPOON.\n// In reality, there is no", 
            "title": "Current context (.)"
        }, 
        {
            "location": "/api/keypath-prefixes/#parent-keypath", 
            "text": "Resolves the keypath relative to the parent data. This prefix can be used more than once to reference ancestors.   Ractive({\n  target: 'body',\n  data: {\n    id: 'reality',\n    dream: {\n        id: 'dream1',\n        dream: {\n            id: 'dream2',\n            dream: {\n                id: 'dream3',\n            }\n        }\n    }\n  },\n  template: `\n     div You are in {{ id }} /div \n    {{# dream }}\n       div You are in {{ id }} /div \n      {{# dream }}\n         div You are in {{ id }} /div \n        {{# dream }}\n           div You are in {{ id }} /div \n\n           div Escaping... /div \n           div You are in {{ ../id }} /div \n           div You are in {{ ../../id }} /div \n           div You are in {{ ../../../id }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// You are in reality\n// You are in dream1\n// You are in dream2\n// You are in dream3\n// Escaping...\n// You are in dream2\n// You are in dream1\n// You are in reality", 
            "title": "Parent keypath (../)"
        }, 
        {
            "location": "/api/keypath-prefixes/#parent-context", 
            "text": "While parent keypaths and parent contexts are often the same thing, there are some scenarios in which they are very, very different. For instance, in this horribly contrived example:   Ractive({\n  target: 'body',\n  data: {\n    homebase: {\n      building1: { name: 'Operations' }\n    },\n    bases: [\n      {\n        building1: { name: 'Mess Hall' }\n      },\n      {\n        building1: { name: 'Medical Tent' }\n      }\n    ]\n  },\n  template: `\n    {{#each bases}}\n      {{#with ~/homebase}}\n         div the home base bulding1 is {{.building1.name}} /div \n         div the current iteration base building1 is {{^^/.building1.name}} /div \n      {{/with}}\n    {{/each}}\n  `\n});\n\n// the home base bulding1 is Operations\n// the current iteration base building1 is Mess Hall\n// the home base bulding1 is Operations\n// the current iteration base building1 is Medical Tent", 
            "title": "Parent context (^^/)"
        }, 
        {
            "location": "/api/keypath-prefixes/#instance-root-context", 
            "text": "Resolves the keypath relative to the instance's root data context.   Ractive({\n  target: 'body',\n  data: {\n    room: '1',\n    portal: {\n        room: '2',\n        portal: {\n            room: '3',\n            portal: {\n                room: '4',\n            }\n        }\n    }\n  },\n  template: `\n    {{# portal }}\n        {{# portal }}\n        {{# portal }}\n                 div Entering... /div \n                 div You are in room {{ ~/room }} /div \n                 div You are in room {{ ~/portal.room }} /div \n                 div You are in room {{ ~/portal.portal.room }} /div \n                 div You are in room {{ ~/portal.portal.portal.room }} /div \n            {{/}}\n        {{/}}\n    {{/}}\n  `\n});\n\n// Entering...\n// You are in room 1\n// You are in room 2\n// You are in room 3\n// You are in room 4", 
            "title": "Instance root context (~/)"
        }, 
        {
            "location": "/api/special-references/", 
            "text": "Special references\n\n\nSpecial references are template keywords that act like data references but do not actually exist in your data. These references provide metadata regarding the current instance, context, environment, operation and more.\n\n\nthis\n\n\nThe current data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    info: {\n      message: 'Hello World!',\n      info: {\n        message: 'The quick brown fox',\n        info: {\n          message: 'jumps over the lazy dog',\n          info: {\n            message: 'Thats all folks'\n          }\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nroot: {{ JSON.stringify(this) }}\n/div\n\n    {{# info }}\n      \ndiv\ninfo 1: {{ JSON.stringify(this) }}\n/div\n\n      {{# info }}\n        \ndiv\ninfo 2: {{ JSON.stringify(this) }}\n/div\n\n        {{# info }}\n          \ndiv\ninfo 3: {{ JSON.stringify(this) }}\n/div\n\n          {{# info }}\n            \ndiv\ninfo 4: {{ JSON.stringify(this) }}\n/div\n\n          {{/}}\n        {{/}}\n      {{/}}\n    {{/}}\n  `,\n});\n\n// info 1: {\ninfo\n:{\nmessage\n:\nHello World!\n,\ninfo\n:{\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}}}\n// info 2: {\nmessage\n:\nHello World!\n,\ninfo\n:{\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}}\n// info 3: {\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}\n// info 4: {\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}\n// info 5: {\nmessage\n:\nThats all folks\n}\n\n\n\n\n@this\n\n\nThe current Ractive instance.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n    \ndiv\nCount: {{ count }}\n/div\n\n    \nbutton type=\nbutton\n on-click=\n@this.add('count')\nIncrement\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.myMethod()\nLog count\n/button\n\n  `,\n  myMethod(){\n    console.log(`current count is ${this.get('count')}`);\n  }\n});\n\n\n\n\n@index\n\n\nThe current iteration index of the containing repeated section.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @index }} says: Hi! I'm {{ name }}!\n/div\n\n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!\n\n\n\n\nFor objects, \n@index\n is still the iteration index.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @index }} says: {{ this }}\n/div\n\n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I am bob!\n// User #1 says: Hi! I am alice!\n// User #2 says: Hi! I am eve!\n\n\n\n\n@key\n\n\nThe current key name of the containing object iteration section.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser {{ @key }} says: {{ this }}\n/div\n\n    {{/each}}\n  `\n});\n\n// User bob says: Hi! I am bob!\n// User alice says: Hi! I am alice!\n// User eve says: Hi! I am eve!\n\n\n\n\nFor arrays, \n@key\n's value will be the iteration index.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @key }} says: Hi! I'm {{ name }}!\n/div\n\n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!\n\n\n\n\n@keypath\n\n\nThe keypath to the current data context relative to the instance's root data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nKeypath: {{ @keypath }}\n/div\n\n    {{# foo }}\n      \ndiv\nKeypath: {{ @keypath }}\n/div\n\n      {{# bar }}\n        \ndiv\nKeypath: {{ @keypath }}\n/div\n\n        {{# baz }}\n          \ndiv\nKeypath: {{ @keypath }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz\n\n\n\n\nIf the keypath is a mapping, the keypath will remain relative to the instance.\n\n\n\n\n\nRactive.components.Message = Ractive.extend({\n  data: () =\n ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n      \ndiv\nSender: {{ name }}\n/div\n\n      \ndiv\nMessage: {{ message }}\n/div\n\n      \ndiv\nKeypath: {{ @keypath }}\n/div\n\n    {{/}}\n  `\n});\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n      \nMessage info=\n{{ this }}\n /\n\n    {{/}}\n  `\n});\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: info\n// Sender: bob\n// Message: Hi eve!\n// Keypath: info\n\n\n\n\n@rootpath\n\n\nThe keypath to the current data context relative to the originating instance's root data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n    {{# foo }}\n      \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n      {{# bar }}\n        \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n        {{# baz }}\n          \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz\n\n\n\n\nIf the keypath is a mapping, it will be adjusted relative to the originating instance's root data context. This is what primarily sets \n@rootpath\n apart from \n@keypath\n.\n\n\n\n\n\nRactive.components.Message = Ractive.extend({\n  data: () =\n ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n      \ndiv\nSender: {{ name }}\n/div\n\n      \ndiv\nMessage: {{ message }}\n/div\n\n      \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n    {{/}}\n  `\n});\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n      \nMessage info=\n{{ this }}\n /\n\n    {{/}}\n  `\n});\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: mail.inbox.messages.0\n// Sender: bob\n// Message: Hi eve!\n// Keypath: mail.inbox.messages.1\n\n\n\n\n@global\n\n\nThe global object of the current environment. For browsers, it references the \nwindow\n object. For Node.js, it references the \nglobal\n object.\n\n\n\n\n\nwindow.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n  `\n});\n\n// Hello World!\n\n\n\n\nRactive can automatically update properties on \n@global\n via two-way binding. However, for changes caused externally, \nractive.update()\n must be called to re-render the UI.\n\n\n\n\n\nwindow.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n    \ninput type=\ntext\n value=\n{{ @global.message }}\n\n    \nbutton type=\nbutton\n on-click=\n@this.logReference()\nLog reference value\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.logGlobal()\nLog global value\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.setFooBarBaz()\nChange to \nfoo bar baz\n directly\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.update('@global.message')\nClick to update\n/button\n\n\n    \nol\n\n      \nli\nClick \nLog reference value\n and look at the console\n/li\n\n      \nli\nClick \nLog global value\n and look at the console\n/li\n\n      \nli\nChange the input value and repeat steps 1 and 2\n/li\n\n      \nli\nClick \nChange to 'foo bar baz' directly\n/li\n\n      \nli\nRepeat steps 1 and 2 and notice that step 1 was not aware of the direct change\n/li\n\n      \nli\nClick \nClick to update\n/li\n\n      \nli\nRepeat steps 1 and 2 and notice that both steps are now aware\n/li\n\n    \n/ol\n\n  `,\n  logReference(){\n    console.log(this.get('@global.message'))\n  },\n  logGlobal(){\n    console.log(window.message);\n  },\n  setFooBarBaz(){\n    window.message = \nfoo bar baz\n\n  }\n});\n\n\n\n\n\n\n@shared\n\n\n@shared\n is a Ractive-global model similar to \n@global\n but not subject to interference from outside of Ractive.\n\n\n\n\n@context\n\n\nThe \ncontext object\n associated with the current context.\n\n\n\n\n@event\n\n\nThe DOM event that is triggering an event directive. This reference is only available to event directive expressions.\n\n\n\n\n@node\n\n\nThe DOM node associated with an event directive. This reference is only available to event directive expressions.\n\n\n\n\n@local\n\n\nSpecial context-local storage associated with the current context. This is intended more for library use with decorators and parser transforms.", 
            "title": "Special References"
        }, 
        {
            "location": "/api/special-references/#special-references", 
            "text": "Special references are template keywords that act like data references but do not actually exist in your data. These references provide metadata regarding the current instance, context, environment, operation and more.", 
            "title": "Special references"
        }, 
        {
            "location": "/api/special-references/#this", 
            "text": "The current data context.   Ractive({\n  el: 'body',\n  data: {\n    info: {\n      message: 'Hello World!',\n      info: {\n        message: 'The quick brown fox',\n        info: {\n          message: 'jumps over the lazy dog',\n          info: {\n            message: 'Thats all folks'\n          }\n        }\n      }\n    }\n  },\n  template: `\n     div root: {{ JSON.stringify(this) }} /div \n    {{# info }}\n       div info 1: {{ JSON.stringify(this) }} /div \n      {{# info }}\n         div info 2: {{ JSON.stringify(this) }} /div \n        {{# info }}\n           div info 3: {{ JSON.stringify(this) }} /div \n          {{# info }}\n             div info 4: {{ JSON.stringify(this) }} /div \n          {{/}}\n        {{/}}\n      {{/}}\n    {{/}}\n  `,\n});\n\n// info 1: { info :{ message : Hello World! , info :{ message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}}}\n// info 2: { message : Hello World! , info :{ message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}}\n// info 3: { message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}\n// info 4: { message : jumps over the lazy dog , info :{ message : Thats all folks }}\n// info 5: { message : Thats all folks }", 
            "title": "this"
        }, 
        {
            "location": "/api/special-references/#this_1", 
            "text": "The current Ractive instance.   Ractive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n     div Count: {{ count }} /div \n     button type= button  on-click= @this.add('count') Increment /button \n     button type= button  on-click= @this.myMethod() Log count /button \n  `,\n  myMethod(){\n    console.log(`current count is ${this.get('count')}`);\n  }\n});", 
            "title": "@this"
        }, 
        {
            "location": "/api/special-references/#index", 
            "text": "The current iteration index of the containing repeated section.   Ractive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @index }} says: Hi! I'm {{ name }}! /div \n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!  For objects,  @index  is still the iteration index.   Ractive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @index }} says: {{ this }} /div \n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I am bob!\n// User #1 says: Hi! I am alice!\n// User #2 says: Hi! I am eve!", 
            "title": "@index"
        }, 
        {
            "location": "/api/special-references/#key", 
            "text": "The current key name of the containing object iteration section.   Ractive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n       div User {{ @key }} says: {{ this }} /div \n    {{/each}}\n  `\n});\n\n// User bob says: Hi! I am bob!\n// User alice says: Hi! I am alice!\n// User eve says: Hi! I am eve!  For arrays,  @key 's value will be the iteration index.   Ractive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @key }} says: Hi! I'm {{ name }}! /div \n    {{/each}}\n  `\n});\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!", 
            "title": "@key"
        }, 
        {
            "location": "/api/special-references/#keypath", 
            "text": "The keypath to the current data context relative to the instance's root data context.   Ractive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n     div Keypath: {{ @keypath }} /div \n    {{# foo }}\n       div Keypath: {{ @keypath }} /div \n      {{# bar }}\n         div Keypath: {{ @keypath }} /div \n        {{# baz }}\n           div Keypath: {{ @keypath }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz  If the keypath is a mapping, the keypath will remain relative to the instance.   Ractive.components.Message = Ractive.extend({\n  data: () =  ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n       div Sender: {{ name }} /div \n       div Message: {{ message }} /div \n       div Keypath: {{ @keypath }} /div \n    {{/}}\n  `\n});\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n       Message info= {{ this }}  / \n    {{/}}\n  `\n});\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: info\n// Sender: bob\n// Message: Hi eve!\n// Keypath: info", 
            "title": "@keypath"
        }, 
        {
            "location": "/api/special-references/#rootpath", 
            "text": "The keypath to the current data context relative to the originating instance's root data context.   Ractive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n     div Keypath: {{ @rootpath }} /div \n    {{# foo }}\n       div Keypath: {{ @rootpath }} /div \n      {{# bar }}\n         div Keypath: {{ @rootpath }} /div \n        {{# baz }}\n           div Keypath: {{ @rootpath }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n});\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz  If the keypath is a mapping, it will be adjusted relative to the originating instance's root data context. This is what primarily sets  @rootpath  apart from  @keypath .   Ractive.components.Message = Ractive.extend({\n  data: () =  ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n       div Sender: {{ name }} /div \n       div Message: {{ message }} /div \n       div Keypath: {{ @rootpath }} /div \n    {{/}}\n  `\n});\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n       Message info= {{ this }}  / \n    {{/}}\n  `\n});\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: mail.inbox.messages.0\n// Sender: bob\n// Message: Hi eve!\n// Keypath: mail.inbox.messages.1", 
            "title": "@rootpath"
        }, 
        {
            "location": "/api/special-references/#global", 
            "text": "The global object of the current environment. For browsers, it references the  window  object. For Node.js, it references the  global  object.   window.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n  `\n});\n\n// Hello World!  Ractive can automatically update properties on  @global  via two-way binding. However, for changes caused externally,  ractive.update()  must be called to re-render the UI.   window.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n     input type= text  value= {{ @global.message }} \n     button type= button  on-click= @this.logReference() Log reference value /button \n     button type= button  on-click= @this.logGlobal() Log global value /button \n     button type= button  on-click= @this.setFooBarBaz() Change to  foo bar baz  directly /button \n     button type= button  on-click= @this.update('@global.message') Click to update /button \n\n     ol \n       li Click  Log reference value  and look at the console /li \n       li Click  Log global value  and look at the console /li \n       li Change the input value and repeat steps 1 and 2 /li \n       li Click  Change to 'foo bar baz' directly /li \n       li Repeat steps 1 and 2 and notice that step 1 was not aware of the direct change /li \n       li Click  Click to update /li \n       li Repeat steps 1 and 2 and notice that both steps are now aware /li \n     /ol \n  `,\n  logReference(){\n    console.log(this.get('@global.message'))\n  },\n  logGlobal(){\n    console.log(window.message);\n  },\n  setFooBarBaz(){\n    window.message =  foo bar baz \n  }\n});", 
            "title": "@global"
        }, 
        {
            "location": "/api/special-references/#shared", 
            "text": "@shared  is a Ractive-global model similar to  @global  but not subject to interference from outside of Ractive.", 
            "title": "@shared"
        }, 
        {
            "location": "/api/special-references/#context", 
            "text": "The  context object  associated with the current context.", 
            "title": "@context"
        }, 
        {
            "location": "/api/special-references/#event", 
            "text": "The DOM event that is triggering an event directive. This reference is only available to event directive expressions.", 
            "title": "@event"
        }, 
        {
            "location": "/api/special-references/#node", 
            "text": "The DOM node associated with an event directive. This reference is only available to event directive expressions.", 
            "title": "@node"
        }, 
        {
            "location": "/api/special-references/#local", 
            "text": "Special context-local storage associated with the current context. This is intended more for library use with decorators and parser transforms.", 
            "title": "@local"
        }, 
        {
            "location": "/api/context/", 
            "text": "Context\n\n\nThe context object is the type of object you receive when calling \ngetContext()\n. This object contains various properties and methods that allow you to interact with and obtain information about the Ractive instance, the node associated with it and the context surrounding it.\n\n\nThe special \n@context\n reference is also a context object that is associated with the nearest VDOM item and element. It's frequently used with event directives to interact with the data associated with the immediate context.\n\n\nHelper methods that take a \nkeypath\n will resolve relative to that node's context. Special references, template aliases, and key and index aliases are supported. If the method doesn't require a keypath, like \nget\n, then the keypath will implicitly be \n.\n rather than \n~/\n, as with regular instance methods.\n\n\n\n\ncontext.add()\n\n\nSee \nractive.add()\n.\n\n\n\n\ncontext.animate()\n\n\nSee \nractive.animate()\n.\n\n\n\n\ncontext.decorators\n\n\n(Object)\n\n\nA map of decorator name to decorator return object for all of the decorators on the node associated with the context.\n\n\n\n\ncontext.event\n\n\n(Event|undefined)\n\n\nThe original event for contexts supplied to event directives. This is \nundefined\n for contexts not associated with an event.\n\n\n\n\ncontext.get()\n\n\nSee \nractive.get()\n.\n\n\n\n\ncontext.getBinding()\n\n\nReturns the value of the binding if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\ncontext.getBinding()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(any)\n: The value of the binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\ninput id=\nfindMe\n value=\n{{.baz}}\n /\n{{/with}}\n\n\n\n\nRactive.getContext('#findMe').getBinding(); // returns value of foo.bar.baz\n\n\n\n\ncontext.getBindingPath()\n\n\nReturns the keypath of the binding if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\ncontext.getBindingPath([ractive])\n\n\n\n\nArguments\n\n\n\n\n[ractive] (Ractive)\n: The instance to resolve the keypath against.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The keypath of the node binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\ninput id=\nfindMe\n value=\n{{.baz}}\n /\n{{/with}}\n\n\n\n\nRactive.getContext('#findMe').getBindingPath(); // Returns \nfoo.bar.baz\n\n\n\n\n\n\n\ncontext.isBound()\n\n\nReturns \ntrue\n if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\ncontext.isBound()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: \ntrue\n if the node represented has a two-way binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\n  \ninput id=\nfoo\n value=\n{{.baz}}\n /\n\n  \ninput id=\nbar\n value=\n /\n\n{{/with}}\n\n\n\n\nRactive.getContext('#foo').isBound(); // Returns true\nRactive.getContext('#bar').isBound(); // Returns false\n\n\n\n\n\n\ncontext.link()\n\n\nSee \nractive.link()\n.\n\n\n\n\ncontext.node\n\n\n(Node|undefined)\n\n\nThe node associated with the context. Note that it is possible to get a context that is not associated with an element, which will leave the node \nundefined\n.\n\n\n\n\ncontext.observe()\n\n\nSee \nractive.observe()\n.\n\n\n\n\ncontext.observeOnce()\n\n\nSee \nractive.observeOnce()\n.\n\n\n\n\ncontext.original\n\n\n(Event|undefined)\n\n\nThe original DOM event object. Normally present when the event is a Ractive DOM event. May be \nundefined\n on custom events or events from event plugins.\n\n\n\n\ncontext.pop()\n\n\nSee \nractive.pop()\n.\n\n\n\n\ncontext.push()\n\n\nSee \nractive.push()\n.\n\n\n\n\ncontext.ractive\n\n\n(Ractive)\n\n\nThis property holds a reference to the Ractive instance that controls the node represented by this info object.\n\n\n\n\ncontext.raise()\n\n\nTriggers the nearest matching event directive relative to the context. This is useful for decorators and other library constructs that want to be able to raise their own events that aren't necessarily tied to a DOM event. Raised events do not bubble.\n\n\nSyntax\n\n\n\n\ncontext.raise(eventName[, event[, ...args]])\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The name of the event to raise. For \ndiv on-something=\"...\"\n, the event name would be \n'something'\n.\n\n\n[event] (context|object)\n: The context for the event or an object of properties to assign to the context for the event. Defaults to \n{}\n.\n\n\n[args] (...any)\n: Additional arguments to supply to the event handler.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\ncontext.readLink()\n\n\nSee \nractive.readLink()\n.\n\n\n\n\ncontext.resolve()\n\n\nResolves the given keypath to a full keypath. If a Ractive instance is supplied, the resolved path will also account for any mappings defined for the instance.\n\n\nSyntax\n\n\n\n\ncontext.resolve([keypath[, ractive]])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The keypath to resolve.\n\n\n[ractive] (Ractive)\n: The instance to resolve the keypath against.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The resolved keypath.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\ncontext.reverse()\n\n\nSee \nractive.reverse()\n.\n\n\n\n\ncontext.set()\n\n\nSee \nractive.set()\n.\n\n\n\n\ncontext.setBinding()\n\n\nSets the binding of the node represented by this info object to the specified value.\n\n\nSyntax\n\n\n\n\ncontext.setBinding(value)\n\n\n\n\nArguments\n\n\n\n\nvalue (any)\n. The value to set.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\ncontext.shift()\n\n\nSee \nractive.shift()\n.\n\n\n\n\ncontext.splice()\n\n\nSee \nractive.splice()\n.\n\n\n\n\ncontext.sort()\n\n\nSee \nractive.sort()\n.\n\n\n\n\ncontext.subtract()\n\n\nSee \nractive.subtract()\n.\n\n\n\n\ncontext.toggle()\n\n\nSee \nractive.toggle()\n.\n\n\n\n\ncontext.unlink()\n\n\nSee \nractive.unlink()\n.\n\n\n\n\ncontext.unshift()\n\n\nSee \nractive.unshift()\n.\n\n\n\n\ncontext.update()\n\n\nSee \nractive.update()\n.\n\n\n\n\ncontext.updateModel()\n\n\nSee \nractive.updateModel()\n.", 
            "title": "Context Object"
        }, 
        {
            "location": "/api/context/#context", 
            "text": "The context object is the type of object you receive when calling  getContext() . This object contains various properties and methods that allow you to interact with and obtain information about the Ractive instance, the node associated with it and the context surrounding it.  The special  @context  reference is also a context object that is associated with the nearest VDOM item and element. It's frequently used with event directives to interact with the data associated with the immediate context.  Helper methods that take a  keypath  will resolve relative to that node's context. Special references, template aliases, and key and index aliases are supported. If the method doesn't require a keypath, like  get , then the keypath will implicitly be  .  rather than  ~/ , as with regular instance methods.", 
            "title": "Context"
        }, 
        {
            "location": "/api/context/#contextadd", 
            "text": "See  ractive.add() .", 
            "title": "context.add()"
        }, 
        {
            "location": "/api/context/#contextanimate", 
            "text": "See  ractive.animate() .", 
            "title": "context.animate()"
        }, 
        {
            "location": "/api/context/#contextdecorators", 
            "text": "(Object)  A map of decorator name to decorator return object for all of the decorators on the node associated with the context.", 
            "title": "context.decorators"
        }, 
        {
            "location": "/api/context/#contextevent", 
            "text": "(Event|undefined)  The original event for contexts supplied to event directives. This is  undefined  for contexts not associated with an event.", 
            "title": "context.event"
        }, 
        {
            "location": "/api/context/#contextget", 
            "text": "See  ractive.get() .", 
            "title": "context.get()"
        }, 
        {
            "location": "/api/context/#contextgetbinding", 
            "text": "Returns the value of the binding if the node represented by this info object has a two-way binding.  Syntax   context.getBinding()   Arguments   None   Returns   (any) : The value of the binding.   Examples  {{#with foo.bar}} input id= findMe  value= {{.baz}}  / {{/with}}  Ractive.getContext('#findMe').getBinding(); // returns value of foo.bar.baz", 
            "title": "context.getBinding()"
        }, 
        {
            "location": "/api/context/#contextgetbindingpath", 
            "text": "Returns the keypath of the binding if the node represented by this info object has a two-way binding.  Syntax   context.getBindingPath([ractive])   Arguments   [ractive] (Ractive) : The instance to resolve the keypath against.   Returns   (string) : The keypath of the node binding.   Examples  {{#with foo.bar}} input id= findMe  value= {{.baz}}  / {{/with}}  Ractive.getContext('#findMe').getBindingPath(); // Returns  foo.bar.baz", 
            "title": "context.getBindingPath()"
        }, 
        {
            "location": "/api/context/#contextisbound", 
            "text": "Returns  true  if the node represented by this info object has a two-way binding.  Syntax   context.isBound()   Arguments   None   Returns   (boolean) :  true  if the node represented has a two-way binding.   Examples  {{#with foo.bar}}\n   input id= foo  value= {{.baz}}  / \n   input id= bar  value=  / \n{{/with}}  Ractive.getContext('#foo').isBound(); // Returns true\nRactive.getContext('#bar').isBound(); // Returns false", 
            "title": "context.isBound()"
        }, 
        {
            "location": "/api/context/#contextlink", 
            "text": "See  ractive.link() .", 
            "title": "context.link()"
        }, 
        {
            "location": "/api/context/#contextnode", 
            "text": "(Node|undefined)  The node associated with the context. Note that it is possible to get a context that is not associated with an element, which will leave the node  undefined .", 
            "title": "context.node"
        }, 
        {
            "location": "/api/context/#contextobserve", 
            "text": "See  ractive.observe() .", 
            "title": "context.observe()"
        }, 
        {
            "location": "/api/context/#contextobserveonce", 
            "text": "See  ractive.observeOnce() .", 
            "title": "context.observeOnce()"
        }, 
        {
            "location": "/api/context/#contextoriginal", 
            "text": "(Event|undefined)  The original DOM event object. Normally present when the event is a Ractive DOM event. May be  undefined  on custom events or events from event plugins.", 
            "title": "context.original"
        }, 
        {
            "location": "/api/context/#contextpop", 
            "text": "See  ractive.pop() .", 
            "title": "context.pop()"
        }, 
        {
            "location": "/api/context/#contextpush", 
            "text": "See  ractive.push() .", 
            "title": "context.push()"
        }, 
        {
            "location": "/api/context/#contextractive", 
            "text": "(Ractive)  This property holds a reference to the Ractive instance that controls the node represented by this info object.", 
            "title": "context.ractive"
        }, 
        {
            "location": "/api/context/#contextraise", 
            "text": "Triggers the nearest matching event directive relative to the context. This is useful for decorators and other library constructs that want to be able to raise their own events that aren't necessarily tied to a DOM event. Raised events do not bubble.  Syntax   context.raise(eventName[, event[, ...args]])   Arguments   eventName (string) : The name of the event to raise. For  div on-something=\"...\" , the event name would be  'something' .  [event] (context|object) : The context for the event or an object of properties to assign to the context for the event. Defaults to  {} .  [args] (...any) : Additional arguments to supply to the event handler.   Examples  // TODO", 
            "title": "context.raise()"
        }, 
        {
            "location": "/api/context/#contextreadlink", 
            "text": "See  ractive.readLink() .", 
            "title": "context.readLink()"
        }, 
        {
            "location": "/api/context/#contextresolve", 
            "text": "Resolves the given keypath to a full keypath. If a Ractive instance is supplied, the resolved path will also account for any mappings defined for the instance.  Syntax   context.resolve([keypath[, ractive]])   Arguments   [keypath] (string) : The keypath to resolve.  [ractive] (Ractive) : The instance to resolve the keypath against.   Returns   (string) : The resolved keypath.   Examples  // TODO", 
            "title": "context.resolve()"
        }, 
        {
            "location": "/api/context/#contextreverse", 
            "text": "See  ractive.reverse() .", 
            "title": "context.reverse()"
        }, 
        {
            "location": "/api/context/#contextset", 
            "text": "See  ractive.set() .", 
            "title": "context.set()"
        }, 
        {
            "location": "/api/context/#contextsetbinding", 
            "text": "Sets the binding of the node represented by this info object to the specified value.  Syntax   context.setBinding(value)   Arguments   value (any) . The value to set.   Returns   (Promise)   Examples  // TODO", 
            "title": "context.setBinding()"
        }, 
        {
            "location": "/api/context/#contextshift", 
            "text": "See  ractive.shift() .", 
            "title": "context.shift()"
        }, 
        {
            "location": "/api/context/#contextsplice", 
            "text": "See  ractive.splice() .", 
            "title": "context.splice()"
        }, 
        {
            "location": "/api/context/#contextsort", 
            "text": "See  ractive.sort() .", 
            "title": "context.sort()"
        }, 
        {
            "location": "/api/context/#contextsubtract", 
            "text": "See  ractive.subtract() .", 
            "title": "context.subtract()"
        }, 
        {
            "location": "/api/context/#contexttoggle", 
            "text": "See  ractive.toggle() .", 
            "title": "context.toggle()"
        }, 
        {
            "location": "/api/context/#contextunlink", 
            "text": "See  ractive.unlink() .", 
            "title": "context.unlink()"
        }, 
        {
            "location": "/api/context/#contextunshift", 
            "text": "See  ractive.unshift() .", 
            "title": "context.unshift()"
        }, 
        {
            "location": "/api/context/#contextupdate", 
            "text": "See  ractive.update() .", 
            "title": "context.update()"
        }, 
        {
            "location": "/api/context/#contextupdatemodel", 
            "text": "See  ractive.updateModel() .", 
            "title": "context.updateModel()"
        }, 
        {
            "location": "/api/parse/", 
            "text": "Parse\n\n\nThe parse object is an object you receive as the second argument in \nfunction templates\n. This helper object provides you with essential functions to dissect markup before turning over the template for use.\n\n\n\n\np.fromId()\n\n\nRetrieves the template from the DOM \nscript\n tag specified by \nid\n. Make sure to set \ntype='text/ractive'\n on the \nscript\n tag to prevent the browser from running the template as a script.\n\n\nSyntax\n\n\n\n\np.fromId(id)\n\n\n\n\nArguments\n\n\n\n\nid (string)\n: The id of the \nscript\n tag containing the template. The leading \n#\n is optional.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The template inside the specified element.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\np.isParsed()\n\n\nTest whether the supplied template is already parsed and is in its object form.\n\n\nSyntax\n\n\n\n\np.isParsed(template)\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The template, either in its string form or object form.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: Returns \ntrue\n if the template is already parsed, \nfalse\n if otherwise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\np.parse()\n\n\nParses the template using \nRactive.parse()\n. Full Ractive runtime must be loaded.\n\n\nSyntax\n\n\n\n\np.parse(template[, parseOptions])\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The template in its string form or object form.\n\n\n[parseOptions] (Object)\n: Template parser options. See \nRactive.parse()\n for all available options. If \nparseOptions\n is not specified, it defaults to those of the current instance.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: The parsed template.\n\n\n\n\nExamples\n\n\n// TODO", 
            "title": "Parse"
        }, 
        {
            "location": "/api/parse/#parse", 
            "text": "The parse object is an object you receive as the second argument in  function templates . This helper object provides you with essential functions to dissect markup before turning over the template for use.", 
            "title": "Parse"
        }, 
        {
            "location": "/api/parse/#pfromid", 
            "text": "Retrieves the template from the DOM  script  tag specified by  id . Make sure to set  type='text/ractive'  on the  script  tag to prevent the browser from running the template as a script.  Syntax   p.fromId(id)   Arguments   id (string) : The id of the  script  tag containing the template. The leading  #  is optional.   Returns   (string) : The template inside the specified element.   Examples  // TODO", 
            "title": "p.fromId()"
        }, 
        {
            "location": "/api/parse/#pisparsed", 
            "text": "Test whether the supplied template is already parsed and is in its object form.  Syntax   p.isParsed(template)   Arguments   template (string|Object) : The template, either in its string form or object form.   Returns   (boolean) : Returns  true  if the template is already parsed,  false  if otherwise.   Examples  // TODO", 
            "title": "p.isParsed()"
        }, 
        {
            "location": "/api/parse/#pparse", 
            "text": "Parses the template using  Ractive.parse() . Full Ractive runtime must be loaded.  Syntax   p.parse(template[, parseOptions])   Arguments   template (string|Object) : The template in its string form or object form.  [parseOptions] (Object) : Template parser options. See  Ractive.parse()  for all available options. If  parseOptions  is not specified, it defaults to those of the current instance.   Returns   (Object) : The parsed template.   Examples  // TODO", 
            "title": "p.parse()"
        }, 
        {
            "location": "/api/transition/", 
            "text": "Transition\n\n\nThe transition object is an object you receive when writing transitions. It has a few properties and methods designed to make creating transitions easier.\n\n\n\n\nt.animateStyle()\n\n\nAnimates CSS properties to a certain value.\n\n\nSyntax\n\n\n\n\nt.animateStyle(prop, value, options[, complete])\n\n\nt.animateStyle(props, options[, complete])\n\n\n\n\nArguments\n\n\n\n\nprops (Object)\n: A map of animation properties and values.\n\n\nprop (string)\n: The style to animate.\n\n\nvalue (any)\n: The value to animate it to.\n\n\noptions (Object)\n: Animation options.\n\n\nduration (number)\n: The duration of the animation.\n\n\neasing (string)\n: The easing function of the animation.\n\n\ndelay (number)\n: The number of milliseconds before the animation starts.\n\n\n[complete] (Function)\n: A function that is executed when the animation completes, or immediately if no changes were made.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the animation completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.complete()\n\n\nSignals Ractive that the transition is complete.\n\n\nSyntax\n\n\n\n\nt.complete[noReset])\n\n\n\n\nArguments\n\n\n\n\n[noReset] (boolean)\n: If \ntrue\n, \nt.resetStyle()\n is not called. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.getStyle()\n\n\nRetrieve a CSS property value from \nt.node\n.\n\n\nSyntax\n\n\n\n\nt.getStyle(prop)\n\n\n\n\nArguments\n\n\n\n\nprop (string)\n: An unprefixed CSS property either in camelCase or kebab-case.\n\n\nprop (Array)\n: An array of CSS properties.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The value of the specified style property.\n\n\n(Object)\n: A key-value pair of properties and their respective values.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.isIntro\n\n\n(boolean)\n\n\nShould be self-explanatory...\n\n\n\n\nt.name\n\n\n(string)\n\n\nThe name of the transition.\n\n\n\n\nt.node\n\n\n(Node)\n\n\nThe node that's entering or leaving the DOM\n\n\n\n\nt.processParams()\n\n\nBuilds a map of parameters whose values are taken from the provided arguments. When used with a single number or string argument, serves as a shorthand for creating a map with a \nduration\n property.\n\n\nSyntax\n\n\n\n\nt.processParams(params[, defaults])\n\n\n\n\nArguments\n\n\n\n\nparams (number)\n: Numeric shorthand for the \nduration\n parameter. Expressed in milliseconds.\n\n\nparams (string)\n: String shorthand for the \nduration\n parameter. Valid values are:\n\n\n\"fast\" - 200ms\n\n\n\"slow\" - 600ms\n\n\nAny other string - 400ms\n\n\n\n\n\n\nparams (Object)\n: A map of parameters and their values.\n\n\n[defaults] (Object)\n: A map of parameters and their default values.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: A map of parameters and their values.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.setStyle()\n\n\nSets a CSS property on \nt.node\n to a value.\n\n\nSyntax\n\n\n\n\nt.setStyle(prop, value)\n\n\nt.setStyle(props)\n\n\n\n\nArguments\n\n\n\n\nprop (string)\n: An unprefixed CSS property either in camelCase or kebab-case.\n\n\nprops (Object)\n: A key-value pair of CSS properties and their respective values.\n\n\nvalue (string)\n: A valid value for the specified CSS property.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO", 
            "title": "Transition"
        }, 
        {
            "location": "/api/transition/#transition", 
            "text": "The transition object is an object you receive when writing transitions. It has a few properties and methods designed to make creating transitions easier.", 
            "title": "Transition"
        }, 
        {
            "location": "/api/transition/#tanimatestyle", 
            "text": "Animates CSS properties to a certain value.  Syntax   t.animateStyle(prop, value, options[, complete])  t.animateStyle(props, options[, complete])   Arguments   props (Object) : A map of animation properties and values.  prop (string) : The style to animate.  value (any) : The value to animate it to.  options (Object) : Animation options.  duration (number) : The duration of the animation.  easing (string) : The easing function of the animation.  delay (number) : The number of milliseconds before the animation starts.  [complete] (Function) : A function that is executed when the animation completes, or immediately if no changes were made.   Returns   (Promise) : A promise that resolves when the animation completes.   Examples  // TODO", 
            "title": "t.animateStyle()"
        }, 
        {
            "location": "/api/transition/#tcomplete", 
            "text": "Signals Ractive that the transition is complete.  Syntax   t.complete[noReset])   Arguments   [noReset] (boolean) : If  true ,  t.resetStyle()  is not called. Defaults to  false .   Returns   (undefined)   Examples  // TODO", 
            "title": "t.complete()"
        }, 
        {
            "location": "/api/transition/#tgetstyle", 
            "text": "Retrieve a CSS property value from  t.node .  Syntax   t.getStyle(prop)   Arguments   prop (string) : An unprefixed CSS property either in camelCase or kebab-case.  prop (Array) : An array of CSS properties.   Returns   (string) : The value of the specified style property.  (Object) : A key-value pair of properties and their respective values.   Examples  // TODO", 
            "title": "t.getStyle()"
        }, 
        {
            "location": "/api/transition/#tisintro", 
            "text": "(boolean)  Should be self-explanatory...", 
            "title": "t.isIntro"
        }, 
        {
            "location": "/api/transition/#tname", 
            "text": "(string)  The name of the transition.", 
            "title": "t.name"
        }, 
        {
            "location": "/api/transition/#tnode", 
            "text": "(Node)  The node that's entering or leaving the DOM", 
            "title": "t.node"
        }, 
        {
            "location": "/api/transition/#tprocessparams", 
            "text": "Builds a map of parameters whose values are taken from the provided arguments. When used with a single number or string argument, serves as a shorthand for creating a map with a  duration  property.  Syntax   t.processParams(params[, defaults])   Arguments   params (number) : Numeric shorthand for the  duration  parameter. Expressed in milliseconds.  params (string) : String shorthand for the  duration  parameter. Valid values are:  \"fast\" - 200ms  \"slow\" - 600ms  Any other string - 400ms    params (Object) : A map of parameters and their values.  [defaults] (Object) : A map of parameters and their default values.   Returns   (Object) : A map of parameters and their values.   Examples  // TODO", 
            "title": "t.processParams()"
        }, 
        {
            "location": "/api/transition/#tsetstyle", 
            "text": "Sets a CSS property on  t.node  to a value.  Syntax   t.setStyle(prop, value)  t.setStyle(props)   Arguments   prop (string) : An unprefixed CSS property either in camelCase or kebab-case.  props (Object) : A key-value pair of CSS properties and their respective values.  value (string) : A valid value for the specified CSS property.   Returns   (undefined)   Examples  // TODO", 
            "title": "t.setStyle()"
        }, 
        {
            "location": "/extend/adaptors/", 
            "text": "Adaptors\n\n\nIn some cases you want to write your UI in Ractive but have a custom back-end manage the data. \nAdaptors\n allow you to teach Ractive how to talk to those custom data sources without having to change the way you write Ractive or having to write a lot of connector code up front.\n\n\nWriting\n\n\nconst myAdaptor = {\n  filter: function ( object, keypath, ractive ) {\n    // return `true` if a particular object is of the type we want to adapt.\n  },\n  wrap: function ( ractive, object, keypath, prefixer ) {\n    // Setup\n    return {\n      teardown: function(){\n        // Code executed on teardown.\n      },\n      get: function(){\n        // Returns POJO version of your data backend.\n      },\n      set: function(property, value){\n        // Data setter for POJO property keypaths.\n      },\n      reset: function(value){\n        // Data setter for POJO keypath.\n      }\n    }\n  }\n};\n\n\n\n\nAdaptors are simply the translation and sync layers between your custom data source and Ractive instances. The basic principle of an \nadaptor\n is as follows:\n\n\n\n\nProvides an POJO version of your data source to Ractive.\n\n\nCaptures data changes on your data source and mirror them to the data in Ractive.\n\n\nCaptures data changes on the data in Ractive and mirror them to the data source.\n\n\n\n\nWhether it's a third-party data modelling library, a RESTful service, a socket server, browser storage, or whatever, as long as all of the three can be done, it can be adapted.\n\n\nfilter\n is a function that gets called to check if \nobject\n needs to use an adaptor.\n\n\nobject\n is the data source to adapt.\n\n\nkeypath\n is the keypath to \nobject\n.\n\n\nractive\n is the ractive instance that is currently using the adaptor.\n\n\nwrap\n is a function that gets called to set up the \nadaptor\n on \nobject\n.\n\n\nprefixer\n is a helper function that accepts an object and automatically prefixes \nkeypath\n to the object's keys.\n\n\nget\n is a function that gets called when Ractive needs the adapted representation of the \nobject\n.\n\n\nset\n is a function that is called when \nractive.set()\n updates a keypath to a property of the adapted data. This function allows you to update the same property on \nobject\n.\n\n\nproperty\n is the keypath to the property being updated, relative to \nkeypath\n.\n\n\nvalue\n is the value being passed into \nractive.set()\n.\n\n\nreset\n is a function that is called when \nractive.set()\n updates a keypath to the adapted data. This function allows you to either update \nobject\n or tear down the adaptor.\n\n\nteardown\n is a function called when the \nadaptor\n is being removed. This function allows you to do cleanup work on anything that was done during the \nadaptor\n setup.\n\n\nAdaptors\n only adapt one level\n\n\nAn \nadaptor\n only adapts an object's immediate properties. Updating nested data via Ractive or via the data source will not update the other.\n\n\nNo built-in infinite loop detection\n\n\nThere is no built-in mechanism for avoiding infinite loops. If your \nadaptor\n calls \nractive.set()\n on adapted data, which in turn will call the adaptor's \nset()\n method, which may directly or indirectly trigger another \nractive.set()\n on the same adapted data, a stack overflow error might occur.\n\n\nThis isn't a problem with primitive values since Ractive doesn't bother calling \nset()\n if a value hasn't changed. But with objects and arrays, there's no easy and performant way to tell if the contents have changed. So \nset()\n gets called \nin case something changed\n rather than \nbecause something changed\n.\n\n\nDifferent for every back-end\n\n\nThe \nadaptor\n structure only provides you with the means to talk to and listen from a custom back-end. It does not impose any rules on how to write an \nadaptor\n for a certain back-end. For instance, an \nadaptor\n for a constructor-based object may be written differently from an \nadaptor\n meant to interact with a socket server.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register adaptors:\n\n\nGlobally, via the \nRactive.adaptors\n static property.\n\n\nRactive.adaptors.myAdaptor = myAdaptor;\n\n\n\n\nPer component, via the component's \nadaptors\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  adaptors: { myAdaptor }\n});\n\n\n\n\nPer instance, via the instance's \nadaptors\n initialization property.\n\n\nconst ractive = new Ractive({\n  adaptors: { myAdaptor }\n});\n\n\n\n\nUsing\n\n\nIn order to use an adaptor, you must tell the component or an instance to use it using the \nadapt\n \ninitialization option\n.\n\n\nconst ractive = new Ractive({\n  adapt: [ 'myAdaptor' ]\n})\n\n\n\n\nExamples\n\n\nIn the following example, we have a \nBox\n constructor that uses accessors to get and set its \nwidth\n and \nheight\n properties. Since an instance of \nBox\n will have no publicly visible properties, Ractive cannot bind to them directly.\n\n\nfunction Box(width, height){\n  var _width = width;\n  var _height = height;\n\n  this.getWidth = function(){ return _width; };\n  this.setWidth = function(width){ _width = width; };\n  this.getHeight = function(){ return _height; };\n  this.setHeight = function(height){ _height = height };\n}\n\n\n\n\nIn order for Ractive to properly use a \nBox\n instance, we build an \nadaptor\n for \nBox\n.\n\n\nRactive.adaptors.boxAdaptor = {\n  filter: function ( object ) {\n    // Checks if the piece of data is an instance of Box.\n    return object instanceof Box;\n  },\n  wrap: function ( ractive, box, keypath, prefixer ) {\n\n    // We keep a reference to the original functions before monkey-patching.\n    const setWidth = box.setWidth;\n    const setHeight = box.setHeight;\n\n    // Use ractive.set on the the adapted data whenever the setters are used.\n    box.setWidth = function(width){\n      ractive.set(prefixer({\n        width: width\n      }));\n    };\n\n    box.setHeight = function(height){\n      ractive.set(prefixer({\n        height: height\n      }));\n    };\n\n    return {\n      // Return a POJO representation of an instance of Box.\n      get: function(){\n        return {\n          width: box.getWidth(),\n          height: box.getHeight();\n        };\n      },\n      // Update the adapted object's properties\n      set: function(property, value){\n        if(property === 'width') setWidth.call(box, value);\n        if(property === 'height') setHeight.call(box, value);\n      },\n      // Update the adapted object.\n      reset: function(data){\n        // We don't adapt non-objects. And if the new data is an instance of Box\n        // there's a high chance that its a new instance. In either case, we\n        // need to tear down this adapter and have Ractive set it up again if\n        // necessary.\n        if(typeof data !== 'object' || data instanceof Box) return false;\n\n        // Otherwise, we just parse through the data and update the existing box\n        // instance.\n        if(data.width !== undefined) setWidth.call(box, data.width);\n        if(data.height !== undefined) setHeight.call(box, data.height);\n      },\n      // Delete the monkey-patched methods.\n      teardown: function(){\n        delete box.setWidth;\n        delete box.setHeight;\n      }\n    };\n  }\n};\n\n\n\n\nThen we use \nboxAdaptor\n on an instance. The data can now be treated like regular Ractive data. Updates done directly on \nbox\n will reflect on Ractive. Any changes via Ractive will reflect on \nbox\n.\n\n\nconst ractive = new Ractive({\n  el: 'body',\n  // Tell the instance we'll be using boxAdaptor\n  adapt: [ 'boxAdaptor' ],\n  // We write Ractive like normal.\n  template: `\n    \ndiv\nBox is {{ box.width }}x{{ box.height }}\n/div\n,\n    \ndiv\ninput type=\ntext\n value=\n{{ box.width }}\n/div\n\n    \ndiv\ninput type=\ntext\n value=\n{{ box.height }}\n/div\n\n  `\n});\n\nconst box = new Box(3, 4);\n\n// Set the Box instance as if it were a POJO.\nractive.set('box', box);\n\n// Both box instance and box object will have 7 width and 11 height and will\n// be rendered in the UI accordingly.\nbox.setWidth(7);\nractive.set('box.height', 11);", 
            "title": "Adaptors"
        }, 
        {
            "location": "/extend/adaptors/#adaptors", 
            "text": "In some cases you want to write your UI in Ractive but have a custom back-end manage the data.  Adaptors  allow you to teach Ractive how to talk to those custom data sources without having to change the way you write Ractive or having to write a lot of connector code up front.", 
            "title": "Adaptors"
        }, 
        {
            "location": "/extend/adaptors/#writing", 
            "text": "const myAdaptor = {\n  filter: function ( object, keypath, ractive ) {\n    // return `true` if a particular object is of the type we want to adapt.\n  },\n  wrap: function ( ractive, object, keypath, prefixer ) {\n    // Setup\n    return {\n      teardown: function(){\n        // Code executed on teardown.\n      },\n      get: function(){\n        // Returns POJO version of your data backend.\n      },\n      set: function(property, value){\n        // Data setter for POJO property keypaths.\n      },\n      reset: function(value){\n        // Data setter for POJO keypath.\n      }\n    }\n  }\n};  Adaptors are simply the translation and sync layers between your custom data source and Ractive instances. The basic principle of an  adaptor  is as follows:   Provides an POJO version of your data source to Ractive.  Captures data changes on your data source and mirror them to the data in Ractive.  Captures data changes on the data in Ractive and mirror them to the data source.   Whether it's a third-party data modelling library, a RESTful service, a socket server, browser storage, or whatever, as long as all of the three can be done, it can be adapted.  filter  is a function that gets called to check if  object  needs to use an adaptor.  object  is the data source to adapt.  keypath  is the keypath to  object .  ractive  is the ractive instance that is currently using the adaptor.  wrap  is a function that gets called to set up the  adaptor  on  object .  prefixer  is a helper function that accepts an object and automatically prefixes  keypath  to the object's keys.  get  is a function that gets called when Ractive needs the adapted representation of the  object .  set  is a function that is called when  ractive.set()  updates a keypath to a property of the adapted data. This function allows you to update the same property on  object .  property  is the keypath to the property being updated, relative to  keypath .  value  is the value being passed into  ractive.set() .  reset  is a function that is called when  ractive.set()  updates a keypath to the adapted data. This function allows you to either update  object  or tear down the adaptor.  teardown  is a function called when the  adaptor  is being removed. This function allows you to do cleanup work on anything that was done during the  adaptor  setup.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/adaptors/#adaptors-only-adapt-one-level", 
            "text": "An  adaptor  only adapts an object's immediate properties. Updating nested data via Ractive or via the data source will not update the other.", 
            "title": "Adaptors only adapt one level"
        }, 
        {
            "location": "/extend/adaptors/#no-built-in-infinite-loop-detection", 
            "text": "There is no built-in mechanism for avoiding infinite loops. If your  adaptor  calls  ractive.set()  on adapted data, which in turn will call the adaptor's  set()  method, which may directly or indirectly trigger another  ractive.set()  on the same adapted data, a stack overflow error might occur.  This isn't a problem with primitive values since Ractive doesn't bother calling  set()  if a value hasn't changed. But with objects and arrays, there's no easy and performant way to tell if the contents have changed. So  set()  gets called  in case something changed  rather than  because something changed .", 
            "title": "No built-in infinite loop detection"
        }, 
        {
            "location": "/extend/adaptors/#different-for-every-back-end", 
            "text": "The  adaptor  structure only provides you with the means to talk to and listen from a custom back-end. It does not impose any rules on how to write an  adaptor  for a certain back-end. For instance, an  adaptor  for a constructor-based object may be written differently from an  adaptor  meant to interact with a socket server.", 
            "title": "Different for every back-end"
        }, 
        {
            "location": "/extend/adaptors/#registering", 
            "text": "Like other plugins, there's 3 ways you can register adaptors:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/adaptors/#globally-via-the-ractiveadaptors-static-property", 
            "text": "Ractive.adaptors.myAdaptor = myAdaptor;", 
            "title": "Globally, via the Ractive.adaptors static property."
        }, 
        {
            "location": "/extend/adaptors/#per-component-via-the-components-adaptors-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  adaptors: { myAdaptor }\n});", 
            "title": "Per component, via the component's adaptors initialization property."
        }, 
        {
            "location": "/extend/adaptors/#per-instance-via-the-instances-adaptors-initialization-property", 
            "text": "const ractive = new Ractive({\n  adaptors: { myAdaptor }\n});", 
            "title": "Per instance, via the instance's adaptors initialization property."
        }, 
        {
            "location": "/extend/adaptors/#using", 
            "text": "In order to use an adaptor, you must tell the component or an instance to use it using the  adapt   initialization option .  const ractive = new Ractive({\n  adapt: [ 'myAdaptor' ]\n})", 
            "title": "Using"
        }, 
        {
            "location": "/extend/adaptors/#examples", 
            "text": "In the following example, we have a  Box  constructor that uses accessors to get and set its  width  and  height  properties. Since an instance of  Box  will have no publicly visible properties, Ractive cannot bind to them directly.  function Box(width, height){\n  var _width = width;\n  var _height = height;\n\n  this.getWidth = function(){ return _width; };\n  this.setWidth = function(width){ _width = width; };\n  this.getHeight = function(){ return _height; };\n  this.setHeight = function(height){ _height = height };\n}  In order for Ractive to properly use a  Box  instance, we build an  adaptor  for  Box .  Ractive.adaptors.boxAdaptor = {\n  filter: function ( object ) {\n    // Checks if the piece of data is an instance of Box.\n    return object instanceof Box;\n  },\n  wrap: function ( ractive, box, keypath, prefixer ) {\n\n    // We keep a reference to the original functions before monkey-patching.\n    const setWidth = box.setWidth;\n    const setHeight = box.setHeight;\n\n    // Use ractive.set on the the adapted data whenever the setters are used.\n    box.setWidth = function(width){\n      ractive.set(prefixer({\n        width: width\n      }));\n    };\n\n    box.setHeight = function(height){\n      ractive.set(prefixer({\n        height: height\n      }));\n    };\n\n    return {\n      // Return a POJO representation of an instance of Box.\n      get: function(){\n        return {\n          width: box.getWidth(),\n          height: box.getHeight();\n        };\n      },\n      // Update the adapted object's properties\n      set: function(property, value){\n        if(property === 'width') setWidth.call(box, value);\n        if(property === 'height') setHeight.call(box, value);\n      },\n      // Update the adapted object.\n      reset: function(data){\n        // We don't adapt non-objects. And if the new data is an instance of Box\n        // there's a high chance that its a new instance. In either case, we\n        // need to tear down this adapter and have Ractive set it up again if\n        // necessary.\n        if(typeof data !== 'object' || data instanceof Box) return false;\n\n        // Otherwise, we just parse through the data and update the existing box\n        // instance.\n        if(data.width !== undefined) setWidth.call(box, data.width);\n        if(data.height !== undefined) setHeight.call(box, data.height);\n      },\n      // Delete the monkey-patched methods.\n      teardown: function(){\n        delete box.setWidth;\n        delete box.setHeight;\n      }\n    };\n  }\n};  Then we use  boxAdaptor  on an instance. The data can now be treated like regular Ractive data. Updates done directly on  box  will reflect on Ractive. Any changes via Ractive will reflect on  box .  const ractive = new Ractive({\n  el: 'body',\n  // Tell the instance we'll be using boxAdaptor\n  adapt: [ 'boxAdaptor' ],\n  // We write Ractive like normal.\n  template: `\n     div Box is {{ box.width }}x{{ box.height }} /div ,\n     div input type= text  value= {{ box.width }} /div \n     div input type= text  value= {{ box.height }} /div \n  `\n});\n\nconst box = new Box(3, 4);\n\n// Set the Box instance as if it were a POJO.\nractive.set('box', box);\n\n// Both box instance and box object will have 7 width and 11 height and will\n// be rendered in the UI accordingly.\nbox.setWidth(7);\nractive.set('box.height', 11);", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/components/", 
            "text": "Components\n\n\nIn many situations, you want to encapsulate behaviour and markup into a single reusable \ncomponent\n, which can be dropped into Ractive applications. Components are simply custom-configured \"subclasses\" of Ractive (analogous, but technically incorrect).\n\n\nWriting\n\n\nThere are several ways to write Ractive components. Standard \ninitialization options\n apply for configuration unless where changes are explicitly mentioned.\n\n\nThe most common way to define a component is by using \nRactive.extend()\n.\n\n\n// A subclass of Ractive\nconst MyComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nmy-component\n\n      \nspan class=\nmy-component__message\n{{ message }}\n/span\n\n    \n/div\n\n  `,\n  css: `\n    .my-component__message { color: red }\n  `,\n  data: { message: 'Hello World' }\n});\n\n\n\n\nAnother way to define a component is by using \ncomponent files\n and \nloaders\n.\n\n\ndiv class=\nmy-component\n\n  \nspan class=\nmy-component__message\n{{ message }}\n/span\n\n\n/div\n\n\n\nstyle\n\n  .my-component__message { color: red }\n\n/style\n\n\n\nscript\n\ncomponent.exports = {\n  data: { message: 'Hello World' }\n};\n\n/script\n\n\n\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register components:\n\n\nGlobally, via the \nRactive.components\n static property:\n\n\n// Available to all instances of Ractive.\nRactive.components.MyComponent = Ractive.extend({ ... });\n\n\n\n\nPer component, via the component's \ncomponents\n initialization property.\n\n\n// Only available for instances of AnotherComponent.\nconst AnotherComponent = Ractive.extend({\n  components: { MyComponent }\n});\n\n\n\n\nPer instance, via the instance's \ncomponents\n initialization property.\n\n\n// Only available to this specific instance.\nconst ractive = new Ractive({\n  components: { MyComponent }\n});\n\n\n\n\nUsing\n\n\nComponents are simply subclasses of Ractive, which means the are instatiable via the \nnew\n keyword.\n\n\nconst ractive = new MyComponent({ ... });\n\n\n\n\nBut where components really shine is when they're used on templates. They are written like \ncustom elements\n. Each custom element notation represents one instance of the component.\n\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n    \ndiv\n\n      \nMyComponent /\n \n!-- One instance of MyComponent --\n\n      \nMyComponent /\n \n!-- Another instance of MyComponent --\n\n      \nMyComponent /\n \n!-- Yet another instance of MyComponent --\n\n    \n/div\n\n  `\n});\n\n\n\n\nThe component's tag name depends on the name used upon registration. The same component can be registered more than once using different names.\n\n\nconst MyComponent = Ractive.extend({...});\nRactive.components.MyComponent = MyComponent;\nRactive.components.MyComponentOtherName = MyComponent;\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n    \ndiv\n\n      \nMyComponent /\n          \n!-- Using MyComponent --\n\n      \nMyComponentOtherName /\n \n!-- Using MyComponent's other name --\n\n    \n/div\n\n  `\n});\n\n\n\n\nIsolation\n\n\nBy default, components are \"isolated\". This means it can only bind data explicitely provided to it.\nIn the following example, the instance of \nChildComponent\n will not print anything.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: 'Message missing {{ message }}'\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: '\nChildComponent /\n',\n  data: {\n    message: 'The ChildComponent will not know anything about this message'\n  }\n});\n\n\n\n\nYou have to pass data explicitely:\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: 'My message: {{ message }}'\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nChildComponent message=\nSome static message\n /\n\n    \nChildComponent message=\n{{myMessage}}\n /\n\n  `,\n  data: {\n    myMessage: 'Hello World!'\n  }\n});\n\n\n\n\nThis ensures the reusability of components in any context and avoids accidentally binding to wrong data.\n\n\n\n\nThere is also a possibility to make components aware of the outer context by specifying \nisolated: false\n \ninitialization option\n.\nIn that case, it climbs to the parent component's data context if it does not resolve on the child data context.\n\n\nIn the following example, the instance of \nChildComponent\n prints \"Hello World!\" even when the data is set on the outer-most instance.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  isolated: false,\n  template: 'Child: {{ message }}'\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  isolated: false,\n  template: 'Nested \nChildComponent /\n'\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: '\nParentComponent /\n',\n  data: {\n    message: 'The nested component will find me!'\n  }\n});\n\n\n\n\nBinding\n\n\nBindings connect a piece of data on the parent instance to data on the child instance. Changes on one side will reflect on the other. The syntax is similar to how one would write HTML element attributes.\n\n\nThe following example binds \ntext\n on the instance to \nMyComponent\n's \nmessage\n. Updates on the value of \ntext\n will update \nmessage\n. Typing on the \ninput\n bound to \nmessage\n will update \ntext\n.\n\n\nRactive.components.MyComponent = Ractive.extend({\n  template: `\n    \ninput type=\ntext\n value=\n{{ message }}\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: '\nMyComponent message=\n{{ text }} /\n'\n});\n\nractive.set('text', 'Hello World!');\n\n\n\n\nData context\n\n\nEach component instance comes with its own data context so that parameters don't pollute the primary data. Bindings will still update across both contexts.\n\n\nIn the following example, we have an instance that has \nname\n and \ncolors\n. We bind bind \ncolors\n and set an \noption1\n to \nMyComponent\n. Upon inspection, the data context is just as described. \nname\n doesn't cross over to \nMyComponent\n nor does \noption1\n cross over to the instance. However, since we bound \ncolors\n to \nshades\n, updating one updates the other.\n\n\nRactive.components.MyComponent = Ractive.extend({});\n\nconst ractive = new Ractive({\n  template: `\n    \nMyComponent shades='{{colors}}' option1='A' /\n\n  `,\n  data: {\n    name: 'Colors',\n    colors: ['red', 'blue', 'yellow']\n  }\n});\n\nconst widget = ractive.findComponent('MyComponent')\n\nractive.get(); // {\ncolors\n:[\nred\n,\nblue\n,\nyellow\n], \nname\n:\nColors\n}\nwidget.get();  // {\nshades\n:[\nred\n,\nblue\n,\nyellow\n], \noption1\n:\nA\n}\n\nractive.set('colors.1', 'green');\n\nractive.get(); // {\ncolors\n:[\nred\n,\ngreen\n,\nyellow\n], \nname\n:\nColors\n}\nwidget.get();  // {\nshades\n:[\nred\n,\ngreen\n,\nyellow\n], \noption1\n:\nA\n}\n\nwidget.set('colors.2', 'blue');\n\nractive.get(); // {\ncolors\n:[\nred\n,\ngreen\n,\nblue\n], \nname\n:\nColors\n}\nwidget.get();  // {\nshades\n:[\nred\n,\ngreen\n,\nblue\n], \noption1\n:\nA\n}\n\n\n\n\nEvents\n\n\nComponents can fire events like regular elements using \nractive.fire()\n. Enclosing instances can listen for events using the same \non-*\n event notation. There are two ways to handle component events.\n\n\nThe first is using the method call syntax which is similar to how you would write inline JavaScript.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent on-boringeventname=\n@this.greetz()\n /\n\n  `,\n  greetz: function(){\n    console.log('Hello World');\n  }\n});\n\n\n\n\nThe other is using the proxy event syntax. It's called \"proxy\" in the sense that the component event is assigned another name which is actually listened to by the enclosing instance.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent on-boringeventname=\ngreetz\n /\n\n  `,\n  oninit: function(){\n    this.on('greetz', function(){\n      console.log('Hello World')\n    });\n  }\n});\n\n\n\n\nBubbling\n\n\nEvents fired from within components will also \"bubble\" up the component hierarchy with their component name attached as a namespace. This can be used to avoid having to re-fire events at each level in a deeply nested component hierarchy.\n\n\nIn the following example, the event from the \nChildComponent\n instance can be listened to from the outer Ractive instance.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('Hello World!');\n});\n\n\n\n\nTo listen to the same event name regardless of the component that's firing the event, an \n*\n can be used as the namespace.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('*.sameevent', function(){\n  console.log('This will fire two times, one for each component.');\n});\n\n\n\n\nThe namespace is not bound to the component definition but rather to the name of the component.\n\n\nIn the following example, \nChildComponent\n is registered onto the \nParentComponent\n as \nChildComponent1\n and \nChildComponent2\n. Even with the same definition, there will be two namespaces, one for \nChildComponent1\n and \nChildComponent2\n.\n\n\nconst ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent1 /\n\n    \nChildComponent2 /\n\n  `,\n  components: {\n    ChildComponent1: ChildComponent,\n    ChildComponent2: ChildComponent\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent1.sameevent', function(){\n  console.log('Same component definition, instance with name 1.');\n});\n\nractive.on('ChildComponent2.sameevent', function(){\n  console.log('Same component definition, instance with name 2.');\n});\n\n\n\n\nStopping propagation\n\n\nIn order to stop bubbling, simply return \nfalse\n from an event handler. Should the event come from a DOM event, it will call \nstopPropagation()\n and \npreventDefault()\n automatically.\n\n\nIn the following example, \nParentComponent\n listens to \nchildevent\n and returns false to in its handler. This prevents the outer instance from receiving the event.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `,\n  oninit: function(){\n    this.on('ChildComponent.childevent', function(){\n      return false;\n    });\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('This will not fire');\n});\n\n\n\n\nEvents that have been assigned a handler using \non-*\n will also prevent the bubbling of the original event. A proxy event is assigned, will bubble in its place.\n\n\nIn the following example, \nchildevent1\n is prevented by not assigning a handle. \nchildevent2\n is prevented by having a proxy event \nchildevent2proxy\n assigned to it, which will also bubble in its place. \nchildevent3\n is prevented by a method call.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function() {\n    this.fire('childevent1');\n    this.fire('childevent2');\n    this.fire('childevent3');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent on-childevent1=\n on-childevent2=\nchildevent2proxy\n on-childevent3=\n@this.parentMethod()\n /\n\n  `,\n  oninit: function() {\n    this.on('childevent2proxy', function() {\n      console.log('childevent2 handled and will no longer bubble.');\n      console.log('childevent2proxy will take its place.');\n    });\n  },\n  parentMethod: function(){\n    console.log('childevent3 handled by a method')\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent.childevent1', function() {\n  console.log('childevent1 stopped');\n});\n\nractive.on('ChildComponent.childevent2', function() {\n  console.log('childevent2 stopped');\n});\n\nractive.on('ParentComponent.childevent2proxy', function() {\n  console.log('childevent2proxy fired');\n});\n\nractive.on('ChildComponent.childevent3', function() {\n  console.log('childevent3 fired');\n});\n\n\n\n\n{{\ncontent}}\n\n\n{{\ncontent}}\n renders the inner HTML in the context of the component. Partials, components, and any other valid template items can be used as inner HTML. \n{{\ncontent}}\n can be thought of as a special partial.\n\n\nIn the following example, the result will print \"Lorem Ipsum\" because the inner HTML's context is the component, whose \nmessage\n is set to \"Lorem Ipsum\".\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n{{\ncontent}}\n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        \ndiv class=\ninner-content\n{{ message }}\n/div\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\nPartials defined in the inner HTML can be used to override partials defined on the component. This can be used to allow easy customization of each instance using partials.\n\n\nIn the following example, \nChildComponent\n's default template for the \nmessageWrapper\n partial is a \nstrong\n. Upon use of \nChildComponent\n in the instance, it overrides the partial to use an \nem\n instead.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  partials: {\n    messageWrapper: '\nstrong\n{{message}}\n/strong\n'\n  },\n  template: `\n    \ndiv class=\nchild-component\n{{\ncontent}}\n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n\n        {{#partial messageWrapper}}\nem\n{{message}}\n/em\n{{/}}\n\n        \ndiv class=\ninner-content\n\n          {{\n messageWrapper }}\n        \n/div\n\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\n{{yield}}\n\n\n{{yield}}\n renders the inner HTML in the context of the parent component. Partials, components, and any other valid template items can be used as inner HTML. A common use case of \n{{yield}}\n is to provide wrapper markup transparently.\n\n\nIn the following example, the result will print \"Hello World!\" because the inner HTML's context is the parent component's, whose \nmessage\n is \"Hello World!\".\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n{{ yield }}\n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        \ndiv class=\ninner-content\n{{ message }}\n/div\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\nYields can also be customized using named yields. Instead of rendering with the component's inner HTML, a named yield will look for a partial in the inner HTML with the same name and use that to render the yielded content.\n\n\nIn the following example, \nChildComponent\n renders the yield content 3 times. However, the last two yields will look for \nitalicYield\n and \nboldYield\n partials in the inner HTML and use that to render. What's rendered is three \"Hello World!\"s in regular, italic and bold.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n\n      {{ yield }}\n      {{ yield italicYield }}\n      {{ yield boldYield }}\n    \n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        {{#partial italicYield }}\nem\n{{message}}\n/em\n{{/}}\n        {{#partial boldYield }}\nstrong\n{{message}}\n/strong\n{{/}}\n        {{message}}\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\nExamples", 
            "title": "Components"
        }, 
        {
            "location": "/extend/components/#components", 
            "text": "In many situations, you want to encapsulate behaviour and markup into a single reusable  component , which can be dropped into Ractive applications. Components are simply custom-configured \"subclasses\" of Ractive (analogous, but technically incorrect).", 
            "title": "Components"
        }, 
        {
            "location": "/extend/components/#writing", 
            "text": "There are several ways to write Ractive components. Standard  initialization options  apply for configuration unless where changes are explicitly mentioned.  The most common way to define a component is by using  Ractive.extend() .  // A subclass of Ractive\nconst MyComponent = Ractive.extend({\n  template: `\n     div class= my-component \n       span class= my-component__message {{ message }} /span \n     /div \n  `,\n  css: `\n    .my-component__message { color: red }\n  `,\n  data: { message: 'Hello World' }\n});  Another way to define a component is by using  component files  and  loaders .  div class= my-component \n   span class= my-component__message {{ message }} /span  /div  style \n  .my-component__message { color: red } /style  script \ncomponent.exports = {\n  data: { message: 'Hello World' }\n}; /script", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/components/#registering", 
            "text": "Like other plugins, there's 3 ways you can register components:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/components/#globally-via-the-ractivecomponents-static-property", 
            "text": "// Available to all instances of Ractive.\nRactive.components.MyComponent = Ractive.extend({ ... });", 
            "title": "Globally, via the Ractive.components static property:"
        }, 
        {
            "location": "/extend/components/#per-component-via-the-components-components-initialization-property", 
            "text": "// Only available for instances of AnotherComponent.\nconst AnotherComponent = Ractive.extend({\n  components: { MyComponent }\n});", 
            "title": "Per component, via the component's components initialization property."
        }, 
        {
            "location": "/extend/components/#per-instance-via-the-instances-components-initialization-property", 
            "text": "// Only available to this specific instance.\nconst ractive = new Ractive({\n  components: { MyComponent }\n});", 
            "title": "Per instance, via the instance's components initialization property."
        }, 
        {
            "location": "/extend/components/#using", 
            "text": "Components are simply subclasses of Ractive, which means the are instatiable via the  new  keyword.  const ractive = new MyComponent({ ... });  But where components really shine is when they're used on templates. They are written like  custom elements . Each custom element notation represents one instance of the component.  const AnotherComponent = Ractive.extend({\n  template: `\n     div \n       MyComponent /   !-- One instance of MyComponent -- \n       MyComponent /   !-- Another instance of MyComponent -- \n       MyComponent /   !-- Yet another instance of MyComponent -- \n     /div \n  `\n});  The component's tag name depends on the name used upon registration. The same component can be registered more than once using different names.  const MyComponent = Ractive.extend({...});\nRactive.components.MyComponent = MyComponent;\nRactive.components.MyComponentOtherName = MyComponent;\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n     div \n       MyComponent /            !-- Using MyComponent -- \n       MyComponentOtherName /   !-- Using MyComponent's other name -- \n     /div \n  `\n});", 
            "title": "Using"
        }, 
        {
            "location": "/extend/components/#isolation", 
            "text": "By default, components are \"isolated\". This means it can only bind data explicitely provided to it.\nIn the following example, the instance of  ChildComponent  will not print anything.  Ractive.components.ChildComponent = Ractive.extend({\n  template: 'Message missing {{ message }}'\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: ' ChildComponent / ',\n  data: {\n    message: 'The ChildComponent will not know anything about this message'\n  }\n});  You have to pass data explicitely:  Ractive.components.ChildComponent = Ractive.extend({\n  template: 'My message: {{ message }}'\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ChildComponent message= Some static message  / \n     ChildComponent message= {{myMessage}}  / \n  `,\n  data: {\n    myMessage: 'Hello World!'\n  }\n});  This ensures the reusability of components in any context and avoids accidentally binding to wrong data.   There is also a possibility to make components aware of the outer context by specifying  isolated: false   initialization option .\nIn that case, it climbs to the parent component's data context if it does not resolve on the child data context.  In the following example, the instance of  ChildComponent  prints \"Hello World!\" even when the data is set on the outer-most instance.  Ractive.components.ChildComponent = Ractive.extend({\n  isolated: false,\n  template: 'Child: {{ message }}'\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  isolated: false,\n  template: 'Nested  ChildComponent / '\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: ' ParentComponent / ',\n  data: {\n    message: 'The nested component will find me!'\n  }\n});", 
            "title": "Isolation"
        }, 
        {
            "location": "/extend/components/#binding", 
            "text": "Bindings connect a piece of data on the parent instance to data on the child instance. Changes on one side will reflect on the other. The syntax is similar to how one would write HTML element attributes.  The following example binds  text  on the instance to  MyComponent 's  message . Updates on the value of  text  will update  message . Typing on the  input  bound to  message  will update  text .  Ractive.components.MyComponent = Ractive.extend({\n  template: `\n     input type= text  value= {{ message }} \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: ' MyComponent message= {{ text }} / '\n});\n\nractive.set('text', 'Hello World!');", 
            "title": "Binding"
        }, 
        {
            "location": "/extend/components/#data-context", 
            "text": "Each component instance comes with its own data context so that parameters don't pollute the primary data. Bindings will still update across both contexts.  In the following example, we have an instance that has  name  and  colors . We bind bind  colors  and set an  option1  to  MyComponent . Upon inspection, the data context is just as described.  name  doesn't cross over to  MyComponent  nor does  option1  cross over to the instance. However, since we bound  colors  to  shades , updating one updates the other.  Ractive.components.MyComponent = Ractive.extend({});\n\nconst ractive = new Ractive({\n  template: `\n     MyComponent shades='{{colors}}' option1='A' / \n  `,\n  data: {\n    name: 'Colors',\n    colors: ['red', 'blue', 'yellow']\n  }\n});\n\nconst widget = ractive.findComponent('MyComponent')\n\nractive.get(); // { colors :[ red , blue , yellow ],  name : Colors }\nwidget.get();  // { shades :[ red , blue , yellow ],  option1 : A }\n\nractive.set('colors.1', 'green');\n\nractive.get(); // { colors :[ red , green , yellow ],  name : Colors }\nwidget.get();  // { shades :[ red , green , yellow ],  option1 : A }\n\nwidget.set('colors.2', 'blue');\n\nractive.get(); // { colors :[ red , green , blue ],  name : Colors }\nwidget.get();  // { shades :[ red , green , blue ],  option1 : A }", 
            "title": "Data context"
        }, 
        {
            "location": "/extend/components/#events", 
            "text": "Components can fire events like regular elements using  ractive.fire() . Enclosing instances can listen for events using the same  on-*  event notation. There are two ways to handle component events.  The first is using the method call syntax which is similar to how you would write inline JavaScript.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent on-boringeventname= @this.greetz()  / \n  `,\n  greetz: function(){\n    console.log('Hello World');\n  }\n});  The other is using the proxy event syntax. It's called \"proxy\" in the sense that the component event is assigned another name which is actually listened to by the enclosing instance.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent on-boringeventname= greetz  / \n  `,\n  oninit: function(){\n    this.on('greetz', function(){\n      console.log('Hello World')\n    });\n  }\n});", 
            "title": "Events"
        }, 
        {
            "location": "/extend/components/#bubbling", 
            "text": "Events fired from within components will also \"bubble\" up the component hierarchy with their component name attached as a namespace. This can be used to avoid having to re-fire events at each level in a deeply nested component hierarchy.  In the following example, the event from the  ChildComponent  instance can be listened to from the outer Ractive instance.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('Hello World!');\n});  To listen to the same event name regardless of the component that's firing the event, an  *  can be used as the namespace.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('*.sameevent', function(){\n  console.log('This will fire two times, one for each component.');\n});  The namespace is not bound to the component definition but rather to the name of the component.  In the following example,  ChildComponent  is registered onto the  ParentComponent  as  ChildComponent1  and  ChildComponent2 . Even with the same definition, there will be two namespaces, one for  ChildComponent1  and  ChildComponent2 .  const ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent1 / \n     ChildComponent2 / \n  `,\n  components: {\n    ChildComponent1: ChildComponent,\n    ChildComponent2: ChildComponent\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent1.sameevent', function(){\n  console.log('Same component definition, instance with name 1.');\n});\n\nractive.on('ChildComponent2.sameevent', function(){\n  console.log('Same component definition, instance with name 2.');\n});", 
            "title": "Bubbling"
        }, 
        {
            "location": "/extend/components/#stopping-propagation", 
            "text": "In order to stop bubbling, simply return  false  from an event handler. Should the event come from a DOM event, it will call  stopPropagation()  and  preventDefault()  automatically.  In the following example,  ParentComponent  listens to  childevent  and returns false to in its handler. This prevents the outer instance from receiving the event.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `,\n  oninit: function(){\n    this.on('ChildComponent.childevent', function(){\n      return false;\n    });\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('This will not fire');\n});  Events that have been assigned a handler using  on-*  will also prevent the bubbling of the original event. A proxy event is assigned, will bubble in its place.  In the following example,  childevent1  is prevented by not assigning a handle.  childevent2  is prevented by having a proxy event  childevent2proxy  assigned to it, which will also bubble in its place.  childevent3  is prevented by a method call.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function() {\n    this.fire('childevent1');\n    this.fire('childevent2');\n    this.fire('childevent3');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent on-childevent1=  on-childevent2= childevent2proxy  on-childevent3= @this.parentMethod()  / \n  `,\n  oninit: function() {\n    this.on('childevent2proxy', function() {\n      console.log('childevent2 handled and will no longer bubble.');\n      console.log('childevent2proxy will take its place.');\n    });\n  },\n  parentMethod: function(){\n    console.log('childevent3 handled by a method')\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent.childevent1', function() {\n  console.log('childevent1 stopped');\n});\n\nractive.on('ChildComponent.childevent2', function() {\n  console.log('childevent2 stopped');\n});\n\nractive.on('ParentComponent.childevent2proxy', function() {\n  console.log('childevent2proxy fired');\n});\n\nractive.on('ChildComponent.childevent3', function() {\n  console.log('childevent3 fired');\n});", 
            "title": "Stopping propagation"
        }, 
        {
            "location": "/extend/components/#content", 
            "text": "{{ content}}  renders the inner HTML in the context of the component. Partials, components, and any other valid template items can be used as inner HTML.  {{ content}}  can be thought of as a special partial.  In the following example, the result will print \"Lorem Ipsum\" because the inner HTML's context is the component, whose  message  is set to \"Lorem Ipsum\".  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component {{ content}} /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n         div class= inner-content {{ message }} /div \n       /ChildComponent \n     /div \n  `\n});  Partials defined in the inner HTML can be used to override partials defined on the component. This can be used to allow easy customization of each instance using partials.  In the following example,  ChildComponent 's default template for the  messageWrapper  partial is a  strong . Upon use of  ChildComponent  in the instance, it overrides the partial to use an  em  instead.  Ractive.components.ChildComponent = Ractive.extend({\n  partials: {\n    messageWrapper: ' strong {{message}} /strong '\n  },\n  template: `\n     div class= child-component {{ content}} /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n\n        {{#partial messageWrapper}} em {{message}} /em {{/}}\n\n         div class= inner-content \n          {{  messageWrapper }}\n         /div \n\n       /ChildComponent \n     /div \n  `\n});", 
            "title": "{{&gt;content}}"
        }, 
        {
            "location": "/extend/components/#yield", 
            "text": "{{yield}}  renders the inner HTML in the context of the parent component. Partials, components, and any other valid template items can be used as inner HTML. A common use case of  {{yield}}  is to provide wrapper markup transparently.  In the following example, the result will print \"Hello World!\" because the inner HTML's context is the parent component's, whose  message  is \"Hello World!\".  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component {{ yield }} /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n         div class= inner-content {{ message }} /div \n       /ChildComponent \n     /div \n  `\n});  Yields can also be customized using named yields. Instead of rendering with the component's inner HTML, a named yield will look for a partial in the inner HTML with the same name and use that to render the yielded content.  In the following example,  ChildComponent  renders the yield content 3 times. However, the last two yields will look for  italicYield  and  boldYield  partials in the inner HTML and use that to render. What's rendered is three \"Hello World!\"s in regular, italic and bold.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component \n      {{ yield }}\n      {{ yield italicYield }}\n      {{ yield boldYield }}\n     /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n        {{#partial italicYield }} em {{message}} /em {{/}}\n        {{#partial boldYield }} strong {{message}} /strong {{/}}\n        {{message}}\n       /ChildComponent \n     /div \n  `\n});", 
            "title": "{{yield}}"
        }, 
        {
            "location": "/extend/components/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/decorators/", 
            "text": "Decorators\n\n\nA decorator is a simple way to add behaviour to a node when it is rendered, or to augment it in some way. Decorators are a good way to integrate DOM manipulation libraries with Ractive, such as \njQuery UI\n or \nBootstrap\n.\n\n\nWriting\n\n\nconst myDecorator = function(node[, ...args]) {\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    },\n    update: function([...args]){\n      // Update code\n    }\n  };\n};\n\n\n\n\nDecorators are simply functions that are called upon to setup the decorator once Ractive detects its use. It takes a \nnode\n argument and returns an object with a \nteardown\n and \nupdate\n property.\n\n\nnode\n is the element to which the decorator is applied to.\n\n\nargs\n are optional arguments provided by the decorator directive.\n\n\nteardown\n is a function that gets called when the decorator is torn down.\n\n\nupdate\n is an optional function that gets called when the arguments update.\n\n\nAny updates to the arguments will call the decorator's \nteardown\n and run the decorator function again, essentially setting up the decorator again. If an \nupdate\n function is provided on the return object, that will be called instead of the \nteardown\n and setup function.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register decorators:\n\n\nGlobally, via the \nRactive.decorators\n static property.\n\n\nRactive.decorators.myDecorator = myDecorator;\n\n\n\n\nPer component, via the component's \ndecorators\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  decorators: { myDecorator }\n});\n\n\n\n\nPer instance, via the instance's \ndecorators\n initialization property.\n\n\nconst ractive = new Ractive({\n  decorators: { myDecorator }\n});\n\n\n\n\nUsing\n\n\nYou can invoke one or more decorators on your elements by using a decorator directive. Arguments are optional. Argument-less decorators can simply use the directive without value. Decorators with arguments take a comma-separated set of expressions that resolve to the element's context.\n\n\n!-- without arguments --\n\n\ndiv as-myDecorator\n...\n/div\n\n\n\n!-- with arguments --\n\n\ndiv as-myDecorator=\narg1, .some.other.arg2, 10 * @index\n as-somethingElseToo\n...\n/div\n\n\n\n\n\nExamples\n\n\nThe following example builds a decorator that updates the time.\n\n\nRactive.decorators.timer = function(node, time) {\n  node.innerHTML = 'Hello World!';\n\n  return {\n    teardown: function() {\n      node.innerHTML = '';\n    },\n    update: function(time) {\n      node.innerHTML = time;\n    }\n  }\n};\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nspan as-timer=\ntime\n/span\n\n  `,\n  data: {\n    time: 0\n  }\n});\n\nsetInterval(function() {\n  ractive.set('time', Date.now())\n}, 1000);", 
            "title": "Decorators"
        }, 
        {
            "location": "/extend/decorators/#decorators", 
            "text": "A decorator is a simple way to add behaviour to a node when it is rendered, or to augment it in some way. Decorators are a good way to integrate DOM manipulation libraries with Ractive, such as  jQuery UI  or  Bootstrap .", 
            "title": "Decorators"
        }, 
        {
            "location": "/extend/decorators/#writing", 
            "text": "const myDecorator = function(node[, ...args]) {\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    },\n    update: function([...args]){\n      // Update code\n    }\n  };\n};  Decorators are simply functions that are called upon to setup the decorator once Ractive detects its use. It takes a  node  argument and returns an object with a  teardown  and  update  property.  node  is the element to which the decorator is applied to.  args  are optional arguments provided by the decorator directive.  teardown  is a function that gets called when the decorator is torn down.  update  is an optional function that gets called when the arguments update.  Any updates to the arguments will call the decorator's  teardown  and run the decorator function again, essentially setting up the decorator again. If an  update  function is provided on the return object, that will be called instead of the  teardown  and setup function.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/decorators/#registering", 
            "text": "Like other plugins, there's 3 ways you can register decorators:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/decorators/#globally-via-the-ractivedecorators-static-property", 
            "text": "Ractive.decorators.myDecorator = myDecorator;", 
            "title": "Globally, via the Ractive.decorators static property."
        }, 
        {
            "location": "/extend/decorators/#per-component-via-the-components-decorators-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  decorators: { myDecorator }\n});", 
            "title": "Per component, via the component's decorators initialization property."
        }, 
        {
            "location": "/extend/decorators/#per-instance-via-the-instances-decorators-initialization-property", 
            "text": "const ractive = new Ractive({\n  decorators: { myDecorator }\n});", 
            "title": "Per instance, via the instance's decorators initialization property."
        }, 
        {
            "location": "/extend/decorators/#using", 
            "text": "You can invoke one or more decorators on your elements by using a decorator directive. Arguments are optional. Argument-less decorators can simply use the directive without value. Decorators with arguments take a comma-separated set of expressions that resolve to the element's context.  !-- without arguments --  div as-myDecorator ... /div  !-- with arguments --  div as-myDecorator= arg1, .some.other.arg2, 10 * @index  as-somethingElseToo ... /div", 
            "title": "Using"
        }, 
        {
            "location": "/extend/decorators/#examples", 
            "text": "The following example builds a decorator that updates the time.  Ractive.decorators.timer = function(node, time) {\n  node.innerHTML = 'Hello World!';\n\n  return {\n    teardown: function() {\n      node.innerHTML = '';\n    },\n    update: function(time) {\n      node.innerHTML = time;\n    }\n  }\n};\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     span as-timer= time /span \n  `,\n  data: {\n    time: 0\n  }\n});\n\nsetInterval(function() {\n  ractive.set('time', Date.now())\n}, 1000);", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/easings/", 
            "text": "Easings\n\n\nEasing functions are used by \nractive.animate\n and some transitions. They describe the animation's progression from start to finish.\n\n\nWriting\n\n\nconst myEasing = function ( x ) {\n  // Calculation\n  return y;\n};\n\n\n\n\nEasing functions are simply functions that accept one argument, a numeric value \nx\n between 0 and 1 representing progress along a timeline. The function must return a numeric \ny\n value to represent its progression.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register an easing function:\n\n\nGlobally via the \nRactive.easing\n static property.\n\n\nRactive.easing.myEasing = myEasing;\n\n\n\n\nPer component via the component's \neasing\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  easing: { myEasing }\n});\n\n\n\n\nPer instance, via the instance's \neasing\n initialization property.\n\n\nconst ractive = new Ractive({\n  easing: { myEasing }\n});\n\n\n\n\nUsing\n\n\nEasing functions don't work alone. They are utilized by \nractive.animate()\n and \nTransitions\n to dictate animations.\n\n\nractive.animate('foo.bar', 1, {\n  easing: 'myEasing'\n});\n\n\n\n\nExamples\n\n\nHere's an \nelastic\n easing function taken from \ndanro\n's excellent \neasing.js\n library.\n\n\nRactive.easing.elastic = function ( x ) {\n  return -1 * Math.pow(4,-8*x) * Math.sin((x*6-1)*(2*Math.PI)/2) + 1;\n};", 
            "title": "Easings"
        }, 
        {
            "location": "/extend/easings/#easings", 
            "text": "Easing functions are used by  ractive.animate  and some transitions. They describe the animation's progression from start to finish.", 
            "title": "Easings"
        }, 
        {
            "location": "/extend/easings/#writing", 
            "text": "const myEasing = function ( x ) {\n  // Calculation\n  return y;\n};  Easing functions are simply functions that accept one argument, a numeric value  x  between 0 and 1 representing progress along a timeline. The function must return a numeric  y  value to represent its progression.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/easings/#registering", 
            "text": "Like other plugins, there's 3 ways you can register an easing function:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/easings/#globally-via-the-ractiveeasing-static-property", 
            "text": "Ractive.easing.myEasing = myEasing;", 
            "title": "Globally via the Ractive.easing static property."
        }, 
        {
            "location": "/extend/easings/#per-component-via-the-components-easing-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  easing: { myEasing }\n});", 
            "title": "Per component via the component's easing initialization property."
        }, 
        {
            "location": "/extend/easings/#per-instance-via-the-instances-easing-initialization-property", 
            "text": "const ractive = new Ractive({\n  easing: { myEasing }\n});", 
            "title": "Per instance, via the instance's easing initialization property."
        }, 
        {
            "location": "/extend/easings/#using", 
            "text": "Easing functions don't work alone. They are utilized by  ractive.animate()  and  Transitions  to dictate animations.  ractive.animate('foo.bar', 1, {\n  easing: 'myEasing'\n});", 
            "title": "Using"
        }, 
        {
            "location": "/extend/easings/#examples", 
            "text": "Here's an  elastic  easing function taken from  danro 's excellent  easing.js  library.  Ractive.easing.elastic = function ( x ) {\n  return -1 * Math.pow(4,-8*x) * Math.sin((x*6-1)*(2*Math.PI)/2) + 1;\n};", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/events/", 
            "text": "Events\n\n\nEvents allow custom-named events on DOM elements. Common use cases for custom DOM events include normalizing cross-browser events, normalizing cross-device events, implementing custom events, and so much more.\n\n\nWriting\n\n\nconst myEvent = function(node, fire){\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    }\n  };\n}\n\n\n\n\nEvents are simply functions that are called to set up the event on a DOM element. The event function accepts two arguments: \nnode\n and \nfire\n, and returns an object containing a \nteardown\n property.\n\n\nnode\n is the element to which the event is being applied.\n\n\nfire\n is the function that must be called when the event has taken place. \nfire\n takes a single argument, the event object received by handlers. The minimum requirement for the event object is a \nnode\n property that references DOM node the event is attached to, and an \noriginal\n property which references the native DOM \nevent\n object supplied by the native handler, if available.\n\n\nThe event object will be augmented with \ncontext\n, \nkeypath\n and \nindex\n properties, whose values depend on the data context the node is in. \ncontext\n references the data context that surrounds the node, \nkeypath\n is a string that leads to the current data context and \nindex\n is a number that references the index number of the data, should the data context be in an array.\n\n\nteardown\n is a function that gets called once the element is torn down. This allows the event to clean up after itself.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register events:\n\n\nGlobally, via the \nRactive.events\n static property.\n\n\nRactive.events.myEvent = myEvent;\n\n\n\n\nPer component, via the component's \nevents\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  events: { myEvent }\n});\n\n\n\n\nPer instance, via the instance's \nevents\n initialization property.\n\n\nconst ractive = new Ractive({\n  events: { myEvent }\n});\n\n\n\n\nUsing\n\n\nEvents use the same \non-*\n attribute syntax as component and DOM events. When Ractive encounters an \non-*\n attribute on a DOM element, it looks for a registered event and applies it on the element. If no matching event name was found, Ractive will think the event name is a native DOM event and will attach one accordingly.\n\n\n// This will apply the \nmyEvent\n custom event if one is registered.\n// Otherwise, Ractive will think it's a DOM event. You have been warned!\n\nspan on-myEvent=\nfoo()\nClick me!\n/span\n\n\n\n\n\nExamples\n\n\nHere's an example of a \"long press\" event which fires when the mouse is clicked and held for 1 second.\n\n\n// Definition\nRactive.events.longpress = function(node, fire){\n  let timer = null;\n\n  function clearTimer(){\n    if(timer) clearTimeout(timer);\n    timer = null;\n  }\n\n  function mouseDownHandler(event){\n    clearTimer();\n\n    timer = setTimeout(function(){\n      fire({\n        node: node,\n        original: event\n      });\n    }, 1000);\n  }\n\n  function mouseUpHandler(){\n    clearTimer();\n  }\n\n  node.addEventListener('mousedown', mouseDownHandler);\n  node.addEventListener('mouseup', mouseUpHandler);\n\n  return {\n    teardown: function(){\n      node.removeEventListener('mousedown', mouseDownHandler);\n      node.removeEventListener('mouseup', mouseUpHandler);\n    }\n  };\n};\n\n// Usage:\nnew Ractive({\n  el: 'body',\n  template: `\n    \nbutton type=\nbutton\n on-longpress=\n@this.greetz()\nClick Me!\n/button\n\n  `,\n  greetz: function(){\n    console.log('Hello World!');\n  }\n});", 
            "title": "Events"
        }, 
        {
            "location": "/extend/events/#events", 
            "text": "Events allow custom-named events on DOM elements. Common use cases for custom DOM events include normalizing cross-browser events, normalizing cross-device events, implementing custom events, and so much more.", 
            "title": "Events"
        }, 
        {
            "location": "/extend/events/#writing", 
            "text": "const myEvent = function(node, fire){\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    }\n  };\n}  Events are simply functions that are called to set up the event on a DOM element. The event function accepts two arguments:  node  and  fire , and returns an object containing a  teardown  property.  node  is the element to which the event is being applied.  fire  is the function that must be called when the event has taken place.  fire  takes a single argument, the event object received by handlers. The minimum requirement for the event object is a  node  property that references DOM node the event is attached to, and an  original  property which references the native DOM  event  object supplied by the native handler, if available.  The event object will be augmented with  context ,  keypath  and  index  properties, whose values depend on the data context the node is in.  context  references the data context that surrounds the node,  keypath  is a string that leads to the current data context and  index  is a number that references the index number of the data, should the data context be in an array.  teardown  is a function that gets called once the element is torn down. This allows the event to clean up after itself.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/events/#registering", 
            "text": "Like other plugins, there's 3 ways you can register events:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/events/#globally-via-the-ractiveevents-static-property", 
            "text": "Ractive.events.myEvent = myEvent;", 
            "title": "Globally, via the Ractive.events static property."
        }, 
        {
            "location": "/extend/events/#per-component-via-the-components-events-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  events: { myEvent }\n});", 
            "title": "Per component, via the component's events initialization property."
        }, 
        {
            "location": "/extend/events/#per-instance-via-the-instances-events-initialization-property", 
            "text": "const ractive = new Ractive({\n  events: { myEvent }\n});", 
            "title": "Per instance, via the instance's events initialization property."
        }, 
        {
            "location": "/extend/events/#using", 
            "text": "Events use the same  on-*  attribute syntax as component and DOM events. When Ractive encounters an  on-*  attribute on a DOM element, it looks for a registered event and applies it on the element. If no matching event name was found, Ractive will think the event name is a native DOM event and will attach one accordingly.  // This will apply the  myEvent  custom event if one is registered.\n// Otherwise, Ractive will think it's a DOM event. You have been warned! span on-myEvent= foo() Click me! /span", 
            "title": "Using"
        }, 
        {
            "location": "/extend/events/#examples", 
            "text": "Here's an example of a \"long press\" event which fires when the mouse is clicked and held for 1 second.  // Definition\nRactive.events.longpress = function(node, fire){\n  let timer = null;\n\n  function clearTimer(){\n    if(timer) clearTimeout(timer);\n    timer = null;\n  }\n\n  function mouseDownHandler(event){\n    clearTimer();\n\n    timer = setTimeout(function(){\n      fire({\n        node: node,\n        original: event\n      });\n    }, 1000);\n  }\n\n  function mouseUpHandler(){\n    clearTimer();\n  }\n\n  node.addEventListener('mousedown', mouseDownHandler);\n  node.addEventListener('mouseup', mouseUpHandler);\n\n  return {\n    teardown: function(){\n      node.removeEventListener('mousedown', mouseDownHandler);\n      node.removeEventListener('mouseup', mouseUpHandler);\n    }\n  };\n};\n\n// Usage:\nnew Ractive({\n  el: 'body',\n  template: `\n     button type= button  on-longpress= @this.greetz() Click Me! /button \n  `,\n  greetz: function(){\n    console.log('Hello World!');\n  }\n});", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/interpolators/", 
            "text": "Interpolators\n\n\nTODO\n\n\nWriting\n\n\nTODO\n\n\nRegistering\n\n\nTODO\n\n\nUsing\n\n\nTODO\n\n\nExamples\n\n\nTODO", 
            "title": "Interpolators"
        }, 
        {
            "location": "/extend/interpolators/#interpolators", 
            "text": "TODO", 
            "title": "Interpolators"
        }, 
        {
            "location": "/extend/interpolators/#writing", 
            "text": "TODO", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/interpolators/#registering", 
            "text": "TODO", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/interpolators/#using", 
            "text": "TODO", 
            "title": "Using"
        }, 
        {
            "location": "/extend/interpolators/#examples", 
            "text": "TODO", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/partials/", 
            "text": "Partials\n\n\nA partial is a template snippet which can be reused in templates or in other partials. They help to keep templates uncluttered, non-repetetive and easy to read.\n\n\nWriting\n\n\nconst myPartial = '\n!-- template --\n';\n\n\n\n\nPartials are simply Ractive templates.\n\n\nRegistering\n\n\nUnlike other plugins, partials have more than 3 registration options.\n\n\nGlobally via the \nRactive.partials\n static property.\n\n\nRactive.partials.myPartial = MyPartial;\n\n\n\n\nGlobally, via a non-executing script tag on the current page.\n\n\nscript type=\nractive/template\n id=\nmyPartial\n\n  ...\n\n/script\n\n\n\n\n\ntext/html\n is another good choice for \ntype\n because many editors will highlight the content of the tag as HTML. Anything other than \ntext/javascript\n, \napplication/javascript\n, or no \ntype\n at all will do.\n\n\nPer component, via the component's \npartials\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  partials: { myPartial }\n});\n\n\n\n\nPer instance, via the instance's \npartials\n initialization property.\n\n\nconst ractive = new Ractive({\n  partials: { myPartial }\n});\n\n\n\n\nInline, using the \n{{#partial}}\n mustache.\n\n\nAvailability depends on whoever uses the template containing the inline partial, whether it's a component, an instance or another partial. Inline partials are scoped to the nearest tag, be it component or element, and are available to any child of that element.\n\n\n{{#partial myPartial}}\n  ...\n{{/}}\n\n\n\n\nUsing\n\n\nPartials can be used using the \n{{\npartialName}}\n syntax. Partials work where any template would work. It works as if the partial template is manually put into where the partial mustache is positioned.\n\n\n{{#partial myPartial}}\n  \ndiv class=\nmessage\n{{message}}\n/div\n\n{{/}}\n\n\ndiv class=\napp\n\n  {{\nmyPartial}}\n\n/div\n\n\n\n\n\nValid names\n\n\nPartials may be named with the same rules as any other identifier in Ractive or JavaScript, but since there isn't much danger of trying to do math in a partial name, they enjoy relaxed naming requirements that allow otherwise reserved globals and keywords to be used for partial names.\n\n\nPartial names may also contain \n-\n and \n/\n characters as long as they are surrounded by other valid characters e.g. \ntemplates/some-partial-template\n.\n\n\nPartial context\n\n\nBy default, a partial's context is the context of wherever it is positioned.\n\n\nIn the following example, the context of the partial is the current item in the list.\n\n\n{{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{\nmyPartial}}\n{{/}}\n\n\n\n\n\nHowever, partials may be given explicit context using the \n{{\n[name expression] [context expression]}}\n syntax. It's similar to wrapping the partial with a \n{{#with}}\n mustache. Ancestor references, members, object literals, and any other expressions that resolve to an object may be used as a context expression.\n\n\nIn the following example, context of the partial is the current item's \nfoo.bar\n value.\n\n\n{{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{\nmyPartial .foo.bar}}\n{{/}}\n\n\n\n\nExplicit contexts can also be aliased. In the case of plain refereces, it can be used for two-way binding.\n\n\nIn the following example, the current item's \nfoo.bar\n path is aliased with \nitem\n. In the partial, \n.label\n refers to the current item's \nlabel\n property. However, \nitem\n is essentially the current item's \n{{.foo.bar.item}}\n. The \nitem\n binds two-way and updates the current item's \n.foo.bar\n.\n\n\n{{#partial myPartial}}\n  \nlabel\n{{.label}}\n/label\n\n  \ninput type=\ntext\n value=\n{{item}}\n\n{{/}}\n\n{{# list }}\n  {{\nmyPartial .foo.bar as item}}\n{{/}}\n\n\n\n\nRecursive partials\n\n\nPartials can be used recursively. A common use case for this is when reusing partials on a tree-like structure, like a directory listing.\n\n\ndiv class='fileSystem'\n\n  {{#root}}\n    {{\nfolder}}\n  {{/root}}\n\n/div\n\n\n{{#partial folder}}\n\nul class='folder'\n\n  {{#files}}\n    {{\nfile}}\n  {{/files}}\n\n/ul\n\n{{/partial}}\n\n{{#partial file}}\n\nli class='file'\n\n  \nimg class='icon-{{type}}'\n\n  \nspan\n{{filename}}\n/span\n\n\n  \n!-- if this is actually a folder, embed the folder partial --\n\n  {{# type === 'folder' }}\n    {{\nfolder}}\n  {{/ type === 'folder' }}\n\n/li\n\n{{/partial}}\n\n\n\n\nrv = new Ractive({\n  el: 'container',\n  template: '#myTemplate',\n  data: {\n    root: {\n      files: [\n        { type: 'jpg', filename: 'hello.jpg' },\n        { type: 'mp3', filename: 'NeverGonna.mp3' },\n        { type: 'folder', filename: 'subfolder', files: [\n          { type: 'txt', filename: 'README.txt' },\n          { type: 'folder', filename: 'rabbithole', files: [\n            { type: 'txt', filename: 'Inception.txt' }\n          ]}\n        ]}\n      ]\n    }\n  }\n});\n\n\n\n\nIn the example above, subfolders use the \n{{\nfolder}}\n partial, which uses the \n{{\nfile}}\n partial for each file, and if any of those files are folders, the \n{{\nfolder}}\n partial will be invoked again, and so on until there are no more files.\n\n\nBeware of cyclical data structures! Ractive makes no attempt to detect cyclicality, and will happily continue rendering partials until the \nBig Crunch\n (or your browser exceeds its maximum call stack size. Whichever is sooner).\n\n\nInjecting partials\n\n\nOne good use of partials is to vary the shape of a template according to some condition, the same way you might use \ndependency injection\n elsewhere in your code.\n\n\nFor example, you might offer a different view to mobile users:\n\n\ndiv class='main'\n\n  \ndiv class='content'\n\n    {{\ncontent}}\n  \n/div\n\n\n  \ndiv class='sidebar'\n\n    {{\nsidebar}}\n  \n/div\n\n\n/div\n\n\n\n\n\nisMobile = /mobile/i.test( navigator.userAgent ); // please don't do this in real life!\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  partials: {\n    content: isMobile ? mobileContentPartial : desktopContentPartial,\n    sidebar: isMobile ? mobileSidebarPartial : desktopSidebarPartial\n  }\n});\n\n\n\n\nOr you might make it possible to \nextend\n a subclass without overriding its template:\n\n\ndiv class='modal-background'\n\n  \ndiv class='modal'\n\n    {{\nmodalContent}}\n  \n/div\n\n\n/div\n\n\n\n\n\n// Create a Modal subclass\nModal = Ractive.extend({\n  template: modalTemplate,\n  init: function () {\n    var self = this, resizeHandler;\n\n    resizeHandler = function () {\n      self.center();\n    };\n\n    // when the window resizes, keep the modal horizontally and vertically centred\n    window.addEventListener( 'resize', resizeHandler );\n\n    // clean up after ourselves later\n    this.on( 'teardown', function () {\n      window.removeEventListener( 'resize', resizeHandler );\n    });\n\n    // manually call this.center() the first time\n    this.center();\n  },\n  center: function () {\n    // centering logic goes here\n  }\n});\n\nhelloModal = new Modal({\n  el: document.body,\n  partials: {\n    modalContent: '\np\nHello!\n/p\na class=\nmodal-button\n proxy-tap=\nclose\nClose\n/a\n'\n  }\n});\n\nhelloModal.on( 'close', function () {\n  this.teardown();\n});\n\n\n\n\nPartial expressions\n\n\nExpressions can also be used to reference a partial instead of fixed partial names. Ractive will evaluate the expression and use its return value to select a partial. This is useful when you want the data to indicate what type of partial it should render with.\n\n\nIn the following example, \norganisms\n contains a list of organisms whose \ntype\n can either be \nperson\n or \nanimal\n. Partials for each type is defined and the list uses the \ntype\n of each item to determine which partial to use.\n\n\n{{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n\nul\n\n  {{# organisms }}\n    \nli\n{{\n type }}\n/li\n\n  {{/}}\n\n/ul\n\n\n\n\n\nIn the case where there's a collision between the expression and a partial of the same name, Ractive will not evaluate the expression and instead, will immediately resolve to that partial.\n\n\nIn the following example, a partial named \ntype\n is defined. Instead of evaluating \ntype\n's value, it will resolve to the partial named \ntype\n.\n\n\n{{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n{{#partial type}}Hi! I am {{.name}}{{/}}\n\n\nul\n\n  {{# organisms }}\n    \nli\n{{\n type }}\n/li\n\n  {{/}}\n\n/ul\n\n\n\n\n\nPartials can also be registered on-the-fly as well as have functions determine the partial to use.\n\n\nIn the following example, \nmakePartial\n registers a partial on the fly using \ntemplate\n and \nid\n, and returns the partial name for use in the template.\n\n\nnew Ractive({\n  el: 'main',\n  template: `\n    \nspan\nAdd a partial:\n/span\n\n    \ntextarea value=\n{{tpl}}\n /\n/div\n\n    \nbutton on-click=\n@this.add()\nAdd\n/button\nbr/\n\n\n    {{#list}}\n      {{\n @this.makePartial(.id, .template) }}\n    {{/}}\n  `,\n  data: {\n    list: [],\n    tpl: '',\n\n  },\n  add: function() {\n    this.push('list', {\n      id: Math.random(),\n      template: this.get('tpl')\n    });\n    this.set('tpl', '');\n  },\n  makePartial: function(id, template) {\n    const name = 'partial-' + id;\n    this.partials[name] = this.partials[name] || template;\n    return name;\n  }\n});\n\n\n\n\nUpdating Partials\n\n\nPartials may be reset after they are rendered using \nractive.resetPartial()\n. A reset partial will update everywhere it is referenced, so if it is used multiple times or inherited by a component, those instances will be updated as well. If a component has a partial with the same name as a parent partial, partial resets will not affect it since it is a different partial.\n\n\nIt should be noted that partials evaluate lazily, so it is possible to cause a single partial to update by wrapping it in a conditional section and causing the section to be hidden and re-shown.\n\n\n{{^toggle}}{{\nrickroll}}{{/}}\n\n\n\n\nractive.partials.rickroll = 'I wouldn\\'t do that to you, chum.';\nractive.set('toggle', true);\nractive.set('toggle', false);\n\n\n\n\nExamples\n\n\nHere's an example of a gallery using a partial for its thumbnail information:\n\n\n!-- The partial called \nthumbnail\n --\n\n\nfigure class='thumbnail'\n\n  \nimg src='assets/thumbnails/{{id}}.jpg'\n\n  \nfigcaption\n{{description}}\n/figcaption\n\n\n/figure\n\n\n\n!-- The template that uses the partial --\n\n\ndiv class='gallery'\n\n  {{#items}}\n    {{\nthumbnail}}\n  {{/items}}\n\n/div", 
            "title": "Partials"
        }, 
        {
            "location": "/extend/partials/#partials", 
            "text": "A partial is a template snippet which can be reused in templates or in other partials. They help to keep templates uncluttered, non-repetetive and easy to read.", 
            "title": "Partials"
        }, 
        {
            "location": "/extend/partials/#writing", 
            "text": "const myPartial = ' !-- template -- ';  Partials are simply Ractive templates.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/partials/#registering", 
            "text": "Unlike other plugins, partials have more than 3 registration options.", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/partials/#globally-via-the-ractivepartials-static-property", 
            "text": "Ractive.partials.myPartial = MyPartial;", 
            "title": "Globally via the Ractive.partials static property."
        }, 
        {
            "location": "/extend/partials/#globally-via-a-non-executing-script-tag-on-the-current-page", 
            "text": "script type= ractive/template  id= myPartial \n  ... /script   text/html  is another good choice for  type  because many editors will highlight the content of the tag as HTML. Anything other than  text/javascript ,  application/javascript , or no  type  at all will do.", 
            "title": "Globally, via a non-executing script tag on the current page."
        }, 
        {
            "location": "/extend/partials/#per-component-via-the-components-partials-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  partials: { myPartial }\n});", 
            "title": "Per component, via the component's partials initialization property."
        }, 
        {
            "location": "/extend/partials/#per-instance-via-the-instances-partials-initialization-property", 
            "text": "const ractive = new Ractive({\n  partials: { myPartial }\n});", 
            "title": "Per instance, via the instance's partials initialization property."
        }, 
        {
            "location": "/extend/partials/#inline-using-the-partial-mustache", 
            "text": "Availability depends on whoever uses the template containing the inline partial, whether it's a component, an instance or another partial. Inline partials are scoped to the nearest tag, be it component or element, and are available to any child of that element.  {{#partial myPartial}}\n  ...\n{{/}}", 
            "title": "Inline, using the {{#partial}} mustache."
        }, 
        {
            "location": "/extend/partials/#using", 
            "text": "Partials can be used using the  {{ partialName}}  syntax. Partials work where any template would work. It works as if the partial template is manually put into where the partial mustache is positioned.  {{#partial myPartial}}\n   div class= message {{message}} /div \n{{/}} div class= app \n  {{ myPartial}} /div", 
            "title": "Using"
        }, 
        {
            "location": "/extend/partials/#valid-names", 
            "text": "Partials may be named with the same rules as any other identifier in Ractive or JavaScript, but since there isn't much danger of trying to do math in a partial name, they enjoy relaxed naming requirements that allow otherwise reserved globals and keywords to be used for partial names.  Partial names may also contain  -  and  /  characters as long as they are surrounded by other valid characters e.g.  templates/some-partial-template .", 
            "title": "Valid names"
        }, 
        {
            "location": "/extend/partials/#partial-context", 
            "text": "By default, a partial's context is the context of wherever it is positioned.  In the following example, the context of the partial is the current item in the list.  {{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{ myPartial}}\n{{/}}  However, partials may be given explicit context using the  {{ [name expression] [context expression]}}  syntax. It's similar to wrapping the partial with a  {{#with}}  mustache. Ancestor references, members, object literals, and any other expressions that resolve to an object may be used as a context expression.  In the following example, context of the partial is the current item's  foo.bar  value.  {{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{ myPartial .foo.bar}}\n{{/}}  Explicit contexts can also be aliased. In the case of plain refereces, it can be used for two-way binding.  In the following example, the current item's  foo.bar  path is aliased with  item . In the partial,  .label  refers to the current item's  label  property. However,  item  is essentially the current item's  {{.foo.bar.item}} . The  item  binds two-way and updates the current item's  .foo.bar .  {{#partial myPartial}}\n   label {{.label}} /label \n   input type= text  value= {{item}} \n{{/}}\n\n{{# list }}\n  {{ myPartial .foo.bar as item}}\n{{/}}", 
            "title": "Partial context"
        }, 
        {
            "location": "/extend/partials/#recursive-partials", 
            "text": "Partials can be used recursively. A common use case for this is when reusing partials on a tree-like structure, like a directory listing.  div class='fileSystem' \n  {{#root}}\n    {{ folder}}\n  {{/root}} /div \n\n{{#partial folder}} ul class='folder' \n  {{#files}}\n    {{ file}}\n  {{/files}} /ul \n{{/partial}}\n\n{{#partial file}} li class='file' \n   img class='icon-{{type}}' \n   span {{filename}} /span \n\n   !-- if this is actually a folder, embed the folder partial -- \n  {{# type === 'folder' }}\n    {{ folder}}\n  {{/ type === 'folder' }} /li \n{{/partial}}  rv = new Ractive({\n  el: 'container',\n  template: '#myTemplate',\n  data: {\n    root: {\n      files: [\n        { type: 'jpg', filename: 'hello.jpg' },\n        { type: 'mp3', filename: 'NeverGonna.mp3' },\n        { type: 'folder', filename: 'subfolder', files: [\n          { type: 'txt', filename: 'README.txt' },\n          { type: 'folder', filename: 'rabbithole', files: [\n            { type: 'txt', filename: 'Inception.txt' }\n          ]}\n        ]}\n      ]\n    }\n  }\n});  In the example above, subfolders use the  {{ folder}}  partial, which uses the  {{ file}}  partial for each file, and if any of those files are folders, the  {{ folder}}  partial will be invoked again, and so on until there are no more files.  Beware of cyclical data structures! Ractive makes no attempt to detect cyclicality, and will happily continue rendering partials until the  Big Crunch  (or your browser exceeds its maximum call stack size. Whichever is sooner).", 
            "title": "Recursive partials"
        }, 
        {
            "location": "/extend/partials/#injecting-partials", 
            "text": "One good use of partials is to vary the shape of a template according to some condition, the same way you might use  dependency injection  elsewhere in your code.  For example, you might offer a different view to mobile users:  div class='main' \n   div class='content' \n    {{ content}}\n   /div \n\n   div class='sidebar' \n    {{ sidebar}}\n   /div  /div   isMobile = /mobile/i.test( navigator.userAgent ); // please don't do this in real life!\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  partials: {\n    content: isMobile ? mobileContentPartial : desktopContentPartial,\n    sidebar: isMobile ? mobileSidebarPartial : desktopSidebarPartial\n  }\n});  Or you might make it possible to  extend  a subclass without overriding its template:  div class='modal-background' \n   div class='modal' \n    {{ modalContent}}\n   /div  /div   // Create a Modal subclass\nModal = Ractive.extend({\n  template: modalTemplate,\n  init: function () {\n    var self = this, resizeHandler;\n\n    resizeHandler = function () {\n      self.center();\n    };\n\n    // when the window resizes, keep the modal horizontally and vertically centred\n    window.addEventListener( 'resize', resizeHandler );\n\n    // clean up after ourselves later\n    this.on( 'teardown', function () {\n      window.removeEventListener( 'resize', resizeHandler );\n    });\n\n    // manually call this.center() the first time\n    this.center();\n  },\n  center: function () {\n    // centering logic goes here\n  }\n});\n\nhelloModal = new Modal({\n  el: document.body,\n  partials: {\n    modalContent: ' p Hello! /p a class= modal-button  proxy-tap= close Close /a '\n  }\n});\n\nhelloModal.on( 'close', function () {\n  this.teardown();\n});", 
            "title": "Injecting partials"
        }, 
        {
            "location": "/extend/partials/#partial-expressions", 
            "text": "Expressions can also be used to reference a partial instead of fixed partial names. Ractive will evaluate the expression and use its return value to select a partial. This is useful when you want the data to indicate what type of partial it should render with.  In the following example,  organisms  contains a list of organisms whose  type  can either be  person  or  animal . Partials for each type is defined and the list uses the  type  of each item to determine which partial to use.  {{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}} ul \n  {{# organisms }}\n     li {{  type }} /li \n  {{/}} /ul   In the case where there's a collision between the expression and a partial of the same name, Ractive will not evaluate the expression and instead, will immediately resolve to that partial.  In the following example, a partial named  type  is defined. Instead of evaluating  type 's value, it will resolve to the partial named  type .  {{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n{{#partial type}}Hi! I am {{.name}}{{/}} ul \n  {{# organisms }}\n     li {{  type }} /li \n  {{/}} /ul   Partials can also be registered on-the-fly as well as have functions determine the partial to use.  In the following example,  makePartial  registers a partial on the fly using  template  and  id , and returns the partial name for use in the template.  new Ractive({\n  el: 'main',\n  template: `\n     span Add a partial: /span \n     textarea value= {{tpl}}  / /div \n     button on-click= @this.add() Add /button br/ \n\n    {{#list}}\n      {{  @this.makePartial(.id, .template) }}\n    {{/}}\n  `,\n  data: {\n    list: [],\n    tpl: '',\n\n  },\n  add: function() {\n    this.push('list', {\n      id: Math.random(),\n      template: this.get('tpl')\n    });\n    this.set('tpl', '');\n  },\n  makePartial: function(id, template) {\n    const name = 'partial-' + id;\n    this.partials[name] = this.partials[name] || template;\n    return name;\n  }\n});", 
            "title": "Partial expressions"
        }, 
        {
            "location": "/extend/partials/#updating-partials", 
            "text": "Partials may be reset after they are rendered using  ractive.resetPartial() . A reset partial will update everywhere it is referenced, so if it is used multiple times or inherited by a component, those instances will be updated as well. If a component has a partial with the same name as a parent partial, partial resets will not affect it since it is a different partial.  It should be noted that partials evaluate lazily, so it is possible to cause a single partial to update by wrapping it in a conditional section and causing the section to be hidden and re-shown.  {{^toggle}}{{ rickroll}}{{/}}  ractive.partials.rickroll = 'I wouldn\\'t do that to you, chum.';\nractive.set('toggle', true);\nractive.set('toggle', false);", 
            "title": "Updating Partials"
        }, 
        {
            "location": "/extend/partials/#examples", 
            "text": "Here's an example of a gallery using a partial for its thumbnail information:  !-- The partial called  thumbnail  --  figure class='thumbnail' \n   img src='assets/thumbnails/{{id}}.jpg' \n   figcaption {{description}} /figcaption  /figure  !-- The template that uses the partial --  div class='gallery' \n  {{#items}}\n    {{ thumbnail}}\n  {{/items}} /div", 
            "title": "Examples"
        }, 
        {
            "location": "/extend/transitions/", 
            "text": "Transitions\n\n\nTransitions allow you to control how enter the DOM and how they leave the DOM. This allows you to define intro and outro behavior, particularly animations, when elements go in and out of the page.\n\n\nWriting\n\n\nconst myTransition = function ( t, params ) {\n  // Manipulate the DOM.\n  // Call t.complete() when completed.\n};\n\n\n\n\nTransitions are simply functions that get called to animate a specified element.\n\n\nt\n is a \ntransition helper object\n that aids in the implementation of the transition.\n\n\nparams\n is the parameters passed in via the transition directive.\n\n\nTransitions are expected to be asynchronous. In order to signal Ractive that the transition has completed, the transition must call the \nt.complete()\n.\n\n\nNote that transitions control the element's arrival and departure to the page. That means upon completion, any styling done to the element will be removed automatically.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register transitions:\n\n\nGlobally, via the \nRactive.transitions\n static property.\n\n\nRactive.transitions.myTransition = myTransition;\n\n\n\n\nPer component, via the component's \ntransitions\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  transitions: { myTransition }\n});\n\n\n\n\nPer instance, via the instance's \ntransitions\n initialization property.\n\n\nconst ractive = new Ractive({\n  transitions: { myTransition }\n});\n\n\n\n\nUsing\n\n\nTransitions are added to an element via a transition directive. The directive starts with the transition name followed by one or more suffixes. The transition may be intro-only (upon rendering) using the suffix \n-in\n, outro-only (upon removal) using the suffix \n-out\n, or both using the suffix \n-in-out\n.\n\n\ndiv myTransition-in\nIntro-only\n/div\n\n\ndiv myTransition-out\nOutro-only\n/div\n\n\ndiv myTransition-in-out\nIntro and outro\n/div\n\n\n\n\n\nTo pass arguments to the transition, simply provide an expression as the directive's value. This will be passed as the second argument of the transition function.\n\n\ndiv myTransition-in=\n{ /*params */ }\nIntro-only\n/div\n\n\ndiv myTransition-out=\n{ /*params */ }\nOutro-only\n/div\n\n\ndiv myTransition-in-out=\n{ /*params */ }\nIntro and outro\n/div\n\n\n\n\n\nExamples\n\n\nThe following example demonstrates a \"flash\" transition which colors the element green upon attachment, and red prior to removal.\n\n\nRactive.transitions.flash = function(t, params) {\n  // Process params and declaring defaults.\n  const options = t.processParams(params, {\n    color: t.isIntro ? '#0f0' : '#f00',\n    duration: 400\n  });\n\n  // The \ntransition\n\n  t.setStyle('color', options.color);\n\n  // Signal Ractive that the transition is complete.\n  setTimeout(t.complete, options.duration);\n};\n\nnew Ractive({\n  el: 'body',\n  template: `\n    \nbutton on-click='@this.insert()'\nInsert item\n/button\n\n    \nbutton on-click='@this.remove()'\nRemove item\n/button\n\n    \nul\n\n      {{#items}}\n      \nli flash-in-out\n{{this}}\n/li\n\n      {{/items}}\n    \n/ul\n\n  `,\n  data: {\n    items: []\n  },\n  insert() {\n    this.push('items', Date.now());\n  },\n  remove() {\n    this.splice('items', 0, 1);\n  }\n});", 
            "title": "Transitions"
        }, 
        {
            "location": "/extend/transitions/#transitions", 
            "text": "Transitions allow you to control how enter the DOM and how they leave the DOM. This allows you to define intro and outro behavior, particularly animations, when elements go in and out of the page.", 
            "title": "Transitions"
        }, 
        {
            "location": "/extend/transitions/#writing", 
            "text": "const myTransition = function ( t, params ) {\n  // Manipulate the DOM.\n  // Call t.complete() when completed.\n};  Transitions are simply functions that get called to animate a specified element.  t  is a  transition helper object  that aids in the implementation of the transition.  params  is the parameters passed in via the transition directive.  Transitions are expected to be asynchronous. In order to signal Ractive that the transition has completed, the transition must call the  t.complete() .  Note that transitions control the element's arrival and departure to the page. That means upon completion, any styling done to the element will be removed automatically.", 
            "title": "Writing"
        }, 
        {
            "location": "/extend/transitions/#registering", 
            "text": "Like other plugins, there's 3 ways you can register transitions:", 
            "title": "Registering"
        }, 
        {
            "location": "/extend/transitions/#globally-via-the-ractivetransitions-static-property", 
            "text": "Ractive.transitions.myTransition = myTransition;", 
            "title": "Globally, via the Ractive.transitions static property."
        }, 
        {
            "location": "/extend/transitions/#per-component-via-the-components-transitions-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  transitions: { myTransition }\n});", 
            "title": "Per component, via the component's transitions initialization property."
        }, 
        {
            "location": "/extend/transitions/#per-instance-via-the-instances-transitions-initialization-property", 
            "text": "const ractive = new Ractive({\n  transitions: { myTransition }\n});", 
            "title": "Per instance, via the instance's transitions initialization property."
        }, 
        {
            "location": "/extend/transitions/#using", 
            "text": "Transitions are added to an element via a transition directive. The directive starts with the transition name followed by one or more suffixes. The transition may be intro-only (upon rendering) using the suffix  -in , outro-only (upon removal) using the suffix  -out , or both using the suffix  -in-out .  div myTransition-in Intro-only /div  div myTransition-out Outro-only /div  div myTransition-in-out Intro and outro /div   To pass arguments to the transition, simply provide an expression as the directive's value. This will be passed as the second argument of the transition function.  div myTransition-in= { /*params */ } Intro-only /div  div myTransition-out= { /*params */ } Outro-only /div  div myTransition-in-out= { /*params */ } Intro and outro /div", 
            "title": "Using"
        }, 
        {
            "location": "/extend/transitions/#examples", 
            "text": "The following example demonstrates a \"flash\" transition which colors the element green upon attachment, and red prior to removal.  Ractive.transitions.flash = function(t, params) {\n  // Process params and declaring defaults.\n  const options = t.processParams(params, {\n    color: t.isIntro ? '#0f0' : '#f00',\n    duration: 400\n  });\n\n  // The  transition \n  t.setStyle('color', options.color);\n\n  // Signal Ractive that the transition is complete.\n  setTimeout(t.complete, options.duration);\n};\n\nnew Ractive({\n  el: 'body',\n  template: `\n     button on-click='@this.insert()' Insert item /button \n     button on-click='@this.remove()' Remove item /button \n     ul \n      {{#items}}\n       li flash-in-out {{this}} /li \n      {{/items}}\n     /ul \n  `,\n  data: {\n    items: []\n  },\n  insert() {\n    this.push('items', Date.now());\n  },\n  remove() {\n    this.splice('items', 0, 1);\n  }\n});", 
            "title": "Examples"
        }, 
        {
            "location": "/api/component-files/", 
            "text": "Component files\n\n\nRemember the good old days? When all CSS went in \nstyle\n elements in \nhead\n? When all JS went in \nscript\n elements just before \n/body\n? When all HTML was written in Mustache inside inert \nscript\n elements? When it felt good when everything just worked after a page refresh? Ractive remembers, and it's bringing those good times back with component files.\n\n\nRactive component files are simply self-contained HTML files that define a component and contains all the markup, data, styles and logic it needs. It's also designed with dependency management in mind, allowing it to declare library and component dependencies. Best of all, component files are written in the same way regardless of the development process involved, build step or none.\n\n\nExample component file\n\n\n!-- Example component file --\n\n\n\n!-- Import a component named Foo from the file foo.html. --\n\n\nlink rel='ractive' href='foo.html' name='foo'\n\n\n\n!-- Define the markup for this component. --\n\n\nh1\n{{ title }}\n/h1\n\n\n\n!-- Use imported foo component --\n\n\np\nThis is an imported 'foo' component: \nfoo/\n/p\n\n\n\n!-- Define the styles for this component. --\n\n\nstyle\n\n  p { color: red; }\n\n/style\n\n\n\n!-- Define the behavior for this component. --\n\n\nscript\n\nconst $ = require( 'jquery' );\n\ncomponent.exports = {\n  onrender: function () {\n    $('\np /\n').text('component rendered').insertAfter($this.find('p'));\n  },\n  data: {\n    title: 'Hello World!'\n  }\n};\n\n/script\n\n\n\n\n\nThe above component file roughly translates to the following in vanilla JS:\n\n\nimport Ractive from 'ractive';\nimport $ from 'jquery';\nimport foo from './foo.html';\n\nexport default Ractive.extend({\n  components: { foo },\n  onrender: function () {\n    $('\np /\n').text('component rendered').insertAfter($this.find('p'));\n  },\n  data: {\n    title: 'Hello World!'\n  },\n  template: `\n    \nh1\n{{ title }}\n/h1\n\n    \np\nThis is an imported 'foo' component: \nfoo/\n/p\n\n  `,\n  css: `\n    p { color: red; }\n  `\n});\n\n\n\n\nWriting\n\n\nlink rel=\"ractive\"\n\n\nTop-level \nlink rel=\"ractive\"\n elements define dependencies on other components. It accepts two attributes:\n\n\n\n\n\n\nhref\n - The path to the required component file. Paths that start with \n./\n or \n../\n are resolved relative to the importing component file. Otherwise, resolution is loader-specific.\n\n\n\n\n\n\nname\n (optional) - The registered name of the component. This corresponds to the key used in the \ncomponents\n initialization option. When not defined, the filename of the dependency will be used as the name.\n\n\n\n\n\n\nThe names and the loaded dependency will be assigned to the component's \ncomponents\n initialization option.\n\n\nstyle\n\n\nTop-level \nstyle\n elements define the styles for the component. If more than one \nstyle\n element is found on the component file, their contents are concatenated in the order of appearance of the \nstyle\n elements. Contents of these elements will be concatenated and assigned to the component's \ncss\n initialization option.\n\n\nscript\n\n\nA top-level \nscript\n defines the component's initialization. The script's scope has a \ncomponent\n object that is similar to Node's \nmodule\n object. Initialization options for the component is expected via \ncomponent.exports\n. It also has a special \nrequire\n function that fetches script dependencies. \nrequire\n's behavior depends on the loader used. Refer to the specific loader's documentation to know more.\n\n\nThere can only ever be one \nscript\n in a component file. Defining more than one will result in the loader throwing an error.\n\n\nTemplate\n\n\nAfter yanking out top-level \nlink rel=\"ractive\"\n, \nstyle\n or \nscript\n from the component file, anything that's left becomes a part of the template. The remaining markup will be assigned to the component's \ntemplate\n initialization option.\n\n\nUsing\n\n\nIn order to use component files, you will have to use \nloaders\n, Head over to the \nloaders\n page to learn more about loaders and help you choose a loader that suits your needs.", 
            "title": "Component Files"
        }, 
        {
            "location": "/api/component-files/#component-files", 
            "text": "Remember the good old days? When all CSS went in  style  elements in  head ? When all JS went in  script  elements just before  /body ? When all HTML was written in Mustache inside inert  script  elements? When it felt good when everything just worked after a page refresh? Ractive remembers, and it's bringing those good times back with component files.  Ractive component files are simply self-contained HTML files that define a component and contains all the markup, data, styles and logic it needs. It's also designed with dependency management in mind, allowing it to declare library and component dependencies. Best of all, component files are written in the same way regardless of the development process involved, build step or none.", 
            "title": "Component files"
        }, 
        {
            "location": "/api/component-files/#example-component-file", 
            "text": "!-- Example component file --  !-- Import a component named Foo from the file foo.html. --  link rel='ractive' href='foo.html' name='foo'  !-- Define the markup for this component. --  h1 {{ title }} /h1  !-- Use imported foo component --  p This is an imported 'foo' component:  foo/ /p  !-- Define the styles for this component. --  style \n  p { color: red; } /style  !-- Define the behavior for this component. --  script \nconst $ = require( 'jquery' );\n\ncomponent.exports = {\n  onrender: function () {\n    $(' p / ').text('component rendered').insertAfter($this.find('p'));\n  },\n  data: {\n    title: 'Hello World!'\n  }\n}; /script   The above component file roughly translates to the following in vanilla JS:  import Ractive from 'ractive';\nimport $ from 'jquery';\nimport foo from './foo.html';\n\nexport default Ractive.extend({\n  components: { foo },\n  onrender: function () {\n    $(' p / ').text('component rendered').insertAfter($this.find('p'));\n  },\n  data: {\n    title: 'Hello World!'\n  },\n  template: `\n     h1 {{ title }} /h1 \n     p This is an imported 'foo' component:  foo/ /p \n  `,\n  css: `\n    p { color: red; }\n  `\n});", 
            "title": "Example component file"
        }, 
        {
            "location": "/api/component-files/#writing", 
            "text": "", 
            "title": "Writing"
        }, 
        {
            "location": "/api/component-files/#link-relractive", 
            "text": "Top-level  link rel=\"ractive\"  elements define dependencies on other components. It accepts two attributes:    href  - The path to the required component file. Paths that start with  ./  or  ../  are resolved relative to the importing component file. Otherwise, resolution is loader-specific.    name  (optional) - The registered name of the component. This corresponds to the key used in the  components  initialization option. When not defined, the filename of the dependency will be used as the name.    The names and the loaded dependency will be assigned to the component's  components  initialization option.", 
            "title": "&lt;link rel=\"ractive\"&gt;"
        }, 
        {
            "location": "/api/component-files/#style", 
            "text": "Top-level  style  elements define the styles for the component. If more than one  style  element is found on the component file, their contents are concatenated in the order of appearance of the  style  elements. Contents of these elements will be concatenated and assigned to the component's  css  initialization option.", 
            "title": "&lt;style&gt;"
        }, 
        {
            "location": "/api/component-files/#script", 
            "text": "A top-level  script  defines the component's initialization. The script's scope has a  component  object that is similar to Node's  module  object. Initialization options for the component is expected via  component.exports . It also has a special  require  function that fetches script dependencies.  require 's behavior depends on the loader used. Refer to the specific loader's documentation to know more.  There can only ever be one  script  in a component file. Defining more than one will result in the loader throwing an error.", 
            "title": "&lt;script&gt;"
        }, 
        {
            "location": "/api/component-files/#template", 
            "text": "After yanking out top-level  link rel=\"ractive\" ,  style  or  script  from the component file, anything that's left becomes a part of the template. The remaining markup will be assigned to the component's  template  initialization option.", 
            "title": "Template"
        }, 
        {
            "location": "/api/component-files/#using", 
            "text": "In order to use component files, you will have to use  loaders , Head over to the  loaders  page to learn more about loaders and help you choose a loader that suits your needs.", 
            "title": "Using"
        }, 
        {
            "location": "/integrations/loaders/", 
            "text": "Loaders\n\n\nBy itself, neither Ractive nor your tools know what to do with a \ncomponent file\n. You will need a \nloader\n to transform a component file into a representation that the target tool or environment can understand.\n\n\nAvailable loaders\n\n\nVanilla\n\n\n\n\nractive-load\n - Uses \nXHR\n to load your component files and creates component constructors at runtime.\n\n\n\n\nRequireJS\n\n\n\n\nrvc\n - Converts component files into \nAMD modules\n. Works with plain and \noptimized\n AMD modules.\n\n\n\n\nBrowserify\n\n\n\n\nractify\n - Converts component files into \nCJS modules\n.\n\n\nractiveify\n - Similar to ractify, but supports JS/CSS compilation.\n\n\nractive-componentify\n - Similar to ractiveify, but supports \nsource maps\n and partial imports.\n\n\n\n\nBroccoli\n\n\n\n\nbroccoli-ractive\n - Converts your component files into either AMD, CJS, or ES modules.\n\n\n\n\nWebpack\n\n\n\n\nractive-component-loader\n - Allows you to load component files as constructors via Webpack.\n\n\n\n\nLooking to write your own loader?\n\n\nHead over to the \ncomponent file specifications\n repo for a full rundown about the parts of a component file as well as loader behaviors and responsibilities.\n\n\nRactive also has a couple of handy modules to aid you in loader development:\n\n\n\n\nrcu\n - An importable/embeddable library that provides utility APIs to help your loader parse the different portions of the component file.\n\n\nrcu-builders\n - A module that provides utility APIs to help your loader convert parsed component files into other module formats like ES, AMD and CJS.", 
            "title": "Loaders"
        }, 
        {
            "location": "/integrations/loaders/#loaders", 
            "text": "By itself, neither Ractive nor your tools know what to do with a  component file . You will need a  loader  to transform a component file into a representation that the target tool or environment can understand.", 
            "title": "Loaders"
        }, 
        {
            "location": "/integrations/loaders/#available-loaders", 
            "text": "", 
            "title": "Available loaders"
        }, 
        {
            "location": "/integrations/loaders/#vanilla", 
            "text": "ractive-load  - Uses  XHR  to load your component files and creates component constructors at runtime.", 
            "title": "Vanilla"
        }, 
        {
            "location": "/integrations/loaders/#requirejs", 
            "text": "rvc  - Converts component files into  AMD modules . Works with plain and  optimized  AMD modules.", 
            "title": "RequireJS"
        }, 
        {
            "location": "/integrations/loaders/#browserify", 
            "text": "ractify  - Converts component files into  CJS modules .  ractiveify  - Similar to ractify, but supports JS/CSS compilation.  ractive-componentify  - Similar to ractiveify, but supports  source maps  and partial imports.", 
            "title": "Browserify"
        }, 
        {
            "location": "/integrations/loaders/#broccoli", 
            "text": "broccoli-ractive  - Converts your component files into either AMD, CJS, or ES modules.", 
            "title": "Broccoli"
        }, 
        {
            "location": "/integrations/loaders/#webpack", 
            "text": "ractive-component-loader  - Allows you to load component files as constructors via Webpack.", 
            "title": "Webpack"
        }, 
        {
            "location": "/integrations/loaders/#looking-to-write-your-own-loader", 
            "text": "Head over to the  component file specifications  repo for a full rundown about the parts of a component file as well as loader behaviors and responsibilities.  Ractive also has a couple of handy modules to aid you in loader development:   rcu  - An importable/embeddable library that provides utility APIs to help your loader parse the different portions of the component file.  rcu-builders  - A module that provides utility APIs to help your loader convert parsed component files into other module formats like ES, AMD and CJS.", 
            "title": "Looking to write your own loader?"
        }, 
        {
            "location": "/integrations/plugins/", 
            "text": "Plugins\n\n\nIt may not be apparent but Ractive is actually built with extreme extensibility in mind. Plugins allow you to augment Ractive with extra functionality. Whether you're a JavaScript developer, an interface designer or just trying to get away from your framework overlords, Ractive can accomodate one and all.\n\n\nAvailable plugins\n\n\nAdaptors\n\n\nInterface with different backends.\n\n\n\n\nBackbone\n\n\nBacon.js\n\n\nModella\n by \n@staygrimm\n\n\nPromises\n by \n@lluchs\n\n\nPromise-alt\n by \n@rstacruz\n\n\nRxJS\n\n\nRactive\n by \n@rstacruz\n - Synchronise several Ractive instances.\n\n\nss-ractive\n by Robert Hall \n@arxpoetica\n - Ractive Template Engine wrapper for \nSocketStream\n.\n\n\n\n\nComponents\n\n\nEncapsulate functionality behind the guise of a custom element.\n\n\n\n\nRactive-Require\n\n\nCodeMirror\n\n\nBootstrap\n\n\nDatatable\n\n\nSelect\n - A \nselect\n replacement component.\n\n\nStepper\n - A numeric stepper component.\n\n\nSplit\n\n\n\n\nDecorators\n\n\nAugment the DOM with more functionality.\n\n\n\n\nChosen\n by \n@rahulcs\n (\n@kalcifer\n)\n\n\nminmaxwidth\n by \n@cfenzo\n\n\nSelect2\n by \n@sandermarechal\n (\n@Prezent\n)\n\n\nSortable\n\n\nTooltip\n\n\n\n\nEasings\n\n\nCustom animation progressions.\n\n\nEvents\n\n\nAugment the DOM with custom events beyond those supported by the browser.\n\n\n\n\nDrag and Drop (HTML5)\n by \n@Nijikokun\n\n\nDrag and Drop (non-HTML5)\n by \n@smallhadroncollider\n\n\nDrag and Drop Sortable List\n by \n@Nijikokun\n\n\nResize\n by \n@smallhadroncollider\n\n\nHover\n\n\nKeys\n\n\nMousewheel\n\n\nTap\n\n\nTouch\n by \n@rstacruz\n\n\nTyping\n by \n@svapreddy\n\n\nViewport\n by \n@svapreddy\n\n\n\n\nPartials\n\n\nReusable pieces of markup.\n\n\nTransitions\n\n\nApply custom animation.\n\n\n\n\nFade\n\n\nFly\n\n\nScale\n by \n@1N50MN14\n\n\nSlide\n\n\nTypewriter\n\n\n\n\nAnd so much more!\n\n\nDue to the nature of how easy it is to write and distribute plugins as well as how diverse the distribution channels are, we cannot possibly know what other Ractive plugins exist in the wild.\n\n\nTo discover more, try searching your favorite package manager, search engine, or code hosting service for the keyword \"ractive\". I guarantee you'll be surprised.\n\n\nNote: Like any other open-source project, these plugins may not have been maintained for a while. Should bugs arise, we highly encourage reporting the issue to relevant parties so that it can be addressed.", 
            "title": "Plugins"
        }, 
        {
            "location": "/integrations/plugins/#plugins", 
            "text": "It may not be apparent but Ractive is actually built with extreme extensibility in mind. Plugins allow you to augment Ractive with extra functionality. Whether you're a JavaScript developer, an interface designer or just trying to get away from your framework overlords, Ractive can accomodate one and all.", 
            "title": "Plugins"
        }, 
        {
            "location": "/integrations/plugins/#available-plugins", 
            "text": "", 
            "title": "Available plugins"
        }, 
        {
            "location": "/integrations/plugins/#adaptors", 
            "text": "Interface with different backends.   Backbone  Bacon.js  Modella  by  @staygrimm  Promises  by  @lluchs  Promise-alt  by  @rstacruz  RxJS  Ractive  by  @rstacruz  - Synchronise several Ractive instances.  ss-ractive  by Robert Hall  @arxpoetica  - Ractive Template Engine wrapper for  SocketStream .", 
            "title": "Adaptors"
        }, 
        {
            "location": "/integrations/plugins/#components", 
            "text": "Encapsulate functionality behind the guise of a custom element.   Ractive-Require  CodeMirror  Bootstrap  Datatable  Select  - A  select  replacement component.  Stepper  - A numeric stepper component.  Split", 
            "title": "Components"
        }, 
        {
            "location": "/integrations/plugins/#decorators", 
            "text": "Augment the DOM with more functionality.   Chosen  by  @rahulcs  ( @kalcifer )  minmaxwidth  by  @cfenzo  Select2  by  @sandermarechal  ( @Prezent )  Sortable  Tooltip", 
            "title": "Decorators"
        }, 
        {
            "location": "/integrations/plugins/#easings", 
            "text": "Custom animation progressions.", 
            "title": "Easings"
        }, 
        {
            "location": "/integrations/plugins/#events", 
            "text": "Augment the DOM with custom events beyond those supported by the browser.   Drag and Drop (HTML5)  by  @Nijikokun  Drag and Drop (non-HTML5)  by  @smallhadroncollider  Drag and Drop Sortable List  by  @Nijikokun  Resize  by  @smallhadroncollider  Hover  Keys  Mousewheel  Tap  Touch  by  @rstacruz  Typing  by  @svapreddy  Viewport  by  @svapreddy", 
            "title": "Events"
        }, 
        {
            "location": "/integrations/plugins/#partials", 
            "text": "Reusable pieces of markup.", 
            "title": "Partials"
        }, 
        {
            "location": "/integrations/plugins/#transitions", 
            "text": "Apply custom animation.   Fade  Fly  Scale  by  @1N50MN14  Slide  Typewriter", 
            "title": "Transitions"
        }, 
        {
            "location": "/integrations/plugins/#and-so-much-more", 
            "text": "Due to the nature of how easy it is to write and distribute plugins as well as how diverse the distribution channels are, we cannot possibly know what other Ractive plugins exist in the wild.  To discover more, try searching your favorite package manager, search engine, or code hosting service for the keyword \"ractive\". I guarantee you'll be surprised.  Note: Like any other open-source project, these plugins may not have been maintained for a while. Should bugs arise, we highly encourage reporting the issue to relevant parties so that it can be addressed.", 
            "title": "And so much more!"
        }, 
        {
            "location": "/integrations/tools/", 
            "text": "Tools\n\n\nBrowserify\n\n\nBrowserify\n is a way of using \nnode-style\n requires in the browser, bundling your scripts into a single file for efficient deployment.\n\n\nThere are three Browserify transforms available that you can use for Ractive.js:\n\n\n\n\nRactivate\n, a transform that will pre-parse templates. Contributed by \njrajav\n. \n(Github repository)\n\n\nRactify\n, a transform that will pre-compile components. Contributed by \nmarcello3d\n. \n(Github repository)\n\n\nRactiveify\n, a transform that will pre-compile components with support for compiling embedded scripts and style tags (with Livescript, CoffeeScript, Sass, etc). Inspired by ractify. Contributed by \nnorcalli\n. \n(Github repository)\n\n\n\n\nA \nstarter project\n is available for using Ractivate with \ngulp.js\n build system.\n\n\nUsing plugins with Ractive and Browserify\n\n\nPlugins\n typically include a Universal Module Definition (UMD) block that, in a node.js or Browserify environment, calls \nrequire('ractive')\n. If you want to be explicit about \nwhich\n version of Ractive gets loaded, you can do it when you configure browserify like so:\n\n\nbrowserify.require('./my-copy-of-ractive.js', { expose: 'ractive' });\n\n\n\n\nRequireJS\n\n\nPsst! Looking for the \nRactive + RequireJS sample application\n?\n\n\nIf Ractive detects that you're using an \nAMD\n module loader (in other words, if \ntypeof define !== 'undefined' \n define.amd\n) such as \nRequireJS\n, it will register itself as an AMD module rather than as a browser global.\n\n\nYou'd then use Ractive the same as you'd use any other module, such as in this (contrived, oversimple) example:\n\n\n// define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'jquery', 'Ractive' ], function ( $, Ractive ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // load our template with jQuery AJAX\n      $.ajax( 'templates/main.html' ).then( function ( mainTemplate ) {\n\n        // render our main view\n        this.mainView = new Ractive({\n          el: 'container',\n          template: mainTemplate\n        });\n      });\n    }\n  };\n\n  return app;\n\n});\n\n\n\n\nLoading templates without AJAX\n\n\nWe can do one better than that. Rather than stuffing our code full of asynchronous logic, we can use AMD to do the donkey work for us.\n\n\nInclude the \nRequireJS text loader plugin\n in the root of your project (or whatever you've specified as the RequireJS \nbaseUrl\n) - you can now do this (note we no longer require jQuery):\n\n\n// define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'text!templates/main.html' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});\n\n\n\n\nBut we can do even better. If you use the \nRactive RequireJS loader plugin\n, it will pre-parse the template for us. We'll see in a moment why that's useful.\n\n\nPut the plugin in the same folder as the text loader plugin (which the Ractive plugin depends on). Note that we can omit the \n'.html'\n file extension:\n\n\n// define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'rv!templates/main' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});\n\n\n\n\nUsing the RequireJS optimiser\n\n\nYou might wonder why the third example is better than the second - after all, we've basically just added another middleman, right?\n\n\nThe answer is that you can now use the \nRequireJS optimiser\n to parse your template as part of your build process. The optimiser converts your project into a single minified file, which in most cases makes your app much quicker to load for the end user (because the browser only needs to make one HTTP request, and the total file size is reduced).\n\n\nBy pre-parsing templates, we save browsers having to do it, which shaves a few milliseconds off at render time.\n\n\nSo you get the best of both worlds - your templates stay neatly organised in their own files, where you can easily edit them, and the user gets the best possible experience.\n\n\nIf you're \nreally\n anal about performance, you can tweak things further still. We don't need the loader plugins any more (because everything has been inlined), but they're still there in our optimised file. We can instruct the optimiser to 'stub them out', saving ourselves a few precious bytes. In your optimiser config, add the following option:\n\n\n({\n    stubModules: [ 'rv', 'text' ]\n})\n\n\n\n\n(This assumes you're using a \nbuild.js\n file, or a build system like Grunt. If you're using the optimiser on the command line it will be different - consult the \ndocumentation\n for more info.)\n\n\nGetting to grips with AMD and RequireJS can be tricky at first, but it's worth the effort. Good luck!\n\n\nYeoman\n\n\nYeoman\n is a tool for scaffolding webapps. \nJorge Colindres\n has created \ngenerator-ractive\n, a Yeoman generator to quickly set up a Ractive application.\n\n\nRollup\n\n\nTODO\n\n\nBabel\n\n\nTODO", 
            "title": "Tools"
        }, 
        {
            "location": "/integrations/tools/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/integrations/tools/#browserify", 
            "text": "Browserify  is a way of using  node-style  requires in the browser, bundling your scripts into a single file for efficient deployment.  There are three Browserify transforms available that you can use for Ractive.js:   Ractivate , a transform that will pre-parse templates. Contributed by  jrajav .  (Github repository)  Ractify , a transform that will pre-compile components. Contributed by  marcello3d .  (Github repository)  Ractiveify , a transform that will pre-compile components with support for compiling embedded scripts and style tags (with Livescript, CoffeeScript, Sass, etc). Inspired by ractify. Contributed by  norcalli .  (Github repository)   A  starter project  is available for using Ractivate with  gulp.js  build system.", 
            "title": "Browserify"
        }, 
        {
            "location": "/integrations/tools/#using-plugins-with-ractive-and-browserify", 
            "text": "Plugins  typically include a Universal Module Definition (UMD) block that, in a node.js or Browserify environment, calls  require('ractive') . If you want to be explicit about  which  version of Ractive gets loaded, you can do it when you configure browserify like so:  browserify.require('./my-copy-of-ractive.js', { expose: 'ractive' });", 
            "title": "Using plugins with Ractive and Browserify"
        }, 
        {
            "location": "/integrations/tools/#requirejs", 
            "text": "Psst! Looking for the  Ractive + RequireJS sample application ?  If Ractive detects that you're using an  AMD  module loader (in other words, if  typeof define !== 'undefined'   define.amd ) such as  RequireJS , it will register itself as an AMD module rather than as a browser global.  You'd then use Ractive the same as you'd use any other module, such as in this (contrived, oversimple) example:  // define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'jquery', 'Ractive' ], function ( $, Ractive ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // load our template with jQuery AJAX\n      $.ajax( 'templates/main.html' ).then( function ( mainTemplate ) {\n\n        // render our main view\n        this.mainView = new Ractive({\n          el: 'container',\n          template: mainTemplate\n        });\n      });\n    }\n  };\n\n  return app;\n\n});", 
            "title": "RequireJS"
        }, 
        {
            "location": "/integrations/tools/#loading-templates-without-ajax", 
            "text": "We can do one better than that. Rather than stuffing our code full of asynchronous logic, we can use AMD to do the donkey work for us.  Include the  RequireJS text loader plugin  in the root of your project (or whatever you've specified as the RequireJS  baseUrl ) - you can now do this (note we no longer require jQuery):  // define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'text!templates/main.html' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});  But we can do even better. If you use the  Ractive RequireJS loader plugin , it will pre-parse the template for us. We'll see in a moment why that's useful.  Put the plugin in the same folder as the text loader plugin (which the Ractive plugin depends on). Note that we can omit the  '.html'  file extension:  // define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'rv!templates/main' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});", 
            "title": "Loading templates without AJAX"
        }, 
        {
            "location": "/integrations/tools/#using-the-requirejs-optimiser", 
            "text": "You might wonder why the third example is better than the second - after all, we've basically just added another middleman, right?  The answer is that you can now use the  RequireJS optimiser  to parse your template as part of your build process. The optimiser converts your project into a single minified file, which in most cases makes your app much quicker to load for the end user (because the browser only needs to make one HTTP request, and the total file size is reduced).  By pre-parsing templates, we save browsers having to do it, which shaves a few milliseconds off at render time.  So you get the best of both worlds - your templates stay neatly organised in their own files, where you can easily edit them, and the user gets the best possible experience.  If you're  really  anal about performance, you can tweak things further still. We don't need the loader plugins any more (because everything has been inlined), but they're still there in our optimised file. We can instruct the optimiser to 'stub them out', saving ourselves a few precious bytes. In your optimiser config, add the following option:  ({\n    stubModules: [ 'rv', 'text' ]\n})  (This assumes you're using a  build.js  file, or a build system like Grunt. If you're using the optimiser on the command line it will be different - consult the  documentation  for more info.)  Getting to grips with AMD and RequireJS can be tricky at first, but it's worth the effort. Good luck!", 
            "title": "Using the RequireJS optimiser"
        }, 
        {
            "location": "/integrations/tools/#yeoman", 
            "text": "Yeoman  is a tool for scaffolding webapps.  Jorge Colindres  has created  generator-ractive , a Yeoman generator to quickly set up a Ractive application.", 
            "title": "Yeoman"
        }, 
        {
            "location": "/integrations/tools/#rollup", 
            "text": "TODO", 
            "title": "Rollup"
        }, 
        {
            "location": "/integrations/tools/#babel", 
            "text": "TODO", 
            "title": "Babel"
        }, 
        {
            "location": "/integrations/libraries/", 
            "text": "Libraries\n\n\nWe heard that you love your framework so much, we put Ractive in your framework!\n\n\njQuery Mobile\n\n\nSergio Castillo\n has made a jQuery mobile plugin, which you can \nsee in action on this JSFiddle\n.", 
            "title": "Libraries"
        }, 
        {
            "location": "/integrations/libraries/#libraries", 
            "text": "We heard that you love your framework so much, we put Ractive in your framework!", 
            "title": "Libraries"
        }, 
        {
            "location": "/integrations/libraries/#jquery-mobile", 
            "text": "Sergio Castillo  has made a jQuery mobile plugin, which you can  see in action on this JSFiddle .", 
            "title": "jQuery Mobile"
        }, 
        {
            "location": "/concepts/architecture/", 
            "text": "Ractive General Overview\n\n\nThere are three major sections in the Ractive source code: The parser which handles template parsing, the models which handle data management and the views which handle the virtual DOM. This document aims to give a breakdown of just what exactly each of these sections do.\n\n\nParser\n\n\nRactive's parser is reponsible for taking in Mustache-like/Handlebar-like templates. Unlike Mustache and Handlebars, however, it turns them into an \nAST\n for use by the runtime. In addition, it also supports a fair amount of ES syntax for use in expressions.\n\n\nEach item expressable in Ractive-flavored mustache has its own parsing function that may also be comprised of other parsing functions. Each bit of ES syntax that Ractive understands for expressions also has its own parsing function. The parser starts at the beginning of the template string and starts applying each parsing function in precedence order. Each function will then consume as much of the template as needed to return an item, like an element, a section, a partial, a bit of text, or an interpolator. It may also return nothing. Most items can also contain children, including items of the same type as themselves, and will thus recurse by trying to parse their content.\n\n\nMustaches\n\n\nEach type of mustache has its own reader that calls the appropriate expression or reference readers internally. For instance, the partial reader reads the current open mustache delimiter (defaults to \n{{\n) followed by a \n. It then expects to find a relaxed reference, meaning it may contain dashes and slashes among other usually-forbidden characters. It may then optionally read a context expression or series of alias definitions\n\n\nExpressions\n\n\nThe expression readers are set arranged such that they can read valid ES expressions with the correct operator precedence by starting with ternary conditionals and trying different expression types from there. Once the expression tree has been parsed, it is flattened into an expression string and a list of references that are used within that string. If the parsing is done with \ncsp\n (Content Security Policy) support enabled, then the expression strings are also turned into functions and attached to the output template structure so that the template can be used as-is from a script tag without \neval\ning.\n\n\nCleanup\n\n\nAfter all of the nodes have been parsed from the template, the template is cleaned up in a process that, among other things, merges adjacent text nodes and forms individual conditional sections out of \nelseif\n/\nelse\n trees.\n\n\nModels\n\n\nRactive wraps any data given to it into a tree-like hierarchy of \nModel\n. Any data that is rendered into a template will be bound to a \nModel\n. Access to read and write data in Ractive is handled through the model hierarchy based on keypaths, which are, generally, a list of object properties that one would need to follow to reach a leaf of the data tree starting from the root. Each key along the keypath has its own corresponding model.\n\n\nModels allow entities that depend upon them to register themeselves to receive change notifications when the model value changes. This is how Ractive keeps track of exactly which parts of the view need to be updated when values change.\n\n\nAll of the data managed by Ractive is represented by its model hierarchy.\n\n\nAlmost every type of Model is a subclass of \nModel\n, so it seems a good place to start. Each model typically has a parent model, a key that is used to access its value from its parent, and a value. Most models also have children of some sort, which are tracked by key such that \n{ foo: { bar: 'baz' } }\n would have a model with a \nchildByKey['foo']\n, which would also have a model at \nchildByKey['bar']\n. The value of each of the models listed there would be the object containing \nfoo: { bar:\nbaz\n}\n, its \nfoo\n child would be the object \nbar: 'baz'\n, and its \nbar\n child would be the string \n'baz'\n. Where children of a model are other models, dependents (\ndeps\n) of a model may be anything that wants to be notified of changes, and each model will typically have a number of dependents, too.\n\n\nEach model has a unique keypath that is assembled by taking its key and each of its parents keys up to the root and joining them with a \n.\n.\n\n\nModels are also inherently lazy, meaning their value is not necessarily available when the are created. A value is retrieved from a model using its \nget\n method which may have the side effect of computing the value. Once a value has been computed, it is generally cached until a change happens that would cause the cache to be invalidated. In most models, there isn't really an opportunity for that change outside of normal change propagation.\n\n\nRootModel\n\n\nEvery tree needs a root, and \nRootModel\n serves that purpose here. Each Ractive instance gets its own \nRootModel\n that is stored at its \nviewmodel\n property. This special model is also the storage point for computations and mappings.\n\n\nKeyModel\n\n\nThe last major model remaining is the \nKeyModel\n. Instances of this represent indices of arrays and keys of objects during iteration. The key flavor never is immutable, becuase the keys of  objects never change (they may be removed, but that doesn't change the key itself). The index flavor \ndoes\n change, but only when the array represented by its parent model is shuffled.\n\n\nOther models\n\n\nThere are a few other types of \nModel\n in the code, such as the \nRactiveModel\n, which represents a Ractive instance, and the \nGlobalModel\n, which represents the global object of the current environment a.k.a. \nwindow\n for browsers and \nglobal\n for Node.js.\n\n\nModel operations\n\n\nChange propagation\n\n\nWhen a change is supplied to a model, its \nset\n method is called, which usually delegates to \napplyValue\n. \napplyValue\n checks to see that the value has actually changed in some way (hint: setting to the same object or array is considered a change because something may have changed further in), and if it has, it will start change notification for all of the model's children and dependents. If the model has resolvers registered with it trying to get an unresolved value, then this is where the unresolved value will be resolved and the resolver satisfied and cleared. Next, any children will be notified that their parent has had a value change and that they may need to update accordingly, which may trigger further cascades of resolution and change notification. Next, any dependents of the model will be notified that the model has had a value change as their \nhandleChange\n methods are called. Finally, upstream models (parents) are notified that a change has taken place somewhere among its children.\n\n\nThe child notification of the propagation is handled by the model's \nmark\n method. \nmark\n also checks to see that the value has actually changed, and if it has, will notify its children and dependents that it has had a value change. This is also the method called when the user signals that they have changed some data externally by calling \nractive.update()\n.\n\n\nShuffling\n\n\nThere is a special form of change wherein an array is modified without being swapped out, which is triggered by array methods like \nsplice\n, \npush\n, and \npop\n. When an array modification happens, change propagation takes a special path through the model that allows more precise DOM manipulation rather than throwing all of the DOM out and replacing it with a new result. This is achieved by having the special array method handlers compute which indexes are actually changed and having the array model's deps that can actally handle a shuffle ignore any untouched indices.\n\n\nThe instance method \nmerge\n does something similar, but instead of modifying the underlying array, it compares the members of the new supplied array against the model array to compute the index changes. It the swaps in the new array and triggers a shuffle based on the computed index changes.\n\n\nAdaptation\n\n\nBetween the change check and the change propagation during \napplyValue\n, there is a step that handles part of adaptation so that external objects with special behaviors, like backbone models, can be used as data sources. An adaptors takes the special object, wraps it up, and returns the wrapper that also has a value that represents the object for consumption by Ractive. Most adaptors also have methods to update values in their source data as well, and those methods are called when an update is applied to an adapted model.\n\n\nComputations\n\n\nA computation is exactly what is sounds like: a getter and optional setter function that are used to provide read and optional write access to some non-fixed piece of data. Each computation is stored in the root model \ncomputations\n hash by its keypath. Computations can be created in two places:\n\n\n\n\nExplicitly when a \ncomputed\n map is passed to a Ractive instantiation or when an entry is later added to a instance's computed map. These may be read/write and have a keypath that mirrors their name.\n\n\nImplicitly when an expression is used in a template. These are read-only and have a keypath that is an expanded representation of their expression.\n\n\n\n\nA computation is also a form of model, so anything that depends on it will subscribe to it as if it were a regular model. Change propagation happens in the same way as a regular model as well.\n\n\nSince computations may depend on other bits of data controlled by Ractive, while they are being retrieved, any references to other models will cause the extra references to be \ncapture\nd. When the computation is complete, the computation will register with each of its captured dependencies so that it will be notified when it needs to invalidate and notify its dependents of the change.\n\n\nMappings\n\n\nWhen a Ractive instance has children, typically components, it may supply a handles to its own data to them in the form of mappings. The child instance stores a reference to the parent model at its mapped name and uses it when its dependents request access to keypaths that start with the mapped name. This allows child instances, which may be isolated, to stay in sync with portions of their parents data easily, because the parent still controls the data (single source of truth) and there is no syncing involved. So if a parent has a component \nComponent foo=\"{{bar.baz.bat.bippy}}\" /\n, then the component instance will get a mapping \nfoo\n that references the parent model at \nbar.baz.bat.bippy\n.\n\n\nVirtual DOM\n\n\nEvery piece of DOM that Ractive can manage has a corresponding class in the virtual DOM to handle the DOM node, which generally end up being either Elements or Text Nodes. View items are grouped together as Fragments of view, which may then be owned by other fragments or items. At the root of every ractive instance is a Fragment instance that contains its entire virtual DOM tree. Each Ractive template construct has at least one analog in the virtual DOM. The bulk of Ractive's view functionality is implemented in the Section, Interpolator, and Element items, with there being a number of specialized element classes to handle special types of HTML element.\n\n\nAll virtual DOM items go through roughly the same lifecycle: creation, binding, rendering, bubbling, updating, unrendering, and unbinding. Creation is basically just the constructor call and almost always is immediately followed by binding. Binding is the point at which the item resolves and registers with its data references. Rendering is the point at which the item inserts an actual DOM node into the DOM. Bubbling and updating are the two halves of the update process, which is discussed in the next section. Unrendering is the point at which the item should no longer be present in the DOM, and it often occurs at the same point as unbinding, which is the point at which the item unregisters with the viewmodel and is effectively destroyed.\n\n\nThere a number of other members, such as events and decorators, and processes, such as change propagation, which are described in detail in the \nview overview\n.\n\n\nRactive views are structured virtual DOM trees that are assembled from template AST and manage DOM nodes on the page when they are rendered. Virtual DOM items are grouped together in \nFragment\ns, which contain them, and they may also own \nFragment\ns that contain other items. Each item may contain a reference to a DOM node when rendered, though every item doesn not have a DOM analog.\n\n\nStates\n\n\nItems generally follow a fixed lifecycle.\n\n\n\n\nConstruction - the item is created and knows about its parent and the template chunk from which it was created. Its template may also indicate what its children should look like if it has them.\n\n\nbind\n - the item looks up any references is may have and registers with the model(s) that they represent. At this point, the item may create child items and bind them as well.\n\n\nrender\n - the item may create an actual DOM node and tell its children to create their DOM nodes as necessary. The resulting nodes will be inserted into the document.\n\n\nunrender\n - thie item is no longer needed and will be removed from the document immediately or in the near future.\n\n\nunbind\n - this typically goes along with \nunrender\n and tells the models on which this item depends that they should no longer send change notifications to it.\n\n\n\n\nThere is a sixth floating step \nrebind\n that happens any time one dependency models shuffles (and in certain other very special circumstances) that causes the items to re-resolve their models and re-register if necessary.\n\n\nVirtual DOM Items\n\n\nText\n\n\nText is the simplest item. It simply holds a string that it turns into a \nTextNode\n when rendered.\n\n\nInterpolator\n\n\nThis is the next simplest item. It resolves a model for its reference or expression and renders the value of the model as a text node if needed. Interpolators don't necessarily render directly, as they may be used for values by other items, such as attributes, mappings, and bindings.\n\n\nElement\n\n\nAn \nElement\n represents a DOM element. It also contains a number of other items in the form of \nAttribute\ns, \nDecorator\ns, \nTransition\ns, \nEventDirective\ns, and its children in a \nFragment\n.\n\n\nAttributes\n\n\nThere are actually several different items that are treated as attributes for \nElement\ns, event though only two of them actually may render into the DOM.\n\n\n\n\nAttribute\ns - maybe obvious, they these represent a DOM attribute on their parent element. There are a number of different handlers for updating attributes depending on the element and attribute name. The \nupdateDelegate\n for a particular attribute can be found in \ngetUpdateDelegate.js\n.\n\n\nConditionalAttribute\ns - render as a string and are parsed into actual DOM attributes using a \ndiv\n or an \nsvg\n depending on their parent element.\n\n\nMapping\ns - when rendered add a mapping to their component, and when unrendered, remove it. These aren't attached to \nElement\ns, but instead, are attached to \nComponent\ns (see below).\n\n\nEventDirective\ns - when rendered attach an event listener to their parent, and when unrenedered, remove it. Event parameters are kept in sync with their bindings and are evaluated when the event fires.\n\n\nBindingDirective\ns - when rendered and unrendered update their parent element's bindings, if they exist.\n\n\nDecorator\ns - when rendered call the named decorator with their parent element, and when unrenedered, remove it. \nDecorator\ns also have an update cycle related to their parameters.\n\n\nTransition\ns - are a sort of weird case. When rendered, they attach a transition handler to their element, and when the element renders or unrenders, if an appropriate transition handler is registered, will trigger the transition. Transition parameters are also kept in sync with their bindings.\n\n\n\n\nBindings\n\n\nCertain attributes may also trigger a binding to be created on their parent element. For instance, if two-way binding is enabled on the parent element, and the parent element is an \ninput\n, a \nvalue\n attribute with a single \nInterpolator\n as its content will cause a two-way binding to be created between the value of the \ninput\n and the model of the \nInterpolator\n. This binding will handle updating the model when the input \nvalue\n has changed. There are a few other types of bindings for managing check values, content editables, name-bound lists of checkboxes, and other miscellaneous special values.\n\n\nA \nlazy\n binding directive will cause any associated two-way bindings to fire either after a timeout or on blur, depending on the value of the \nlazy\n directive.\n\n\nSection\n\n\nSection\ns come in many flavors, depending on the chunk of template from which they are created. A section may provide context, be conditional (positive or negative), or be iterative. Generic sections (\n{{#something}}...{{/}}\n in template) will adjust their type, to a certain extent, based on the value of their model. A generic section will always provide context in the form of their model. An \nif\n-style conditional section, including \nelseif\n, \nelse\n, and \nunless\n do not provide context. An \neach\n section will always provide context in the form of the current iteration. A \nwith\n section will always provide context as its model, but it will only render if its model is considered truthy by Ractive, which is pretty much the same as JS truthy except \n{}\n and \n[]\n are falsey. A generic section will be context/conditional if it is anything other than an array, which will make it iterative.\n\n\nSections that provide context do so by binding their \nFragment\ns with their model so that the reference resolution process can find the appropriate contexts when resolving.\n\n\nContext/Conditional\n\n\nContext and conditional sections will render and unrender their child fragment as their model changes truthiness. Conditional sections always stand alone, even it they have \nelseif\n or \nelse\n branches nested within them, because those branches are turned into independent sections during parsing.\n\n\nIterative\n\n\nIf section is designated iterative (\n{{#each ...}}\n) or is a general section with an array value resolution, the section will create a special form of fragment for each index or key in the value. The special form \nRepeatedFragment\n handles mapping of indices, keys, and references to those to a corresponding model. Iterative sections also have special handling for shuffles so that DOM is not wholesale destroyed and recreated when the array shuffles.\n\n\nIterative sections may supply an alias for their context, so that referencing the iterated value is a little bit easier. See \nAliases\n below for more info, as this is just a slightly specialized form of that.\n\n\nIterative sections may also supply key and/or index aliases so that their keys and/or indices may be referenced by a name from within their child fragments.\n\n\nAlias\n\n\nAlias sections simply resolve their models and act as a lookup endpoint for reference resolution. Aliasing happens entirely in the view.\n\n\nComponent\n\n\nA component is a sort-of special form of \nElement\n that, instead of creating a DOM element, creates a new Ractive instance. The child instance will be rendered and unrendered in place of the component placeholder in the DOM.\n\n\nAny plain \nAttribute\ns with a single \nInterpolator\n as content in a component's template are turned into \nMapping\ns.\n\n\nResolution\n\n\nThe resolution process for references requires a keypath and a \nFragment\n as a starting point.\n\n\n\n\nIf the reference is a special reference (\n@index\n, \n@this\n, etc), the appropriate model is looked up and returned.\n\n\nIf the reference is relative (starts with \n~/\n, \n.\n, or \n../\n) the appropriate base model is retrieved and the rest of the keypath is joined onto it and the resulting model is returned.\n\n\nIf the reference is non-relative and the base of the keypath is a member of the current context, then the context is joined to the keypath and the resulting model is returned.\n\n\nThe reference is ambiguous, so the following loop until resolution or no fragments are left, starting with the given fragment:\n\n\nIf the fragment is an iteration, check to see if there is an index or key alias that matches the root of the reference, and if so, return it.\n\n\nIf the fragment has aliases, check to see if there is one that matches the root of the reference, and if so, return it.\n\n\nIf the fragment has context:\n\n\nIf the fragment is the root of an instance, note it\n\n\nIf the context has a child matching the root of the reference:\n\n\nIf we crossed a component boundary, create an implicit mapping the to the newly discovered model in the current component.\n\n\nReturn it\n\n\n\n\n\n\nIf the fragment belongs to a component, use the component's parent fragment and loop.\n\n\nUse the fragment's parent and loop.\n\n\n\n\nThe resolution process no longer happens strictly within the vDOM, as the result of \nRactive.getContext\n also uses the target \nElement\n's fragment to resolve relative references. Event objects are also extended with methods from the same helper.\n\n\nUpdates\n\n\nThe \nrunloop\n controls when the DOM is actually updated and when transitions start in \nbatch\nes. It also handles resolving promises when transitions have completed and the DOM is completely up to date.\n\n\nAs changes propagate through the viewmodel, view items are notified of the change through their \nhandleChange\n method. Most items just set a dirty flag and notify their parent, via their \nbubble\n method, that they will need to be updated at the completion of the runloop turn. The root fragment of each instance affected will then register with the runloop. Once the changes are ready to be flushed to the view, each fragment registered with the runloop is called on to update, where the process happens in reverse, with each parent fragment checking to see if there is a change it needs to respond to and propagating the update downward to its children.", 
            "title": "Architecture"
        }, 
        {
            "location": "/concepts/architecture/#ractive-general-overview", 
            "text": "There are three major sections in the Ractive source code: The parser which handles template parsing, the models which handle data management and the views which handle the virtual DOM. This document aims to give a breakdown of just what exactly each of these sections do.", 
            "title": "Ractive General Overview"
        }, 
        {
            "location": "/concepts/architecture/#parser", 
            "text": "Ractive's parser is reponsible for taking in Mustache-like/Handlebar-like templates. Unlike Mustache and Handlebars, however, it turns them into an  AST  for use by the runtime. In addition, it also supports a fair amount of ES syntax for use in expressions.  Each item expressable in Ractive-flavored mustache has its own parsing function that may also be comprised of other parsing functions. Each bit of ES syntax that Ractive understands for expressions also has its own parsing function. The parser starts at the beginning of the template string and starts applying each parsing function in precedence order. Each function will then consume as much of the template as needed to return an item, like an element, a section, a partial, a bit of text, or an interpolator. It may also return nothing. Most items can also contain children, including items of the same type as themselves, and will thus recurse by trying to parse their content.", 
            "title": "Parser"
        }, 
        {
            "location": "/concepts/architecture/#mustaches", 
            "text": "Each type of mustache has its own reader that calls the appropriate expression or reference readers internally. For instance, the partial reader reads the current open mustache delimiter (defaults to  {{ ) followed by a  . It then expects to find a relaxed reference, meaning it may contain dashes and slashes among other usually-forbidden characters. It may then optionally read a context expression or series of alias definitions", 
            "title": "Mustaches"
        }, 
        {
            "location": "/concepts/architecture/#expressions", 
            "text": "The expression readers are set arranged such that they can read valid ES expressions with the correct operator precedence by starting with ternary conditionals and trying different expression types from there. Once the expression tree has been parsed, it is flattened into an expression string and a list of references that are used within that string. If the parsing is done with  csp  (Content Security Policy) support enabled, then the expression strings are also turned into functions and attached to the output template structure so that the template can be used as-is from a script tag without  eval ing.", 
            "title": "Expressions"
        }, 
        {
            "location": "/concepts/architecture/#cleanup", 
            "text": "After all of the nodes have been parsed from the template, the template is cleaned up in a process that, among other things, merges adjacent text nodes and forms individual conditional sections out of  elseif / else  trees.", 
            "title": "Cleanup"
        }, 
        {
            "location": "/concepts/architecture/#models", 
            "text": "Ractive wraps any data given to it into a tree-like hierarchy of  Model . Any data that is rendered into a template will be bound to a  Model . Access to read and write data in Ractive is handled through the model hierarchy based on keypaths, which are, generally, a list of object properties that one would need to follow to reach a leaf of the data tree starting from the root. Each key along the keypath has its own corresponding model.  Models allow entities that depend upon them to register themeselves to receive change notifications when the model value changes. This is how Ractive keeps track of exactly which parts of the view need to be updated when values change.  All of the data managed by Ractive is represented by its model hierarchy.  Almost every type of Model is a subclass of  Model , so it seems a good place to start. Each model typically has a parent model, a key that is used to access its value from its parent, and a value. Most models also have children of some sort, which are tracked by key such that  { foo: { bar: 'baz' } }  would have a model with a  childByKey['foo'] , which would also have a model at  childByKey['bar'] . The value of each of the models listed there would be the object containing  foo: { bar: baz } , its  foo  child would be the object  bar: 'baz' , and its  bar  child would be the string  'baz' . Where children of a model are other models, dependents ( deps ) of a model may be anything that wants to be notified of changes, and each model will typically have a number of dependents, too.  Each model has a unique keypath that is assembled by taking its key and each of its parents keys up to the root and joining them with a  . .  Models are also inherently lazy, meaning their value is not necessarily available when the are created. A value is retrieved from a model using its  get  method which may have the side effect of computing the value. Once a value has been computed, it is generally cached until a change happens that would cause the cache to be invalidated. In most models, there isn't really an opportunity for that change outside of normal change propagation.", 
            "title": "Models"
        }, 
        {
            "location": "/concepts/architecture/#rootmodel", 
            "text": "Every tree needs a root, and  RootModel  serves that purpose here. Each Ractive instance gets its own  RootModel  that is stored at its  viewmodel  property. This special model is also the storage point for computations and mappings.", 
            "title": "RootModel"
        }, 
        {
            "location": "/concepts/architecture/#keymodel", 
            "text": "The last major model remaining is the  KeyModel . Instances of this represent indices of arrays and keys of objects during iteration. The key flavor never is immutable, becuase the keys of  objects never change (they may be removed, but that doesn't change the key itself). The index flavor  does  change, but only when the array represented by its parent model is shuffled.", 
            "title": "KeyModel"
        }, 
        {
            "location": "/concepts/architecture/#other-models", 
            "text": "There are a few other types of  Model  in the code, such as the  RactiveModel , which represents a Ractive instance, and the  GlobalModel , which represents the global object of the current environment a.k.a.  window  for browsers and  global  for Node.js.", 
            "title": "Other models"
        }, 
        {
            "location": "/concepts/architecture/#model-operations", 
            "text": "", 
            "title": "Model operations"
        }, 
        {
            "location": "/concepts/architecture/#change-propagation", 
            "text": "When a change is supplied to a model, its  set  method is called, which usually delegates to  applyValue .  applyValue  checks to see that the value has actually changed in some way (hint: setting to the same object or array is considered a change because something may have changed further in), and if it has, it will start change notification for all of the model's children and dependents. If the model has resolvers registered with it trying to get an unresolved value, then this is where the unresolved value will be resolved and the resolver satisfied and cleared. Next, any children will be notified that their parent has had a value change and that they may need to update accordingly, which may trigger further cascades of resolution and change notification. Next, any dependents of the model will be notified that the model has had a value change as their  handleChange  methods are called. Finally, upstream models (parents) are notified that a change has taken place somewhere among its children.  The child notification of the propagation is handled by the model's  mark  method.  mark  also checks to see that the value has actually changed, and if it has, will notify its children and dependents that it has had a value change. This is also the method called when the user signals that they have changed some data externally by calling  ractive.update() .", 
            "title": "Change propagation"
        }, 
        {
            "location": "/concepts/architecture/#shuffling", 
            "text": "There is a special form of change wherein an array is modified without being swapped out, which is triggered by array methods like  splice ,  push , and  pop . When an array modification happens, change propagation takes a special path through the model that allows more precise DOM manipulation rather than throwing all of the DOM out and replacing it with a new result. This is achieved by having the special array method handlers compute which indexes are actually changed and having the array model's deps that can actally handle a shuffle ignore any untouched indices.  The instance method  merge  does something similar, but instead of modifying the underlying array, it compares the members of the new supplied array against the model array to compute the index changes. It the swaps in the new array and triggers a shuffle based on the computed index changes.", 
            "title": "Shuffling"
        }, 
        {
            "location": "/concepts/architecture/#adaptation", 
            "text": "Between the change check and the change propagation during  applyValue , there is a step that handles part of adaptation so that external objects with special behaviors, like backbone models, can be used as data sources. An adaptors takes the special object, wraps it up, and returns the wrapper that also has a value that represents the object for consumption by Ractive. Most adaptors also have methods to update values in their source data as well, and those methods are called when an update is applied to an adapted model.", 
            "title": "Adaptation"
        }, 
        {
            "location": "/concepts/architecture/#computations", 
            "text": "A computation is exactly what is sounds like: a getter and optional setter function that are used to provide read and optional write access to some non-fixed piece of data. Each computation is stored in the root model  computations  hash by its keypath. Computations can be created in two places:   Explicitly when a  computed  map is passed to a Ractive instantiation or when an entry is later added to a instance's computed map. These may be read/write and have a keypath that mirrors their name.  Implicitly when an expression is used in a template. These are read-only and have a keypath that is an expanded representation of their expression.   A computation is also a form of model, so anything that depends on it will subscribe to it as if it were a regular model. Change propagation happens in the same way as a regular model as well.  Since computations may depend on other bits of data controlled by Ractive, while they are being retrieved, any references to other models will cause the extra references to be  capture d. When the computation is complete, the computation will register with each of its captured dependencies so that it will be notified when it needs to invalidate and notify its dependents of the change.", 
            "title": "Computations"
        }, 
        {
            "location": "/concepts/architecture/#mappings", 
            "text": "When a Ractive instance has children, typically components, it may supply a handles to its own data to them in the form of mappings. The child instance stores a reference to the parent model at its mapped name and uses it when its dependents request access to keypaths that start with the mapped name. This allows child instances, which may be isolated, to stay in sync with portions of their parents data easily, because the parent still controls the data (single source of truth) and there is no syncing involved. So if a parent has a component  Component foo=\"{{bar.baz.bat.bippy}}\" / , then the component instance will get a mapping  foo  that references the parent model at  bar.baz.bat.bippy .", 
            "title": "Mappings"
        }, 
        {
            "location": "/concepts/architecture/#virtual-dom", 
            "text": "Every piece of DOM that Ractive can manage has a corresponding class in the virtual DOM to handle the DOM node, which generally end up being either Elements or Text Nodes. View items are grouped together as Fragments of view, which may then be owned by other fragments or items. At the root of every ractive instance is a Fragment instance that contains its entire virtual DOM tree. Each Ractive template construct has at least one analog in the virtual DOM. The bulk of Ractive's view functionality is implemented in the Section, Interpolator, and Element items, with there being a number of specialized element classes to handle special types of HTML element.  All virtual DOM items go through roughly the same lifecycle: creation, binding, rendering, bubbling, updating, unrendering, and unbinding. Creation is basically just the constructor call and almost always is immediately followed by binding. Binding is the point at which the item resolves and registers with its data references. Rendering is the point at which the item inserts an actual DOM node into the DOM. Bubbling and updating are the two halves of the update process, which is discussed in the next section. Unrendering is the point at which the item should no longer be present in the DOM, and it often occurs at the same point as unbinding, which is the point at which the item unregisters with the viewmodel and is effectively destroyed.  There a number of other members, such as events and decorators, and processes, such as change propagation, which are described in detail in the  view overview .  Ractive views are structured virtual DOM trees that are assembled from template AST and manage DOM nodes on the page when they are rendered. Virtual DOM items are grouped together in  Fragment s, which contain them, and they may also own  Fragment s that contain other items. Each item may contain a reference to a DOM node when rendered, though every item doesn not have a DOM analog.", 
            "title": "Virtual DOM"
        }, 
        {
            "location": "/concepts/architecture/#states", 
            "text": "Items generally follow a fixed lifecycle.   Construction - the item is created and knows about its parent and the template chunk from which it was created. Its template may also indicate what its children should look like if it has them.  bind  - the item looks up any references is may have and registers with the model(s) that they represent. At this point, the item may create child items and bind them as well.  render  - the item may create an actual DOM node and tell its children to create their DOM nodes as necessary. The resulting nodes will be inserted into the document.  unrender  - thie item is no longer needed and will be removed from the document immediately or in the near future.  unbind  - this typically goes along with  unrender  and tells the models on which this item depends that they should no longer send change notifications to it.   There is a sixth floating step  rebind  that happens any time one dependency models shuffles (and in certain other very special circumstances) that causes the items to re-resolve their models and re-register if necessary.", 
            "title": "States"
        }, 
        {
            "location": "/concepts/architecture/#virtual-dom-items", 
            "text": "", 
            "title": "Virtual DOM Items"
        }, 
        {
            "location": "/concepts/architecture/#text", 
            "text": "Text is the simplest item. It simply holds a string that it turns into a  TextNode  when rendered.", 
            "title": "Text"
        }, 
        {
            "location": "/concepts/architecture/#interpolator", 
            "text": "This is the next simplest item. It resolves a model for its reference or expression and renders the value of the model as a text node if needed. Interpolators don't necessarily render directly, as they may be used for values by other items, such as attributes, mappings, and bindings.", 
            "title": "Interpolator"
        }, 
        {
            "location": "/concepts/architecture/#element", 
            "text": "An  Element  represents a DOM element. It also contains a number of other items in the form of  Attribute s,  Decorator s,  Transition s,  EventDirective s, and its children in a  Fragment .", 
            "title": "Element"
        }, 
        {
            "location": "/concepts/architecture/#attributes", 
            "text": "There are actually several different items that are treated as attributes for  Element s, event though only two of them actually may render into the DOM.   Attribute s - maybe obvious, they these represent a DOM attribute on their parent element. There are a number of different handlers for updating attributes depending on the element and attribute name. The  updateDelegate  for a particular attribute can be found in  getUpdateDelegate.js .  ConditionalAttribute s - render as a string and are parsed into actual DOM attributes using a  div  or an  svg  depending on their parent element.  Mapping s - when rendered add a mapping to their component, and when unrendered, remove it. These aren't attached to  Element s, but instead, are attached to  Component s (see below).  EventDirective s - when rendered attach an event listener to their parent, and when unrenedered, remove it. Event parameters are kept in sync with their bindings and are evaluated when the event fires.  BindingDirective s - when rendered and unrendered update their parent element's bindings, if they exist.  Decorator s - when rendered call the named decorator with their parent element, and when unrenedered, remove it.  Decorator s also have an update cycle related to their parameters.  Transition s - are a sort of weird case. When rendered, they attach a transition handler to their element, and when the element renders or unrenders, if an appropriate transition handler is registered, will trigger the transition. Transition parameters are also kept in sync with their bindings.", 
            "title": "Attributes"
        }, 
        {
            "location": "/concepts/architecture/#bindings", 
            "text": "Certain attributes may also trigger a binding to be created on their parent element. For instance, if two-way binding is enabled on the parent element, and the parent element is an  input , a  value  attribute with a single  Interpolator  as its content will cause a two-way binding to be created between the value of the  input  and the model of the  Interpolator . This binding will handle updating the model when the input  value  has changed. There are a few other types of bindings for managing check values, content editables, name-bound lists of checkboxes, and other miscellaneous special values.  A  lazy  binding directive will cause any associated two-way bindings to fire either after a timeout or on blur, depending on the value of the  lazy  directive.", 
            "title": "Bindings"
        }, 
        {
            "location": "/concepts/architecture/#section", 
            "text": "Section s come in many flavors, depending on the chunk of template from which they are created. A section may provide context, be conditional (positive or negative), or be iterative. Generic sections ( {{#something}}...{{/}}  in template) will adjust their type, to a certain extent, based on the value of their model. A generic section will always provide context in the form of their model. An  if -style conditional section, including  elseif ,  else , and  unless  do not provide context. An  each  section will always provide context in the form of the current iteration. A  with  section will always provide context as its model, but it will only render if its model is considered truthy by Ractive, which is pretty much the same as JS truthy except  {}  and  []  are falsey. A generic section will be context/conditional if it is anything other than an array, which will make it iterative.  Sections that provide context do so by binding their  Fragment s with their model so that the reference resolution process can find the appropriate contexts when resolving.", 
            "title": "Section"
        }, 
        {
            "location": "/concepts/architecture/#contextconditional", 
            "text": "Context and conditional sections will render and unrender their child fragment as their model changes truthiness. Conditional sections always stand alone, even it they have  elseif  or  else  branches nested within them, because those branches are turned into independent sections during parsing.", 
            "title": "Context/Conditional"
        }, 
        {
            "location": "/concepts/architecture/#iterative", 
            "text": "If section is designated iterative ( {{#each ...}} ) or is a general section with an array value resolution, the section will create a special form of fragment for each index or key in the value. The special form  RepeatedFragment  handles mapping of indices, keys, and references to those to a corresponding model. Iterative sections also have special handling for shuffles so that DOM is not wholesale destroyed and recreated when the array shuffles.  Iterative sections may supply an alias for their context, so that referencing the iterated value is a little bit easier. See  Aliases  below for more info, as this is just a slightly specialized form of that.  Iterative sections may also supply key and/or index aliases so that their keys and/or indices may be referenced by a name from within their child fragments.", 
            "title": "Iterative"
        }, 
        {
            "location": "/concepts/architecture/#alias", 
            "text": "Alias sections simply resolve their models and act as a lookup endpoint for reference resolution. Aliasing happens entirely in the view.", 
            "title": "Alias"
        }, 
        {
            "location": "/concepts/architecture/#component", 
            "text": "A component is a sort-of special form of  Element  that, instead of creating a DOM element, creates a new Ractive instance. The child instance will be rendered and unrendered in place of the component placeholder in the DOM.  Any plain  Attribute s with a single  Interpolator  as content in a component's template are turned into  Mapping s.", 
            "title": "Component"
        }, 
        {
            "location": "/concepts/architecture/#resolution", 
            "text": "The resolution process for references requires a keypath and a  Fragment  as a starting point.   If the reference is a special reference ( @index ,  @this , etc), the appropriate model is looked up and returned.  If the reference is relative (starts with  ~/ ,  . , or  ../ ) the appropriate base model is retrieved and the rest of the keypath is joined onto it and the resulting model is returned.  If the reference is non-relative and the base of the keypath is a member of the current context, then the context is joined to the keypath and the resulting model is returned.  The reference is ambiguous, so the following loop until resolution or no fragments are left, starting with the given fragment:  If the fragment is an iteration, check to see if there is an index or key alias that matches the root of the reference, and if so, return it.  If the fragment has aliases, check to see if there is one that matches the root of the reference, and if so, return it.  If the fragment has context:  If the fragment is the root of an instance, note it  If the context has a child matching the root of the reference:  If we crossed a component boundary, create an implicit mapping the to the newly discovered model in the current component.  Return it    If the fragment belongs to a component, use the component's parent fragment and loop.  Use the fragment's parent and loop.   The resolution process no longer happens strictly within the vDOM, as the result of  Ractive.getContext  also uses the target  Element 's fragment to resolve relative references. Event objects are also extended with methods from the same helper.", 
            "title": "Resolution"
        }, 
        {
            "location": "/concepts/architecture/#updates", 
            "text": "The  runloop  controls when the DOM is actually updated and when transitions start in  batch es. It also handles resolving promises when transitions have completed and the DOM is completely up to date.  As changes propagate through the viewmodel, view items are notified of the change through their  handleChange  method. Most items just set a dirty flag and notify their parent, via their  bubble  method, that they will need to be updated at the completion of the runloop turn. The root fragment of each instance affected will then register with the runloop. Once the changes are ready to be flushed to the view, each fragment registered with the runloop is called on to update, where the process happens in reverse, with each parent fragment checking to see if there is a change it needs to respond to and propagating the update downward to its children.", 
            "title": "Updates"
        }, 
        {
            "location": "/concepts/rendering/", 
            "text": "Progressive Enhancement\n\n\nTODO\n\n\nServer-side\n\n\nTODO", 
            "title": "Rendering"
        }, 
        {
            "location": "/concepts/rendering/#progressive-enhancement", 
            "text": "TODO", 
            "title": "Progressive Enhancement"
        }, 
        {
            "location": "/concepts/rendering/#server-side", 
            "text": "TODO", 
            "title": "Server-side"
        }, 
        {
            "location": "/concepts/security/", 
            "text": "CSP\n\n\nTo use ractive with \nContent Security Policy\n, you'll currently need \n'unsafe-eval'\n specified for \nscriptSrc\n in your CSP header. This may change in future - see https://github.com/ractivejs/ractive/issues/1897 .", 
            "title": "Security"
        }, 
        {
            "location": "/concepts/security/#csp", 
            "text": "To use ractive with  Content Security Policy , you'll currently need  'unsafe-eval'  specified for  scriptSrc  in your CSP header. This may change in future - see https://github.com/ractivejs/ractive/issues/1897 .", 
            "title": "CSP"
        }, 
        {
            "location": "/concepts/data-binding/", 
            "text": "Computed Properties\n\n\nThe idea is fairly simple: you can define computed properties that update reactively based on their dependencies. In previous versions you may have done something as follows.\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '{{width}} * {{height}} = {{ area() }}', // note the function invocation\n  data: {\n    width: 100,\n    height: 100,\n    area: function () { return this.get( 'width' ) * this.get( 'height' ); }\n  }\n});\n\n\n\n\nThat's nice and all - the \n{{ area() }}\n mustache updates reactively as \nwidth\n and \nheight\n change - but it's limited. To get the area value programmatically you'd have to do something like...\n\n\narea = ractive.get('area').call(ractive);\n\n\n\n\n...which effectively prevents you from composing computed values together in any meaningful way. And you can't 'observe' the area outside of the template, without doing something like this:\n\n\nractive.observe( 'width height', function () {\n    var area = this.get( 'width' ) * this.get( 'height' );\n    doSomething( area );\n});\n\n\n\n\nComputed properties to the rescue\n\n\nNow, you can do\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '{{width}} * {{height}} = {{area}}', // `area` looks like a regular property\n  data: {\n    width: 100,\n    height: 100\n  },\n  computed: {\n    area: function () { return this.get( 'width' ) * this.get( 'height' ); }\n  }\n});\n\n\n\n\nWith this, the \narea\n property can be treated like any other. It will update reactively (because the calls to \nractive.get()\n tell Ractive that it should be recomputed when \nwidth\n or \nheight\n change), so you can do...\n\n\nractive.observe( 'area', doSomething );\n\n\n\n\n...instead of manually recalculating it. And computed values can depend on other computed values, and so on (before anyone asks, we're not doing a topological sort or anything fancy like that - in real world scenarios I'd expect the overhead of doing the sort to be greater than the cost of occasionally recomputing a node in the dependency graph more times than is required).\n\n\nCompact syntax\n\n\nThe syntax used above, where each computed property is defined as a function, gives you a lot of flexibility. But there's a more compact string syntax you can use:\n\n\nractive = new Ractive({\n  ...,\n  computed: {\n    area: '${width} * ${height}'\n  }\n});\n\n\n\n\nThis string is turned into a function with the \nFunction\n constructor (which unfortunately means it isn't \nCSP compliant\n) - any \n${...}\n blocks are basically turned into \nractive.get('...')\n, so it works exactly the same way. Needless to say you can use any JavaScript here - \n${foo}.toUpperCase()\n, \nMath.round(${num})\n, and so on.\n\n\nSetting computed values\n\n\nBy default, computed values are read-only, and if you try to \nractive.set('someComputedProperty')\n an error will be thrown. But you can use a third syntax option which allows you to declare a \nset()\n method:\n\n\nractive = new Ractive({\n  data: { firstname: 'Douglas', lastname: 'Crockford' },\n  computed: {\n    fullname: {\n      get: '${firstname} + \n \n + ${lastname}', // or use the function syntax\n      set: function ( fullname ) {\n        var names = fullname.split( ' ' );\n\n        this.set({\n          firstname: names[0] || '',\n          lastname: names[1] || ''\n        });\n      }\n    }\n  }\n});\n\nractive.set( 'fullname', 'Rich Harris' );\n\nractive.get( 'firstname' ); // Rich\nractive.get( 'lastname' ); // Harris\n\n\n\n\nComponents\n\n\nYou can, of course, declare computed values on components:\n\n\nBox = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nbox = new Box({\n  ...,\n  data: { width: 20, height: 40 }\n});\n\nbox.get( 'area' ); // 800\n\n\n\n\nAdditional computed properties can be declared on the instance:\n\n\nbox2 = new Box({\n  ...,\n  data: { width: 20, height: 40, depth: 60 },\n  computed: { volume: '${area} * ${depth}' }\n});\n\nbox2.get( 'area' ); // 800\nbox2.get( 'volume' ); // 48000\n\n\n\n\nData context for computed properties\n\n\nComputed properties can only be calculated for the instance context as a whole. You can't, for example, directly\ncompute a value for each member of an array:\n\n\nnew Ractive({\n  template: '{{#boxes}}{{area}}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  // there's no way to specify this for \neach\n box :(\n  computed: { area: '${width} * ${height}' }\n});\n\n\n\n\nThe solution is to either use a function that calculates the value for each member:\n\n\n  template: '{{#boxes:b}}{{ getArea(b) }}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ],\n    getArea: function ( i ) {\n      var box = this.get( 'boxes.' + i );\n      return box.width * box.area;\n    }\n  }\n\n\n\n\nOr leverage a component to \"scope\" the data to each item:\n\n\nBox = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nnew Ractive({\n  template: '{{#boxes}}\nbox/\n{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  components: { box: Box }\n});\n\n\n\n\nDependents\n\n\nRactive maintains a \ndependency graph\n in order to do the minimum amount of work necessary to keep the DOM up-to-date.\n\n\nIf you inspect a Ractive instance in your console, you'll see a property called \n_deps\n. This is where all dependants are listed, indexed by their dependency.\n\n\nThere is also a concept of 'priority', which exists to save us some work. If, for example, a section needs to be removed (perhaps it's a conditional section, and the condition just went from truthy to falsy), there is no point in updating all its children, so we make sure that we teardown the section first. As part of that teardown process, the children - which all have lower priority - unregister themselves as dependants before they get a chance to update.\n\n\nIndirect dependencies\n\n\nIf you have a mustache which depends on \nfoo.bar\n, and \nfoo\n changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an \nindirect dependency\n on \nfoo\n, or that it has a \ndirect dependency on a downstream keypath\n of \nfoo\n.\n\n\nThis relationship is expressed through the \n_depsMap\n property of a Ractive instance - whenever \nfoo\n changes, as well as dealing with direct \nfoo\n dependants we check the map for those indirect dependants.\n\n\nIn the case of \nexpressions\n and \nobservers\n, we also need to consider dependants of \nupstream keypaths\n. For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:\n\n\n{{#( sort( list, 'name' ) )}}\n  \np\n{{name}}\n/p\n\n{{/()}}\n\n\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],\n    sort: function ( list, property ) {\n      return list.slice().sort( function ( a, b ) {\n        return a[ property ] \n b[ property ] ? -1 : 1;\n      });\n    }\n  }\n});\n\n// renders Alice, Bob, Charles\n\nractive.set( 'list[0].name', 'Zebediah' );\n\n// updates to Alice, Charles, Zebediah\n\n\n\n\nIn the example, setting \nlist[0].name\n causes dependants of \nlist\n to be updated.\n\n\nAs well as \nexpressions\n, \nObservers\n respond to both upstream and downstream changes.\n\n\nExpressions with multiple dependencies\n\n\nThe expression \n{{ a + b }}\n has two dependencies - \na\n and \nb\n (or more accurately, whatever those \nreferences\n resolve to). The \n_deps\n graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.\n\n\nBecause the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing \nractive.set({ a: 1, b: 2 })\n will only trigger one update, not two.\n\n\n\n\nObservers\n\n\nLike publish/subscribe, but different\n\n\nA common pattern in modern JavaScript is to make models \nobservable\n, using the traditional \npublish/subscribe\n mechanism.\n\n\nFor example, you can observe changes to attributes within a Backbone Model like so:\n\n\nmodel = Backbone.Model({ myValue: 1 });\n\nmodel.on( 'change:myValue', function ( model, value, options ) {\n  alert( 'myValue changed to ' + value );\n});\n\nmodel.set( 'myValue', 2 ); // alerts 'myValue changed to 2'\n\n\n\n\nThis works because \nBackbone.Model.prototype\n inherits from \nBackbone.Events\n.\n\n\nRactive implements pub/sub with \nractive.on()\n, \nractive.off()\n and \nractive.fire()\n, \nractive.off()\n and \nractive.fire\n - see \nEvents\n for more info.\n\n\nObserving models with nested properties\n\n\nBut the normal pub/sub mechanism won't work for monitoring data changes with Ractive, because our data can contain nested properties. It's no good subscribing to a \nchange:foo.bar\n event, if \nfoo.bar\n can change as a result of \nfoo\n changing.\n\n\nSo instead, we introduce the concept of \nobservers\n.\n\n\nAn observer observes a particular \nkeypath\n, and is \nnotified\n when the value of its keypath changes, whether directly or indirectly (because an \nupstream\n or \ndownstream\n keypath changed). You create one with \nractive.observe()\n (see \nractive.observe()\n for full method\nAPI).\n\n\nHere's an example:\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    foo: { bar: 1 }\n  }\n});\n\n// The observer will be initialised with ( currentValue, undefined ) unless\n// we pass a third `options` argument in which `init` is `false`. In other\n// words this will alert 'foo.bar changed to 1'\nobserver = ractive.observe( 'foo.bar', function ( newValue, oldValue, keypath ) {\n  alert( keypath + ' changed to ' + newValue );\n});\n\nractive.set( 'foo.bar', 2 ); // alerts 'foo.bar changed to 2'\nractive.get( 'foo' ); // returns { bar: 2 }\n\nractive.set( 'foo', { bar: 3 }); // alerts 'foo.bar changed to 3'\nractive.get( 'foo.bar' ); // returns 3\n\nobserver.cancel();\n\nractive.set( 'foo.bar', 4 ); // alerts nothing; the observer was cancelled\n\n\n\n\nObservers are most useful in the context of \ntwo\u2010way binding\n.\n\n\nPattern Observers\n\n\nIt is useful to observe on specific keypaths but in the event your data contains array, or a set of dynamic data it isn't logical to bind to every potential keypath that could exist. Pattern observers use a \n*\n to indicate to Ractive that you would like to be notified whenever anything changes in your data at a particular depth as well as below the specified depth.\n\n\nThere are a few caveats when it comes to observing on array data, when observing on keypath \npeople.*\n you are observing on the length of the array. This means that the \nnewValue\n will be the index at which the new object was pushed. However when you use \nset\n to change an item at a particular index or a key that is on an object in the array then it will provide the object as the \nnewValue\n.\n\n\nvar ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    people: [\n      {name: 'Rich Harris'},\n      {name: 'Marty Nelson'}\n    ]\n  }\n});\n\nractive.observe('people.*', function(newValue, oldValue, keypath) {\n\n});\n\nvar people = ractive.get('people');\npeople.push({name: 'Jason Brown'});\n//newValue will equal 3, and the keypath will be people.length\n\nractive.set('people.3', {name: 'Jack Black'});\n//newValue will be {name: 'Jack Black'} and the keypath will be people.3\n\nractive.set('people.3.isACelebrity', true);\n//newValue will be {name: 'Jack Black', isACelebrity: true} and the keypath will be people.3\n\nractive.set('people.0.info.isCreator', true);\n//newValue will be the object for index 0 and the keypath will be people.0\n\n\n\n\n\nNotice that because you are observing at the array level that \nnewValue\n will be set as the entire object. What if you were only interested in knowing when a user became a celebrity? Simply tell Ractive you only want to observe dynamically on the array but only be notified when the \nisACelebrity\n key changes, \npeople.*.isACelebrity\n.\n\n\nractive.observe('people.*.isACelebrity', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('people.0.isACelebrity', true); //Rich Harris is a celebrity\n//newValue will be `true` and the keypath will be people.0.isACelebrity\n\n\n\n\n\nYou are not limited to just one \n*\n for your pattern, you can use as many as you would like and in any particular order.\n\n\n\nractive.observe('people.*.comments.*', function(newValue, oldValue, keypath) {\n\n});\n\n//even arrays of arrays\n\nractive.observe('people.*.*', function(newValue, oldValue, keypath) {\n\n});\n\n\n\n\n\nFurthermore it works on objects as well \nconfig.*\n will notify you when a value is changed on any key on the config object. However this differs from observing on an array in that it will provide the value set and keypath to the key that was set.\n\n\nvar ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  }\n});\n\nractive.observe('config.*', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('config.allowEdit', true);\n//newValue will be true and the keypath will be config.allowEdit\n\n\n\n\n\nIn addition to \nnewValue\n, \noldValue\n, and \nkeypath\n, any widlcards that are matched in the \nkeypath\n will be passed to the callback. Each additional wildcard will cause an extra parameter to be passed to the callback. For instance:\n\n\nractive.observe('items.*.*', function(newValue, oldValue, keypath, idx, key) {\n  console.log('item', idx, key, 'is now', newValue);\n});\nractive.set('items.1.foo', 'bar');\n// logs 'item 1 foo is now bar'\n\n\n\n\nPattern observers are a simple and flexible that will allow you to observe your data any way that you want.\n\n\nSpace Delimited Observers\n\n\nSpace delimited observers are useful when different keypaths should trigger the same function. In previous version you would have had to bind each keypath individually to the function.\n\n\nThis is a contrived example but for examples sake bare with us.\n\n\nvar ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    user: {username: 'browniefed'},\n    config: {isAdmin: false},\n    commentCount: 0\n  }\n});\n\nfunction updateServer() {\n  //Make call to server because something in user, config, comments changed\n}\n\nractive.observe('user.username', updateServer);\nractive.observe('config.isAdmin', updateServer);\nractive.observe('commentCount', updateServer);\n\n\n\n\n\nThis is unecessarily verbose, now with space delimited observers this becomes a single line.\n\n\nractive.observe('user.username config.isAdmin commentCount', updateServer);\n\n\n\n\n\nThis will work with patterns observers as well.\n\n\nractive.observe('user.* config.* commentCount', updateServer);\n\n\n\n\n\nA 'gotcha' to be aware of\n\n\nObservers will be notified whenever the new value is not equal to the old value - \nsort of\n.\n\n\nWhat does 'not equal' mean? Well, with \nprimitive values\n such as strings and numbers, that's easy - they're either identical (in the \n===\n sense) or they're not.\n\n\nWith objects and arrays (hereafter, just 'objects', since that's what arrays technically are), it's not so straightforward:\n\n\na = { one: 1, two: 2, three: 3 };\nb = { one: 1, two: 2, three: 3 };\n\nalert( a === b ); // alerts 'false' - they look the same, but they ain't\n\nb = a;\nb.four = 4;\n\nalert( a === b ); // alerts 'true'. Hang on, `a` didn't have a 'four' property?\nalert( a.four ); // alerts '4'. Oh. Right.\n\n\n\n\nSo one the one hand, objects which look identical aren't. On the other, you can set a property of an object and have no idea whether doing so resulted in a change.\n\n\nThere are two possible responses to this problem. First, we could do a 'deep clone' of an object whenever we do \nractive.set(keypath, object)\n, using an algorithm similar to \njQuery extend\n. That would mean any references you held to \nobject\n would become irrelevant. It would also mean a whole load of extra computation, and probably some very strange behaviour with cyclical data structures. No thanks.\n\n\nThe second is to sidestep the issue, and simply state that for the purposes of determining whether to notify observers, \nno two objects are equal, even when they're identical\n (unless they're both \nnull\n, of course - since \ntypeof null === 'object'\n due to a \nbug in the language\n).\n\n\nThis is the safest, sanest behaviour, but it can lead to unexpected behaviour in one situation - accessing properties within an observer:\n\n\nobj = { a: { b: { c: 1 } } };\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: { obj: obj }\n});\n\n// We observe 'obj.a.b.c' indirectly, and directly\nractive.observe({\n  'obj': function ( newObj, oldObj ) {\n    alert( 'Indirect observer: changed from ' + oldObj.a.b.c + ' to ' + newObj.a.b.c );\n  },\n  'obj.a.b.c': function ( newC, oldC ) {\n    alert( 'Direct observer: changed from ' + oldC + ' to ' + newC );\n  }\n});\n\nobj.a.b.c = 2;\n\n// The next line will cause two alerts:\n//   'Direct observer: changed from 1 to 2'\n//   'Indirect observer: changed from 2 to 2' - because oldObj === newObj\nractive.set( 'obj', obj );\n\n\n\n\nThis is definitely an edge case, but one that it's worth being aware of.\n\n\nParallel DOM\n\n\nRactive works by maintaining a simplified model of the part of the DOM that it's responsible for. This model contains all the information - about data-binding, event handling and so on - that it needs to keep things up-to-date.\n\n\nYou can inspect the parallel DOM to understand what's going on under the hood, if you're into that sort of thing. Each Ractive instance, once rendered, has a \nfragment\n property. Each fragment has a number of properties:\n\n\n\n\ncontextStack\n - the context stack in which mustache \nreferences\n should be evaluated\n\n\nroot\n - a reference to the Ractive instance to which it belongs\n\n\nowner\n - the \nitem\n that owns this fragment (in the case of the root fragment, the same as \nroot\n)\n\n\nitems\n - the items belonging to this fragment\n\n\n\n\nItems\n means elements, text nodes, and mustaches. Elements may have fragments of their own (i.e. if they have children). A partial mustache will have a fragment, and a section mustache will have zero or more fragments depending on the value of its keypath.\n\n\nElements may also have attributes, which have a different kind of fragment (a \ntext fragment\n as opposed to a \nDOM fragment\n), containing text and mustaches.\n\n\nEach item has a \ndescriptor\n, which is something like DNA. This comes straight from the \nparsed template\n.\n\n\nThis is the briefest of overviews - if you want to gain a deeper understanding of what's going on under the hood, \nuse the source\n.\n\n\n\n\nTwo-way binding\n\n\nBy default, a Ractive instance will update its internal model based on user input, if you have \ninput\n, \ntextarea\n or \nselect\n elements.\n\n\nIf that's unhelpful for your app, you can disable it by passing \ntwoway: false\n as an \ninitialisation option\n.\n\n\nTwo-way vinding can also be overridden on a per-element basis using the \ntwoway\n directive e.g. \ninput value=\"{{foo}}\" twoway=\"false\"\n. If the \ntwoway\n option is set to false, it can be overridden on a per-element bases using \ntwoway\n as a boolean attribute e.g. \ninput value=\"{{foo}}\" twoway\n or \ninput value=\"{{foo}}\" twoway=\"true\"\n.\n\n\ninput\n elements\n\n\nTwo-way binding works with \ninput\n elements of any type, including the new HTML5 types such as \ncolor\n or \nemail\n. In most cases, you just add a mustache as the \nvalue\n attribute - this must be a single, standard \ninterpolator\n mustache, like this:\n\n\ninput placeholder='Type your name' value='{{user.name}}'\n\n\n\n\n\nIn the example above, any changes the user makes to the input will be reflected in the \nuser.name\n property.\n\n\nCheckboxes\n\n\nCheckboxes are used to flag a property as \ntrue\n or \nfalse\n. Rather than binding the \nvalue\n attribute, we bind the \nchecked\n attribute:\n\n\nlabel\n\n    \ninput type='checkbox' checked='{{on}}'\n\n    The lights are {{ on ? 'on' : 'off' }}\n\n/label\n\n\n\n\n\n(True HTML nerds will recognise that \nboolean attributes\n such as checked don't have a value, as such - they either exist on an element or they don't. This makes life unnecessarily difficult; Ractive treats dynamic (i.e., controlled by a mustache) boolean attributes as present if the mustache is \ntrue\n, absent if \nfalse\n.)\n\n\nCheckboxes may also be bound by the \nname\n attribute, which will result in the value specified in the \nname\n attribute containing an array of selected checkbox values.\n\n\n{{#colors}}\n  \nlabel\n\n    \ninput type='checkbox' name='{{selected}}' value='{{.}}' /\n{{.}}\n  \n/label\n\n{{/}}\n\n\n\n\nIf \ncolors\n is an array, \n['Red', 'Yellow', 'Green', 'Blue']\n, then checking the first box will result in \nselected\n becoming \n['Red']\n. Checking the third box will result in \nselected\n becoming \n['Red', 'Green']\n. The array may also be updated from code using \nset\n or any of the array modification methods available to Ractive, and the checkboxes will be updated to reflect the contents of the array in the Ractive viewmodel.\n\n\nNote\n that checkboxes with both a \nchecked\n and \nname\n binding will \nonly\n bind on \nchecked\n, not both. The \nname\n binding will be treated\nas a normal mustache variable.\n\n\nRadios\n\n\nRadio buttons can be controlled in the same way as checkboxes. However the chances are, if you're using radio buttons, you have a set of mutually exclusive options to choose between. In this case, if you set the \nname\n attribute on a radio input to e.g. \n{{someValue}}\n, \nsomeValue\n will reflect the \nvalue\n of the currently checked option:\n\n\nlabel\ninput type='radio' name='{{color}}' value='red' checked\n Red\n/label\n\n\nlabel\ninput type='radio' name='{{color}}' value='green'\n Green\n/label\n\n\nlabel\ninput type='radio' name='{{color}}' value='blue'\n Blue\n/label\n\n\n\np\nThe currently selected color is \nspan style='color: {{color}};'\n{{color}}\n/span\n/p\n\n\n\n\n\nIn the example above, the value of \ncolor\n will initially be \n'red'\n (because that input is checked in the template), and will update as and when the user selects another option.\n\n\ntextarea\n elements\n\n\nTextareas work exactly the same as standard text inputs - slap a dynamic \nvalue\n attribute on them, and you're done:\n\n\ntextarea value='{{content}}'\n/textarea\n\n\n\n\n\nselect\n elements\n\n\nDrop-down select menus are good when you have many options to choose from. They're straightforward to use in Ractive:\n\n\nselect value='{{selectedCountry}}'\n\n    \noption selected disabled\nSelect a country\n/option\n\n    {{#countries}}\n        \noption value='{{id}}'\n{{name}}\n/option\n\n    {{/countries}}\n\n/select\n\n\n\n\n\nractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        countries: [\n            { id: 'AFG', name: 'Afghanistan' },\n            { id: 'ALB', name: 'Albania' },\n            { id: 'DZA', name: 'Algeria' },\n            { id: 'ASM', name: 'American Samoa' }\n            // and so on...\n        ]\n    }\n});\n\n\n\n\nIn the example above, no country will initially be selected. If the user were to select Afghanistan from the list, the value of \nselectedCountry\n would change to \n'AFG'\n.\n\n\ncontenteditable\n\n\nRactive can two-way data bind contenteditable elements.\n\n\nvar ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        content: 'Edit me'\n    }\n});\n\nractive.observe('content', function(newValue, oldValue, keypath) {\n    //newValue will contain the new content of the div\n});\n\n\n\n\nmyTemplate\n\n\ndiv contenteditable=\ntrue\n value=\n{{content}}\n/div\n\n\n\n\n\nThis will be rendered as\n\n\ndiv contenteditable=\ntrue\nEdit Me\n/div\n\n\n\n\n\nAs the user edits the data the \ncontent\n will update, and observe will fire.\n\n\nThere are a few caveats that you need to know. Despite the value binding with only two curly braces \n{{content}}\n (double curly braces are required for two way data binding) the returned content may or may not be a string of HTML. If a user presses enter after most browsers will insert a \nbr /\n. The \ncontent\n would be set to \nEdit Me\nbr/\n. Additionally anything you set to \ncontent\n would be rendered as HTML and not escaped despite the lack of triple curly braces(\n{{{content}}}\n).\n\n\nractive.set('content', '\nul\nli\nEdit Me\n/li\n/ul\n');\n\n\n\n\nThis would actually render an editable unordered list.\n\n\nBe aware that not all browsers actually operate the same way when it comes to interacting with contenteditable. HTML generated by one browser may differ from another.\n\n\nAmbiguous references\n\n\nA mustache used in a two-way binding context must have an \nunambiguous reference\n. Consider the following:\n\n\n{{#foo}}\n    \ninput value='{{bar}}'\n\n{{/foo}}\n\n\n\n\nractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: { foo: {} }\n});\n\n\n\n\nRactive must decide, straight away, what \nkeypath\n to bind the input's \nvalue\n attribute to. It will first see if it can \nreference\n (\n'bar'\n) given the current context stack (which includes a single context - \n'foo'\n). It can't, so it is forced to make an assumption - that the \n'bar'\n reference should resolve to the \n'bar'\n keypath.\n\n\nBut this might not be what you want - maybe you \ndid\n want it to resolve to \n'foo.bar'\n.\n\n\nYou have two options - either use a \nrestricted reference\n, i.e. \ninput value='{{.bar}}'\n, or ensure that \nfoo\n has a \nbar\n property (even if the initial value is \nundefined\n).\n\n\nLazy updates\n\n\nUnder the hood, Ractive always binds to the \nchange\n event (and the \nclick\n event in IE, in the case of checkboxes, due to an IE bug). By default, it will also bind to the \ninput\n event, which means the model is updated instantly when the user enters data (the \nchange\n event fires when a change is \n'committed by the user'\n). In some situations, that's not what you want - if you want to only bind to \nchange\n, pass in \nlazy: true\n as an \ninitialisation option\n.\n\n\nAs with \ntwoway\n, laziness may be specified on a per-element basis. Besides \ntrue\n (or simply having the attribute preset) and \nfalse\n values, the \nlazy\n directive may also be a number that specifies the number of milliseconds to wait after the last \ninput\n event fires with subsequent \ninput\n events resetting the timeout. For instance \ninput value=\"{{foo}}\" lazy\n will trigger updates to \nfoo\n on \nchange\n and \ninput value=\"{{foo}}\" lazy=\"1000\"\n will trigger updates 1 second after the last keypress.\n\n\nObserving changes\n\n\nTo use user input elsewhere in your app, you'll need to observe it using \nractive.observe()\n:\n\n\ninput placeholder='Type your name' value='{{user.name}}'\n\n\n\n\n\nractive = new Ractive({\n    el: myContainer,\n    template: myTemplate\n});\n\nractive.observe( 'user.name', function ( newValue ) {\n    app.user.name = newValue;\n    triggerSomeBehaviour();\n});", 
            "title": "Data Binding"
        }, 
        {
            "location": "/concepts/data-binding/#computed-properties", 
            "text": "The idea is fairly simple: you can define computed properties that update reactively based on their dependencies. In previous versions you may have done something as follows.  ractive = new Ractive({\n  el: 'body',\n  template: '{{width}} * {{height}} = {{ area() }}', // note the function invocation\n  data: {\n    width: 100,\n    height: 100,\n    area: function () { return this.get( 'width' ) * this.get( 'height' ); }\n  }\n});  That's nice and all - the  {{ area() }}  mustache updates reactively as  width  and  height  change - but it's limited. To get the area value programmatically you'd have to do something like...  area = ractive.get('area').call(ractive);  ...which effectively prevents you from composing computed values together in any meaningful way. And you can't 'observe' the area outside of the template, without doing something like this:  ractive.observe( 'width height', function () {\n    var area = this.get( 'width' ) * this.get( 'height' );\n    doSomething( area );\n});", 
            "title": "Computed Properties"
        }, 
        {
            "location": "/concepts/data-binding/#computed-properties-to-the-rescue", 
            "text": "Now, you can do  ractive = new Ractive({\n  el: 'body',\n  template: '{{width}} * {{height}} = {{area}}', // `area` looks like a regular property\n  data: {\n    width: 100,\n    height: 100\n  },\n  computed: {\n    area: function () { return this.get( 'width' ) * this.get( 'height' ); }\n  }\n});  With this, the  area  property can be treated like any other. It will update reactively (because the calls to  ractive.get()  tell Ractive that it should be recomputed when  width  or  height  change), so you can do...  ractive.observe( 'area', doSomething );  ...instead of manually recalculating it. And computed values can depend on other computed values, and so on (before anyone asks, we're not doing a topological sort or anything fancy like that - in real world scenarios I'd expect the overhead of doing the sort to be greater than the cost of occasionally recomputing a node in the dependency graph more times than is required).", 
            "title": "Computed properties to the rescue"
        }, 
        {
            "location": "/concepts/data-binding/#compact-syntax", 
            "text": "The syntax used above, where each computed property is defined as a function, gives you a lot of flexibility. But there's a more compact string syntax you can use:  ractive = new Ractive({\n  ...,\n  computed: {\n    area: '${width} * ${height}'\n  }\n});  This string is turned into a function with the  Function  constructor (which unfortunately means it isn't  CSP compliant ) - any  ${...}  blocks are basically turned into  ractive.get('...') , so it works exactly the same way. Needless to say you can use any JavaScript here -  ${foo}.toUpperCase() ,  Math.round(${num}) , and so on.", 
            "title": "Compact syntax"
        }, 
        {
            "location": "/concepts/data-binding/#setting-computed-values", 
            "text": "By default, computed values are read-only, and if you try to  ractive.set('someComputedProperty')  an error will be thrown. But you can use a third syntax option which allows you to declare a  set()  method:  ractive = new Ractive({\n  data: { firstname: 'Douglas', lastname: 'Crockford' },\n  computed: {\n    fullname: {\n      get: '${firstname} +     + ${lastname}', // or use the function syntax\n      set: function ( fullname ) {\n        var names = fullname.split( ' ' );\n\n        this.set({\n          firstname: names[0] || '',\n          lastname: names[1] || ''\n        });\n      }\n    }\n  }\n});\n\nractive.set( 'fullname', 'Rich Harris' );\n\nractive.get( 'firstname' ); // Rich\nractive.get( 'lastname' ); // Harris", 
            "title": "Setting computed values"
        }, 
        {
            "location": "/concepts/data-binding/#components", 
            "text": "You can, of course, declare computed values on components:  Box = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nbox = new Box({\n  ...,\n  data: { width: 20, height: 40 }\n});\n\nbox.get( 'area' ); // 800  Additional computed properties can be declared on the instance:  box2 = new Box({\n  ...,\n  data: { width: 20, height: 40, depth: 60 },\n  computed: { volume: '${area} * ${depth}' }\n});\n\nbox2.get( 'area' ); // 800\nbox2.get( 'volume' ); // 48000", 
            "title": "Components"
        }, 
        {
            "location": "/concepts/data-binding/#data-context-for-computed-properties", 
            "text": "Computed properties can only be calculated for the instance context as a whole. You can't, for example, directly\ncompute a value for each member of an array:  new Ractive({\n  template: '{{#boxes}}{{area}}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  // there's no way to specify this for  each  box :(\n  computed: { area: '${width} * ${height}' }\n});  The solution is to either use a function that calculates the value for each member:    template: '{{#boxes:b}}{{ getArea(b) }}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ],\n    getArea: function ( i ) {\n      var box = this.get( 'boxes.' + i );\n      return box.width * box.area;\n    }\n  }  Or leverage a component to \"scope\" the data to each item:  Box = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nnew Ractive({\n  template: '{{#boxes}} box/ {{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  components: { box: Box }\n});", 
            "title": "Data context for computed properties"
        }, 
        {
            "location": "/concepts/data-binding/#dependents", 
            "text": "Ractive maintains a  dependency graph  in order to do the minimum amount of work necessary to keep the DOM up-to-date.  If you inspect a Ractive instance in your console, you'll see a property called  _deps . This is where all dependants are listed, indexed by their dependency.  There is also a concept of 'priority', which exists to save us some work. If, for example, a section needs to be removed (perhaps it's a conditional section, and the condition just went from truthy to falsy), there is no point in updating all its children, so we make sure that we teardown the section first. As part of that teardown process, the children - which all have lower priority - unregister themselves as dependants before they get a chance to update.", 
            "title": "Dependents"
        }, 
        {
            "location": "/concepts/data-binding/#indirect-dependencies", 
            "text": "If you have a mustache which depends on  foo.bar , and  foo  changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an  indirect dependency  on  foo , or that it has a  direct dependency on a downstream keypath  of  foo .  This relationship is expressed through the  _depsMap  property of a Ractive instance - whenever  foo  changes, as well as dealing with direct  foo  dependants we check the map for those indirect dependants.  In the case of  expressions  and  observers , we also need to consider dependants of  upstream keypaths . For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:  {{#( sort( list, 'name' ) )}}\n   p {{name}} /p \n{{/()}}  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],\n    sort: function ( list, property ) {\n      return list.slice().sort( function ( a, b ) {\n        return a[ property ]   b[ property ] ? -1 : 1;\n      });\n    }\n  }\n});\n\n// renders Alice, Bob, Charles\n\nractive.set( 'list[0].name', 'Zebediah' );\n\n// updates to Alice, Charles, Zebediah  In the example, setting  list[0].name  causes dependants of  list  to be updated.  As well as  expressions ,  Observers  respond to both upstream and downstream changes.", 
            "title": "Indirect dependencies"
        }, 
        {
            "location": "/concepts/data-binding/#expressions-with-multiple-dependencies", 
            "text": "The expression  {{ a + b }}  has two dependencies -  a  and  b  (or more accurately, whatever those  references  resolve to). The  _deps  graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.  Because the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing  ractive.set({ a: 1, b: 2 })  will only trigger one update, not two.", 
            "title": "Expressions with multiple dependencies"
        }, 
        {
            "location": "/concepts/data-binding/#observers", 
            "text": "", 
            "title": "Observers"
        }, 
        {
            "location": "/concepts/data-binding/#like-publishsubscribe-but-different", 
            "text": "A common pattern in modern JavaScript is to make models  observable , using the traditional  publish/subscribe  mechanism.  For example, you can observe changes to attributes within a Backbone Model like so:  model = Backbone.Model({ myValue: 1 });\n\nmodel.on( 'change:myValue', function ( model, value, options ) {\n  alert( 'myValue changed to ' + value );\n});\n\nmodel.set( 'myValue', 2 ); // alerts 'myValue changed to 2'  This works because  Backbone.Model.prototype  inherits from  Backbone.Events .  Ractive implements pub/sub with  ractive.on() ,  ractive.off()  and  ractive.fire() ,  ractive.off()  and  ractive.fire  - see  Events  for more info.", 
            "title": "Like publish/subscribe, but different"
        }, 
        {
            "location": "/concepts/data-binding/#observing-models-with-nested-properties", 
            "text": "But the normal pub/sub mechanism won't work for monitoring data changes with Ractive, because our data can contain nested properties. It's no good subscribing to a  change:foo.bar  event, if  foo.bar  can change as a result of  foo  changing.  So instead, we introduce the concept of  observers .  An observer observes a particular  keypath , and is  notified  when the value of its keypath changes, whether directly or indirectly (because an  upstream  or  downstream  keypath changed). You create one with  ractive.observe()  (see  ractive.observe()  for full method\nAPI).  Here's an example:  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    foo: { bar: 1 }\n  }\n});\n\n// The observer will be initialised with ( currentValue, undefined ) unless\n// we pass a third `options` argument in which `init` is `false`. In other\n// words this will alert 'foo.bar changed to 1'\nobserver = ractive.observe( 'foo.bar', function ( newValue, oldValue, keypath ) {\n  alert( keypath + ' changed to ' + newValue );\n});\n\nractive.set( 'foo.bar', 2 ); // alerts 'foo.bar changed to 2'\nractive.get( 'foo' ); // returns { bar: 2 }\n\nractive.set( 'foo', { bar: 3 }); // alerts 'foo.bar changed to 3'\nractive.get( 'foo.bar' ); // returns 3\n\nobserver.cancel();\n\nractive.set( 'foo.bar', 4 ); // alerts nothing; the observer was cancelled  Observers are most useful in the context of  two\u2010way binding .", 
            "title": "Observing models with nested properties"
        }, 
        {
            "location": "/concepts/data-binding/#pattern-observers", 
            "text": "It is useful to observe on specific keypaths but in the event your data contains array, or a set of dynamic data it isn't logical to bind to every potential keypath that could exist. Pattern observers use a  *  to indicate to Ractive that you would like to be notified whenever anything changes in your data at a particular depth as well as below the specified depth.  There are a few caveats when it comes to observing on array data, when observing on keypath  people.*  you are observing on the length of the array. This means that the  newValue  will be the index at which the new object was pushed. However when you use  set  to change an item at a particular index or a key that is on an object in the array then it will provide the object as the  newValue .  var ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    people: [\n      {name: 'Rich Harris'},\n      {name: 'Marty Nelson'}\n    ]\n  }\n});\n\nractive.observe('people.*', function(newValue, oldValue, keypath) {\n\n});\n\nvar people = ractive.get('people');\npeople.push({name: 'Jason Brown'});\n//newValue will equal 3, and the keypath will be people.length\n\nractive.set('people.3', {name: 'Jack Black'});\n//newValue will be {name: 'Jack Black'} and the keypath will be people.3\n\nractive.set('people.3.isACelebrity', true);\n//newValue will be {name: 'Jack Black', isACelebrity: true} and the keypath will be people.3\n\nractive.set('people.0.info.isCreator', true);\n//newValue will be the object for index 0 and the keypath will be people.0  Notice that because you are observing at the array level that  newValue  will be set as the entire object. What if you were only interested in knowing when a user became a celebrity? Simply tell Ractive you only want to observe dynamically on the array but only be notified when the  isACelebrity  key changes,  people.*.isACelebrity .  ractive.observe('people.*.isACelebrity', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('people.0.isACelebrity', true); //Rich Harris is a celebrity\n//newValue will be `true` and the keypath will be people.0.isACelebrity  You are not limited to just one  *  for your pattern, you can use as many as you would like and in any particular order.  \nractive.observe('people.*.comments.*', function(newValue, oldValue, keypath) {\n\n});\n\n//even arrays of arrays\n\nractive.observe('people.*.*', function(newValue, oldValue, keypath) {\n\n});  Furthermore it works on objects as well  config.*  will notify you when a value is changed on any key on the config object. However this differs from observing on an array in that it will provide the value set and keypath to the key that was set.  var ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  }\n});\n\nractive.observe('config.*', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('config.allowEdit', true);\n//newValue will be true and the keypath will be config.allowEdit  In addition to  newValue ,  oldValue , and  keypath , any widlcards that are matched in the  keypath  will be passed to the callback. Each additional wildcard will cause an extra parameter to be passed to the callback. For instance:  ractive.observe('items.*.*', function(newValue, oldValue, keypath, idx, key) {\n  console.log('item', idx, key, 'is now', newValue);\n});\nractive.set('items.1.foo', 'bar');\n// logs 'item 1 foo is now bar'  Pattern observers are a simple and flexible that will allow you to observe your data any way that you want.", 
            "title": "Pattern Observers"
        }, 
        {
            "location": "/concepts/data-binding/#space-delimited-observers", 
            "text": "Space delimited observers are useful when different keypaths should trigger the same function. In previous version you would have had to bind each keypath individually to the function.  This is a contrived example but for examples sake bare with us.  var ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    user: {username: 'browniefed'},\n    config: {isAdmin: false},\n    commentCount: 0\n  }\n});\n\nfunction updateServer() {\n  //Make call to server because something in user, config, comments changed\n}\n\nractive.observe('user.username', updateServer);\nractive.observe('config.isAdmin', updateServer);\nractive.observe('commentCount', updateServer);  This is unecessarily verbose, now with space delimited observers this becomes a single line.  ractive.observe('user.username config.isAdmin commentCount', updateServer);  This will work with patterns observers as well.  ractive.observe('user.* config.* commentCount', updateServer);", 
            "title": "Space Delimited Observers"
        }, 
        {
            "location": "/concepts/data-binding/#a-gotcha-to-be-aware-of", 
            "text": "Observers will be notified whenever the new value is not equal to the old value -  sort of .  What does 'not equal' mean? Well, with  primitive values  such as strings and numbers, that's easy - they're either identical (in the  ===  sense) or they're not.  With objects and arrays (hereafter, just 'objects', since that's what arrays technically are), it's not so straightforward:  a = { one: 1, two: 2, three: 3 };\nb = { one: 1, two: 2, three: 3 };\n\nalert( a === b ); // alerts 'false' - they look the same, but they ain't\n\nb = a;\nb.four = 4;\n\nalert( a === b ); // alerts 'true'. Hang on, `a` didn't have a 'four' property?\nalert( a.four ); // alerts '4'. Oh. Right.  So one the one hand, objects which look identical aren't. On the other, you can set a property of an object and have no idea whether doing so resulted in a change.  There are two possible responses to this problem. First, we could do a 'deep clone' of an object whenever we do  ractive.set(keypath, object) , using an algorithm similar to  jQuery extend . That would mean any references you held to  object  would become irrelevant. It would also mean a whole load of extra computation, and probably some very strange behaviour with cyclical data structures. No thanks.  The second is to sidestep the issue, and simply state that for the purposes of determining whether to notify observers,  no two objects are equal, even when they're identical  (unless they're both  null , of course - since  typeof null === 'object'  due to a  bug in the language ).  This is the safest, sanest behaviour, but it can lead to unexpected behaviour in one situation - accessing properties within an observer:  obj = { a: { b: { c: 1 } } };\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: { obj: obj }\n});\n\n// We observe 'obj.a.b.c' indirectly, and directly\nractive.observe({\n  'obj': function ( newObj, oldObj ) {\n    alert( 'Indirect observer: changed from ' + oldObj.a.b.c + ' to ' + newObj.a.b.c );\n  },\n  'obj.a.b.c': function ( newC, oldC ) {\n    alert( 'Direct observer: changed from ' + oldC + ' to ' + newC );\n  }\n});\n\nobj.a.b.c = 2;\n\n// The next line will cause two alerts:\n//   'Direct observer: changed from 1 to 2'\n//   'Indirect observer: changed from 2 to 2' - because oldObj === newObj\nractive.set( 'obj', obj );  This is definitely an edge case, but one that it's worth being aware of.", 
            "title": "A 'gotcha' to be aware of"
        }, 
        {
            "location": "/concepts/data-binding/#parallel-dom", 
            "text": "Ractive works by maintaining a simplified model of the part of the DOM that it's responsible for. This model contains all the information - about data-binding, event handling and so on - that it needs to keep things up-to-date.  You can inspect the parallel DOM to understand what's going on under the hood, if you're into that sort of thing. Each Ractive instance, once rendered, has a  fragment  property. Each fragment has a number of properties:   contextStack  - the context stack in which mustache  references  should be evaluated  root  - a reference to the Ractive instance to which it belongs  owner  - the  item  that owns this fragment (in the case of the root fragment, the same as  root )  items  - the items belonging to this fragment   Items  means elements, text nodes, and mustaches. Elements may have fragments of their own (i.e. if they have children). A partial mustache will have a fragment, and a section mustache will have zero or more fragments depending on the value of its keypath.  Elements may also have attributes, which have a different kind of fragment (a  text fragment  as opposed to a  DOM fragment ), containing text and mustaches.  Each item has a  descriptor , which is something like DNA. This comes straight from the  parsed template .  This is the briefest of overviews - if you want to gain a deeper understanding of what's going on under the hood,  use the source .", 
            "title": "Parallel DOM"
        }, 
        {
            "location": "/concepts/data-binding/#two-way-binding", 
            "text": "By default, a Ractive instance will update its internal model based on user input, if you have  input ,  textarea  or  select  elements.  If that's unhelpful for your app, you can disable it by passing  twoway: false  as an  initialisation option .  Two-way vinding can also be overridden on a per-element basis using the  twoway  directive e.g.  input value=\"{{foo}}\" twoway=\"false\" . If the  twoway  option is set to false, it can be overridden on a per-element bases using  twoway  as a boolean attribute e.g.  input value=\"{{foo}}\" twoway  or  input value=\"{{foo}}\" twoway=\"true\" .", 
            "title": "Two-way binding"
        }, 
        {
            "location": "/concepts/data-binding/#input-elements", 
            "text": "Two-way binding works with  input  elements of any type, including the new HTML5 types such as  color  or  email . In most cases, you just add a mustache as the  value  attribute - this must be a single, standard  interpolator  mustache, like this:  input placeholder='Type your name' value='{{user.name}}'   In the example above, any changes the user makes to the input will be reflected in the  user.name  property.", 
            "title": "&lt;input&gt; elements"
        }, 
        {
            "location": "/concepts/data-binding/#checkboxes", 
            "text": "Checkboxes are used to flag a property as  true  or  false . Rather than binding the  value  attribute, we bind the  checked  attribute:  label \n     input type='checkbox' checked='{{on}}' \n    The lights are {{ on ? 'on' : 'off' }} /label   (True HTML nerds will recognise that  boolean attributes  such as checked don't have a value, as such - they either exist on an element or they don't. This makes life unnecessarily difficult; Ractive treats dynamic (i.e., controlled by a mustache) boolean attributes as present if the mustache is  true , absent if  false .)  Checkboxes may also be bound by the  name  attribute, which will result in the value specified in the  name  attribute containing an array of selected checkbox values.  {{#colors}}\n   label \n     input type='checkbox' name='{{selected}}' value='{{.}}' / {{.}}\n   /label \n{{/}}  If  colors  is an array,  ['Red', 'Yellow', 'Green', 'Blue'] , then checking the first box will result in  selected  becoming  ['Red'] . Checking the third box will result in  selected  becoming  ['Red', 'Green'] . The array may also be updated from code using  set  or any of the array modification methods available to Ractive, and the checkboxes will be updated to reflect the contents of the array in the Ractive viewmodel.  Note  that checkboxes with both a  checked  and  name  binding will  only  bind on  checked , not both. The  name  binding will be treated\nas a normal mustache variable.", 
            "title": "Checkboxes"
        }, 
        {
            "location": "/concepts/data-binding/#radios", 
            "text": "Radio buttons can be controlled in the same way as checkboxes. However the chances are, if you're using radio buttons, you have a set of mutually exclusive options to choose between. In this case, if you set the  name  attribute on a radio input to e.g.  {{someValue}} ,  someValue  will reflect the  value  of the currently checked option:  label input type='radio' name='{{color}}' value='red' checked  Red /label  label input type='radio' name='{{color}}' value='green'  Green /label  label input type='radio' name='{{color}}' value='blue'  Blue /label  p The currently selected color is  span style='color: {{color}};' {{color}} /span /p   In the example above, the value of  color  will initially be  'red'  (because that input is checked in the template), and will update as and when the user selects another option.", 
            "title": "Radios"
        }, 
        {
            "location": "/concepts/data-binding/#textarea-elements", 
            "text": "Textareas work exactly the same as standard text inputs - slap a dynamic  value  attribute on them, and you're done:  textarea value='{{content}}' /textarea", 
            "title": "&lt;textarea&gt; elements"
        }, 
        {
            "location": "/concepts/data-binding/#select-elements", 
            "text": "Drop-down select menus are good when you have many options to choose from. They're straightforward to use in Ractive:  select value='{{selectedCountry}}' \n     option selected disabled Select a country /option \n    {{#countries}}\n         option value='{{id}}' {{name}} /option \n    {{/countries}} /select   ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        countries: [\n            { id: 'AFG', name: 'Afghanistan' },\n            { id: 'ALB', name: 'Albania' },\n            { id: 'DZA', name: 'Algeria' },\n            { id: 'ASM', name: 'American Samoa' }\n            // and so on...\n        ]\n    }\n});  In the example above, no country will initially be selected. If the user were to select Afghanistan from the list, the value of  selectedCountry  would change to  'AFG' .", 
            "title": "&lt;select&gt; elements"
        }, 
        {
            "location": "/concepts/data-binding/#contenteditable", 
            "text": "Ractive can two-way data bind contenteditable elements.  var ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        content: 'Edit me'\n    }\n});\n\nractive.observe('content', function(newValue, oldValue, keypath) {\n    //newValue will contain the new content of the div\n});  myTemplate  div contenteditable= true  value= {{content}} /div   This will be rendered as  div contenteditable= true Edit Me /div   As the user edits the data the  content  will update, and observe will fire.  There are a few caveats that you need to know. Despite the value binding with only two curly braces  {{content}}  (double curly braces are required for two way data binding) the returned content may or may not be a string of HTML. If a user presses enter after most browsers will insert a  br / . The  content  would be set to  Edit Me br/ . Additionally anything you set to  content  would be rendered as HTML and not escaped despite the lack of triple curly braces( {{{content}}} ).  ractive.set('content', ' ul li Edit Me /li /ul ');  This would actually render an editable unordered list.  Be aware that not all browsers actually operate the same way when it comes to interacting with contenteditable. HTML generated by one browser may differ from another.", 
            "title": "contenteditable"
        }, 
        {
            "location": "/concepts/data-binding/#ambiguous-references", 
            "text": "A mustache used in a two-way binding context must have an  unambiguous reference . Consider the following:  {{#foo}}\n     input value='{{bar}}' \n{{/foo}}  ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: { foo: {} }\n});  Ractive must decide, straight away, what  keypath  to bind the input's  value  attribute to. It will first see if it can  reference  ( 'bar' ) given the current context stack (which includes a single context -  'foo' ). It can't, so it is forced to make an assumption - that the  'bar'  reference should resolve to the  'bar'  keypath.  But this might not be what you want - maybe you  did  want it to resolve to  'foo.bar' .  You have two options - either use a  restricted reference , i.e.  input value='{{.bar}}' , or ensure that  foo  has a  bar  property (even if the initial value is  undefined ).", 
            "title": "Ambiguous references"
        }, 
        {
            "location": "/concepts/data-binding/#lazy-updates", 
            "text": "Under the hood, Ractive always binds to the  change  event (and the  click  event in IE, in the case of checkboxes, due to an IE bug). By default, it will also bind to the  input  event, which means the model is updated instantly when the user enters data (the  change  event fires when a change is  'committed by the user' ). In some situations, that's not what you want - if you want to only bind to  change , pass in  lazy: true  as an  initialisation option .  As with  twoway , laziness may be specified on a per-element basis. Besides  true  (or simply having the attribute preset) and  false  values, the  lazy  directive may also be a number that specifies the number of milliseconds to wait after the last  input  event fires with subsequent  input  events resetting the timeout. For instance  input value=\"{{foo}}\" lazy  will trigger updates to  foo  on  change  and  input value=\"{{foo}}\" lazy=\"1000\"  will trigger updates 1 second after the last keypress.", 
            "title": "Lazy updates"
        }, 
        {
            "location": "/concepts/data-binding/#observing-changes", 
            "text": "To use user input elsewhere in your app, you'll need to observe it using  ractive.observe() :  input placeholder='Type your name' value='{{user.name}}'   ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate\n});\n\nractive.observe( 'user.name', function ( newValue ) {\n    app.user.name = newValue;\n    triggerSomeBehaviour();\n});", 
            "title": "Observing changes"
        }, 
        {
            "location": "/concepts/events/", 
            "text": "Overview\n\n\nLike many libraries, Ractive implements the \npublish/subscribe\n mechanism to allow you to respond to, or trigger, particular events.\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\nactivate\nclick me!\n/button\n'\n});\n\nractive.on( 'activate', function ( event ) {\n  alert( 'Activating!' );\n});\n\n\n\n\nThere are actually two-levels of event handling in Ractive:\n\n\n\n\nThe lower-level interaction with DOM events or \ncustom events\n. These are specified using \nEvent directives\n that also specify how the event is to be handled using either \nproxy events\n or \nmethod calls\n.\n\n\nThe \npublish-subscribe\n api and event system within Ractive and between components. Proxy events bridge the DOM event into a Ractive event, whereas method calls directly invoke the ractive instance and do not use the pub/sub infrastructure.\n\n\n\n\n\nThe \npublish-subscribe\n event handling in Ractive allows you to consistently handle three different categories of generated events:\n\n\n\n\nProxy events\n, mentioned above, proxy DOM and custom events defined in your template\n\n\nMethod calls\n are a more powerful alternative to proxy events that allow you to execute one or more expressions when an event fires.\n\n\nLifecycle events\n generated by each ractive instance - such as \ninit\n, \nrender\n and \nteardown\n\n\nCustom events\n fired in code using \nractive.fire()\n, which can be anything you like\n\n\n\n\nHygiene\n\n\nOne of the advantages of using Ractive events is that, in addition to being able to manually unsubscribe events, both DOM events and\nRactive Events will be automatically unsubscribed when the ractive instance or component is torndown.\n\n\nIn practice, this means adding a template directive like \non-click='select'\n is all that is needed to manage the DOM event.\n\n\nBubbling\n\n\nEvents that fire in components will bubble up the view hierarchy - \nsee this demonstration\n. Bubbling events are namespaced by the element name used for that component in the template:\n\n\nractive = new Ractive({\n    el: document.body,\n    template: '\nwidget/\n',\n    components: {\n        widget: Ractive.extend({\n            template: '\nbutton on-click=\nselect\nSelect Me\n/button\n'\n        })\n    },\n    oninit: function () {\n        this.on( 'widget.select', function () {\n            alert('selected!');\n        });\n    }\n});\n\n\n\n\nThe event will continue to bubble up under the name of the originating component, not the name of each parent component.\n\n\nCancelling\n\n\nReturning \nfalse\n from an event handler will prevent that event from bubbling further:\n\n\nthis.on( 'widget.select', function () {\n    return false;\n});\n\n\n\n\n\nSibling event handlers will still be called. Cancelling only applies to bubbling up to the next level of the view hierarchy.\n\n\nNote that returning \nfalse\n has a dual purpose of both cancelling the view hierarchy event bubbling \nand\n cancelling the DOM Event if the event was DOM-based.\n\n\nTemplate directives for handling component events \nimplicitly\n cancel bubbling of the subscribed event:\n\n\nwidget on-foo='bar'/\n\n\n\n\n\nIn this example, \nwidget.foo\n will not bubble. Instead a new event \nbar\n will be fired and bubbled, assuming the above template is also contained in a component, under the name of the new component.\n\n\nThe \nevent.component\n Property\n\n\nEvents that bubble add a \ncomponent\n property to the event object that is the component ractive instance raising the event:\n\n\nthis.on( 'widget.select', function ( event ) {\n    event.component.observe( 'foo', function ( n, o, k ) {\n        console.log( 'foo changed from', o, 'to', n );\n    });\n});\n\n\n\n\n\nDirectives\n\n\nDOM events are handled with template directives that take the form of element attributes, similar to global native DOM handlers, but are prefixed with \non-\n plus the name of the event:\n\n\nbutton on-click=\nactivate\nclick me!\n/button\n\n\n\n\n\nYou can assign multiple events by separating them with a hyphen:\n\n\ndiv on-mouseover-mousemove='@this.set( \nhover\n, true )'\n...\n/div\n\n\n\n\n\nThe structure of the attribute content will vary depending on whether you are using \nproxy events\n (the first example) or \nmethod calls\n (the second example). See each respective section for more details.\n\n\nDOM events can be any supported event on the element node. Touch events - \ntouchstart\n, \ntouchmove\n, \ntouchend\n, \ntouchcancel\n, and \ntouchleave\n (not w3c, but supported in some browsers) - can be used as well, and will be safely ignored if not supported by the current browser.\n\n\nDOM Events will be automatically unsubscribed when the ractive instance is torndown.\n\n\nCancelling DOM Events\n\n\nSee \npublish-subscribe\n for information on automatically stopping DOM event propagation and default action.\n\n\nCustom events\n\n\nIn addition to all the usual DOM events, you can use \ncustom events\n via \nevent plugins\n. These allow you to define what conditions on the node should generate a directive-level event.\n\n\nFor example, you could add gesture support to your app with \nractive-touch\n, which integrates \nHammer.js\n with Ractive.\n\n\nOnce defined, the custom event can then be used like any other event directive:\n\n\ndiv on-swipeleft=\nnextPage\n...\n/div\n\n\n\n\n\nBe aware that custom event names take precedence over native DOM event names.\n\n\nComponent event directives\n\n\nTemplate component elements can also have event directives:\n\n\nmy-widget on-foo=\nbar\n/\n\n\n\n\n\nHowever, there are some differences and limitations to component event directives:\n\n\n\n\nThese only respond to component raised events and are not DOM event or custom event subscriptions.\n\n\nArguments to proxy events are ignored\n\n\nMethod calls are not currently supported\n\n\nPattern matching \nis\n supported (see \npublish-subscribe\n):\n\n\n\n\nmy-widget on-foo.*=\nbar\n/\n\n\n\n\n\nMethod calls\n\n\nNote:\n Unqualified event method calls are deprecated and have been replaced with event expressions that resolve the same way as every other expression in a Ractive template. This means that to call, for instance, \nset('foo', 'bar')\n in an event, you would now use \n@this.set('foo', 'bar')\n. Unfortunately, this adds a bit of boilerplate to common method calls, but it is also resolves the disparity between event directives and other template references, allows calling data methods from events, and allows executing multiple, possibly more complex, expressions when an event fires.\n\n\nAs an alternative to \nevent directive\n, right from your template:\n\n\np\nfoo is {{foo}}\n/p\n\n\nbutton on-click='@this.toggle(\nfoo\n)'\ntoggle foo\n/button\n\n\n\n\n\nIn this case, because \nractive.toggle()\n is a built-in method, clicking the button will toggle the value of \nfoo\n between \ntrue\n and \nfalse\n (\ndemo\n).\n\n\nThis also works with custom methods:\n\n\nvar ractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\n@this.klaxon()\nsound the klaxon\n/button\n',\n  audio: new Audio( 'klaxon.mp3' ),\n  klaxon: function () {\n    this.audio.play();\n  }\n});\n\n\n\n\nYou can pass as many arguments to the method as you like, including data references:\n\n\n{{#each items :i}}\n  \nbutton on-click='@this.select(this,i)'\nselect this item\n/button\n\n{{/each}}\n\n\n\n\nNotice that mustaches are \nnot\n used with data reference in method calls, i.e. \n{{i}}\n and will cause errors if they are. String literals need to be in quotes:\n\n\nbutton on-click='@this.set(\nfoo\n, true)'\nmake foo true\n/button\n\n\n\n\n\nYou can also pass the \nevent\n object, or properties thereof (\nevent.original\n is the original DOM event) (\ndemo\n):\n\n\ndiv\n  on-mousemove='@this.set({\n    x: event.original.clientX,\n    y: event.original.clientY\n  })'\n  on-mouseleave='@this.set({\n    x: \nunknown\n,\n    y: \nunknown\n\n  })'\n\n\n  \np\ncurrent mouse position: {{x}} x {{y}}\n/p\n\n\n/div\n\n\n\n\n\nThe \nevent\n object is also available within body of the method call function as \nthis.event\n. Note that methods on your Ractive instance that may handle your events are effectively part of your public API, and \nthis.event\n will only be available during invocations triggered by an event.\n\n\nThe \nevent\n argument is also extended with contextual helper methods. See \ncontext objects\n.\n\n\nIf you need to evaluate multiple expressions from an event directive, simply separate them with a \n,\n. For instance:\n\n\n{{#each someList as item}}\n\ndiv\n\n  {{item.display}}\n  \na href=\n#\n on-click=\nevent.pop('../'), @this.notifyUser('item removed!'), false\n\n    Remove and Notify\n  \n/a\n\n\n/div\n\n{{/each}}\n\n\n\n\nNote that this is a list of independent expressions, and as long as one doesn't throw, they will all be evaluated.\n\n\nCancelling events\n\n\nAs with proxy events, you can cancel a DOM event by returning \nfalse\n from your event handler. Ractive with then call \npreventDefault()\n and \nstopPropagation()\n on the original DOM event. You can also call any methods on the original event by having it passed to your handler or accessing it using \nthis.event.original\n. With event expressions, you can force the cancellation regardless of the return from any methods you call by simply including \nfalse\n as the last expression in your list, as above in the 'Remove and Notify' example. You can also override cancellation in much the same way by using \ntrue\n instead of \nfalse\n.\n\n\nProxy events\n\n\nRactive has a concept of \nproxy events\n, which translate a user \naction\n (e.g. a mouseclick) defined via an \nevent directive\n into an \nintention\n (e.g. 'select this option'). This allows you to handle user interaction in a readable, declarative fashion, without resorting to peppering your markup with class names to use as 'hooks' (which must then be kept consistent between your markup and your JavaScript code).\n\n\nAs with all events in Ractive, you subscribe with \nractive.on()\n (also see \npublish-subscribe\n). Proxy events declare the handler name of the event that will be fired, along with any optional arguments:\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\nactivate\nclick me!\n/button\n'\n});\n\nractive.on( 'activate', function ( event ) {\n  alert( 'Activating!' );\n});\n\n\n\n\nIn this example, it is \nactivate\n (and not \nclick\n!) that is the name of the handler event that will be fired for any registered handlers created via \nractive.on()\n.\n\n\nEvent arguments\n\n\nThe \nevent\n object\n\n\nThe first argument to a proxy event handler is always a Ractive \nevent\n object. It contains various properties:\n\n\n\n\nevent.name\n - the name of the event, in this case 'activate'\n\n\nevent.node\n - the DOM node in question\n\n\nevent.keypath\n - the \nkeypath\n of the current context\n\n\nevent.context\n - the value of \nthis.get(event.keypath)\n\n\nevent.index\n - a map of index references\n\n\nevent.component\n - the component that raised the event, only present on \nbubbled events\n\n\nevent.original\n - the original DOM event, if available\n\n\n\n\nIn the example above, \nevent.keypath\n might be \nitems.0\n for the first item in the list, \nitems.1\n for the second, and so on. The \nevent.index\n map would have a property \ni\n, which would correspond to those indices.\n\n\nThe event object is also available in event handlers using \nthis.event\n, see \npublish-subscribe\n for more details.\n\n\nCustom arguments\n\n\nNOTE:\n Arguments to proxy events have been deprecated because they are too easy to break. If you need to pass arguments with your event, you can use \n@this.fire('myEvent', event, arg1, arg2, etc)\n.\n\n\nWe might want to pass arguments to our handler in addition to the \nevent\n object. We can do that by listing them, comma-separated, after the event name:\n\n\nh1\nLet's shop!\n/h1\n\n\nul\n\n  {{#each items: i}}\n    \nli\n\n      \np\n{{i+1}}: {{description}}\n/p\n\n      \nlabel\ninput value='{{qty}}'\n Quantity\n/label\n\n\n      \n!-- when the user clicks this button, add {{qty}} of this item --\n\n      \nbutton on-click='addToCart:{{this}},{{qty}}'\nAdd to cart\n/button\n\n    \n/li\n\n  {{/each}}\n\n/ul\n\n\n\n\n\nractive.on( 'addToCart', function ( event, item, qty ) {\n  /* code goes here */\n});\n\n\n\n\nCancelling DOM events\n\n\nIf you return \nfalse\n from a proxy event handler, ractive will automatically call both \npreventDefault()\n and \nstopPropagation()\n on the original DOM event.\n\n\nNote that returning \nfalse\n has a dual purpose of both cancelling further bubbling up the view hierarchy \nevent bubbling\n \nas well as\n cancelling the DOM Event if the event was DOM-based.\n\n\nIf you only want to cancel the DOM event, you can call the appropriate methods directly on \nevent.original\n or \nthis.event.original\n, which are both references to the current DOM event object.\n\n\nReserved event names\n\n\nNote: the built-in \nlifecycle events\n are \nreserved\n, which means you can't use their names as proxy events.\n\n\nDynamic proxy event names\n\n\nMustache references\n can be used as proxy event names:\n\n\nbutton on-click=\n{{handler}}\nclick me!\n/button\n\n\n\n\n\nIn practive this is of limited value, but a more important side effect is that if no handler is specified (a falsey value) the DOM event is not subscribed and will unsubscribe or resubscribe as the handler value changes. Combined with a conditional section, this allows a proxy event to be conditionally subscribed \nat the DOM level\n:\n\n\nbutton on-click=\n{{#active}}select{{/}}\nclick me!\n/button\n\n\n\n\n\nIn this example, the DOM \nclick\n event is subscribed and unsubscribed as the value of \nactive\n is truthy or falsey.\n\n\nPublish Subscribe\n\n\nLike many libraries, Ractive implements the \npublish/subscribe\n mechanism to allow you to respond to, or trigger, particular events.\n\n\nSubscribe\n\n\nTo subscribe to an event, use \nractive.on()\n:\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\nactivate\nclick me!\n/button\n'\n});\n\nractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});\n\n\n\n\nThis can be used to subscribe to any of the following type of events:\n\n\n\n\nProxy events\n for DOM and custom events defined in your template\n\n\nLifecycle events\n generated by each ractive instance - such as \ninit\n, \nrender\n and \nteardown\n\n\nCustom events\n fired in code using \nractive.fire()\n, which can be anything you like, see below.\n\n\n\n\nMultiple events to one handler\n\n\nYou can subscribe a handler to more than one event by separating event names with a space:\n\n\nractive.on( 'activate select', function () {...} );\n\n\n\n\nThis example will fire for either an \nactivate\n event or a \nselect\n event.\n\n\nObject map of multiple event/handler pairs\n\n\nMultiple hander/function pairs can be subscribed using an object hash:\n\n\nractive.on({\n    activate: function () {...},\n    select: function () {...}\n});\n\n\n\n\nWildcard pattern handlers\n\n\nEvent names that use a keypath-like name can be subscribed using the pattern-matching wildcard \"\n*\n\" for any name path segment:\n\n\nractive.on( 'foo.*', function () {...} );\n\n\n\n\nThis example will fire on any event name that starts with \nfoo.\n - \nfoo.active\n, \nfoo.select\n, etc.\n\n\nThis is very useful with \nevent bubbling\n and auto-prefixed event names that bubble up from components.\n\n\nBe aware that handlers like \nwidget.*\n or \n*\n will fire for \nall\n matching events, including \nlifecycle events\n.\n\n\nAccessing the event object\n\n\nIn addition to the event argument that is passed with proxy events, the event object can be accessed using \nthis.event\n in the function body of any handler. This object is also present in non-proxy events including lifecycle events, though it includes a more limited set of properties.\n\n\nProperties on all \nthis.event\n objects:\n\n\n\n\nthis.event.name\n - the name of the event\n\n\nthis.event.context\n - the value of \nthis.get(event.keypath)\n or \nractive.get()\n for non-proxy events\n\n\nthis.event.component\n - the component that raised the event, only present on \nbubbled events\n\n\nthis.event.original\n - the original DOM event, if available\n\n\n\n\nProperties only on proxy events:\n\n \nthis.event.node\n - the DOM node in question\n\n \nthis.event.keypath\n - the \nkeypath\n of the current context\n* \nthis.event.index\n - a map of index references\n\n\nOne useful aspect of \nthis.event\n is that the name of the event can be determined when wildcards are used:\n\n\nractive.on( 'foo.*', function () {\n    console.log( this.event.name );\n});\n\n\n\n\nCancelling DOM events\n\n\nIf you return 'false' from a proxy event handler, ractive will automatically call both \npreventDefault()\n and \nstopPropagation()\n on the original DOM event.\n\n\nNote that returning \nfalse\n has a dual purpose of both cancelling the view hierarchy \nevent bubbling\n \nas well as\n cancelling the DOM Event if the event was DOM-based.\n\n\nUnsubscribe\n\n\nEvent handlers are automatically removed if the instance is torn down (e.g. with \nractive.teardown()\n) (which also happens as components are removed due to template/data logic).\n\n\nYou can also unsubscribe event handlers manually using one of two approaches:\n\n\nvar listener = ractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});\n\n// later...\nlistener.cancel();\n\n\n\n\nor...\n\n\nvar handler = function () {\n  alert( 'Activating!' );\n};\n\nractive.on( 'activate', handler );\n\n// later...\nractive.off( 'activate', handler );\n\n\n\n\nIn the second case, note that if you don't specify a handler, all 'activate' handlers will be removed. If you don't specify an event name, \nall\n event handlers will be removed from the instance. See \nractive.off()\n for more detail.\n\n\nThe \nractive.off()\n method is chainable for easily replacing subscribtions:\n\n\nractive.off( 'activate' ).on( 'activate', function () {...} );\n\n\n\n\nPublish\n\n\nIn addition to the built-in \nlifecycle events\n and \nproxy events\n, you can fire your own events with \nractive.fire()\n.\n\n\nThis is most useful in the context of a \ncomponent\n that needs to emit custom events. Here's a (somewhat contrived) example:\n\n\nvar Ticker = Ractive.extend({\n  oninit: function () {\n    var i = 1;\n\n    this.interval = setInterval( function () {\n      this.fire( 'tick', i++ );\n    }.bind( this ), 1000 );\n  },\n  onteardown: function () {\n    clearInterval( this.interval );\n  }\n});\n\nvar ticker = new Ticker();\n\nticker.on( 'tick', function ( i ) {\n  console.log( i % 2 ? 'tick' : 'tock' );\n});", 
            "title": "Events"
        }, 
        {
            "location": "/concepts/events/#overview", 
            "text": "Like many libraries, Ractive implements the  publish/subscribe  mechanism to allow you to respond to, or trigger, particular events.  ractive = new Ractive({\n  el: 'body',\n  template: ' button on-click= activate click me! /button '\n});\n\nractive.on( 'activate', function ( event ) {\n  alert( 'Activating!' );\n});  There are actually two-levels of event handling in Ractive:   The lower-level interaction with DOM events or  custom events . These are specified using  Event directives  that also specify how the event is to be handled using either  proxy events  or  method calls .  The  publish-subscribe  api and event system within Ractive and between components. Proxy events bridge the DOM event into a Ractive event, whereas method calls directly invoke the ractive instance and do not use the pub/sub infrastructure.   \nThe  publish-subscribe  event handling in Ractive allows you to consistently handle three different categories of generated events:   Proxy events , mentioned above, proxy DOM and custom events defined in your template  Method calls  are a more powerful alternative to proxy events that allow you to execute one or more expressions when an event fires.  Lifecycle events  generated by each ractive instance - such as  init ,  render  and  teardown  Custom events  fired in code using  ractive.fire() , which can be anything you like", 
            "title": "Overview"
        }, 
        {
            "location": "/concepts/events/#hygiene", 
            "text": "One of the advantages of using Ractive events is that, in addition to being able to manually unsubscribe events, both DOM events and\nRactive Events will be automatically unsubscribed when the ractive instance or component is torndown.  In practice, this means adding a template directive like  on-click='select'  is all that is needed to manage the DOM event.", 
            "title": "Hygiene"
        }, 
        {
            "location": "/concepts/events/#bubbling", 
            "text": "Events that fire in components will bubble up the view hierarchy -  see this demonstration . Bubbling events are namespaced by the element name used for that component in the template:  ractive = new Ractive({\n    el: document.body,\n    template: ' widget/ ',\n    components: {\n        widget: Ractive.extend({\n            template: ' button on-click= select Select Me /button '\n        })\n    },\n    oninit: function () {\n        this.on( 'widget.select', function () {\n            alert('selected!');\n        });\n    }\n});  The event will continue to bubble up under the name of the originating component, not the name of each parent component.", 
            "title": "Bubbling"
        }, 
        {
            "location": "/concepts/events/#cancelling", 
            "text": "Returning  false  from an event handler will prevent that event from bubbling further:  this.on( 'widget.select', function () {\n    return false;\n});  Sibling event handlers will still be called. Cancelling only applies to bubbling up to the next level of the view hierarchy.  Note that returning  false  has a dual purpose of both cancelling the view hierarchy event bubbling  and  cancelling the DOM Event if the event was DOM-based.  Template directives for handling component events  implicitly  cancel bubbling of the subscribed event:  widget on-foo='bar'/   In this example,  widget.foo  will not bubble. Instead a new event  bar  will be fired and bubbled, assuming the above template is also contained in a component, under the name of the new component.", 
            "title": "Cancelling"
        }, 
        {
            "location": "/concepts/events/#the-eventcomponent-property", 
            "text": "Events that bubble add a  component  property to the event object that is the component ractive instance raising the event:  this.on( 'widget.select', function ( event ) {\n    event.component.observe( 'foo', function ( n, o, k ) {\n        console.log( 'foo changed from', o, 'to', n );\n    });\n});", 
            "title": "The event.component Property"
        }, 
        {
            "location": "/concepts/events/#directives", 
            "text": "DOM events are handled with template directives that take the form of element attributes, similar to global native DOM handlers, but are prefixed with  on-  plus the name of the event:  button on-click= activate click me! /button   You can assign multiple events by separating them with a hyphen:  div on-mouseover-mousemove='@this.set(  hover , true )' ... /div   The structure of the attribute content will vary depending on whether you are using  proxy events  (the first example) or  method calls  (the second example). See each respective section for more details.  DOM events can be any supported event on the element node. Touch events -  touchstart ,  touchmove ,  touchend ,  touchcancel , and  touchleave  (not w3c, but supported in some browsers) - can be used as well, and will be safely ignored if not supported by the current browser.  DOM Events will be automatically unsubscribed when the ractive instance is torndown.", 
            "title": "Directives"
        }, 
        {
            "location": "/concepts/events/#cancelling-dom-events", 
            "text": "See  publish-subscribe  for information on automatically stopping DOM event propagation and default action.", 
            "title": "Cancelling DOM Events"
        }, 
        {
            "location": "/concepts/events/#custom-events", 
            "text": "In addition to all the usual DOM events, you can use  custom events  via  event plugins . These allow you to define what conditions on the node should generate a directive-level event.  For example, you could add gesture support to your app with  ractive-touch , which integrates  Hammer.js  with Ractive.  Once defined, the custom event can then be used like any other event directive:  div on-swipeleft= nextPage ... /div   Be aware that custom event names take precedence over native DOM event names.", 
            "title": "Custom events"
        }, 
        {
            "location": "/concepts/events/#component-event-directives", 
            "text": "Template component elements can also have event directives:  my-widget on-foo= bar /   However, there are some differences and limitations to component event directives:   These only respond to component raised events and are not DOM event or custom event subscriptions.  Arguments to proxy events are ignored  Method calls are not currently supported  Pattern matching  is  supported (see  publish-subscribe ):   my-widget on-foo.*= bar /", 
            "title": "Component event directives"
        }, 
        {
            "location": "/concepts/events/#method-calls", 
            "text": "Note:  Unqualified event method calls are deprecated and have been replaced with event expressions that resolve the same way as every other expression in a Ractive template. This means that to call, for instance,  set('foo', 'bar')  in an event, you would now use  @this.set('foo', 'bar') . Unfortunately, this adds a bit of boilerplate to common method calls, but it is also resolves the disparity between event directives and other template references, allows calling data methods from events, and allows executing multiple, possibly more complex, expressions when an event fires.  As an alternative to  event directive , right from your template:  p foo is {{foo}} /p  button on-click='@this.toggle( foo )' toggle foo /button   In this case, because  ractive.toggle()  is a built-in method, clicking the button will toggle the value of  foo  between  true  and  false  ( demo ).  This also works with custom methods:  var ractive = new Ractive({\n  el: 'body',\n  template: ' button on-click= @this.klaxon() sound the klaxon /button ',\n  audio: new Audio( 'klaxon.mp3' ),\n  klaxon: function () {\n    this.audio.play();\n  }\n});  You can pass as many arguments to the method as you like, including data references:  {{#each items :i}}\n   button on-click='@this.select(this,i)' select this item /button \n{{/each}}  Notice that mustaches are  not  used with data reference in method calls, i.e.  {{i}}  and will cause errors if they are. String literals need to be in quotes:  button on-click='@this.set( foo , true)' make foo true /button   You can also pass the  event  object, or properties thereof ( event.original  is the original DOM event) ( demo ):  div\n  on-mousemove='@this.set({\n    x: event.original.clientX,\n    y: event.original.clientY\n  })'\n  on-mouseleave='@this.set({\n    x:  unknown ,\n    y:  unknown \n  })' \n   p current mouse position: {{x}} x {{y}} /p  /div   The  event  object is also available within body of the method call function as  this.event . Note that methods on your Ractive instance that may handle your events are effectively part of your public API, and  this.event  will only be available during invocations triggered by an event.  The  event  argument is also extended with contextual helper methods. See  context objects .  If you need to evaluate multiple expressions from an event directive, simply separate them with a  , . For instance:  {{#each someList as item}} div \n  {{item.display}}\n   a href= #  on-click= event.pop('../'), @this.notifyUser('item removed!'), false \n    Remove and Notify\n   /a  /div \n{{/each}}  Note that this is a list of independent expressions, and as long as one doesn't throw, they will all be evaluated.", 
            "title": "Method calls"
        }, 
        {
            "location": "/concepts/events/#cancelling-events", 
            "text": "As with proxy events, you can cancel a DOM event by returning  false  from your event handler. Ractive with then call  preventDefault()  and  stopPropagation()  on the original DOM event. You can also call any methods on the original event by having it passed to your handler or accessing it using  this.event.original . With event expressions, you can force the cancellation regardless of the return from any methods you call by simply including  false  as the last expression in your list, as above in the 'Remove and Notify' example. You can also override cancellation in much the same way by using  true  instead of  false .", 
            "title": "Cancelling events"
        }, 
        {
            "location": "/concepts/events/#proxy-events", 
            "text": "Ractive has a concept of  proxy events , which translate a user  action  (e.g. a mouseclick) defined via an  event directive  into an  intention  (e.g. 'select this option'). This allows you to handle user interaction in a readable, declarative fashion, without resorting to peppering your markup with class names to use as 'hooks' (which must then be kept consistent between your markup and your JavaScript code).  As with all events in Ractive, you subscribe with  ractive.on()  (also see  publish-subscribe ). Proxy events declare the handler name of the event that will be fired, along with any optional arguments:  ractive = new Ractive({\n  el: 'body',\n  template: ' button on-click= activate click me! /button '\n});\n\nractive.on( 'activate', function ( event ) {\n  alert( 'Activating!' );\n});  In this example, it is  activate  (and not  click !) that is the name of the handler event that will be fired for any registered handlers created via  ractive.on() .", 
            "title": "Proxy events"
        }, 
        {
            "location": "/concepts/events/#event-arguments", 
            "text": "", 
            "title": "Event arguments"
        }, 
        {
            "location": "/concepts/events/#the-event-object", 
            "text": "The first argument to a proxy event handler is always a Ractive  event  object. It contains various properties:   event.name  - the name of the event, in this case 'activate'  event.node  - the DOM node in question  event.keypath  - the  keypath  of the current context  event.context  - the value of  this.get(event.keypath)  event.index  - a map of index references  event.component  - the component that raised the event, only present on  bubbled events  event.original  - the original DOM event, if available   In the example above,  event.keypath  might be  items.0  for the first item in the list,  items.1  for the second, and so on. The  event.index  map would have a property  i , which would correspond to those indices.  The event object is also available in event handlers using  this.event , see  publish-subscribe  for more details.", 
            "title": "The event object"
        }, 
        {
            "location": "/concepts/events/#custom-arguments", 
            "text": "NOTE:  Arguments to proxy events have been deprecated because they are too easy to break. If you need to pass arguments with your event, you can use  @this.fire('myEvent', event, arg1, arg2, etc) .  We might want to pass arguments to our handler in addition to the  event  object. We can do that by listing them, comma-separated, after the event name:  h1 Let's shop! /h1  ul \n  {{#each items: i}}\n     li \n       p {{i+1}}: {{description}} /p \n       label input value='{{qty}}'  Quantity /label \n\n       !-- when the user clicks this button, add {{qty}} of this item -- \n       button on-click='addToCart:{{this}},{{qty}}' Add to cart /button \n     /li \n  {{/each}} /ul   ractive.on( 'addToCart', function ( event, item, qty ) {\n  /* code goes here */\n});", 
            "title": "Custom arguments"
        }, 
        {
            "location": "/concepts/events/#cancelling-dom-events_1", 
            "text": "If you return  false  from a proxy event handler, ractive will automatically call both  preventDefault()  and  stopPropagation()  on the original DOM event.  Note that returning  false  has a dual purpose of both cancelling further bubbling up the view hierarchy  event bubbling   as well as  cancelling the DOM Event if the event was DOM-based.  If you only want to cancel the DOM event, you can call the appropriate methods directly on  event.original  or  this.event.original , which are both references to the current DOM event object.", 
            "title": "Cancelling DOM events"
        }, 
        {
            "location": "/concepts/events/#reserved-event-names", 
            "text": "Note: the built-in  lifecycle events  are  reserved , which means you can't use their names as proxy events.", 
            "title": "Reserved event names"
        }, 
        {
            "location": "/concepts/events/#dynamic-proxy-event-names", 
            "text": "Mustache references  can be used as proxy event names:  button on-click= {{handler}} click me! /button   In practive this is of limited value, but a more important side effect is that if no handler is specified (a falsey value) the DOM event is not subscribed and will unsubscribe or resubscribe as the handler value changes. Combined with a conditional section, this allows a proxy event to be conditionally subscribed  at the DOM level :  button on-click= {{#active}}select{{/}} click me! /button   In this example, the DOM  click  event is subscribed and unsubscribed as the value of  active  is truthy or falsey.", 
            "title": "Dynamic proxy event names"
        }, 
        {
            "location": "/concepts/events/#publish-subscribe", 
            "text": "Like many libraries, Ractive implements the  publish/subscribe  mechanism to allow you to respond to, or trigger, particular events.", 
            "title": "Publish Subscribe"
        }, 
        {
            "location": "/concepts/events/#subscribe", 
            "text": "To subscribe to an event, use  ractive.on() :  ractive = new Ractive({\n  el: 'body',\n  template: ' button on-click= activate click me! /button '\n});\n\nractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});  This can be used to subscribe to any of the following type of events:   Proxy events  for DOM and custom events defined in your template  Lifecycle events  generated by each ractive instance - such as  init ,  render  and  teardown  Custom events  fired in code using  ractive.fire() , which can be anything you like, see below.", 
            "title": "Subscribe"
        }, 
        {
            "location": "/concepts/events/#multiple-events-to-one-handler", 
            "text": "You can subscribe a handler to more than one event by separating event names with a space:  ractive.on( 'activate select', function () {...} );  This example will fire for either an  activate  event or a  select  event.", 
            "title": "Multiple events to one handler"
        }, 
        {
            "location": "/concepts/events/#object-map-of-multiple-eventhandler-pairs", 
            "text": "Multiple hander/function pairs can be subscribed using an object hash:  ractive.on({\n    activate: function () {...},\n    select: function () {...}\n});", 
            "title": "Object map of multiple event/handler pairs"
        }, 
        {
            "location": "/concepts/events/#wildcard-pattern-handlers", 
            "text": "Event names that use a keypath-like name can be subscribed using the pattern-matching wildcard \" * \" for any name path segment:  ractive.on( 'foo.*', function () {...} );  This example will fire on any event name that starts with  foo.  -  foo.active ,  foo.select , etc.  This is very useful with  event bubbling  and auto-prefixed event names that bubble up from components.  Be aware that handlers like  widget.*  or  *  will fire for  all  matching events, including  lifecycle events .", 
            "title": "Wildcard pattern handlers"
        }, 
        {
            "location": "/concepts/events/#accessing-the-event-object", 
            "text": "In addition to the event argument that is passed with proxy events, the event object can be accessed using  this.event  in the function body of any handler. This object is also present in non-proxy events including lifecycle events, though it includes a more limited set of properties.  Properties on all  this.event  objects:   this.event.name  - the name of the event  this.event.context  - the value of  this.get(event.keypath)  or  ractive.get()  for non-proxy events  this.event.component  - the component that raised the event, only present on  bubbled events  this.event.original  - the original DOM event, if available   Properties only on proxy events:   this.event.node  - the DOM node in question   this.event.keypath  - the  keypath  of the current context\n*  this.event.index  - a map of index references  One useful aspect of  this.event  is that the name of the event can be determined when wildcards are used:  ractive.on( 'foo.*', function () {\n    console.log( this.event.name );\n});", 
            "title": "Accessing the event object"
        }, 
        {
            "location": "/concepts/events/#cancelling-dom-events_2", 
            "text": "If you return 'false' from a proxy event handler, ractive will automatically call both  preventDefault()  and  stopPropagation()  on the original DOM event.  Note that returning  false  has a dual purpose of both cancelling the view hierarchy  event bubbling   as well as  cancelling the DOM Event if the event was DOM-based.", 
            "title": "Cancelling DOM events"
        }, 
        {
            "location": "/concepts/events/#unsubscribe", 
            "text": "Event handlers are automatically removed if the instance is torn down (e.g. with  ractive.teardown() ) (which also happens as components are removed due to template/data logic).  You can also unsubscribe event handlers manually using one of two approaches:  var listener = ractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});\n\n// later...\nlistener.cancel();  or...  var handler = function () {\n  alert( 'Activating!' );\n};\n\nractive.on( 'activate', handler );\n\n// later...\nractive.off( 'activate', handler );  In the second case, note that if you don't specify a handler, all 'activate' handlers will be removed. If you don't specify an event name,  all  event handlers will be removed from the instance. See  ractive.off()  for more detail.  The  ractive.off()  method is chainable for easily replacing subscribtions:  ractive.off( 'activate' ).on( 'activate', function () {...} );", 
            "title": "Unsubscribe"
        }, 
        {
            "location": "/concepts/events/#publish", 
            "text": "In addition to the built-in  lifecycle events  and  proxy events , you can fire your own events with  ractive.fire() .  This is most useful in the context of a  component  that needs to emit custom events. Here's a (somewhat contrived) example:  var Ticker = Ractive.extend({\n  oninit: function () {\n    var i = 1;\n\n    this.interval = setInterval( function () {\n      this.fire( 'tick', i++ );\n    }.bind( this ), 1000 );\n  },\n  onteardown: function () {\n    clearInterval( this.interval );\n  }\n});\n\nvar ticker = new Ticker();\n\nticker.on( 'tick', function ( i ) {\n  console.log( i % 2 ? 'tick' : 'tock' );\n});", 
            "title": "Publish"
        }, 
        {
            "location": "/concepts/templates/", 
            "text": "Elements\n\n\nStrictly speaking, Ractive templates are are not HTML. It has a few special directives and other constructs built into its element representation to make DOM manipulation a bit easier. You can think of them as \"HTML-like\" - they look like HTML for ease of authoring but are not really HTML nor even a superset of HTML. However, when rendered, they are emitted as perfectly valid HTML.\n\n\nIn addition, Ractive's template parser is not quite as forgiving as the browser's HTML parser either and may throw parser errors where it sees ambiguity. However, it does allow things like implicitly closed elements.\n\n\nConditional attributes\n\n\nYou can wrap one or more attributes inside an element tag in a conditional section, and Ractive will add and remove those attributes as the conditional section is rendered and unrendered. For instance:\n\n\ndiv {{#if highlighted}}class=\nhighlighted\n{{/if}}\nHighlightable element\n/div\n\n\n\n\n\nAny number of attributes can be used in a section, and other \nMustache\n constructs can be used to supply attributes.\n\n\ndiv {{#if highlighted}}class=\nhighlighted {{ anotherClass }}\n title=\nI'm highlighted\n{{/if}}\nHighlightable element\n/div\n\n\n\n\n\nExpressions\n\n\nExpressions allow you to use logic within a template. At their simplest, that may just mean a basic arithmetic operation, such as converting to percentages, or making your \nindex references\n start at 1 rather than 0:\n\n\ndiv class='bar-chart'\n\n  {{#bars:i}}\n    \ndiv style='width: {{ value * 100 }}%;'\n{{ i + 1 }}\n/div\n\n  {{/bars}}\n\n/div\n\n\n\n\n\nOr it could mean formatting a currency so that \n1.79\n renders as \n\u00a31.79p\n:\n\n\np\nPrice: \nstrong\n{{ format( price ) }}\n/strong\n/p\n\n\n\n\n\nOr it could mean adding a class based on some condition:\n\n\na class='button {{ active ? \non\n : \noff\n }}'\nswitch\n/a\n\n\n\n\n\nOr it could mean filtering a list to exclude certain records:\n\n\nul\n\n{{# exclude( list, 'N/A' ) }}\n  \nli\n{{author}}: {{title}}\n/li\n\n{{/ end of filter }}\n\n/ul\n\n\n\n\n\nThese are all examples casually plucked from the air - whether they would be useful or not in real life depends on what you're trying to do. The point is that you can include more of your view logic at the declarative layer - the template - where it's easier to \nreason about\n.\n\n\nFrequently Used Expressions\n\n\nIf you use a particular expression frequently, you can save time by adding it Ractive's default data. This way you won't have to set up the expressions on each individual \nractive\n instance.\n\n\nThe example below adds expressions for some frequenlty used parts of \nmoment.js\n to the default data:\n\n\nvar helpers = Ractive.defaults.data;\nhelpers.fromNow = function(timeString){\n    return moment(timeString).fromNow()\n}\nhelpers.formatTime = function(timeString){\n    return moment(timeString).format(\nddd, h:mmA\n);\n}\nhelpers.humanizeTime = function(timeString){\n    return moment.duration(timeString).humanize();\n}\n\n\n\n\nValid expressions\n\n\nThese are, of course, JavaScript expressions. Almost any valid JavaScript expression can be used, with a few exceptions:\n\n\n\n\nNo assignment operators (i.e. \na = b\n, \na += 1\n, \na--\n and so on)\n\n\nNo \nnew\n, \ndelete\n, or \nvoid\n operators\n\n\nNo function literals (i.e. anything that involves the \nfunction\n keyword)\n\n\n\n\nAside from a subset of global objects (e.g. \nMath\n, \nArray\n, \nparseInt\n, \nencodeURIComponent\n - full list below), any references must be to properties (however deeply nested) of the Ractive instance's data, rather than arbitrary variables. Reference resolution follows the \nnormal process\n.\n\n\nDoes this use \neval\n?\n\n\nYes and no. You've probably read that 'eval is evil', or some other such nonsense. The truth is that while it does get abused, and can theoretically introduce security risks when user input gets involved, there are some situations where it's both necessary and sensible.\n\n\nBut repeatedly \neval\ning the same code is a performance disaster. Instead, we use the \nFunction\n constructor, which is a form of \neval\n, except that the code gets compiled once instead of every time it executes.\n\n\nA note about efficiency\n\n\nUsing the \nFunction\n constructor instead of \neval\n is just one way that Ractive optimises expressions. Consider a case like this:\n\n\n{{a}} + {{b}} = {{ a + b }}\n{{c}} + {{d}} = {{ c+d }}\n\n\n\n\nAt \nparse time\n, Ractive generates an \nabstract syntax tree\n (AST) from these expressions, to verify that it's a valid expression and to extract any references that are used. It then 'stringifies' the AST, so that the expression can later be compiled into a function.\n\n\nAs anyone who has seen minified JavaScript can attest, JavaScript cares not one fig what your variables are called. It also doesn't care about whitespace. So both of the expressions can be stringified the same way:\n\n\n_0+_1\n\n\n\n\n\nWhen we \nevaluate\n \n{{ a + b }}\n or \n{{ c+d }}\n, we can therefore use the same function but with different arguments. Recognising this, the function only gets compiled once, after which it is cached. (The cache is shared between all Ractive instances on the page.) Further, the result of the evaluation is itself cached (until one or more of the dependencies change), so you can repeat expressions as often as you like without creating unnecessary work.\n\n\nAll of this means that you could have an expression within a list section that was repeated 10,000 times, and the corresponding function would be created once \nat most\n, and only called when necessary.\n\n\nThe \nthis\n reference\n\n\nWithin an expression, you can use \nthis\n to refer to the current \ncontext\n:\n\n\nul\n\n  {{#items}}\n    \n!-- here, `this` means 'the current array member' --\n\n    \nli\n{{this.toUpperCase()}}\n/li\n\n  {{/items}}\n\n/ul\n\n\n\n\n\nIn regular mustache, we have something called the \nimplicit iterator\n - \n{{.}}\n - which does the same thing. Ractive allows you to use \nthis\n in place of \n.\n for purely aesthetic reasons.\n\n\nSupported global objects\n\n\n\n\nArray\n\n\nDate\n\n\nJSON\n\n\nMath\n\n\nNaN\n\n\nRegExp\n\n\ndecodeURI\n\n\ndecodeURIComponent\n\n\nencodeURI\n\n\nencodeURIComponent\n\n\nisFinite\n\n\nisNaN\n\n\nnull\n\n\nparseFloat\n\n\nparseInt\n\n\nundefined\n\n\n\n\nFunctions\n\n\nAny functions that you want to call, outside of the available globals above, must be properties of the Ractive instance's data as well. Functions can also depend on other references and will be re-evaulated when one of their dependencies is changed.\n\n\nDepedendencies are determined by capturing references in the viewmodel while the function is executing. Dependencies for functions are re-captured each time the function is executed.\n\n\np\n{{ formattedName() }}\n/p\n\n\n\n\n\nvar ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    user: { firstName: 'John', lastName: 'Public' },\n    formattedName: function() {\n      return this.get('user.lastName') + ', ' + this.get('user.firstName');\n    }\n  }\n};\n\n\n\n\nResult:\n\n\np\nPublic, John\n/p\n\n\n\n\n\nIn this example, the function \nformattedName\n will depend on both \nuser.firstName\n and \nuser.lastName\n, and updating either (or \nuser\n) will cause any expressions referencing \nformattedName\n to be re-evaluated as well.\n\n\nractive.set('user.firstName', 'Jane')\n\n\n\n\nResult:\n\n\np\nPublic, Jane\n/p\n\n\n\n\n\nFunctions on helper objects and third-party libraries\n\n\nYou can also add helper objects to your data and call functions on those objects in expressions. For example, you could add a reference to \nunderscore.js\n:\n\n\nvar ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    items: [ 2, 10, 200, 3, 1, 4],\n    _: _\n  }\n};\n\n\n\n\nAnd use that to sort an array in your template:\n\n\n{{# _.sortBy(items) }}{{.}}, {{/}}\n\n\n!-- Result: --\n\n1, 2, 3, 4, 10, 200,\n\n\n\n\nKeypaths\n\n\nThe main way to interact with a Ractive instance is by setting \nkeypaths\n. A keypath is a string representing the location of a piece of data:\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n});\n\n// Simple keypath\nractive.get( 'foo' ); // returns { bar: 'baz' }\n\n// Compound keypath\nractive.get( 'foo.bar' ); // returns 'baz'\n\n\n\n\nUpstream and downstream keypaths\n\n\nIn the example above, we say that \n'foo.bar'\n is a \ndownstream keypath\n of \n'foo'\n, while \n'foo'\n is an \nupstream keypath\n of \n'foo.bar'\n.\n\n\nArray versus dot notation\n\n\nThe \n'foo.bar'\n keypath is an example of \ndot notation\n. With arrays, you can use dot notation or \narray notation\n, which may feel more familiar (internally, it gets converted to dot notation):\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [ 'a', 'b', 'c' ]\n  }\n});\n\n// Array notation\nractive.get( 'list[0]' ); // returns 'a'\n\n// Dot notation\nractive.get( 'list.0' ); // also returns 'a'\n\n\n\n\nMissing properties\n\n\nOrdinarily in JavaScript, trying to access a child property of an object that didn't exist would cause an error:\n\n\ndata = { numbers: [ 1, 2, 3 ]};\ndata.letters[0]; // throws an error - cannot read property '0' of undefined\n\n\n\n\nWithin Ractive, this will simply return \nundefined\n:\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    numbers: [ 1, 2, 3 ]\n  }\n});\n\nractive.get( 'letters[0]' ); // returns undefined\n\n\n\n\nEscaping\n\n\nWhile not ideal, sometimes properties of objects have \n.\ns in name e.g. \nfoo['bar.baz']\n. Note that while numbers are supported in array notation, strings are not. To access a peypath with a literal \n.\n in one of the keys, you can escape it with a \n\\\n e.g. \nfoo.bar\\.baz\n. Any keys accessible in the template will be unescaped, so if you're trying to use them with simple string concatenation to access a keypath with a \n.\n in it, you'll need to make sure you escape it first.\n\n\nParsing\n\n\nIn order for Ractive to utilize templates, it first parses the templates into a tree-like data structure, much like how a browser's HTML parser would process HTML. This data structure contains everything Ractive needs to know to construct an instance's DOM, data bindings, events and transitions etc.\n\n\n\n\n\nRactive.parse('\ndiv class=\nmessage\nHello World!\n/div\n');\n\n// {\nv\n:4,\nt\n:[{\nt\n:7,\ne\n:\ndiv\n,\nm\n:[{\nn\n:\nclass\n,\nf\n:\nmessage\n,\nt\n:13}],\nf\n:[\nHello World!\n]}]}\n\n\n\n\nNormally, parsing is done automatically. Ractive will use \nRactive.parse()\n under the hood if a string template is provided to the \ntemplate\n initialization option.\n\n\nThe parsed template is not designed to be readable nor editable by a human. It is meant to represent the template structure as an object in a way Ractive understands with as few bytes as possible. Where the template doesn't use Ractive-specific features, these parts will be represented as plain HTML in the data structure.\n\n\nPre-parsing\n\n\nParsing templates can be a very slow operation, particularly for very large apps, very complex templates, or intricate SVGs. As an optimization option, templates can be pre-parsed into their object form outside of runtime. This would allow Ractive to skip parsing during runtime and speed up app initialization. Typically, a parsed template is only about 30-40% larger than the string version, making pre-parsing a trade-off between space and processing.\n\n\nPre-parsing can be done in many different ways as long as Ractive receives the parsed template during runtime. One way would be to simply serve the pre-parsed template separately from the component or instance and load it via AJAX. Another would be to extract and replace the template on the file with the parsed version during compile time - an approach that works well with \ncomponent files\n. Read more about \nloaders\n to know more about how loaders do pre-parsing on compile time.\n\n\nReferences\n\n\nA reference is a string that refers to a piece of data. They may look like a regular \nkeypath\n, like \n{{ foo.bar.baz }}\n or may contain special keywords and glyphs, like \n{{ @this.sayHello() }}\n.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    foo: 'bar',\n  },\n  template: `\n    \ndiv\nI reference foo with a value: {{ foo }}\n/div\n\n    \nbutton type=\nbutton\n on-click=\n@this.sayHello()\nClick Me\n/button\n\n  `,\n  sayHello(){\n    console.log('Called from an event that used a reference to a method')\n  }\n});\n\n\n\n\nReference resolution\n\n\nIn order for a reference to be usable, it has to resolve to something. Ractive follows the following resolution algorithm to find the value of a reference:\n\n\n\n\nIf the reference a \nspecial reference\n, resolve with that keypath.\n\n\nIf the reference is \nexplicit\n or matches a path in the current context exactly, resolve with that keypath.\n\n\nGrab the current virtual node from the template hierarchy.\n\n\nIf the reference matches an \nalias\n, section indexes, or keys, resolve with that keypath.\n\n\nIf the reference matches any \nmappings\n, resolve with that keypath.\n\n\nIf the reference matches a path on the context, resolve with that keypath.\n\n\nRemove the innermost context from the stack. Repeat steps 3-7.\n\n\nIf the reference is a valid keypath by itself, resolve with that keypath.\n\n\nIf the reference is still unresolved, add it to the 'pending resolution' pile. Each time potentially matching keypaths are updated, resolution will be attempted for the unresolved reference.\n\n\n\n\nContext stack\n\n\nSteps 6 and 7 of the \nresolution algorithm\n defines the ability of Ractive to \"climb\" contexts when a reference does not resolve in the current context. This is similar to how JavaScript climbs to the global scope to resolve a variable.\n\n\nTo do this, whenever Ractive encounters \nsection mustaches\n or similar constructs, it stores the context in a \ncontext stack\n. Ractive then resolves references starting with the context on the top of the stack, and popping off contexts until the reference resolves to a keypath.\n\n\n\n\n\nRactive({\n  el: 'body',\n  template: `\n    {{#user}}\n      \np\nWelcome back, {{name}}!\n        {{#messages}}\n          You have {{unread}} unread of {{total}} total messages.\n          You last logged in on {{lastLogin}}.\n        {{/messages}}\n      \n/p\n\n    {{/user}}\n  `,\n  data: {\n    user: {\n      name: 'Jim',\n      messages: {\n        total: 10,\n        unread: 3\n      },\n      lastLogin: 'Wednesday'\n    }\n  }\n});\n\n// Welcome back, Jim! You have 3 unread of 10 total messages. You last logged in on Wednesday.\n\n\n\n\n{{# user }}\n creates a context and the context stack becomes \n['user']\n. To resolve \nname\n, the following context resolution order is followed, where \nname\n resolves with the \nuser.name\n keypath:\n\n\n\n\nuser.name\n (resolved here)\n\n\nname\n\n\n\n\nIn the same way, \n{{# messages }}\n also creates a context. Since the \nmessages\n section under the \nuser\n section, the context stack becomes \n['user', 'user.messages']\n. To resolve \nunread\n and \ntotal\n, the following resolution order is followed:\n\n\nunread\n\n\n\n\nuser.messages.unread\n (resolved here)\n\n\nuser.unread\n\n\nunread\n\n\n\n\ntotal\n\n\n\n\nuser.messages.total\n (resolved here)\n\n\nuser.total\n\n\ntotal\n\n\n\n\nIn the case of \nlastLogin\n, the \nuser.messages.lastLogin\n keypath does not exist. What Ractive does is pop off \nuser.messages\n from the context stack and tries to resolve \nlastLogin\n using \nuser.lastLogin\n. Since \nuser.lastLogin\n is a valid keypath, \nlastLogin\n resolves as \nuser.lastLogin\n.\n\n\n\n\nuser.messages.lastLogin\n\n\nuser.lastLogin\n (resolved here)\n\n\nlastLogin\n\n\n\n\nArrays\n\n\nUnlike objects where the section uses the object as context, the context of a section that goes over an array are the items of that array.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    items: [\n      { content: 'zero' },\n      { content: 'one' },\n      { content: 'two' }\n    ]\n  },\n  template: `\n  {{#items}}\n    {{content}}\n  {{/items}}\n  `\n});\n\n// zeroonetwo\n\n\n\n\nIn the example above, context is created for each item on the array. The first time it is \nitems.0\n, then \nitems.1\n, then \nitems.2\n. \ncontent\n will be resolved for relative to each, doing \nitems.0.content\n, then \nitems.1.content\n and finally \nitems.2.content\n.\n\n\nMustaches\n\n\nWhat is Mustache?\n\n\nMustache\n is one of the most popular templating languages. It's a very lightweight, readable syntax with a comprehensive specification - which means that implementations (such as Ractive) can test that they're doing things correctly.\n\n\nIf you've used \nHandlebars\n or \nAngular\n you'll also find mustaches familiar.\n\n\n\n\nWhat are mustaches?\n\n\nMustache basics\n\n\nVariables\n\n\nSections\n\n\nComments\n\n\nPartials\n\n\nCustom delimiters\n\n\nExtensions\n\n\nArray indices\n\n\nObject iteration\n\n\nSpecial references\n\n\nRestricted references\n\n\nExpressions\n\n\nHandlebars-style sections\n\n\nAliasing\n\n\nStatic mustaches\n\n\n{{else}}\n and \n{{elseif}}\n\n\nEscaping Mustaches\n\n\n\n\nWhat are mustaches?\n\n\nWithin this documentation, and within Ractive's code, 'mustache' means two things - a snippet of a template which uses mustache delimiters, such as \n{{name}}\n, and the object within our \nparallel DOM\n that is responsible for listening to data changes and updating the (real) DOM.\n\n\nWe say that the \n{{name}}\n mustache has a \nreference\n of \nname\n. When it gets rendered, and we create the object whose job it is to represent \nname\n in the DOM, we attempt to \nresolve the reference according to the current context stack\n. For example if we're in the \nuser\n context, and \nuser\n has a property of \nname\n, \nname\n will resolve to a \nkeypath\n of \nuser.name\n.\n\n\nAs soon as the mustache knows what its keypath is (which may not be at render time, if data has not yet been set), it registers itself as a \ndependant\n of the keypath. Then, whenever data changes, Ractive scans the dependency graph to see which mustaches need to update, and notifies them accordingly.\n\n\nMustache basics\n\n\nIf you already know Mustache, Ractive supports all the Mustache features - basic Mustache variables like \n{{name}}\n, as well as sections, partials, and even delimiter changes. If you're already familiar with Mustache, skip to the Extensions section below.\n\n\nYou can also check out the \ntutorials\n.\n\n\nVariables\n\n\nThe most basic mustache type is the variable. A \n{{name}}\n tag in a template will try to find the \nname\n key in the current context. If there is no \nname\n key in the current context, the parent contexts will be checked recursively. If the top context is reached and the name key is still not found, nothing will be rendered.\n\n\nAll variables are HTML escaped by default. If you want to return unescaped HTML, use the triple mustache: \n{{{name}}}\n.\n\n\nYou can also use \n to unescape a variable: \n{{\n name}}\n. This may be useful when changing delimiters (see \"Set Delimiter\" below).\n\n\nTemplate:\n\n\n * {{name}}\n * {{age}}\n * {{company}}\n * {{{company}}}\n\n\n\n\nWith the following data:\n\n\n{\n  \nname\n: \nChris\n,\n  \ncompany\n: \nb\nGitHub\n/b\n\n}\n\n\n\n\nWill generate the following output:\n\n\n * Chris\n *\n * \nlt;b\ngt;GitHub\nlt;/b\ngt;\n * \nb\nGitHub\n/b\n\n\n\n\n\nSections\n\n\nSections render blocks of text one or more times, depending on the value of the key in the current context.\n\n\nA section begins with a pound and ends with a slash. That is, \n{{#person}}\n begins a \"person\" section while \n{{/person}}\n ends it.\n\n\nThe behavior of the section is determined by the value of the key.\n\n\nFalse Values or Empty Lists\n\n\nIf the person key exists and has a value of false or an empty list, the HTML between the pound and slash will not be displayed.\n\n\nTemplate:\n\n\nShown.\n{{#person}}\n  Never shown!\n{{/person}}\n\n\n\n\nData:\n\n\n{\n  \nperson\n: false\n}\n\n\n\n\nOutput:\n\n\nShown.\n\n\n\n\nNon-Empty Lists\n\n\nIf the person key exists and has a non-false value, the HTML between the pound and slash will be rendered and displayed one or more times.\n\n\nWhen the value is a non-empty list, the text in the block will be displayed once for each item in the list. The context of the block will be set to the current item for each iteration. In this way we can loop over collections.\n\n\nTemplate:\n\n\n{{#repo}}\n  \nb\n{{name}}\n/b\n\n{{/repo}}\n\n\n\n\nData:\n\n\n{\n  \nrepo\n: [\n    { \nname\n: \nresque\n },\n    { \nname\n: \nhub\n },\n    { \nname\n: \nrip\n }\n  ]\n}\n\n\n\n\nOutput:\n\n\nb\nresque\n/b\n\n\nb\nhub\n/b\n\n\nb\nrip\n/b\n\n\n\n\n\nNon-False Values\n\n\nWhen the value is non-false but not a list, it will be used as the context for a single rendering of the block.\n\n\nTemplate:\n\n\n{{#person?}}\n  Hi {{name}}!\n{{/person?}}\n\n\n\n\nData:\n\n\n{\n  \nperson?\n: { \nname\n: \nJon\n }\n}\n\n\n\n\nOutput:\n\n\nHi Jon!\n\n\n\n\nInverted Sections\n\n\nAn inverted section begins with a caret (hat) and ends with a slash. That is  \n{{^person}}\n begins a \"person\" inverted section while \n{{/person}}\n ends it.\n\n\nWhile sections can be used to render text one or more times based on the value of the key, inverted sections may render text once based on the inverse value of the key. That is, they will be rendered if the key doesn't exist, is false, or is an empty list.\n\n\nTemplate:\n\n\n{{#repo}}\n  \nb\n{{name}}\n/b\n\n{{/repo}}\n{{^repo}}\n  No repos :(\n{{/repo}}\n\n\n\n\nAttributes\n\n\nSections may also be used within attribute values and around attribute values. Using a conditional section around an attribute or group of attributes will exclude those attributes from the DOM when the conditional is \nfalse\n and include them when it is \ntrue\n. Using a conditional section within an attribute only affects the value of the attribute, and there may be multiple sections within an attribute value.\n\n\nIn the following terribly contrived example, if \nbig\n is truthy, then the button will have a class \nbig\n in addition to the fixed class \nbutton\n. If \nplanetsAligned\n is truthy, the button will also get an annoying \nonmousemove\n attribute. \nNote\n that ractive directives cannot currently be placed within a section, but that may change in the future.\n\n\nbutton class=\n{{#big}}big {{/}}button\n {{#planetsAligned}}onmousemove=\nalert('I am annoying...')\n{{/}}\nI sure hope the planets aren't aligned...\n/button\n\n\n\n\n\nComments\n\n\nComments begin with a bang and are ignored. The following template:\n\n\nh1\nToday{{! ignore me }}.\n/h1\n\n\n\n\n\nWill render as follows:\n\n\nh1\nToday.\n/h1\n\n\n\n\n\nIf you'd like the comments to show up, just use html comments and set \nstripComments\n to \nfalse\n.\nComments may contain newlines.\n\n\nPartials\n\n\nPartials begin with a greater than sign:\n\n\n{{\n box}}\n\n\n\n\nRecursive partials are possible. Just avoid infinite loops.\n\n\nThey also inherit the calling context. For example:\n\n\n{{\n next_more}}\n\n\n\n\nIn this case, \nnext_more.mustache\n file will inherit the size and start methods from the calling context.\n\n\nIn this way you may want to think of partials as includes, or template expansion:\n\n\nFor example, this template and partial:\n\n\nbase.mustache:\n\n\nh2\nNames\n/h2\n\n{{#names}}\n  {{\n user}}\n{{/names}}\n\n\n\n\nWith \nuser.mustache\n containing:\n\n\nstrong\n{{name}}\n/strong\n\n\n\n\n\nCan be thought of as a single, expanded template:\n\n\nh2\nNames\n/h2\n\n{{#names}}\n  \nstrong\n{{name}}\n/strong\n\n{{/names}}\n\n\n\n\nPartials are a very useful construct, and you can find out more about them on the \npartials\n page.\n\n\nCustom delimiters\n\n\nCustom delimiters are set with a 'Set delimiter' tag. Set delimiter tags start with an equal sign and change the tag delimiters from \n{{\n and \n}}\n to custom strings.\n\n\n{{foo}}\n  {{=[[ ]]=}}\n[[bar]]\n\n\n\n\nCustom delimiters may not contain whitespace or the equals sign.\n\n\nYou can also set custom delimiters using the \ndelimiters\n and \ntripleDelimiters\n options in your Ractive instance.\n\n\nvar ractive = new Ractive({\n  el: whatever,\n  template: myTemplate,\n  data: {\n    greeting: 'Hello',\n    greeted: 'world',\n    triple: '\nstrong\nThis is a triple-stache\n/strong\n'\n  },\n  delimiters: [ '[[', ']]' ],\n  tripleDelimiters: [ '[[[', ']]]' ]\n});\n\n\n\n\nExtensions\n\n\nRactive is 99% backwards-compatible with Mustache, but adds several additional features.\n\n\nArray index references\n\n\nIndex references are a way of determining where we are within a list section. It's best explained with an example:\n\n\n{{#items:i}}\n  \n!-- within here, {{i}} refers to the current index --\n\n  \np\nItem {{i}}: {{content}}\n/p\n\n{{/items}}\n\n\n\n\nIf you then set \nitems\n to \n[{content: 'zero'}, {content: 'one'}, {content: 'two'}]\n, the result would be\n\n\np\nItem 0: zero\n/p\n\n\np\nItem 1: one\n/p\n\n\np\nItem 2: two\n/p\n\n\n\n\n\nThis is particularly useful when you need to respond to user interaction. For example you could add a \ndata-index='{{i}}'\n attribute, then easily find which item a user clicked on.\n\n\nObject iteration\n\n\nMustache can also iterate over objects, rather than array. The syntax is the same as for Array indices. Given the following ractive:\n\n\nractive = new Ractive({\n  el: container,\n  template: template,\n  data: {\n    users: {\n      'Joe': { email: 'joe@example.com' },\n      'Jane': { email: 'jane@example.com' },\n      'Mary': { email: 'mary@example.com' }\n    }\n  }\n});\n\n\n\n\nWe can iterate over the users object with the following:\n\n\nul\n\n  {{#users:name}}\n    \nli\n{{name}}: {{email}}\n/li\n\n  {{/users}}\n\n/ul\n\n\n\n\n\nto create:\n\n\nul\n\n  \nli\nJoe: joe@example.com\n/li\n\n  \nli\nJane: jane@example.com\n/li\n\n  \nli\nMary: mary@example.com\n/li\n\n\n/ul\n\n\n\n\n\nIn previous versions of Ractive it was required to close a section with the opening keypath. In the example above \n{{#users}}\n is closed by \n{{/users}}\n. This is no longer the case, you can now simply close an iterator with \n{{/}}\n. Ractive will attempt to warn you in the event of a mismatch, \n{{#users}}\n cannot be closed by \n{{/comments}}\n. This will not effect \nExpressions\n as they have always been able to be closed by \n{{/}}\n.\n\n\n!--- valid markup --\n\n{{#users}}\n\n{{/users}}\n\n{{#users:i}}\n\n{{/users}}\n\n{{#users}}\n\n{{/}}\n\n{{#users.topUsers}}\n\n!-- still matches the first part of the keypath, thus a valid closing tag --\n\n{{/users}}\n\n\n!-- invalid markup --\n\n{{#users}}\n\n{{/comments}}\n\n\n\n\nExpressions\n\n\nExpressions are a big topic, so they have a \npage of their own\n. But this section is about explaining the difference between vanilla Mustache and Ractive Mustache, so they deserve a mention here.\n\n\nExpressions look like any normal mustache. For example this expression converts \nnum\n to a percentage:\n\n\np\n{{ num * 100 }}%\n/p\n\n\n\n\n\nThe neat part is that this expression will recognise it has a dependency on whatever keypath \nnum\n resolves to, and will re-evaluate whenever the value of \nnum\n changes.\n\n\nMustache fans may bristle at expressions - after all, the whole point is that mustache templates are \nlogic-less\n, right? But what that really means is that the logic is \nembedded in the syntax\n (what are conditionals and iterators if not forms of logic?) rather than being language dependent. Expressions just allow you to add a little more, and in so doing make complex tasks simple.\n\n\nHandlebars-style sections\n\n\nIn addition to Mustache-style conditional and iterative sections, Ractive adds Handlebars-style \nif\n, \nunless\n, \neach\n, and \nwith\n to handle branching, iteration, and context control. For \nif\n, \nwith\n, and \neach\n, \n{{elseif}}\n and \n{{else}}\n may be used to provide alternate branches for false conditions, missing contexts, or empty iterables.\n\n\nbutton on-click=\nflip\nFlip Coin\n/button\n\n\np\nCoin flip result: {{#if heads}}heads{{else}}tails{{/if}}\n/p\n\n\nul\n\n  {{#each result}}\n    \nli\n{{.}}\n/li\n\n  {{else}}\n    \nli\nNo results yet...\n/li\n\n  {{/each}}\n\n/ul\n\n\np\nHere is a {{#with some.nested.value}}{{.}}{{/with}} value.\n/p\n\n\n\n\n\nvar ractive = new Ractive({\n  el: document.body,\n  template: myTemplate,\n  data: {\n    results: [],\n    heads: true,\n    some: { nested: { value: 'nested' } }\n  }\n});\n\nractive.on('flip', function() {\n  var sadRandom = Math.floor(Math.random() * 2) === 1;\n  this.set('heads', sadRandom);\n  this.unshift('results', sadRandom ? 'heads' : 'tails');\n});\n\n\n\n\nIn this example, clicking the button gets a \"random\" coin flip result, sets it in an \nif\n conditional section, and prepends it in an \neach\n iterative section. There is also a \nwith\n context section throw in for good measure.\n\n\nAliasing\n\n\nAny section (or \n{{#with}}\n section) provides its own context to the template that falls within it, and any references within the section will be resolved against the section context. Ambiguous references are resolved up the model hierarchy \nand\n the context hierarchy. Given a data structure that looks like\n\n\n{\n  foo: {\n    baz: 99,\n    bar: {\n      baz: 42\n    }\n  },\n  list: [\n    baz: 198,\n    bar: {\n      baz: 84\n    }\n  ]\n}\n\n\n\n\nand a template\n\n\n{{#each list}}\n  explicit 1: {{.bar.baz}}\n  {{#with .bar}}\n    implicit 1: {{baz}}\n    {{#with ~/foo}}\n      explicit 2: {{.bar.baz}}\n      implicit 2: {{baz}}\n    {{/with}}\n  {{/with}}\n{{/each}}\n\n\n\n\nthere is no way to reference \n~/list.0.baz\n from the second implicit site because the site has a different context (\n~/foo\n) and using an ambiguous reference (\nbaz\n) results in \n~/foo.baz\n  being used. Aliasing offers an escape hatch for similarly complex scenarios where ambiguity can cause the wrong reference to be used or performance issues to arise, because ambiguity is expensive.\n\n\nAlias block use the existing \n{{#with}}\n mustache, but instead of setting a context, they set names for one or more keypaths. Aliases follow the form \ndestination as alias\n, where destination is any valid reference at that point in the template e.g. \n{{#with .foo as myFoo, @key as someKey, 10 * @index + ~/offset as someCalculation, .baz.bat as lastOne}}\n. Because plain reference aliases, like the \nmyFoo\n and \nlastOne\n aliases in the example, refer to exactly one non-computed keypath, they can also be used for two-way binding deeper in the template. For example, \ninput value=\"{{myFoo}}\" /\n as a child of the alias block would bind to \n.foo\n in the context where the alias block is defined.\n\n\nAliasing is also extended to \n{{#each}}\n blocks so that the iterated item can be named rather than just referred to as \nthis\n or \n.\n. For instance, \n{{#each list as item}}\n would make \nitem\n equivalent to \nthis\n directly within the \neach\n block, but \nitem\n would still refer to same value in further nested contexts. Index and key aliases can still be used with an aliased iteration e.g. \n{{#each object as item: key, index}}\n.\n\n\nFinally, partials can also be used with alias shorthand in much the same way that they can be passed context e.g. \n{{\nsomePartial .foo.bar as myBar, 20 * @index + baz as myComp}}\n.\n\n\nStatic mustaches\n\n\nSometimes it is useful to have portions of a template render once and stay the same even if their references change. A static mustache will be updated only when its template is rendered and not when its keypath is updated. So, if a static mustache is a child of a section or partial that get re-rendered, the mustache will also be re-rendered using the current value of its keypath.\n\n\nThe default static mustache delimiters are \n[[ ]]\n for escaped values and \n[[[ ]]]\n for unescaped values.\n\n\n[[ foo ]] {{ foo }}\n{{^flag}}\n  [[ foo ]]\n{{/}}\n\n\n\n\nvar ractive = new Ractive({\n  data: { foo: 'bar' },\n  ...\n});\nractive.set('foo', 'bippy');\nractive.set('flag', true);\nractive.set('flag', false);\n\n\n\n\nOutput:\n\n\nbar bippy bippy\n\n\n\n\nStatic mustaches may also be used for sections that should only be updated on render.\n\n\n[[# if admin ]]\nHello, admin\n[[else]]\nHello, normal user\n[[/if]]\n\n\n\n\nvar ractive = new Ractive({\n  data: { admin: false },\n  ...\n});\nractive.set('admin', true);\n\n\n\n\nOutput:\n\n\nHello, normal user\n\n\n\n\n{{else}} and {{elseif}}\n\n\nRactive borrows a trick from Handlebars here and lets you perform:\n\n\n{{#repo}}\n  \nb\n{{name}}\n/b\n\n{{else}}\n  No repos :(\n{{/repo}}\n\n\n\n\nData:\n\n\n{\n  \nrepo\n: []\n}\n\n\n\n\nOutput:\n\n\nNo repos :(\n\n\n\n\nRactive takes it a step further and also allows you to use \n{{elseif otherCondition}}\n for alternate cases.\n\n\n{{#if foo}}\n  foo\n{{elseif bar}}\n  bar but not foo\n{{else}}\n  neither foo nor bar\n{{/if}}\n\n\n\n\nIn this case, the output would be what you would expect. If \nfoo\n is true, then the output will be \nfoo\n. If \nfoo\n is false and \nbar\n is true, the the output will be \nbar but not foo\n. If neither \nfoo\n nor \nbar\n is true, the the output will be \nneither foo nor bar\n.\n\n\nFurther, \n{{else}}\n and \n{{elseif}}\n clauses can be used with \n{{#with}}\n and \n{{#each}}\n sections too. If the context for the \n{{#with}}\n section doesn't exist, then any else clauses will be processed as if the entire section were a conditional with a false first branch. If the array for the \n{{#each}}\n (or regular iterative section) is empty or the object has no keys, then any else clauses will be processed as if the entire section were a conditional with a false first branch.\n\n\nEscaping mustaches\n\n\nIf you need to have Ractive ignore some mustaches in your template, you can escape them with a '\\'.\n\n\n{{ interpolated }} {{backslash}}{{ left alone }}\n\n\n\n\nIf you need to have a backslash before an interpolated mustache, you can escape the backslash with another '\\'. Any additional mustaches will be exported into the template.\n\n\n{{backslash}}{{backslash}}{{ interpolated }} and preceeded by a single slash.\n{{backslash}}{{backslash}}{{backslash}}{{ interpolated }} and preceeded by two slashes.\n\n\n\n\nFootnote\n\n\n*Ractive implements the Mustache specification as closely as possible. 100% compliance is impossible, because it's unlike other templating libraries - rather than turning a string into a string, Ractive turns a string into DOM, which has to be restringified so we can test compliance. Some things, like lambdas, get lost in translation - it's unavoidable, and unimportant.", 
            "title": "Templates"
        }, 
        {
            "location": "/concepts/templates/#elements", 
            "text": "Strictly speaking, Ractive templates are are not HTML. It has a few special directives and other constructs built into its element representation to make DOM manipulation a bit easier. You can think of them as \"HTML-like\" - they look like HTML for ease of authoring but are not really HTML nor even a superset of HTML. However, when rendered, they are emitted as perfectly valid HTML.  In addition, Ractive's template parser is not quite as forgiving as the browser's HTML parser either and may throw parser errors where it sees ambiguity. However, it does allow things like implicitly closed elements.", 
            "title": "Elements"
        }, 
        {
            "location": "/concepts/templates/#conditional-attributes", 
            "text": "You can wrap one or more attributes inside an element tag in a conditional section, and Ractive will add and remove those attributes as the conditional section is rendered and unrendered. For instance:  div {{#if highlighted}}class= highlighted {{/if}} Highlightable element /div   Any number of attributes can be used in a section, and other  Mustache  constructs can be used to supply attributes.  div {{#if highlighted}}class= highlighted {{ anotherClass }}  title= I'm highlighted {{/if}} Highlightable element /div", 
            "title": "Conditional attributes"
        }, 
        {
            "location": "/concepts/templates/#expressions", 
            "text": "Expressions allow you to use logic within a template. At their simplest, that may just mean a basic arithmetic operation, such as converting to percentages, or making your  index references  start at 1 rather than 0:  div class='bar-chart' \n  {{#bars:i}}\n     div style='width: {{ value * 100 }}%;' {{ i + 1 }} /div \n  {{/bars}} /div   Or it could mean formatting a currency so that  1.79  renders as  \u00a31.79p :  p Price:  strong {{ format( price ) }} /strong /p   Or it could mean adding a class based on some condition:  a class='button {{ active ?  on  :  off  }}' switch /a   Or it could mean filtering a list to exclude certain records:  ul \n{{# exclude( list, 'N/A' ) }}\n   li {{author}}: {{title}} /li \n{{/ end of filter }} /ul   These are all examples casually plucked from the air - whether they would be useful or not in real life depends on what you're trying to do. The point is that you can include more of your view logic at the declarative layer - the template - where it's easier to  reason about .", 
            "title": "Expressions"
        }, 
        {
            "location": "/concepts/templates/#frequently-used-expressions", 
            "text": "If you use a particular expression frequently, you can save time by adding it Ractive's default data. This way you won't have to set up the expressions on each individual  ractive  instance.  The example below adds expressions for some frequenlty used parts of  moment.js  to the default data:  var helpers = Ractive.defaults.data;\nhelpers.fromNow = function(timeString){\n    return moment(timeString).fromNow()\n}\nhelpers.formatTime = function(timeString){\n    return moment(timeString).format( ddd, h:mmA );\n}\nhelpers.humanizeTime = function(timeString){\n    return moment.duration(timeString).humanize();\n}", 
            "title": "Frequently Used Expressions"
        }, 
        {
            "location": "/concepts/templates/#valid-expressions", 
            "text": "These are, of course, JavaScript expressions. Almost any valid JavaScript expression can be used, with a few exceptions:   No assignment operators (i.e.  a = b ,  a += 1 ,  a--  and so on)  No  new ,  delete , or  void  operators  No function literals (i.e. anything that involves the  function  keyword)   Aside from a subset of global objects (e.g.  Math ,  Array ,  parseInt ,  encodeURIComponent  - full list below), any references must be to properties (however deeply nested) of the Ractive instance's data, rather than arbitrary variables. Reference resolution follows the  normal process .", 
            "title": "Valid expressions"
        }, 
        {
            "location": "/concepts/templates/#does-this-use-eval", 
            "text": "Yes and no. You've probably read that 'eval is evil', or some other such nonsense. The truth is that while it does get abused, and can theoretically introduce security risks when user input gets involved, there are some situations where it's both necessary and sensible.  But repeatedly  eval ing the same code is a performance disaster. Instead, we use the  Function  constructor, which is a form of  eval , except that the code gets compiled once instead of every time it executes.", 
            "title": "Does this use eval?"
        }, 
        {
            "location": "/concepts/templates/#a-note-about-efficiency", 
            "text": "Using the  Function  constructor instead of  eval  is just one way that Ractive optimises expressions. Consider a case like this:  {{a}} + {{b}} = {{ a + b }}\n{{c}} + {{d}} = {{ c+d }}  At  parse time , Ractive generates an  abstract syntax tree  (AST) from these expressions, to verify that it's a valid expression and to extract any references that are used. It then 'stringifies' the AST, so that the expression can later be compiled into a function.  As anyone who has seen minified JavaScript can attest, JavaScript cares not one fig what your variables are called. It also doesn't care about whitespace. So both of the expressions can be stringified the same way:  _0+_1   When we  evaluate   {{ a + b }}  or  {{ c+d }} , we can therefore use the same function but with different arguments. Recognising this, the function only gets compiled once, after which it is cached. (The cache is shared between all Ractive instances on the page.) Further, the result of the evaluation is itself cached (until one or more of the dependencies change), so you can repeat expressions as often as you like without creating unnecessary work.  All of this means that you could have an expression within a list section that was repeated 10,000 times, and the corresponding function would be created once  at most , and only called when necessary.", 
            "title": "A note about efficiency"
        }, 
        {
            "location": "/concepts/templates/#the-this-reference", 
            "text": "Within an expression, you can use  this  to refer to the current  context :  ul \n  {{#items}}\n     !-- here, `this` means 'the current array member' -- \n     li {{this.toUpperCase()}} /li \n  {{/items}} /ul   In regular mustache, we have something called the  implicit iterator  -  {{.}}  - which does the same thing. Ractive allows you to use  this  in place of  .  for purely aesthetic reasons.", 
            "title": "The this reference"
        }, 
        {
            "location": "/concepts/templates/#supported-global-objects", 
            "text": "Array  Date  JSON  Math  NaN  RegExp  decodeURI  decodeURIComponent  encodeURI  encodeURIComponent  isFinite  isNaN  null  parseFloat  parseInt  undefined", 
            "title": "Supported global objects"
        }, 
        {
            "location": "/concepts/templates/#functions", 
            "text": "Any functions that you want to call, outside of the available globals above, must be properties of the Ractive instance's data as well. Functions can also depend on other references and will be re-evaulated when one of their dependencies is changed.  Depedendencies are determined by capturing references in the viewmodel while the function is executing. Dependencies for functions are re-captured each time the function is executed.  p {{ formattedName() }} /p   var ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    user: { firstName: 'John', lastName: 'Public' },\n    formattedName: function() {\n      return this.get('user.lastName') + ', ' + this.get('user.firstName');\n    }\n  }\n};  Result:  p Public, John /p   In this example, the function  formattedName  will depend on both  user.firstName  and  user.lastName , and updating either (or  user ) will cause any expressions referencing  formattedName  to be re-evaluated as well.  ractive.set('user.firstName', 'Jane')  Result:  p Public, Jane /p", 
            "title": "Functions"
        }, 
        {
            "location": "/concepts/templates/#functions-on-helper-objects-and-third-party-libraries", 
            "text": "You can also add helper objects to your data and call functions on those objects in expressions. For example, you could add a reference to  underscore.js :  var ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    items: [ 2, 10, 200, 3, 1, 4],\n    _: _\n  }\n};  And use that to sort an array in your template:  {{# _.sortBy(items) }}{{.}}, {{/}} !-- Result: -- \n1, 2, 3, 4, 10, 200,", 
            "title": "Functions on helper objects and third-party libraries"
        }, 
        {
            "location": "/concepts/templates/#keypaths", 
            "text": "The main way to interact with a Ractive instance is by setting  keypaths . A keypath is a string representing the location of a piece of data:  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n});\n\n// Simple keypath\nractive.get( 'foo' ); // returns { bar: 'baz' }\n\n// Compound keypath\nractive.get( 'foo.bar' ); // returns 'baz'", 
            "title": "Keypaths"
        }, 
        {
            "location": "/concepts/templates/#upstream-and-downstream-keypaths", 
            "text": "In the example above, we say that  'foo.bar'  is a  downstream keypath  of  'foo' , while  'foo'  is an  upstream keypath  of  'foo.bar' .", 
            "title": "Upstream and downstream keypaths"
        }, 
        {
            "location": "/concepts/templates/#array-versus-dot-notation", 
            "text": "The  'foo.bar'  keypath is an example of  dot notation . With arrays, you can use dot notation or  array notation , which may feel more familiar (internally, it gets converted to dot notation):  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [ 'a', 'b', 'c' ]\n  }\n});\n\n// Array notation\nractive.get( 'list[0]' ); // returns 'a'\n\n// Dot notation\nractive.get( 'list.0' ); // also returns 'a'", 
            "title": "Array versus dot notation"
        }, 
        {
            "location": "/concepts/templates/#missing-properties", 
            "text": "Ordinarily in JavaScript, trying to access a child property of an object that didn't exist would cause an error:  data = { numbers: [ 1, 2, 3 ]};\ndata.letters[0]; // throws an error - cannot read property '0' of undefined  Within Ractive, this will simply return  undefined :  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    numbers: [ 1, 2, 3 ]\n  }\n});\n\nractive.get( 'letters[0]' ); // returns undefined", 
            "title": "Missing properties"
        }, 
        {
            "location": "/concepts/templates/#escaping", 
            "text": "While not ideal, sometimes properties of objects have  . s in name e.g.  foo['bar.baz'] . Note that while numbers are supported in array notation, strings are not. To access a peypath with a literal  .  in one of the keys, you can escape it with a  \\  e.g.  foo.bar\\.baz . Any keys accessible in the template will be unescaped, so if you're trying to use them with simple string concatenation to access a keypath with a  .  in it, you'll need to make sure you escape it first.", 
            "title": "Escaping"
        }, 
        {
            "location": "/concepts/templates/#parsing", 
            "text": "In order for Ractive to utilize templates, it first parses the templates into a tree-like data structure, much like how a browser's HTML parser would process HTML. This data structure contains everything Ractive needs to know to construct an instance's DOM, data bindings, events and transitions etc.   Ractive.parse(' div class= message Hello World! /div ');\n\n// { v :4, t :[{ t :7, e : div , m :[{ n : class , f : message , t :13}], f :[ Hello World! ]}]}  Normally, parsing is done automatically. Ractive will use  Ractive.parse()  under the hood if a string template is provided to the  template  initialization option.  The parsed template is not designed to be readable nor editable by a human. It is meant to represent the template structure as an object in a way Ractive understands with as few bytes as possible. Where the template doesn't use Ractive-specific features, these parts will be represented as plain HTML in the data structure.", 
            "title": "Parsing"
        }, 
        {
            "location": "/concepts/templates/#pre-parsing", 
            "text": "Parsing templates can be a very slow operation, particularly for very large apps, very complex templates, or intricate SVGs. As an optimization option, templates can be pre-parsed into their object form outside of runtime. This would allow Ractive to skip parsing during runtime and speed up app initialization. Typically, a parsed template is only about 30-40% larger than the string version, making pre-parsing a trade-off between space and processing.  Pre-parsing can be done in many different ways as long as Ractive receives the parsed template during runtime. One way would be to simply serve the pre-parsed template separately from the component or instance and load it via AJAX. Another would be to extract and replace the template on the file with the parsed version during compile time - an approach that works well with  component files . Read more about  loaders  to know more about how loaders do pre-parsing on compile time.", 
            "title": "Pre-parsing"
        }, 
        {
            "location": "/concepts/templates/#references", 
            "text": "A reference is a string that refers to a piece of data. They may look like a regular  keypath , like  {{ foo.bar.baz }}  or may contain special keywords and glyphs, like  {{ @this.sayHello() }} .   Ractive({\n  el: 'body',\n  data: {\n    foo: 'bar',\n  },\n  template: `\n     div I reference foo with a value: {{ foo }} /div \n     button type= button  on-click= @this.sayHello() Click Me /button \n  `,\n  sayHello(){\n    console.log('Called from an event that used a reference to a method')\n  }\n});", 
            "title": "References"
        }, 
        {
            "location": "/concepts/templates/#reference-resolution", 
            "text": "In order for a reference to be usable, it has to resolve to something. Ractive follows the following resolution algorithm to find the value of a reference:   If the reference a  special reference , resolve with that keypath.  If the reference is  explicit  or matches a path in the current context exactly, resolve with that keypath.  Grab the current virtual node from the template hierarchy.  If the reference matches an  alias , section indexes, or keys, resolve with that keypath.  If the reference matches any  mappings , resolve with that keypath.  If the reference matches a path on the context, resolve with that keypath.  Remove the innermost context from the stack. Repeat steps 3-7.  If the reference is a valid keypath by itself, resolve with that keypath.  If the reference is still unresolved, add it to the 'pending resolution' pile. Each time potentially matching keypaths are updated, resolution will be attempted for the unresolved reference.", 
            "title": "Reference resolution"
        }, 
        {
            "location": "/concepts/templates/#context-stack", 
            "text": "Steps 6 and 7 of the  resolution algorithm  defines the ability of Ractive to \"climb\" contexts when a reference does not resolve in the current context. This is similar to how JavaScript climbs to the global scope to resolve a variable.  To do this, whenever Ractive encounters  section mustaches  or similar constructs, it stores the context in a  context stack . Ractive then resolves references starting with the context on the top of the stack, and popping off contexts until the reference resolves to a keypath.   Ractive({\n  el: 'body',\n  template: `\n    {{#user}}\n       p Welcome back, {{name}}!\n        {{#messages}}\n          You have {{unread}} unread of {{total}} total messages.\n          You last logged in on {{lastLogin}}.\n        {{/messages}}\n       /p \n    {{/user}}\n  `,\n  data: {\n    user: {\n      name: 'Jim',\n      messages: {\n        total: 10,\n        unread: 3\n      },\n      lastLogin: 'Wednesday'\n    }\n  }\n});\n\n// Welcome back, Jim! You have 3 unread of 10 total messages. You last logged in on Wednesday.  {{# user }}  creates a context and the context stack becomes  ['user'] . To resolve  name , the following context resolution order is followed, where  name  resolves with the  user.name  keypath:   user.name  (resolved here)  name   In the same way,  {{# messages }}  also creates a context. Since the  messages  section under the  user  section, the context stack becomes  ['user', 'user.messages'] . To resolve  unread  and  total , the following resolution order is followed:  unread   user.messages.unread  (resolved here)  user.unread  unread   total   user.messages.total  (resolved here)  user.total  total   In the case of  lastLogin , the  user.messages.lastLogin  keypath does not exist. What Ractive does is pop off  user.messages  from the context stack and tries to resolve  lastLogin  using  user.lastLogin . Since  user.lastLogin  is a valid keypath,  lastLogin  resolves as  user.lastLogin .   user.messages.lastLogin  user.lastLogin  (resolved here)  lastLogin", 
            "title": "Context stack"
        }, 
        {
            "location": "/concepts/templates/#arrays", 
            "text": "Unlike objects where the section uses the object as context, the context of a section that goes over an array are the items of that array.   Ractive({\n  el: 'body',\n  data: {\n    items: [\n      { content: 'zero' },\n      { content: 'one' },\n      { content: 'two' }\n    ]\n  },\n  template: `\n  {{#items}}\n    {{content}}\n  {{/items}}\n  `\n});\n\n// zeroonetwo  In the example above, context is created for each item on the array. The first time it is  items.0 , then  items.1 , then  items.2 .  content  will be resolved for relative to each, doing  items.0.content , then  items.1.content  and finally  items.2.content .", 
            "title": "Arrays"
        }, 
        {
            "location": "/concepts/templates/#mustaches", 
            "text": "", 
            "title": "Mustaches"
        }, 
        {
            "location": "/concepts/templates/#what-is-mustache", 
            "text": "Mustache  is one of the most popular templating languages. It's a very lightweight, readable syntax with a comprehensive specification - which means that implementations (such as Ractive) can test that they're doing things correctly.  If you've used  Handlebars  or  Angular  you'll also find mustaches familiar.   What are mustaches?  Mustache basics  Variables  Sections  Comments  Partials  Custom delimiters  Extensions  Array indices  Object iteration  Special references  Restricted references  Expressions  Handlebars-style sections  Aliasing  Static mustaches  {{else}}  and  {{elseif}}  Escaping Mustaches", 
            "title": "What is Mustache?"
        }, 
        {
            "location": "/concepts/templates/#what-are-mustaches", 
            "text": "Within this documentation, and within Ractive's code, 'mustache' means two things - a snippet of a template which uses mustache delimiters, such as  {{name}} , and the object within our  parallel DOM  that is responsible for listening to data changes and updating the (real) DOM.  We say that the  {{name}}  mustache has a  reference  of  name . When it gets rendered, and we create the object whose job it is to represent  name  in the DOM, we attempt to  resolve the reference according to the current context stack . For example if we're in the  user  context, and  user  has a property of  name ,  name  will resolve to a  keypath  of  user.name .  As soon as the mustache knows what its keypath is (which may not be at render time, if data has not yet been set), it registers itself as a  dependant  of the keypath. Then, whenever data changes, Ractive scans the dependency graph to see which mustaches need to update, and notifies them accordingly.", 
            "title": "What are mustaches?"
        }, 
        {
            "location": "/concepts/templates/#mustache-basics", 
            "text": "If you already know Mustache, Ractive supports all the Mustache features - basic Mustache variables like  {{name}} , as well as sections, partials, and even delimiter changes. If you're already familiar with Mustache, skip to the Extensions section below.  You can also check out the  tutorials .", 
            "title": "Mustache basics"
        }, 
        {
            "location": "/concepts/templates/#variables", 
            "text": "The most basic mustache type is the variable. A  {{name}}  tag in a template will try to find the  name  key in the current context. If there is no  name  key in the current context, the parent contexts will be checked recursively. If the top context is reached and the name key is still not found, nothing will be rendered.  All variables are HTML escaped by default. If you want to return unescaped HTML, use the triple mustache:  {{{name}}} .  You can also use   to unescape a variable:  {{  name}} . This may be useful when changing delimiters (see \"Set Delimiter\" below).  Template:   * {{name}}\n * {{age}}\n * {{company}}\n * {{{company}}}  With the following data:  {\n   name :  Chris ,\n   company :  b GitHub /b \n}  Will generate the following output:   * Chris\n *\n *  lt;b gt;GitHub lt;/b gt;\n *  b GitHub /b", 
            "title": "Variables"
        }, 
        {
            "location": "/concepts/templates/#sections", 
            "text": "Sections render blocks of text one or more times, depending on the value of the key in the current context.  A section begins with a pound and ends with a slash. That is,  {{#person}}  begins a \"person\" section while  {{/person}}  ends it.  The behavior of the section is determined by the value of the key.", 
            "title": "Sections"
        }, 
        {
            "location": "/concepts/templates/#false-values-or-empty-lists", 
            "text": "If the person key exists and has a value of false or an empty list, the HTML between the pound and slash will not be displayed.  Template:  Shown.\n{{#person}}\n  Never shown!\n{{/person}}  Data:  {\n   person : false\n}  Output:  Shown.", 
            "title": "False Values or Empty Lists"
        }, 
        {
            "location": "/concepts/templates/#non-empty-lists", 
            "text": "If the person key exists and has a non-false value, the HTML between the pound and slash will be rendered and displayed one or more times.  When the value is a non-empty list, the text in the block will be displayed once for each item in the list. The context of the block will be set to the current item for each iteration. In this way we can loop over collections.  Template:  {{#repo}}\n   b {{name}} /b \n{{/repo}}  Data:  {\n   repo : [\n    {  name :  resque  },\n    {  name :  hub  },\n    {  name :  rip  }\n  ]\n}  Output:  b resque /b  b hub /b  b rip /b", 
            "title": "Non-Empty Lists"
        }, 
        {
            "location": "/concepts/templates/#non-false-values", 
            "text": "When the value is non-false but not a list, it will be used as the context for a single rendering of the block.  Template:  {{#person?}}\n  Hi {{name}}!\n{{/person?}}  Data:  {\n   person? : {  name :  Jon  }\n}  Output:  Hi Jon!", 
            "title": "Non-False Values"
        }, 
        {
            "location": "/concepts/templates/#inverted-sections", 
            "text": "An inverted section begins with a caret (hat) and ends with a slash. That is   {{^person}}  begins a \"person\" inverted section while  {{/person}}  ends it.  While sections can be used to render text one or more times based on the value of the key, inverted sections may render text once based on the inverse value of the key. That is, they will be rendered if the key doesn't exist, is false, or is an empty list.  Template:  {{#repo}}\n   b {{name}} /b \n{{/repo}}\n{{^repo}}\n  No repos :(\n{{/repo}}", 
            "title": "Inverted Sections"
        }, 
        {
            "location": "/concepts/templates/#attributes", 
            "text": "Sections may also be used within attribute values and around attribute values. Using a conditional section around an attribute or group of attributes will exclude those attributes from the DOM when the conditional is  false  and include them when it is  true . Using a conditional section within an attribute only affects the value of the attribute, and there may be multiple sections within an attribute value.  In the following terribly contrived example, if  big  is truthy, then the button will have a class  big  in addition to the fixed class  button . If  planetsAligned  is truthy, the button will also get an annoying  onmousemove  attribute.  Note  that ractive directives cannot currently be placed within a section, but that may change in the future.  button class= {{#big}}big {{/}}button  {{#planetsAligned}}onmousemove= alert('I am annoying...') {{/}} I sure hope the planets aren't aligned... /button", 
            "title": "Attributes"
        }, 
        {
            "location": "/concepts/templates/#comments", 
            "text": "Comments begin with a bang and are ignored. The following template:  h1 Today{{! ignore me }}. /h1   Will render as follows:  h1 Today. /h1   If you'd like the comments to show up, just use html comments and set  stripComments  to  false .\nComments may contain newlines.", 
            "title": "Comments"
        }, 
        {
            "location": "/concepts/templates/#partials", 
            "text": "Partials begin with a greater than sign:  {{  box}}  Recursive partials are possible. Just avoid infinite loops.  They also inherit the calling context. For example:  {{  next_more}}  In this case,  next_more.mustache  file will inherit the size and start methods from the calling context.  In this way you may want to think of partials as includes, or template expansion:  For example, this template and partial:  base.mustache:  h2 Names /h2 \n{{#names}}\n  {{  user}}\n{{/names}}  With  user.mustache  containing:  strong {{name}} /strong   Can be thought of as a single, expanded template:  h2 Names /h2 \n{{#names}}\n   strong {{name}} /strong \n{{/names}}  Partials are a very useful construct, and you can find out more about them on the  partials  page.", 
            "title": "Partials"
        }, 
        {
            "location": "/concepts/templates/#custom-delimiters", 
            "text": "Custom delimiters are set with a 'Set delimiter' tag. Set delimiter tags start with an equal sign and change the tag delimiters from  {{  and  }}  to custom strings.  {{foo}}\n  {{=[[ ]]=}}\n[[bar]]  Custom delimiters may not contain whitespace or the equals sign.  You can also set custom delimiters using the  delimiters  and  tripleDelimiters  options in your Ractive instance.  var ractive = new Ractive({\n  el: whatever,\n  template: myTemplate,\n  data: {\n    greeting: 'Hello',\n    greeted: 'world',\n    triple: ' strong This is a triple-stache /strong '\n  },\n  delimiters: [ '[[', ']]' ],\n  tripleDelimiters: [ '[[[', ']]]' ]\n});", 
            "title": "Custom delimiters"
        }, 
        {
            "location": "/concepts/templates/#extensions", 
            "text": "Ractive is 99% backwards-compatible with Mustache, but adds several additional features.", 
            "title": "Extensions"
        }, 
        {
            "location": "/concepts/templates/#array-index-references", 
            "text": "Index references are a way of determining where we are within a list section. It's best explained with an example:  {{#items:i}}\n   !-- within here, {{i}} refers to the current index -- \n   p Item {{i}}: {{content}} /p \n{{/items}}  If you then set  items  to  [{content: 'zero'}, {content: 'one'}, {content: 'two'}] , the result would be  p Item 0: zero /p  p Item 1: one /p  p Item 2: two /p   This is particularly useful when you need to respond to user interaction. For example you could add a  data-index='{{i}}'  attribute, then easily find which item a user clicked on.", 
            "title": "Array index references"
        }, 
        {
            "location": "/concepts/templates/#object-iteration", 
            "text": "Mustache can also iterate over objects, rather than array. The syntax is the same as for Array indices. Given the following ractive:  ractive = new Ractive({\n  el: container,\n  template: template,\n  data: {\n    users: {\n      'Joe': { email: 'joe@example.com' },\n      'Jane': { email: 'jane@example.com' },\n      'Mary': { email: 'mary@example.com' }\n    }\n  }\n});  We can iterate over the users object with the following:  ul \n  {{#users:name}}\n     li {{name}}: {{email}} /li \n  {{/users}} /ul   to create:  ul \n   li Joe: joe@example.com /li \n   li Jane: jane@example.com /li \n   li Mary: mary@example.com /li  /ul   In previous versions of Ractive it was required to close a section with the opening keypath. In the example above  {{#users}}  is closed by  {{/users}} . This is no longer the case, you can now simply close an iterator with  {{/}} . Ractive will attempt to warn you in the event of a mismatch,  {{#users}}  cannot be closed by  {{/comments}} . This will not effect  Expressions  as they have always been able to be closed by  {{/}} .  !--- valid markup -- \n{{#users}}\n\n{{/users}}\n\n{{#users:i}}\n\n{{/users}}\n\n{{#users}}\n\n{{/}}\n\n{{#users.topUsers}} !-- still matches the first part of the keypath, thus a valid closing tag -- \n{{/users}} !-- invalid markup -- \n{{#users}}\n\n{{/comments}}", 
            "title": "Object iteration"
        }, 
        {
            "location": "/concepts/templates/#expressions_1", 
            "text": "Expressions are a big topic, so they have a  page of their own . But this section is about explaining the difference between vanilla Mustache and Ractive Mustache, so they deserve a mention here.  Expressions look like any normal mustache. For example this expression converts  num  to a percentage:  p {{ num * 100 }}% /p   The neat part is that this expression will recognise it has a dependency on whatever keypath  num  resolves to, and will re-evaluate whenever the value of  num  changes.  Mustache fans may bristle at expressions - after all, the whole point is that mustache templates are  logic-less , right? But what that really means is that the logic is  embedded in the syntax  (what are conditionals and iterators if not forms of logic?) rather than being language dependent. Expressions just allow you to add a little more, and in so doing make complex tasks simple.", 
            "title": "Expressions"
        }, 
        {
            "location": "/concepts/templates/#handlebars-style-sections", 
            "text": "In addition to Mustache-style conditional and iterative sections, Ractive adds Handlebars-style  if ,  unless ,  each , and  with  to handle branching, iteration, and context control. For  if ,  with , and  each ,  {{elseif}}  and  {{else}}  may be used to provide alternate branches for false conditions, missing contexts, or empty iterables.  button on-click= flip Flip Coin /button  p Coin flip result: {{#if heads}}heads{{else}}tails{{/if}} /p  ul \n  {{#each result}}\n     li {{.}} /li \n  {{else}}\n     li No results yet... /li \n  {{/each}} /ul  p Here is a {{#with some.nested.value}}{{.}}{{/with}} value. /p   var ractive = new Ractive({\n  el: document.body,\n  template: myTemplate,\n  data: {\n    results: [],\n    heads: true,\n    some: { nested: { value: 'nested' } }\n  }\n});\n\nractive.on('flip', function() {\n  var sadRandom = Math.floor(Math.random() * 2) === 1;\n  this.set('heads', sadRandom);\n  this.unshift('results', sadRandom ? 'heads' : 'tails');\n});  In this example, clicking the button gets a \"random\" coin flip result, sets it in an  if  conditional section, and prepends it in an  each  iterative section. There is also a  with  context section throw in for good measure.", 
            "title": "Handlebars-style sections"
        }, 
        {
            "location": "/concepts/templates/#aliasing", 
            "text": "Any section (or  {{#with}}  section) provides its own context to the template that falls within it, and any references within the section will be resolved against the section context. Ambiguous references are resolved up the model hierarchy  and  the context hierarchy. Given a data structure that looks like  {\n  foo: {\n    baz: 99,\n    bar: {\n      baz: 42\n    }\n  },\n  list: [\n    baz: 198,\n    bar: {\n      baz: 84\n    }\n  ]\n}  and a template  {{#each list}}\n  explicit 1: {{.bar.baz}}\n  {{#with .bar}}\n    implicit 1: {{baz}}\n    {{#with ~/foo}}\n      explicit 2: {{.bar.baz}}\n      implicit 2: {{baz}}\n    {{/with}}\n  {{/with}}\n{{/each}}  there is no way to reference  ~/list.0.baz  from the second implicit site because the site has a different context ( ~/foo ) and using an ambiguous reference ( baz ) results in  ~/foo.baz   being used. Aliasing offers an escape hatch for similarly complex scenarios where ambiguity can cause the wrong reference to be used or performance issues to arise, because ambiguity is expensive.  Alias block use the existing  {{#with}}  mustache, but instead of setting a context, they set names for one or more keypaths. Aliases follow the form  destination as alias , where destination is any valid reference at that point in the template e.g.  {{#with .foo as myFoo, @key as someKey, 10 * @index + ~/offset as someCalculation, .baz.bat as lastOne}} . Because plain reference aliases, like the  myFoo  and  lastOne  aliases in the example, refer to exactly one non-computed keypath, they can also be used for two-way binding deeper in the template. For example,  input value=\"{{myFoo}}\" /  as a child of the alias block would bind to  .foo  in the context where the alias block is defined.  Aliasing is also extended to  {{#each}}  blocks so that the iterated item can be named rather than just referred to as  this  or  . . For instance,  {{#each list as item}}  would make  item  equivalent to  this  directly within the  each  block, but  item  would still refer to same value in further nested contexts. Index and key aliases can still be used with an aliased iteration e.g.  {{#each object as item: key, index}} .  Finally, partials can also be used with alias shorthand in much the same way that they can be passed context e.g.  {{ somePartial .foo.bar as myBar, 20 * @index + baz as myComp}} .", 
            "title": "Aliasing"
        }, 
        {
            "location": "/concepts/templates/#static-mustaches", 
            "text": "Sometimes it is useful to have portions of a template render once and stay the same even if their references change. A static mustache will be updated only when its template is rendered and not when its keypath is updated. So, if a static mustache is a child of a section or partial that get re-rendered, the mustache will also be re-rendered using the current value of its keypath.  The default static mustache delimiters are  [[ ]]  for escaped values and  [[[ ]]]  for unescaped values.  [[ foo ]] {{ foo }}\n{{^flag}}\n  [[ foo ]]\n{{/}}  var ractive = new Ractive({\n  data: { foo: 'bar' },\n  ...\n});\nractive.set('foo', 'bippy');\nractive.set('flag', true);\nractive.set('flag', false);  Output:  bar bippy bippy  Static mustaches may also be used for sections that should only be updated on render.  [[# if admin ]]\nHello, admin\n[[else]]\nHello, normal user\n[[/if]]  var ractive = new Ractive({\n  data: { admin: false },\n  ...\n});\nractive.set('admin', true);  Output:  Hello, normal user", 
            "title": "Static mustaches"
        }, 
        {
            "location": "/concepts/templates/#else-and-elseif", 
            "text": "Ractive borrows a trick from Handlebars here and lets you perform:  {{#repo}}\n   b {{name}} /b \n{{else}}\n  No repos :(\n{{/repo}}  Data:  {\n   repo : []\n}  Output:  No repos :(  Ractive takes it a step further and also allows you to use  {{elseif otherCondition}}  for alternate cases.  {{#if foo}}\n  foo\n{{elseif bar}}\n  bar but not foo\n{{else}}\n  neither foo nor bar\n{{/if}}  In this case, the output would be what you would expect. If  foo  is true, then the output will be  foo . If  foo  is false and  bar  is true, the the output will be  bar but not foo . If neither  foo  nor  bar  is true, the the output will be  neither foo nor bar .  Further,  {{else}}  and  {{elseif}}  clauses can be used with  {{#with}}  and  {{#each}}  sections too. If the context for the  {{#with}}  section doesn't exist, then any else clauses will be processed as if the entire section were a conditional with a false first branch. If the array for the  {{#each}}  (or regular iterative section) is empty or the object has no keys, then any else clauses will be processed as if the entire section were a conditional with a false first branch.", 
            "title": "{{else}} and {{elseif}}"
        }, 
        {
            "location": "/concepts/templates/#escaping-mustaches", 
            "text": "If you need to have Ractive ignore some mustaches in your template, you can escape them with a '\\'.  {{ interpolated }} {{backslash}}{{ left alone }}  If you need to have a backslash before an interpolated mustache, you can escape the backslash with another '\\'. Any additional mustaches will be exported into the template.  {{backslash}}{{backslash}}{{ interpolated }} and preceeded by a single slash.\n{{backslash}}{{backslash}}{{backslash}}{{ interpolated }} and preceeded by two slashes.", 
            "title": "Escaping mustaches"
        }, 
        {
            "location": "/concepts/templates/#footnote", 
            "text": "*Ractive implements the Mustache specification as closely as possible. 100% compliance is impossible, because it's unlike other templating libraries - rather than turning a string into a string, Ractive turns a string into DOM, which has to be restringified so we can test compliance. Some things, like lambdas, get lost in translation - it's unavoidable, and unimportant.", 
            "title": "Footnote"
        }
    ]
}