{
    "docs": [
        {
            "location": "/", 
            "text": "Ractive.js\n\n\nWelcome! These pages aim to provide all the information you need to master Ractive.\n\n\nPhilosophy\n\n\nRactive takes care of your UI and your application state. But if you're building a complex app, you'll likely have other things in the mix. Routing, history management, server communication, data validation, realtime communication, user authentication, and all that fun stuff.\n\n\nUnlike other frameworks, Ractive doesn't have an opinion about these things. You are encouraged to build your app from small, loosely coupled modules. It means you're not locked-in writing code for a particular framework The Right Way\u2122. Should you hate one of your modules for some reason, you can easily swap it out for another and move on with life.\n\n\nDownload\n\n\nRactive is available in several places:\n\n\n// unpkg\nhttps://unpkg.com/ractive\n\n// CDNjs\nhttps://cdnjs.com/libraries/ractive\n\n// npm\nnpm install --save-dev ractive\n\n// Bower\nbower install --save ractive\n\n\n\n\nUsage\n\n\nUsing Ractive is very simple. Create a new instance using \nnew Ractive({...})\n with the desired options.\n\n\nvar ractive = new Ractive({\n    el: 'body',\n    template: '\np\n{{greeting}}, {{recipient}}\n/p\n',\n    data: {\n        greeting: 'Hello',\n        recipient: 'World!'\n    }\n});\n\n\n\n\nWhile there are \nno required options\n, \nel\n, \ntemplate\n and \ndata\n are the most common. They specify \nwhat element\n to attach an instance with \nthis markup\n having \nthis data\n. Check out \nInitialization Options\n to learn more about the available options.\n\n\nIf you get stuck at any point, visit the \nGet Support\n page for places to find help.\n\n\n\n\nThis project is the brainchild of an Englishman and has contributors from all over the world. There is an ecclectic mix of primarily the Queen's English, a fair amount of 'Murican English, and a bit of others here and there. Things like \nadaptor\n, \nbehaviour\n, and \ndependant\n may have more than one spelling but we try to stick to the Queen's English to the extent that we are able.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#ractivejs", 
            "text": "Welcome! These pages aim to provide all the information you need to master Ractive.", 
            "title": "Ractive.js"
        }, 
        {
            "location": "/#philosophy", 
            "text": "Ractive takes care of your UI and your application state. But if you're building a complex app, you'll likely have other things in the mix. Routing, history management, server communication, data validation, realtime communication, user authentication, and all that fun stuff.  Unlike other frameworks, Ractive doesn't have an opinion about these things. You are encouraged to build your app from small, loosely coupled modules. It means you're not locked-in writing code for a particular framework The Right Way\u2122. Should you hate one of your modules for some reason, you can easily swap it out for another and move on with life.", 
            "title": "Philosophy"
        }, 
        {
            "location": "/#download", 
            "text": "Ractive is available in several places:  // unpkg\nhttps://unpkg.com/ractive\n\n// CDNjs\nhttps://cdnjs.com/libraries/ractive\n\n// npm\nnpm install --save-dev ractive\n\n// Bower\nbower install --save ractive", 
            "title": "Download"
        }, 
        {
            "location": "/#usage", 
            "text": "Using Ractive is very simple. Create a new instance using  new Ractive({...})  with the desired options.  var ractive = new Ractive({\n    el: 'body',\n    template: ' p {{greeting}}, {{recipient}} /p ',\n    data: {\n        greeting: 'Hello',\n        recipient: 'World!'\n    }\n});  While there are  no required options ,  el ,  template  and  data  are the most common. They specify  what element  to attach an instance with  this markup  having  this data . Check out  Initialization Options  to learn more about the available options.  If you get stuck at any point, visit the  Get Support  page for places to find help.   This project is the brainchild of an Englishman and has contributors from all over the world. There is an ecclectic mix of primarily the Queen's English, a fair amount of 'Murican English, and a bit of others here and there. Things like  adaptor ,  behaviour , and  dependant  may have more than one spelling but we try to stick to the Queen's English to the extent that we are able.", 
            "title": "Usage"
        }, 
        {
            "location": "/Get Started/Examples/Chart/", 
            "text": "Chart", 
            "title": "Animated Chart"
        }, 
        {
            "location": "/Get Started/Examples/Chart/#chart", 
            "text": "", 
            "title": "Chart"
        }, 
        {
            "location": "/Get Started/Examples/Clock/", 
            "text": "Clock", 
            "title": "Clock"
        }, 
        {
            "location": "/Get Started/Examples/Clock/#clock", 
            "text": "", 
            "title": "Clock"
        }, 
        {
            "location": "/Get Started/Examples/Comments/", 
            "text": "Comments", 
            "title": "Comments"
        }, 
        {
            "location": "/Get Started/Examples/Comments/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/Get Started/Examples/Components/", 
            "text": "Components", 
            "title": "Components"
        }, 
        {
            "location": "/Get Started/Examples/Components/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/Get Started/Examples/Illustration/", 
            "text": "Illustration", 
            "title": "Illustration"
        }, 
        {
            "location": "/Get Started/Examples/Illustration/#illustration", 
            "text": "", 
            "title": "Illustration"
        }, 
        {
            "location": "/Get Started/Examples/Infinite Scroll/", 
            "text": "Infinite Scroll", 
            "title": "Infinite Scroll"
        }, 
        {
            "location": "/Get Started/Examples/Infinite Scroll/#infinite-scroll", 
            "text": "", 
            "title": "Infinite Scroll"
        }, 
        {
            "location": "/Get Started/Examples/Backbone/", 
            "text": "Backbone", 
            "title": "Backbone"
        }, 
        {
            "location": "/Get Started/Examples/Backbone/#backbone", 
            "text": "", 
            "title": "Backbone"
        }, 
        {
            "location": "/Get Started/Examples/Ratings/", 
            "text": "Ratings", 
            "title": "Ratings"
        }, 
        {
            "location": "/Get Started/Examples/Ratings/#ratings", 
            "text": "", 
            "title": "Ratings"
        }, 
        {
            "location": "/Get Started/Examples/Todos/", 
            "text": "Todo", 
            "title": "Todos"
        }, 
        {
            "location": "/Get Started/Examples/Todos/#todo", 
            "text": "", 
            "title": "Todo"
        }, 
        {
            "location": "/Get Started/Debugging/", 
            "text": "Debugging\n\n\nUsing \nRactive.getNodeInfo()\n for debugging\n\n\nThis is particularly useful for \ndecorators\n and debugging. Notably, in Chrome, if you inspect an element, that element will be added to the Chrome Developer Tools' node list and can be referenced in the console as \n$0\n. Try inspecting a Ractive-controlled element and using \nRactive.getNodeInfo($0)\n in the console.\n\n\nAdding debugger on evaluated code", 
            "title": "Debugging"
        }, 
        {
            "location": "/Get Started/Debugging/#debugging", 
            "text": "", 
            "title": "Debugging"
        }, 
        {
            "location": "/Get Started/Debugging/#using-ractivegetnodeinfo-for-debugging", 
            "text": "This is particularly useful for  decorators  and debugging. Notably, in Chrome, if you inspect an element, that element will be added to the Chrome Developer Tools' node list and can be referenced in the console as  $0 . Try inspecting a Ractive-controlled element and using  Ractive.getNodeInfo($0)  in the console.", 
            "title": "Using Ractive.getNodeInfo() for debugging"
        }, 
        {
            "location": "/Get Started/Debugging/#adding-debugger-on-evaluated-code", 
            "text": "", 
            "title": "Adding debugger on evaluated code"
        }, 
        {
            "location": "/Get Started/Support/", 
            "text": "Support\n\n\nGetting in touch\n\n\nThere are a lot of places to find help if you get stuck with Ractive:\n\n\n\n\nStackOverflow\n\n\nGoogle Groups\n\n\nGitHub\n\n\nTwitter\n\n\n\n\nLegacy browsers\n\n\nThe core Ractive library requires the following APIs to be present:\n\n\n\n\nArray.isArray\n\n\nArray.prototype.every\n\n\nArray.prototype.filter\n\n\nArray.prototype.forEach\n\n\nArray.prototype.indexOf\n\n\nArray.prototype.map\n\n\nArray.prototype.reduce\n\n\nDate.now\n\n\nFunction.prototype.bind\n\n\nNode.prototype.contains\n\n\nObject.create\n\n\nObject.defineProperty\n\n\nObject.freeze\n\n\nObject.keys\n\n\nPromise\n\n\nrequestAnimationFrame\n\n\nString.prototype.trim\n\n\nwindow.addEventListener\n\n\nwindow.getComputedStyle\n\n\n\n\nMost \nmodern\n browsers already support these APIs. Should you want to serve your app on older browsers, Ractive comes with an optional file containing these specific polyfills. That way, you can still enjoy the full Ractive experience without lugging in a huge polyfill library. Simply load it up before Ractive and pretend as if nothing happened.\n\n\nSVGs\n\n\nRactive doesn't mind whether you're rendering HTML or SVG - it treats both the same way. Unfortunately, some browsers (notably IE8 and below, and Android 2.3 and below) \ndo\n care.\n\n\nThis browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See https://github.com/RactiveJS/Ractive/wiki/SVG-and-older-browsers for more information\n\n\n\n\nIf your template includes SVG and these browsers throw an error along those lines, \nthe only winning move is not to play\n. You will need to provide an alternate fallback when SVG isn't supported.\n\n\nYou might do something along these lines:\n\n\nnew Ractive({\n  el: 'container',\n  template: Ractive.svg ? awesomeVectorGraphicsContent : highResolutionImageContent\n});", 
            "title": "Support"
        }, 
        {
            "location": "/Get Started/Support/#support", 
            "text": "", 
            "title": "Support"
        }, 
        {
            "location": "/Get Started/Support/#getting-in-touch", 
            "text": "There are a lot of places to find help if you get stuck with Ractive:   StackOverflow  Google Groups  GitHub  Twitter", 
            "title": "Getting in touch"
        }, 
        {
            "location": "/Get Started/Support/#legacy-browsers", 
            "text": "The core Ractive library requires the following APIs to be present:   Array.isArray  Array.prototype.every  Array.prototype.filter  Array.prototype.forEach  Array.prototype.indexOf  Array.prototype.map  Array.prototype.reduce  Date.now  Function.prototype.bind  Node.prototype.contains  Object.create  Object.defineProperty  Object.freeze  Object.keys  Promise  requestAnimationFrame  String.prototype.trim  window.addEventListener  window.getComputedStyle   Most  modern  browsers already support these APIs. Should you want to serve your app on older browsers, Ractive comes with an optional file containing these specific polyfills. That way, you can still enjoy the full Ractive experience without lugging in a huge polyfill library. Simply load it up before Ractive and pretend as if nothing happened.", 
            "title": "Legacy browsers"
        }, 
        {
            "location": "/Get Started/Support/#svgs", 
            "text": "Ractive doesn't mind whether you're rendering HTML or SVG - it treats both the same way. Unfortunately, some browsers (notably IE8 and below, and Android 2.3 and below)  do  care.  This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See https://github.com/RactiveJS/Ractive/wiki/SVG-and-older-browsers for more information  If your template includes SVG and these browsers throw an error along those lines,  the only winning move is not to play . You will need to provide an alternate fallback when SVG isn't supported.  You might do something along these lines:  new Ractive({\n  el: 'container',\n  template: Ractive.svg ? awesomeVectorGraphicsContent : highResolutionImageContent\n});", 
            "title": "SVGs"
        }, 
        {
            "location": "/Get Started/Contributing/", 
            "text": "Contributing\n\n\nRactive is a community-driven project. Most of its best features were \nsuggested by users like you\n. There are a lot of ways you can contribute to the project. Here are a few examples:\n\n\nContribute code\n\n\nAn open pull request is better than one that's never submitted. \nPull requests\n are always welcome.\n\n\nWrite documentation\n\n\nEach page in the documentation is just a file written in markdown. Again, \npull requests\n are always welcome.\n\n\nWrite plugins\n\n\nExtend Ractive in ways you've never seen before. Interface with other libraries, create effects, widgets, interactions, custom elements, and so much more with Ractive's very extensible core.\n\n\nRefer to \nPlugins\n for details on how to start writing Ractive plugins.\n\n\nHelp other developers\n\n\nSubscribe to \nStack Overflow questions tagged with \nractivejs\n, and you'll get alerts when someone asks a question that you might be able to answer.\n\n\nSpread the word\n\n\nTweet, write blog posts, recommend it to your friends, submit talks (here are some \ntips on speaking at tech meetups\n). These are just a few ways to spread the word about Ractive. The larger the community, the better it becomes.\n\n\nBuild stuff\n\n\nBut above all, build stuff! If you make something with Ractive, we'd love to hear about it.", 
            "title": "Contributing"
        }, 
        {
            "location": "/Get Started/Contributing/#contributing", 
            "text": "Ractive is a community-driven project. Most of its best features were  suggested by users like you . There are a lot of ways you can contribute to the project. Here are a few examples:", 
            "title": "Contributing"
        }, 
        {
            "location": "/Get Started/Contributing/#contribute-code", 
            "text": "An open pull request is better than one that's never submitted.  Pull requests  are always welcome.", 
            "title": "Contribute code"
        }, 
        {
            "location": "/Get Started/Contributing/#write-documentation", 
            "text": "Each page in the documentation is just a file written in markdown. Again,  pull requests  are always welcome.", 
            "title": "Write documentation"
        }, 
        {
            "location": "/Get Started/Contributing/#write-plugins", 
            "text": "Extend Ractive in ways you've never seen before. Interface with other libraries, create effects, widgets, interactions, custom elements, and so much more with Ractive's very extensible core.  Refer to  Plugins  for details on how to start writing Ractive plugins.", 
            "title": "Write plugins"
        }, 
        {
            "location": "/Get Started/Contributing/#help-other-developers", 
            "text": "Subscribe to  Stack Overflow questions tagged with  ractivejs , and you'll get alerts when someone asks a question that you might be able to answer.", 
            "title": "Help other developers"
        }, 
        {
            "location": "/Get Started/Contributing/#spread-the-word", 
            "text": "Tweet, write blog posts, recommend it to your friends, submit talks (here are some  tips on speaking at tech meetups ). These are just a few ways to spread the word about Ractive. The larger the community, the better it becomes.", 
            "title": "Spread the word"
        }, 
        {
            "location": "/Get Started/Contributing/#build-stuff", 
            "text": "But above all, build stuff! If you make something with Ractive, we'd love to hear about it.", 
            "title": "Build stuff"
        }, 
        {
            "location": "/API/Initialization Options/", 
            "text": "Initialization Options\n\n\nThe following is an exhaustive list of initialisation options that you can pass to \nnew Ractive(options)\n and \nRactive.extend(options)\n, with full descriptions grouped below by category.\n\n\nNote that any additional options set that's not part of the\ninitialization options\nwill be added as properties of the instance.\n\n\nvar ractive = new Ractive({\n  myMethod: function () {\n    alert( 'my method was called' );\n  }\n});\n\nractive.myMethod(); // triggers the alert\n\n\n\n\n\n\nadapt\n\n\n(Array\nstring|Object\n)\n\n\nCustom wrappers to be used with all or part of the supplied data, see \nAdaptors\n. Unlike components or other registries where there is a template-level directive that informs Ractive that plugin is to be used, \nadaptors\n are a data-level construct and so you use the \nadapt\n option to tell Ractive which \nadaptors\n are to be used with that instance. If you define the \nadaptors\n directly on the instance or component, you do not need to specify them in the \nadapt\n option.\n\n\nCan either be the \nadaptor\n itself, or the name of an \nadaptor\n registred via \nRactive.adaptors\n:\n\n\nRactive.adaptors.myAdaptor = MyAdaptor1;\n\nnew Ractive({\n  adapt: [ 'myAdaptor', MyAdaptor2 ]\n})\n\n\n\n\n\n\nadaptors\n\n\n(Object\nstring, Object\n)\n\n\nA key-value hash of \nadaptors\n that are specific to this instance. Usually the \nadapt\n property can directly specify which adaptors\nto use on this instance and the \nadaptors\n property is used to register an \nadaptor\n on components or \nRactive.adaptors\n.\n\n\nadaptors: {\n  myAdaptor: MyAdaptor\n}\n\n\n\n\n\n\nappend\n\n\n(boolean|string|HTMLElement|array-like)\n\n\nControls how the instance is attached to \nel\n. Defaults to \nfalse\n.\n\n\nfalse\n replaces the contents of \nel\n.\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: false,\ntemplate: '\np\nnew content\n/p\n'\n\n\n\n\ndiv id='container'\n\n  \np\nnew content\n/p\n\n\n/div\n\n\n\n\n\ntrue\n appends the instance to \nel\n.\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: true,\ntemplate: '\np\nnew content\n/p\n'\n\n\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n  \np\nnew content\n/p\n\n\n/div\n\n\n\n\n\nAn element id, CSS selector referencing an element, HTML element reference or an array-like object containing an HTML element reference as first item that is a child of \nel\n will render the instance before that element.\n\n\ndiv id='container'\n\n  \np\nred\n/p\n\n  \np\norange\n/p\n\n  \np\nyellow\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: document.querySelector('p:nth-child(2)'),\ntemplate: '\np\ngrey\n/p\n'\n\n\n\n\ndiv id='container'\n\n  \np\nred\n/p\n\n  \np\ngrey\n/p\n\n  \np\norange\n/p\n\n  \np\nyellow\n/p\n\n\n/div\n\n\n\n\n\n\n\ncomponents\n\n\n(Object\nstring, Function\n)\n\n\nA map of \ncomponents\n where the \nkey\n is the name of the component the \nvalue\n is either a component definition or a function that returns either a globally registered component name or a component definition.\n\n\ncomponents: {\n  'my-component': Ractive.extend({\n    template: '#componentTemplate',\n    init: function () {...}\n  }),\n  dynamicComponent: function(data){\n    return data.foo ? 'globallyRegisteredComponent' : componentDefinition;\n  }\n}\n\n\n\n\nIf you need to do additional post-processing on the components, the function option receives post-processed data.\n\n\nDuring a \nractive.reset()\n, function component options will be re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\n\n\ncomputed\n\n\n(Object\nstring, function|Object\n)\n\n\nAn object that maps to a set of computed values.\n\n\ncomputed: {\n  area: '${width} - ${height}'\n}\n\n\n\n\nSee \nComputed Properties\n for more information and examples .\n\n\n\n\ncsp\n\n\n(boolean)\n\n\nDefaults to \nfalse\n. Whether or not to add inline functions for expressions after parsing. This can effectively eliminate \neval\n caused by expressions in templates. It also makes the resulting template no longer JSON compatible, so the template will have to be served via \nscript\n tag.\n\n\n\n\ncss\n\n\n(string)\n\n\nUsed on components to specify \ncss\n styles to be inserted into the document.\n\n\n\n\ndata\n\n\n(Object\nstring, any\n|Function)\n\n\nThe data with which to initialise.\n\n\ndata: { foo: 'bar' }\n\ndata: function() {\n  return { foo: 'bar' };\n}\n\n\n\n\nWhen using a data object on components, the data is attached to the component's prototype. Standard prototype rules apply, which means modifying non-primitive data will modify the value on the prototype.\n\n\nconst Component = Ractive.extend({\n    data: {\n        foo: { bar: 42 }\n    }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 12\n\n\n\n\nWhen using a data function, the function is run to generate the data and the data is attached to each instance rather than to the prototype.\n\n\nconst Component = Ractive.extend({\n    data: function () {\n        return {\n            foo: { bar: 42 }\n        };\n    }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 12\n\n\n\n\nthis._super\n can be used when using a data function option to merge the parent component data into the extending component. Ractive handles the differences between usage of a data object and data function.\n\n\nvar Component1 = Ractive.extend({\n  data: {\n    formatTitle: function (title) {\n      return '\n' + title.toUpperCase() + '\n';\n    }\n  }\n});\n\nvar Component2 = Component1.extend({\n  data: function( data ) {\n    this._super( data );\n    data.scale = 5;\n  }\n});\n\nvar ractive = new Component2({\n    data: { foo: 'bar' }\n});\n\n// r.data: { foo: \nbar\n, formatTitle: function, scale: 5 }\n\n\n\n\nData may also be set asynchronously when using data function options.\n\n\ndata: function () {\n\n    $.get( 'somedata.url', function( data ) {\n        this.set( '', data );\n    }.bind(this) );\n\n    return {\n        foo: 'default'\n    };\n}\n\n\n\n\nModels can also be used to supply data as long as they return plain objects whose properties are public.\n\n\ndata: function ( data ) {\n    return new Model( data );\n}\n\n\n\n\nIf you use a constructor guard clause, you can simply provide the reference to the model directly instead using a data function.\n\n\nfunction Model ( data ) {\n    if ( !( this instanceof Model) ) { return new Model( data ); }\n    // model setup\n}\n\nvar MyComponent = Ractive.extend({\n    data: Model\n});\n\nvar r = new MyComponent({\n    data: { foo: 'bar' }\n})\n\n\n\n\nFor more advanced data modelling and backends, use \nAdaptors\n.\n\n\n\n\ndecorators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of decorators that are specific to this instance, where \nkey\n is the name of the decorator (as referenced within templates as \ndiv decorator=\"myDecorator\"\n/div\n), and \nvalue\n is a is a decorator functions.  See \nDecorators\n for more info.\n\n\ndecorators: {\n  'myDecorator': function( node, fire) {...}\n}\n\n\n\n\n\n\ndelimiters\n\n\n(Array[string])\n\n\nDefaults to \n[ '{{', '}}' ]\n. Used to set what delimiters to use when parsing templates.\n\n\ntemplate: 'hello \n%= world %\n',\ndelimiters: [ '\n%=', '%\n' ],\ndata: { world: 'earth' }\n\n// result:\nhello earth\n\n\n\n\n\n\neasing\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of easing function. See [\nRactive.easing()\n](../API/Static Methods.md#Ractive.easing())\n\n\n\n\nel\n\n\n(string|HTMLElement|array-like)\n\n\nDirectives for the element to render to. Use \nappend\n option (see below) to control whether existing content is replaced.\n\n\nCan either be an element id, CSS selector referencing an element, a reference to an HTML element, or an array-like object containing an HTML element reference as first item.\n\n\nel: 'container'\nel: '#container'\nel: document.getElementById('container')\nel: $('#container')\n\n\n\n\n\n\nenhance\n\n\n(boolean)\n\n\nDefaults to \nfalse\n. Whether or not to try to reuse the existing DOM in the target element when rendering a.k.a. progressive enhancement. This allows you to serve the fully rendered page and then render the Ractive template at load over the pre-rendered page without completely wiping out the existing content. There are a few limitations surrounding text nodes, but all matching elements will be reused.\n\n\nThis option cannot be used with \nappend\n.\n\n\nTo expand on the limitations with text nodes, since HTML does not have a markup representation for individual adjacent text nodes where the DOM does, the loaded DOM will have all text nodes merged when the document loads from the server. Ractive needs individual adjacent text nodes in certain situations like \nouter text {{#if foo}}inner text{{/if}}\n. The \n'outer text '\n text node is always present, and if \nfoo\n becomes truthy, an additional text node will be inserted next to the \n'outer text '\n node containing \n'inner text'\n. It has been suggested that Ractive could also deal with merged text nodes, but that would become quite complex because there are certain scenarios where a text node would have to split and be rejoined as the model changed e.g. \nouter text {{#if foo}}\nspan\nhello\n/span\n{{/if}} the other side\n. In that case, if \nfoo\n is initially falsey, the \n'outer text '\n and \n' the other side'\n nodes could be merged into a single node. However, if \nfoo\n became truthy, that node would have to be split into two to place on either side of the \nspan\n.\n\n\nAdditionally, unescaped HTML mustaches (triples) don't play nicely with enhance because there's no easy way to match up the string content to the target DOM nodes. This may be remedied at some point in the future.\n\n\nTODO: Simplify/restructure\n\n\n\n\nevents\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of \nevent plugins\n that are specific to this instance, where \nkey\n is the name of the event (as referenced within templates as \nbutton on-mycustomevent=\"fire\"\n/button\n), and \nvalue\n is the custom event plugin functions.  See \nWriting Events\n for more info.\n\n\nevents: {\n  'mycustomevent': function( node, fire ) {...}\n}\n\n\n\n\n\n\ninterpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n.\n\n\n\n\nisolated\n\n\n(boolean)\n\n\nDefaults to \nfalse\n. This option is typically only relevant as an extension option for \nComponents\n. Controls whether the component will look outside itself for data and registry items.\n\n\n\n\nlazy\n\n\n(boolean)\n\n\nDefaults to \nfalse\n. If two-way data binding is enabled, whether to only update data based on text inputs on \nchange\n and \nblur\n events, rather than any event (such as key events) that may result in new data.\n\n\nvar ractive = new Ractive({\n  template: '\ninput value=\n{{foo}}\n',\n  data: { foo: 'bar' },\n  lazy: true\n});\n\n// will not fire as user is typing\nractive.on('change', function(){\n  // only happens on exiting \ninputor return if submit\n  console.log('changed!')\n})\n\n\n\n\n\n\nmagic\n\n\n(boolean)\n\n\nDefaults to \nfalse\n. Whether or not to wrap data in ES5 accessors for automatic binding (see \nMagic Mode\n).\n\n\nvar data = { foo: 'bar' };\nnew Ractive({ data: data } );\n// will update automagically:\ndata.foo = 'fizz'\n\n\n\n\n\n\nmodifyArrays\n\n\n(boolean)\n\n\nDefaults to \nfalse\n. Whether or not to modify array mutator methods to enable frictionless data binding with lists (see \nArray Modification\n).\n\n\nvar items = [ 'red', 'blue' ];\nnew Ractive({\n  data: data,\n  modifyArrays: true //default\n});\n\n// will update automagically:\nitems.push( 'green' );\n\n\n\n\n\n\nnoCSSTransform\n\n\n(boolean)\n\n\nDefaults to \nfalse\n. Prevents component css from being transformed with scoping guids.\n\n\n\n\nnoIntro\n\n\n(boolean)\n\n\nDefaults to \nfalse\n. Whether or not to skip intro transitions on render.\n\n\nvar ractive = new Ractive({\n  template: '\nul\n{{#items}}\nli intro=\nfade\n{{.}}\n/li\n{{/items}}\n/ul\n',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: { fade: function ( t, params ) {...} },\n  noIntro: true\n});\n// 'red' and 'blue' list items do not fade in on intro\n\nractive.get('items').push( 'green' );\n// 'green' list item will fade in\n\n\n\n\n\n\nonchange\n\n\n(Function)\n\n\nA lifecycle event that is called when data owned by the instance changes.\n\n\nAccepts an map whose keys are the \nkeypaths\n that changed and whose values are the new values for that keypath.\n\n\n\n\noncomplete\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is rendered \nand\n all the transitions have completed.\n\n\n\n\nonconfig\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed and all configuration options have been processed.\n\n\n\n\nonconstruct\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed but before any configuration has been processed.\n\n\nAccepts the\ninitialization options\nas arguments.\n\n\n\n\nondetach\n\n\n(Function)\n\n\nA lifecycle event that is called whenever \nractive.detach()\n is called.\n\n\nNote that \nractive.insert()\n implicitly calls \nractive.detach()\n if needed.\n\n\n\n\noninit\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed and is ready to be rendered.\n\n\n\n\noninsert\n\n\n(Function)\n\n\nA lifecycle event that is called when \nractive.insert()\n is called.\n\n\n\n\nonrender\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is rendered and \nbefore\n transitions are started.\n\n\n\n\nonteardown\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is being torn down.\n\n\n\n\nonunrender\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is being undrendered.\n\n\n\n\nonupdate\n\n\n(Function)\n\n\nA lifecycle event that is called when \nractive.update()\n is called.\n\n\n\n\npartials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nA map of \npartials\n where the key is the name of the partial, and the value is either a template string, an parsed template object or a function that returns any of the previous options.\n\n\npartials: {\n  stringPartial: '\np\n{{greeting}} world!\n/p\n',\n  parsedPartial: {\nv\n:3,\nt\n:[{\nt\n:7,\ne\n:\np\n,\nf\n:[{\nt\n:2,\nr\n:\ngreeting\n},\n world!\n]}]},\n  functionPartial: function(data, p){\n    return data.condition ? '\np\nhello world\n/p\n' : '\ndiv\nyes, we have no foo\n/div\n';\n  }\n}\n\n\n\n\nIf you need to do additional post-processing on the partials, the function option receives post-processed data and a \nParse Object\n that provides helper methods for template manipulation.\n\n\nDuring a \nractive.reset()\n, function partials will be re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\n\n\npreserveWhitespace\n\n\n(boolean)\n\n\nDefaults to \nfalse\n. Whether or not to preserve whitespace in templates when parsing. (Whitespace in \npre\n elements is always preserved.)\n\n\nvar ractive = new Ractive({\n  template: '\np\nhello\\n\\n  \\tworld   \n/p\n',\n  preserveWhitespace: false //default\n});\nconsole.log( ractive.toHTML() );\n// \np\nhello world\n/p\n\n\nvar ractive = new Ractive({\n  template: '\np\nhello\\n\\n  \\tworld   \n/p\n',\n  preserveWhitespace: true\n});\nconsole.log( ractive.toHTML() );\n//\np\nhello\n//\n//  world   \n/p\n\n\n\n\n\nPlease note that the browser will still deal with whitespace in the normal fashion.\n\n\n\n\nsanitize\n\n\n(boolean|Object)\n\n\nDefaults to \nfalse\n. If \ntrue\n, certain elements will be stripped from templates at parse time - \napplet\n, \nbase\n, \nbasefont\n, \nbody\n, \nframe\n, \nframeset\n, \nhead\n, \nhtml\n, \nisindex\n, \nlink\n, \nmeta\n, \nnoframes\n, \nnoscript\n, \nObject\n, \nparam\n, \nscript\n, \nstyle\n and \ntitle\n - as will event attributes (e.g. \nonclick\n).\n\n\ntemplate: '\np\nsome content\n/p\nframe\nAm I a bad element or just misunderstood?\n/frame\n',\nsanitize: true\n\n// result:\n\np\nsome content\n/p\n\n\n\n\n\nAlternatively, pass in an object with an \nelements\n property containing an array of blacklisted elements, and an optional \neventAttributes\n boolean (\ntrue\n means 'disallow event attributes').\n\n\ntemplate: '\np\nsome content\n/p\ndiv onclick=\ndoEvil()\nthe good stuff\n/div\n',\nsanitize: {\n  elements: [ 'p' ],\n  eventAttributes: true\n}\n\n// result:\n\ndiv\nthe good stuff\n/div\n\n\n\n\n\n\n\nstaticDelimiters\n\n\n(Array[string])\n\n\nDefaults to \n[ '[[', ']]' ]\n. Used to set what static (one-time binding) delimiters to use when parsing templates.\n\n\nvar ractive = new Ractive({\n  template: 'hello [[foo]]',\n  staticDelimiters: [ '[[', ']]' ], //default\n  data: { foo: 'world' }\n});\n// result: \nhello world\n\n\nractive.set( 'foo', 'mars' );\n// still is: \nhello world\n\n\n\n\n\n\n\nstaticTripleDelimiters\n\n\n(Array\nstring\n)\n\n\nDefaults to \n[ '[[[', ']]]' ]\n. Used to set what static (one-time binding) triple delimiters to use when parsing templates.\n\n\nvar ractive = new Ractive({\n  template: 'hello [[[html]]]',\n  staticTripleDelimiters: [ '[[[', ']]]' ], //default\n  data: { html: '\nspan\nworld\n/span\n' }\n});\n// result: \nhello \nspan\nworld\n/span\n\n\nractive.set( 'html', '\nspan\nmars\n/span\n' );\n// still is: \nhello world\n\n\n\n\n\n\n\nstripComments\n\n\n(boolean)\n\n\nDefaults to \ntrue\n. Whether or not to remove comments in templates when parsing.\n\n\ntemplate: '\n!-- html comment --\nhello world',\nstripComments: false\n\n// result:\n\n!-- html comment --\nhello world\n\n\n\n\n\n\ntemplate\n\n\n(string|array|object|function)\n\n\nThe \ntemplate\n to use. Must either be a CSS selector string pointing to an element on the page containing the template, an HTML string, an object resulting from [\nRactive.parse()\n](../API/Static Methods.md#Ractive.parse()) or a function that returns any of the previous options.\n\n\n// Selector\ntemplate: '#my-template',\n\n// HTML\ntemplate: '\np\n{{greeting}} world!\n/p\n',\n\n// Template AST\ntemplate: {\nv\n:3,\nt\n:[{\nt\n:7,\ne\n:\np\n,\nf\n:[{\nt\n:2,\nr\n:\ngreeting\n},\n world!\n]}]},\n\n// Function\ntemplate: function(data, p){\n  return '\np\n{{greeting}} world!\n/p\n';\n},\n\n\n\n\nIf you need to do additional post-processing on templates, the function option receives the post-processed data and a \nParse Object\n that provides helper methods for template manipulation.\n\n\nDuring a \nractive.reset()\n, function templates will be re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\n\n\ntransitions\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of transitions that are specific to this instance. The \nkey\n is referenced within templates using \nintro\n and \noutro\n attributes on elements, and \nvalue\n is a transition functions, see \nTransitions\n for more info.\n\n\ntemplate: '\np intro=\nslide\n outro=\nslide\nhello world\n/p\n',\ntransitions: {\n  slide: function ( t, params ) {...}\n}\n\n\n\n\n\n\ntransitionsEnabled\n\n\n(boolean)\n\n\nDefaults to \ntrue\n. Whether or not transitions are enabled for this instance.\n\n\n\n\ntripleDelimiters\n\n\n(Array[string])\n\n\nDefaults to \n[ '{{{', '}}}' ]\n. Used to set what triple delimiters to use when parsing templates.\n\n\ntemplate: 'hello @html@',\ntripleDelimiters: [ '@', '@' ],\ndata: { html: '\nspan\nworld\n/span\n' }\n\n// result:\nhello \nspan\nworld\n/span\n\n\n\n\n\n\n\ntwoway\n\n\n(boolean)\n\n\nDefaults to \ntrue\n. Whether or not two-way data binding is enabled (see \nTwo-Way Binding\n).\n\n\nvar ractive = new Ractive({\n  template: '\ninput value=\n{{foo}}\n',\n  data: { foo: 'bar' },\n  twoway: false\n});\n\n// user types \nfizz\n into \ninput\n, but data value is not changed:\nconsole.log( ractive.get( 'foo' ) ); //logs \nbar\n\n\n// updates from the model are still pushed to the view\nractive.set( 'foo', 'fizz' );\n\n// input now displays \nfizz\n\n\n\n\n\nAlso see \nstatic delimiters\n for one-time binding", 
            "title": "Initialization Options"
        }, 
        {
            "location": "/API/Initialization Options/#initialization-options", 
            "text": "The following is an exhaustive list of initialisation options that you can pass to  new Ractive(options)  and  Ractive.extend(options) , with full descriptions grouped below by category.  Note that any additional options set that's not part of the initialization options will be added as properties of the instance.  var ractive = new Ractive({\n  myMethod: function () {\n    alert( 'my method was called' );\n  }\n});\n\nractive.myMethod(); // triggers the alert", 
            "title": "Initialization Options"
        }, 
        {
            "location": "/API/Initialization Options/#adapt", 
            "text": "(Array string|Object )  Custom wrappers to be used with all or part of the supplied data, see  Adaptors . Unlike components or other registries where there is a template-level directive that informs Ractive that plugin is to be used,  adaptors  are a data-level construct and so you use the  adapt  option to tell Ractive which  adaptors  are to be used with that instance. If you define the  adaptors  directly on the instance or component, you do not need to specify them in the  adapt  option.  Can either be the  adaptor  itself, or the name of an  adaptor  registred via  Ractive.adaptors :  Ractive.adaptors.myAdaptor = MyAdaptor1;\n\nnew Ractive({\n  adapt: [ 'myAdaptor', MyAdaptor2 ]\n})", 
            "title": "adapt"
        }, 
        {
            "location": "/API/Initialization Options/#adaptors", 
            "text": "(Object string, Object )  A key-value hash of  adaptors  that are specific to this instance. Usually the  adapt  property can directly specify which adaptors\nto use on this instance and the  adaptors  property is used to register an  adaptor  on components or  Ractive.adaptors .  adaptors: {\n  myAdaptor: MyAdaptor\n}", 
            "title": "adaptors"
        }, 
        {
            "location": "/API/Initialization Options/#append", 
            "text": "(boolean|string|HTMLElement|array-like)  Controls how the instance is attached to  el . Defaults to  false .  false  replaces the contents of  el .  div id='container' \n   p existing content /p  /div   el: '#container',\nappend: false,\ntemplate: ' p new content /p '  div id='container' \n   p new content /p  /div   true  appends the instance to  el .  div id='container' \n   p existing content /p  /div   el: '#container',\nappend: true,\ntemplate: ' p new content /p '  div id='container' \n   p existing content /p \n   p new content /p  /div   An element id, CSS selector referencing an element, HTML element reference or an array-like object containing an HTML element reference as first item that is a child of  el  will render the instance before that element.  div id='container' \n   p red /p \n   p orange /p \n   p yellow /p  /div   el: '#container',\nappend: document.querySelector('p:nth-child(2)'),\ntemplate: ' p grey /p '  div id='container' \n   p red /p \n   p grey /p \n   p orange /p \n   p yellow /p  /div", 
            "title": "append"
        }, 
        {
            "location": "/API/Initialization Options/#components", 
            "text": "(Object string, Function )  A map of  components  where the  key  is the name of the component the  value  is either a component definition or a function that returns either a globally registered component name or a component definition.  components: {\n  'my-component': Ractive.extend({\n    template: '#componentTemplate',\n    init: function () {...}\n  }),\n  dynamicComponent: function(data){\n    return data.foo ? 'globallyRegisteredComponent' : componentDefinition;\n  }\n}  If you need to do additional post-processing on the components, the function option receives post-processed data.  During a  ractive.reset() , function component options will be re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "components"
        }, 
        {
            "location": "/API/Initialization Options/#computed", 
            "text": "(Object string, function|Object )  An object that maps to a set of computed values.  computed: {\n  area: '${width} - ${height}'\n}  See  Computed Properties  for more information and examples .", 
            "title": "computed"
        }, 
        {
            "location": "/API/Initialization Options/#csp", 
            "text": "(boolean)  Defaults to  false . Whether or not to add inline functions for expressions after parsing. This can effectively eliminate  eval  caused by expressions in templates. It also makes the resulting template no longer JSON compatible, so the template will have to be served via  script  tag.", 
            "title": "csp"
        }, 
        {
            "location": "/API/Initialization Options/#css", 
            "text": "(string)  Used on components to specify  css  styles to be inserted into the document.", 
            "title": "css"
        }, 
        {
            "location": "/API/Initialization Options/#data", 
            "text": "(Object string, any |Function)  The data with which to initialise.  data: { foo: 'bar' }\n\ndata: function() {\n  return { foo: 'bar' };\n}  When using a data object on components, the data is attached to the component's prototype. Standard prototype rules apply, which means modifying non-primitive data will modify the value on the prototype.  const Component = Ractive.extend({\n    data: {\n        foo: { bar: 42 }\n    }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 12  When using a data function, the function is run to generate the data and the data is attached to each instance rather than to the prototype.  const Component = Ractive.extend({\n    data: function () {\n        return {\n            foo: { bar: 42 }\n        };\n    }\n});\n\nvar component1 = new Component();\nvar component2 = new Component();\ncomponent1.set( 'foo.bar', 12 );\ncomponent2.get( 'foo.bar' ); // returns 12  this._super  can be used when using a data function option to merge the parent component data into the extending component. Ractive handles the differences between usage of a data object and data function.  var Component1 = Ractive.extend({\n  data: {\n    formatTitle: function (title) {\n      return ' ' + title.toUpperCase() + ' ';\n    }\n  }\n});\n\nvar Component2 = Component1.extend({\n  data: function( data ) {\n    this._super( data );\n    data.scale = 5;\n  }\n});\n\nvar ractive = new Component2({\n    data: { foo: 'bar' }\n});\n\n// r.data: { foo:  bar , formatTitle: function, scale: 5 }  Data may also be set asynchronously when using data function options.  data: function () {\n\n    $.get( 'somedata.url', function( data ) {\n        this.set( '', data );\n    }.bind(this) );\n\n    return {\n        foo: 'default'\n    };\n}  Models can also be used to supply data as long as they return plain objects whose properties are public.  data: function ( data ) {\n    return new Model( data );\n}  If you use a constructor guard clause, you can simply provide the reference to the model directly instead using a data function.  function Model ( data ) {\n    if ( !( this instanceof Model) ) { return new Model( data ); }\n    // model setup\n}\n\nvar MyComponent = Ractive.extend({\n    data: Model\n});\n\nvar r = new MyComponent({\n    data: { foo: 'bar' }\n})  For more advanced data modelling and backends, use  Adaptors .", 
            "title": "data"
        }, 
        {
            "location": "/API/Initialization Options/#decorators", 
            "text": "(Object string, Function )  A key-value hash of decorators that are specific to this instance, where  key  is the name of the decorator (as referenced within templates as  div decorator=\"myDecorator\" /div ), and  value  is a is a decorator functions.  See  Decorators  for more info.  decorators: {\n  'myDecorator': function( node, fire) {...}\n}", 
            "title": "decorators"
        }, 
        {
            "location": "/API/Initialization Options/#delimiters", 
            "text": "(Array[string])  Defaults to  [ '{{', '}}' ] . Used to set what delimiters to use when parsing templates.  template: 'hello  %= world % ',\ndelimiters: [ ' %=', '% ' ],\ndata: { world: 'earth' }\n\n// result:\nhello earth", 
            "title": "delimiters"
        }, 
        {
            "location": "/API/Initialization Options/#easing", 
            "text": "(Object string, Function )  A key-value hash of easing function. See [ Ractive.easing() ](../API/Static Methods.md#Ractive.easing())", 
            "title": "easing"
        }, 
        {
            "location": "/API/Initialization Options/#el", 
            "text": "(string|HTMLElement|array-like)  Directives for the element to render to. Use  append  option (see below) to control whether existing content is replaced.  Can either be an element id, CSS selector referencing an element, a reference to an HTML element, or an array-like object containing an HTML element reference as first item.  el: 'container'\nel: '#container'\nel: document.getElementById('container')\nel: $('#container')", 
            "title": "el"
        }, 
        {
            "location": "/API/Initialization Options/#enhance", 
            "text": "(boolean)  Defaults to  false . Whether or not to try to reuse the existing DOM in the target element when rendering a.k.a. progressive enhancement. This allows you to serve the fully rendered page and then render the Ractive template at load over the pre-rendered page without completely wiping out the existing content. There are a few limitations surrounding text nodes, but all matching elements will be reused.  This option cannot be used with  append .  To expand on the limitations with text nodes, since HTML does not have a markup representation for individual adjacent text nodes where the DOM does, the loaded DOM will have all text nodes merged when the document loads from the server. Ractive needs individual adjacent text nodes in certain situations like  outer text {{#if foo}}inner text{{/if}} . The  'outer text '  text node is always present, and if  foo  becomes truthy, an additional text node will be inserted next to the  'outer text '  node containing  'inner text' . It has been suggested that Ractive could also deal with merged text nodes, but that would become quite complex because there are certain scenarios where a text node would have to split and be rejoined as the model changed e.g.  outer text {{#if foo}} span hello /span {{/if}} the other side . In that case, if  foo  is initially falsey, the  'outer text '  and  ' the other side'  nodes could be merged into a single node. However, if  foo  became truthy, that node would have to be split into two to place on either side of the  span .  Additionally, unescaped HTML mustaches (triples) don't play nicely with enhance because there's no easy way to match up the string content to the target DOM nodes. This may be remedied at some point in the future.  TODO: Simplify/restructure", 
            "title": "enhance"
        }, 
        {
            "location": "/API/Initialization Options/#events", 
            "text": "(Object string, Function )  A key-value hash of  event plugins  that are specific to this instance, where  key  is the name of the event (as referenced within templates as  button on-mycustomevent=\"fire\" /button ), and  value  is the custom event plugin functions.  See  Writing Events  for more info.  events: {\n  'mycustomevent': function( node, fire ) {...}\n}", 
            "title": "events"
        }, 
        {
            "location": "/API/Initialization Options/#interpolators", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate() .", 
            "title": "interpolators"
        }, 
        {
            "location": "/API/Initialization Options/#isolated", 
            "text": "(boolean)  Defaults to  false . This option is typically only relevant as an extension option for  Components . Controls whether the component will look outside itself for data and registry items.", 
            "title": "isolated"
        }, 
        {
            "location": "/API/Initialization Options/#lazy", 
            "text": "(boolean)  Defaults to  false . If two-way data binding is enabled, whether to only update data based on text inputs on  change  and  blur  events, rather than any event (such as key events) that may result in new data.  var ractive = new Ractive({\n  template: ' input value= {{foo}} ',\n  data: { foo: 'bar' },\n  lazy: true\n});\n\n// will not fire as user is typing\nractive.on('change', function(){\n  // only happens on exiting  inputor return if submit\n  console.log('changed!')\n})", 
            "title": "lazy"
        }, 
        {
            "location": "/API/Initialization Options/#magic", 
            "text": "(boolean)  Defaults to  false . Whether or not to wrap data in ES5 accessors for automatic binding (see  Magic Mode ).  var data = { foo: 'bar' };\nnew Ractive({ data: data } );\n// will update automagically:\ndata.foo = 'fizz'", 
            "title": "magic"
        }, 
        {
            "location": "/API/Initialization Options/#modifyarrays", 
            "text": "(boolean)  Defaults to  false . Whether or not to modify array mutator methods to enable frictionless data binding with lists (see  Array Modification ).  var items = [ 'red', 'blue' ];\nnew Ractive({\n  data: data,\n  modifyArrays: true //default\n});\n\n// will update automagically:\nitems.push( 'green' );", 
            "title": "modifyArrays"
        }, 
        {
            "location": "/API/Initialization Options/#nocsstransform", 
            "text": "(boolean)  Defaults to  false . Prevents component css from being transformed with scoping guids.", 
            "title": "noCSSTransform"
        }, 
        {
            "location": "/API/Initialization Options/#nointro", 
            "text": "(boolean)  Defaults to  false . Whether or not to skip intro transitions on render.  var ractive = new Ractive({\n  template: ' ul {{#items}} li intro= fade {{.}} /li {{/items}} /ul ',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: { fade: function ( t, params ) {...} },\n  noIntro: true\n});\n// 'red' and 'blue' list items do not fade in on intro\n\nractive.get('items').push( 'green' );\n// 'green' list item will fade in", 
            "title": "noIntro"
        }, 
        {
            "location": "/API/Initialization Options/#onchange", 
            "text": "(Function)  A lifecycle event that is called when data owned by the instance changes.  Accepts an map whose keys are the  keypaths  that changed and whose values are the new values for that keypath.", 
            "title": "onchange"
        }, 
        {
            "location": "/API/Initialization Options/#oncomplete", 
            "text": "(Function)  A lifecycle event that is called when the instance is rendered  and  all the transitions have completed.", 
            "title": "oncomplete"
        }, 
        {
            "location": "/API/Initialization Options/#onconfig", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed and all configuration options have been processed.", 
            "title": "onconfig"
        }, 
        {
            "location": "/API/Initialization Options/#onconstruct", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed but before any configuration has been processed.  Accepts the initialization options as arguments.", 
            "title": "onconstruct"
        }, 
        {
            "location": "/API/Initialization Options/#ondetach", 
            "text": "(Function)  A lifecycle event that is called whenever  ractive.detach()  is called.  Note that  ractive.insert()  implicitly calls  ractive.detach()  if needed.", 
            "title": "ondetach"
        }, 
        {
            "location": "/API/Initialization Options/#oninit", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed and is ready to be rendered.", 
            "title": "oninit"
        }, 
        {
            "location": "/API/Initialization Options/#oninsert", 
            "text": "(Function)  A lifecycle event that is called when  ractive.insert()  is called.", 
            "title": "oninsert"
        }, 
        {
            "location": "/API/Initialization Options/#onrender", 
            "text": "(Function)  A lifecycle event that is called when the instance is rendered and  before  transitions are started.", 
            "title": "onrender"
        }, 
        {
            "location": "/API/Initialization Options/#onteardown", 
            "text": "(Function)  A lifecycle event that is called when the instance is being torn down.", 
            "title": "onteardown"
        }, 
        {
            "location": "/API/Initialization Options/#onunrender", 
            "text": "(Function)  A lifecycle event that is called when the instance is being undrendered.", 
            "title": "onunrender"
        }, 
        {
            "location": "/API/Initialization Options/#onupdate", 
            "text": "(Function)  A lifecycle event that is called when  ractive.update()  is called.", 
            "title": "onupdate"
        }, 
        {
            "location": "/API/Initialization Options/#partials", 
            "text": "(Object string, string|Object|Function )  A map of  partials  where the key is the name of the partial, and the value is either a template string, an parsed template object or a function that returns any of the previous options.  partials: {\n  stringPartial: ' p {{greeting}} world! /p ',\n  parsedPartial: { v :3, t :[{ t :7, e : p , f :[{ t :2, r : greeting },  world! ]}]},\n  functionPartial: function(data, p){\n    return data.condition ? ' p hello world /p ' : ' div yes, we have no foo /div ';\n  }\n}  If you need to do additional post-processing on the partials, the function option receives post-processed data and a  Parse Object  that provides helper methods for template manipulation.  During a  ractive.reset() , function partials will be re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "partials"
        }, 
        {
            "location": "/API/Initialization Options/#preservewhitespace", 
            "text": "(boolean)  Defaults to  false . Whether or not to preserve whitespace in templates when parsing. (Whitespace in  pre  elements is always preserved.)  var ractive = new Ractive({\n  template: ' p hello\\n\\n  \\tworld    /p ',\n  preserveWhitespace: false //default\n});\nconsole.log( ractive.toHTML() );\n//  p hello world /p \n\nvar ractive = new Ractive({\n  template: ' p hello\\n\\n  \\tworld    /p ',\n  preserveWhitespace: true\n});\nconsole.log( ractive.toHTML() );\n// p hello\n//\n//  world    /p   Please note that the browser will still deal with whitespace in the normal fashion.", 
            "title": "preserveWhitespace"
        }, 
        {
            "location": "/API/Initialization Options/#sanitize", 
            "text": "(boolean|Object)  Defaults to  false . If  true , certain elements will be stripped from templates at parse time -  applet ,  base ,  basefont ,  body ,  frame ,  frameset ,  head ,  html ,  isindex ,  link ,  meta ,  noframes ,  noscript ,  Object ,  param ,  script ,  style  and  title  - as will event attributes (e.g.  onclick ).  template: ' p some content /p frame Am I a bad element or just misunderstood? /frame ',\nsanitize: true\n\n// result: p some content /p   Alternatively, pass in an object with an  elements  property containing an array of blacklisted elements, and an optional  eventAttributes  boolean ( true  means 'disallow event attributes').  template: ' p some content /p div onclick= doEvil() the good stuff /div ',\nsanitize: {\n  elements: [ 'p' ],\n  eventAttributes: true\n}\n\n// result: div the good stuff /div", 
            "title": "sanitize"
        }, 
        {
            "location": "/API/Initialization Options/#staticdelimiters", 
            "text": "(Array[string])  Defaults to  [ '[[', ']]' ] . Used to set what static (one-time binding) delimiters to use when parsing templates.  var ractive = new Ractive({\n  template: 'hello [[foo]]',\n  staticDelimiters: [ '[[', ']]' ], //default\n  data: { foo: 'world' }\n});\n// result:  hello world \n\nractive.set( 'foo', 'mars' );\n// still is:  hello world", 
            "title": "staticDelimiters"
        }, 
        {
            "location": "/API/Initialization Options/#statictripledelimiters", 
            "text": "(Array string )  Defaults to  [ '[[[', ']]]' ] . Used to set what static (one-time binding) triple delimiters to use when parsing templates.  var ractive = new Ractive({\n  template: 'hello [[[html]]]',\n  staticTripleDelimiters: [ '[[[', ']]]' ], //default\n  data: { html: ' span world /span ' }\n});\n// result:  hello  span world /span \n\nractive.set( 'html', ' span mars /span ' );\n// still is:  hello world", 
            "title": "staticTripleDelimiters"
        }, 
        {
            "location": "/API/Initialization Options/#stripcomments", 
            "text": "(boolean)  Defaults to  true . Whether or not to remove comments in templates when parsing.  template: ' !-- html comment -- hello world',\nstripComments: false\n\n// result: !-- html comment -- hello world", 
            "title": "stripComments"
        }, 
        {
            "location": "/API/Initialization Options/#template", 
            "text": "(string|array|object|function)  The  template  to use. Must either be a CSS selector string pointing to an element on the page containing the template, an HTML string, an object resulting from [ Ractive.parse() ](../API/Static Methods.md#Ractive.parse()) or a function that returns any of the previous options.  // Selector\ntemplate: '#my-template',\n\n// HTML\ntemplate: ' p {{greeting}} world! /p ',\n\n// Template AST\ntemplate: { v :3, t :[{ t :7, e : p , f :[{ t :2, r : greeting },  world! ]}]},\n\n// Function\ntemplate: function(data, p){\n  return ' p {{greeting}} world! /p ';\n},  If you need to do additional post-processing on templates, the function option receives the post-processed data and a  Parse Object  that provides helper methods for template manipulation.  During a  ractive.reset() , function templates will be re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "template"
        }, 
        {
            "location": "/API/Initialization Options/#transitions", 
            "text": "(Object string, Function )  A key-value hash of transitions that are specific to this instance. The  key  is referenced within templates using  intro  and  outro  attributes on elements, and  value  is a transition functions, see  Transitions  for more info.  template: ' p intro= slide  outro= slide hello world /p ',\ntransitions: {\n  slide: function ( t, params ) {...}\n}", 
            "title": "transitions"
        }, 
        {
            "location": "/API/Initialization Options/#transitionsenabled", 
            "text": "(boolean)  Defaults to  true . Whether or not transitions are enabled for this instance.", 
            "title": "transitionsEnabled"
        }, 
        {
            "location": "/API/Initialization Options/#tripledelimiters", 
            "text": "(Array[string])  Defaults to  [ '{{{', '}}}' ] . Used to set what triple delimiters to use when parsing templates.  template: 'hello @html@',\ntripleDelimiters: [ '@', '@' ],\ndata: { html: ' span world /span ' }\n\n// result:\nhello  span world /span", 
            "title": "tripleDelimiters"
        }, 
        {
            "location": "/API/Initialization Options/#twoway", 
            "text": "(boolean)  Defaults to  true . Whether or not two-way data binding is enabled (see  Two-Way Binding ).  var ractive = new Ractive({\n  template: ' input value= {{foo}} ',\n  data: { foo: 'bar' },\n  twoway: false\n});\n\n// user types  fizz  into  input , but data value is not changed:\nconsole.log( ractive.get( 'foo' ) ); //logs  bar \n\n// updates from the model are still pushed to the view\nractive.set( 'foo', 'fizz' );\n\n// input now displays  fizz   Also see  static delimiters  for one-time binding", 
            "title": "twoway"
        }, 
        {
            "location": "/API/Static Properties/", 
            "text": "Static Properties\n\n\nRactive.adaptors\n\n\n(Object\nstring, Object\n)\n\n\nThe registry of globally available \nadaptors\n.\n\n\n\n\nRactive.components\n\n\n(Object\nstring, Function\n)\n\n\nThe registry of globally available \ncomponent definitions\n.\n\n\n\n\nRactive.DEBUG\n\n\n(boolean)\n\n\nTells Ractive if it's in debug mode or not. When set to \ntrue\n, non-fatal errors are logged. When set to \nfalse\n, non-fatal errors are suppressed. By default, this is set to \ntrue\n.\n\n\n\n\nRactive.DEBUG_PROMISES\n\n\n(boolean)\n\n\nTells Ractive to log errors thrown inside promises. When set to \ntrue\n, errors thrown in promises are logged. When set to \nfalse\n, errors inside promises are suppressed. By default, this is set to \ntrue\n.\n\n\n\n\nRactive.decorators\n\n\n(Object\nstring, Function\n)\n\n\nThe registry of globally available \ndecorators\n.\n\n\n\n\nRactive.defaults\n\n\n(Object\nstring, any\n)\n\n\nThe defaults for \ninitialisation options\n with the exception of \nplugin registries\n.\n\n\n// Change the default mustache delimiters to [[ ]] globally\nRactive.defaults.delimiters = [ '[[', ']]' ];\n\n// Future instances now use [[ ]]\nractive1 = new Ractive({\n    template: 'hello [[world]]'\n});\n\n\n\n\nConfigurations set on the instance override the ones present in \nRactive.defaults\n.\n\n\nRactive.defaults.delimiters = [ '[[', ']]' ];\n\n// Uses the delimiters specified above\nnew Ractive({\n    template: 'hello [[world]]'\n});\n\n// Uses the delimiters specified in the init options\nnew Ractive({\n    template: 'hello //world\\\\',\n    delimiters: [ '//', '\\\\' ]\n});\n\n\n\n\nDefaults can also be specified a subclass of Ractive.\n\n\nvar MyRactive = Ractive.extend();\n\nMyRactive.defaults.el = document.body;\n\n\n\n\n\n\nRactive.easing\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of \neasing functions\n.\n\n\nThe easing functions are used by the \nractive.animate\n method and by \ntransitions\n. Four are included by default: \nlinear\n, \neaseIn\n, \neaseOut\n and \neaseInOut\n.\n\n\n\n\nRactive.events\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of \nevents\n.\n\n\n\n\nRactive.interpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n.\n\n\n\n\nRactive.length\n\n\nSince \nRactive\n is a function, and functions have a \nlength\n equal to their number of declared arguments, \nRactive\n has a \nlength\n of \n1\n.\n\n\n\n\nRactive.magic\n\n\nIndicates whether or not the current environment supports \nmagic mode\n.\n\n\n\n\nRactive.name\n\n\nLike \nlength\n, functions also have a \nname\n, and \nRactive\n's happens to be \n\"Ractive\"\n.\n\n\n\n\nRactive.partials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nThe global registry of \npartial templates\n.\n\n\nLike \ntemplates\n, partials are \nparsed\n at the point of use. The parsed output is cached and utilized for future use.\n\n\n\n\nRactive.Promise\n\n\n(Function)\n\n\nA spec-compliant Promise implementation.\n\n\n\n\nRactive.svg\n\n\n(boolean)\n\n\nIndicates whether or not the browser supports SVG.\n\n\n\n\nRactive.transitions\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of \ntransition functions\n.\n\n\n\n\nRactive.VERSION\n\n\nThe version of the currently loaded Ractive.", 
            "title": "Static Properties"
        }, 
        {
            "location": "/API/Static Properties/#static-properties", 
            "text": "", 
            "title": "Static Properties"
        }, 
        {
            "location": "/API/Static Properties/#ractiveadaptors", 
            "text": "(Object string, Object )  The registry of globally available  adaptors .", 
            "title": "Ractive.adaptors"
        }, 
        {
            "location": "/API/Static Properties/#ractivecomponents", 
            "text": "(Object string, Function )  The registry of globally available  component definitions .", 
            "title": "Ractive.components"
        }, 
        {
            "location": "/API/Static Properties/#ractivedebug", 
            "text": "(boolean)  Tells Ractive if it's in debug mode or not. When set to  true , non-fatal errors are logged. When set to  false , non-fatal errors are suppressed. By default, this is set to  true .", 
            "title": "Ractive.DEBUG"
        }, 
        {
            "location": "/API/Static Properties/#ractivedebug_promises", 
            "text": "(boolean)  Tells Ractive to log errors thrown inside promises. When set to  true , errors thrown in promises are logged. When set to  false , errors inside promises are suppressed. By default, this is set to  true .", 
            "title": "Ractive.DEBUG_PROMISES"
        }, 
        {
            "location": "/API/Static Properties/#ractivedecorators", 
            "text": "(Object string, Function )  The registry of globally available  decorators .", 
            "title": "Ractive.decorators"
        }, 
        {
            "location": "/API/Static Properties/#ractivedefaults", 
            "text": "(Object string, any )  The defaults for  initialisation options  with the exception of  plugin registries .  // Change the default mustache delimiters to [[ ]] globally\nRactive.defaults.delimiters = [ '[[', ']]' ];\n\n// Future instances now use [[ ]]\nractive1 = new Ractive({\n    template: 'hello [[world]]'\n});  Configurations set on the instance override the ones present in  Ractive.defaults .  Ractive.defaults.delimiters = [ '[[', ']]' ];\n\n// Uses the delimiters specified above\nnew Ractive({\n    template: 'hello [[world]]'\n});\n\n// Uses the delimiters specified in the init options\nnew Ractive({\n    template: 'hello //world\\\\',\n    delimiters: [ '//', '\\\\' ]\n});  Defaults can also be specified a subclass of Ractive.  var MyRactive = Ractive.extend();\n\nMyRactive.defaults.el = document.body;", 
            "title": "Ractive.defaults"
        }, 
        {
            "location": "/API/Static Properties/#ractiveeasing", 
            "text": "(Object string, Function )  The global registry of  easing functions .  The easing functions are used by the  ractive.animate  method and by  transitions . Four are included by default:  linear ,  easeIn ,  easeOut  and  easeInOut .", 
            "title": "Ractive.easing"
        }, 
        {
            "location": "/API/Static Properties/#ractiveevents", 
            "text": "(Object string, Function )  The global registry of  events .", 
            "title": "Ractive.events"
        }, 
        {
            "location": "/API/Static Properties/#ractiveinterpolators", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate() .", 
            "title": "Ractive.interpolators"
        }, 
        {
            "location": "/API/Static Properties/#ractivelength", 
            "text": "Since  Ractive  is a function, and functions have a  length  equal to their number of declared arguments,  Ractive  has a  length  of  1 .", 
            "title": "Ractive.length"
        }, 
        {
            "location": "/API/Static Properties/#ractivemagic", 
            "text": "Indicates whether or not the current environment supports  magic mode .", 
            "title": "Ractive.magic"
        }, 
        {
            "location": "/API/Static Properties/#ractivename", 
            "text": "Like  length , functions also have a  name , and  Ractive 's happens to be  \"Ractive\" .", 
            "title": "Ractive.name"
        }, 
        {
            "location": "/API/Static Properties/#ractivepartials", 
            "text": "(Object string, string|Object|Function )  The global registry of  partial templates .  Like  templates , partials are  parsed  at the point of use. The parsed output is cached and utilized for future use.", 
            "title": "Ractive.partials"
        }, 
        {
            "location": "/API/Static Properties/#ractivepromise", 
            "text": "(Function)  A spec-compliant Promise implementation.", 
            "title": "Ractive.Promise"
        }, 
        {
            "location": "/API/Static Properties/#ractivesvg", 
            "text": "(boolean)  Indicates whether or not the browser supports SVG.", 
            "title": "Ractive.svg"
        }, 
        {
            "location": "/API/Static Properties/#ractivetransitions", 
            "text": "(Object string, Function )  The global registry of  transition functions .", 
            "title": "Ractive.transitions"
        }, 
        {
            "location": "/API/Static Properties/#ractiveversion", 
            "text": "The version of the currently loaded Ractive.", 
            "title": "Ractive.VERSION"
        }, 
        {
            "location": "/API/Static Methods/", 
            "text": "Static Methods\n\n\nRactive.escapeKey()\n\n\nEscapes the given key so that it can be concatenated with a \nkeypath\n string.\n\n\nSyntax\n\n\n\n\nRactive.escapeKey(key)\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: The key to escape.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The escaped key.\n\n\n\n\nExamples\n\n\nRactive.escapeKey('foo.bar'); // foo\\.bar\n\n\n\n\n\n\nRactive.extend()\n\n\nCreates a \"subclass\" of the Ractive constructor or a subclass constructor. See \nComponents\n for an in-depth discussion on the use of \nRactive.extend\n.\n\n\nSyntax\n\n\n\n\nRactive.extend([options[, ...optionsN]])\n\n\n\n\nArguments\n\n\n\n\n[options] (Object)\n: One or more objects that represent the defaults for instances of the subclass, with the latter objects' properties taking precedence over the former. See \nInitialization Options\n for a list of possible options.\n\n\n\n\nReturns\n\n\n\n\n(Function)\n: The subclass constructor function.\n\n\n\n\nExamples\n\n\nconst SubClass = Ractive.extend({\n    template: '\ndiv\n{{message}}\n/div\n',\n    data: {\n        message: 'Hello World!'\n    }\n});\n\n// \ndiv\nHello World!\n/div\n\nconst instance1 = new SubClass({\n    el: '.div1'\n});\n\n// \ndiv\nLorem Ipsum\n/div\n\nconst instance2 = new SubClass({\n    el: '.div2',\n    data: {\n        message: 'Lorem Ipsum'\n    }\n});\n\n\n\n\n\n\nRactive.getCSS()\n\n\nReturns the scoped CSS from Ractive subclasses defined at the time of the call.\n\n\nIf used without arguments, it will return the scoped CSS of all subclasses. If provided an array of scoping IDs, it will return the scoped CSS of all subclasses whose scoping ID is included in the array.\n\n\nSyntax\n\n\n\n\nRactive.getCSS([key])\n\n\n\n\nArguments\n\n\n\n\n[key] (Array\nstring\n)\n: Subclass CSS scoping ID.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The scoped CSS.\n\n\n\n\nExamples\n\n\n// Assuming the generated ID for this subclass is 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.\nconst Subclass1 = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\n// Assuming the generated ID for this subclass is 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy'.\nconst Subclass2 = Ractive.extend({\n    ...\n    css: 'div{ color: green }'\n    ...\n});\n\n// CSS contains the scoped versions of div{ color: red } and div{ color: green }.\nconst css = Ractive.getCSS();\n\n// css contains the scoped version of div{ color: red } only.\nconst css = Ractive.getCSS([ 'xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' ]);\n\n\n\n\n\n\n\nRactive.getNodeInfo()\n\n\nAccepts a node and returns an \nNode Info\n object containing details of the Ractive instance the node is associated to.\n\n\nSyntax\n\n\n\n\nRactive.getNodeInfo(node)\n\n\n\n\nArguments\n\n\n\n\nnode (string|Node)\n: The DOM node or a CSS selector of the DOM node for which you wish to retrieve the Ractive instance or view details.\n\n\n\n\nReturns\n\n\n\n\n(NodeInfo)\n: An \nNodeInfo\n object.\n\n\n\n\nExamples\n\n\nconst info = Ractive.getNodeInfo(document.getElementById('some-node'));\n\nconst info = Ractive.getNodeInfo('#some-node');\n\n\n\n\n\n\nRactive.joinKeys()\n\n\nJoins the given keys into a properly escaped \nkeypath\n e.g. `\n\n\nSyntax\n\n\n\n\nRactive.joinKeys(key1 [, ...keyN])\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: One or more strings to join.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: A properly joined and escaped keypath.\n\n\n\n\nExamples\n\n\nRactive.joinKeys( 'foo', 'bar.baz' ); // foo.bar\\.baz\n\n\n\n\n\n\nRactive.parse()\n\n\nParses the template into an abstract syntax tree that Ractive can work on.\n\n\nSyntax\n\n\n\n\nRactive.parse(template[, options])\n\n\n\n\nArguments\n\n\n\n\ntemplate (string)\n: A Ractive-compliant HTML template.\n\n\n[options] (Object)\n: Parser options.\n\n\n[preserveWhitespace] (boolean)\n: When \ntrue\n, preserves whitespace in templates. Whitespace inside the \npre\n element is preserved regardless of the value of this option. Defaults to \nfalse\n.\n\n\n[sanitize] (boolean|Object)\n: When \ntrue\n, strips inline event attributes and certain elements from the markup. Defaults to \nfalse\n.\n\n\n[elements] (Array\nstring\n)\n: An array of element names to blacklist.\n\n\n[eventAttributes] (boolean)\n: When \ntrue\n, strips off inline event attributes.\n\n\n\n\n\n\n\n\n\n\n\n\nWhen \nsanitize\n is \ntrue\n, the following elements are stripped:\n\n\n\n\napplet\n\n\nbase\n\n\nbasefont\n\n\nbody\n\n\nframe\n\n\nframeset\n\n\nhead\n\n\nhtml\n\n\nisindex\n\n\nlink\n\n\nmeta\n\n\nnoframes\n\n\nnoscript\n\n\nobject\n\n\nparam\n\n\nscript\n\n\nstyle\n\n\ntitle\n\n\n\n\nReturns\n\n\n\n\n(Object)\n - The object representation of the provided markup.\n\n\n\n\nExamples\n\n\nAssume the following markup.\n\n\ndiv class='gallery'\n\n  {{#items}}\n    \n!-- comments get stripped out of the template --\n\n    \nfigure proxy-tap='select' intro='staggered'\n\n      \nimg class='thumbnail' src='assets/images/{{id}}.jpg'\n\n      \nfigcaption\n{{( i+1 )}}: {{description}}\n/figcaption\n\n    \n/figure\n\n  {{/items}}\n\n/div\n\n\n\n\n\nRactive.parse( template );\n will yield the following output:\n\n\n[{\nt\n:7,\ne\n:\ndiv\n,\na\n:{\nclass\n:\ngallery\n},\nf\n:[{\nt\n:4,\nr\n:\nitems\n,\ni\n:\ni\n,\nf\n:[\n \n,{\nt\n:7,\ne\n:\nfigure\n,\na\n:{\nintro\n:\nstaggered\n},\nf\n:[{\nt\n:7,\ne\n:\nimg\n,\na\n:{\nclass\n:\nthumbnail\n,\nsrc\n:[\nassets/images/\n,{\nt\n:2,\nr\n:\nid\n,\np\n:4},\n.jpg\n]}},\n \n,{\nt\n:7,\ne\n:\nfigcaption\n,\nf\n:[{\nt\n:2,\nx\n:{\nr\n:[\ni\n],\ns\n:\n\u27560+1\n},\np\n:4},\n: \n,{\nt\n:2,\nr\n:\ndescription\n,\np\n:4}]}],\nv\n:{\ntap\n:\nselect\n}},\n \n],\np\n:1}]}]\n\n\n\n\nTODO: \nRactive.parse\n has more options. Document them.\n\n\n\n\nRactive.splitKeypath()\n\n\nSplits the given \nkeypath\n into an array of unescaped keys.\n\n\nSyntax\n\n\n\n\nRactive.splitKeypath(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n to split into keys.\n\n\n\n\nReturns\n\n\n\n\n(Array)\n: Returns an array of unescaped keys.\n\n\n\n\nExamples\n\n\nRactive.splitKeypath( 'foo.bar\\.baz' ); // [ 'foo', 'bar.baz' ]\n\n\n\n\n\n\nRactive.unescapeKey()\n\n\nUnescapes the given key e.g. \nfoo\\.bar\n =\n \nfoo.bar\n.\n\n\nSyntax\n\n\n\n\nRactive.unescapeKey(key)\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: The key to unescape.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The unescaped key.\n\n\n\n\nExamples\n\n\nRactive.unescapeKey('foo\\.bar'); // foo.bar", 
            "title": "Static Methods"
        }, 
        {
            "location": "/API/Static Methods/#static-methods", 
            "text": "", 
            "title": "Static Methods"
        }, 
        {
            "location": "/API/Static Methods/#ractiveescapekey", 
            "text": "Escapes the given key so that it can be concatenated with a  keypath  string.  Syntax   Ractive.escapeKey(key)   Arguments   key (string) : The key to escape.   Returns   (string) : The escaped key.   Examples  Ractive.escapeKey('foo.bar'); // foo\\.bar", 
            "title": "Ractive.escapeKey()"
        }, 
        {
            "location": "/API/Static Methods/#ractiveextend", 
            "text": "Creates a \"subclass\" of the Ractive constructor or a subclass constructor. See  Components  for an in-depth discussion on the use of  Ractive.extend .  Syntax   Ractive.extend([options[, ...optionsN]])   Arguments   [options] (Object) : One or more objects that represent the defaults for instances of the subclass, with the latter objects' properties taking precedence over the former. See  Initialization Options  for a list of possible options.   Returns   (Function) : The subclass constructor function.   Examples  const SubClass = Ractive.extend({\n    template: ' div {{message}} /div ',\n    data: {\n        message: 'Hello World!'\n    }\n});\n\n//  div Hello World! /div \nconst instance1 = new SubClass({\n    el: '.div1'\n});\n\n//  div Lorem Ipsum /div \nconst instance2 = new SubClass({\n    el: '.div2',\n    data: {\n        message: 'Lorem Ipsum'\n    }\n});", 
            "title": "Ractive.extend()"
        }, 
        {
            "location": "/API/Static Methods/#ractivegetcss", 
            "text": "Returns the scoped CSS from Ractive subclasses defined at the time of the call.  If used without arguments, it will return the scoped CSS of all subclasses. If provided an array of scoping IDs, it will return the scoped CSS of all subclasses whose scoping ID is included in the array.  Syntax   Ractive.getCSS([key])   Arguments   [key] (Array string ) : Subclass CSS scoping ID.   Returns   (string) : The scoped CSS.   Examples  // Assuming the generated ID for this subclass is 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.\nconst Subclass1 = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\n// Assuming the generated ID for this subclass is 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy'.\nconst Subclass2 = Ractive.extend({\n    ...\n    css: 'div{ color: green }'\n    ...\n});\n\n// CSS contains the scoped versions of div{ color: red } and div{ color: green }.\nconst css = Ractive.getCSS();\n\n// css contains the scoped version of div{ color: red } only.\nconst css = Ractive.getCSS([ 'xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' ]);", 
            "title": "Ractive.getCSS()"
        }, 
        {
            "location": "/API/Static Methods/#ractivegetnodeinfo", 
            "text": "Accepts a node and returns an  Node Info  object containing details of the Ractive instance the node is associated to.  Syntax   Ractive.getNodeInfo(node)   Arguments   node (string|Node) : The DOM node or a CSS selector of the DOM node for which you wish to retrieve the Ractive instance or view details.   Returns   (NodeInfo) : An  NodeInfo  object.   Examples  const info = Ractive.getNodeInfo(document.getElementById('some-node'));\n\nconst info = Ractive.getNodeInfo('#some-node');", 
            "title": "Ractive.getNodeInfo()"
        }, 
        {
            "location": "/API/Static Methods/#ractivejoinkeys", 
            "text": "Joins the given keys into a properly escaped  keypath  e.g. `  Syntax   Ractive.joinKeys(key1 [, ...keyN])   Arguments   key (string) : One or more strings to join.   Returns   (string) : A properly joined and escaped keypath.   Examples  Ractive.joinKeys( 'foo', 'bar.baz' ); // foo.bar\\.baz", 
            "title": "Ractive.joinKeys()"
        }, 
        {
            "location": "/API/Static Methods/#ractiveparse", 
            "text": "Parses the template into an abstract syntax tree that Ractive can work on.  Syntax   Ractive.parse(template[, options])   Arguments   template (string) : A Ractive-compliant HTML template.  [options] (Object) : Parser options.  [preserveWhitespace] (boolean) : When  true , preserves whitespace in templates. Whitespace inside the  pre  element is preserved regardless of the value of this option. Defaults to  false .  [sanitize] (boolean|Object) : When  true , strips inline event attributes and certain elements from the markup. Defaults to  false .  [elements] (Array string ) : An array of element names to blacklist.  [eventAttributes] (boolean) : When  true , strips off inline event attributes.       When  sanitize  is  true , the following elements are stripped:   applet  base  basefont  body  frame  frameset  head  html  isindex  link  meta  noframes  noscript  object  param  script  style  title   Returns   (Object)  - The object representation of the provided markup.   Examples  Assume the following markup.  div class='gallery' \n  {{#items}}\n     !-- comments get stripped out of the template -- \n     figure proxy-tap='select' intro='staggered' \n       img class='thumbnail' src='assets/images/{{id}}.jpg' \n       figcaption {{( i+1 )}}: {{description}} /figcaption \n     /figure \n  {{/items}} /div   Ractive.parse( template );  will yield the following output:  [{ t :7, e : div , a :{ class : gallery }, f :[{ t :4, r : items , i : i , f :[   ,{ t :7, e : figure , a :{ intro : staggered }, f :[{ t :7, e : img , a :{ class : thumbnail , src :[ assets/images/ ,{ t :2, r : id , p :4}, .jpg ]}},   ,{ t :7, e : figcaption , f :[{ t :2, x :{ r :[ i ], s : \u27560+1 }, p :4}, :  ,{ t :2, r : description , p :4}]}], v :{ tap : select }},   ], p :1}]}]  TODO:  Ractive.parse  has more options. Document them.", 
            "title": "Ractive.parse()"
        }, 
        {
            "location": "/API/Static Methods/#ractivesplitkeypath", 
            "text": "Splits the given  keypath  into an array of unescaped keys.  Syntax   Ractive.splitKeypath(keypath)   Arguments   keypath (string) : The  keypath  to split into keys.   Returns   (Array) : Returns an array of unescaped keys.   Examples  Ractive.splitKeypath( 'foo.bar\\.baz' ); // [ 'foo', 'bar.baz' ]", 
            "title": "Ractive.splitKeypath()"
        }, 
        {
            "location": "/API/Static Methods/#ractiveunescapekey", 
            "text": "Unescapes the given key e.g.  foo\\.bar  =   foo.bar .  Syntax   Ractive.unescapeKey(key)   Arguments   key (string) : The key to unescape.   Returns   (string) : The unescaped key.   Examples  Ractive.unescapeKey('foo\\.bar'); // foo.bar", 
            "title": "Ractive.unescapeKey()"
        }, 
        {
            "location": "/API/Instance Properties/", 
            "text": "Instance Properties\n\n\nractive.adaptors\n\n\n(Object\nstring, Object\n)\n\n\nThe instance-only registry of \nadaptors\n.\n\n\n\n\nractive.components\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \ncomponents\n.\n\n\n\n\nractive.container\n\n\n(Ractive)\n\n\nEach component instance that is in a yielded fragment has a container instance that is accessible using \nthis.container\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nIf \nbar\n \n{{yield}}\ns, then \nbaz\n's container will be the \nfoo\n instance.\n\n\n\n\nractive.decorators\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \ndecorators\n.\n\n\n\n\nractive.easing\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \neasing functions\n.\n\n\n\n\nractive.events\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \nevents\n.\n\n\n\n\nractive.interpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n.\n\n\n\n\nractive.nodes\n\n\n(Object\nstring, HTMLElement\n)\n\n\nAn object containing all of the elements inside the instance that have an \nid\n attribute.\n\n\nconst ractive = new Ractive({\n  el: body,\n  template: '\ndiv id=\nmyDiv\nAn unimaginatively named div.\n/div\n'\n});\n\nractive.nodes.myDiv === document.getElementById( 'myDiv' ); // true\n\n\n\n\nThis will also reference dynamically created elements.\n\n\nconst ractive = new Ractive({\n  el: myContainer,\n  template: `\n    \nul\n\n        {{#items:i}}\n            \nli id='item_{{i}}'\n{{content}}\n/li\n\n        {{/items}}\n    \n/ul\n\n  `,\n  data: { items: myListOfItems }\n});\n\n// Get a reference to an arbitrary li element.\nractive.nodes[ 'item_' + num ];\n\n\n\n\n\n\nractive.parent\n\n\n(Ractive)\n\n\nEach component instance can access its parent using \nthis.parent\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nbaz\n's parent is the \nbar\n instance, and \nbar\n's parent is the \nfoo\n instance.\n\n\n\n\nractive.partials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nThe instance-only registry of \npartials\n.\n\n\n\n\nractive.root\n\n\n(Ractive)\n\n\nEach component instance can access its root Ractive instance using \nthis.root\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nfoo\n, \nbar\n, and \nbaz\n will all have the Ractive instance with this template as their \nroot\n.\n\n\n\n\nractive.transitions\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of \ntransitions\n.", 
            "title": "Instance Properties"
        }, 
        {
            "location": "/API/Instance Properties/#instance-properties", 
            "text": "", 
            "title": "Instance Properties"
        }, 
        {
            "location": "/API/Instance Properties/#ractiveadaptors", 
            "text": "(Object string, Object )  The instance-only registry of  adaptors .", 
            "title": "ractive.adaptors"
        }, 
        {
            "location": "/API/Instance Properties/#ractivecomponents", 
            "text": "(Object string, Function )  The instance-only registry of  components .", 
            "title": "ractive.components"
        }, 
        {
            "location": "/API/Instance Properties/#ractivecontainer", 
            "text": "(Ractive)  Each component instance that is in a yielded fragment has a container instance that is accessible using  this.container .  foo \n   bar \n     baz / \n   /bar  /foo   If  bar   {{yield}} s, then  baz 's container will be the  foo  instance.", 
            "title": "ractive.container"
        }, 
        {
            "location": "/API/Instance Properties/#ractivedecorators", 
            "text": "(Object string, Function )  The instance-only registry of  decorators .", 
            "title": "ractive.decorators"
        }, 
        {
            "location": "/API/Instance Properties/#ractiveeasing", 
            "text": "(Object string, Function )  The instance-only registry of  easing functions .", 
            "title": "ractive.easing"
        }, 
        {
            "location": "/API/Instance Properties/#ractiveevents", 
            "text": "(Object string, Function )  The instance-only registry of  events .", 
            "title": "ractive.events"
        }, 
        {
            "location": "/API/Instance Properties/#ractiveinterpolators", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate() .", 
            "title": "ractive.interpolators"
        }, 
        {
            "location": "/API/Instance Properties/#ractivenodes", 
            "text": "(Object string, HTMLElement )  An object containing all of the elements inside the instance that have an  id  attribute.  const ractive = new Ractive({\n  el: body,\n  template: ' div id= myDiv An unimaginatively named div. /div '\n});\n\nractive.nodes.myDiv === document.getElementById( 'myDiv' ); // true  This will also reference dynamically created elements.  const ractive = new Ractive({\n  el: myContainer,\n  template: `\n     ul \n        {{#items:i}}\n             li id='item_{{i}}' {{content}} /li \n        {{/items}}\n     /ul \n  `,\n  data: { items: myListOfItems }\n});\n\n// Get a reference to an arbitrary li element.\nractive.nodes[ 'item_' + num ];", 
            "title": "ractive.nodes"
        }, 
        {
            "location": "/API/Instance Properties/#ractiveparent", 
            "text": "(Ractive)  Each component instance can access its parent using  this.parent .  foo \n   bar \n     baz / \n   /bar  /foo   baz 's parent is the  bar  instance, and  bar 's parent is the  foo  instance.", 
            "title": "ractive.parent"
        }, 
        {
            "location": "/API/Instance Properties/#ractivepartials", 
            "text": "(Object string, string|Object|Function )  The instance-only registry of  partials .", 
            "title": "ractive.partials"
        }, 
        {
            "location": "/API/Instance Properties/#ractiveroot", 
            "text": "(Ractive)  Each component instance can access its root Ractive instance using  this.root .  foo \n   bar \n     baz / \n   /bar  /foo   foo ,  bar , and  baz  will all have the Ractive instance with this template as their  root .", 
            "title": "ractive.root"
        }, 
        {
            "location": "/API/Instance Properties/#ractivetransitions", 
            "text": "(Object string, Function )  The instance-only registry of  transitions .", 
            "title": "ractive.transitions"
        }, 
        {
            "location": "/API/Instance Methods/", 
            "text": "Instance Methods\n\n\nractive._super()\n\n\nCalls the parent method from a child method of the same name.\n\n\nractive._super()\n is not always available. Only when Ractive detects its use does it make this reference to the parent method.\n\n\nSyntax\n\n\n\n\nractive._super([arg[, ...argN]])\n\n\n\n\nArguments\n\n\n\n\n[arg] (any)\n: One or more arguments to pass to the function.\n\n\n\n\nReturns\n\n\n\n\n(any)\n: Depends on the method called.\n\n\n\n\nExamples\n\n\nconst MyComponentSubclass = MyComponent.exten({\n  // Overrides the oninit of MyComponent\n  oninit: function(...args){\n    // Call MyComponent's oninit\n    this._super(...args);\n  }\n});\n\n\n\n\n\n\nractive.add()\n\n\nIncrements the selected keypath.\n\n\nSyntax\n\n\n\n\nractive.add(keypath[, number])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the number we're incrementing.\n\n\n[number] (number)\n: The number to increment by. Defaults to \n1\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the operation completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.animate()\n\n\nSimilar to \nractive.set()\n, this will update the data and re-render any affected mustaches and notify \nobservers\n.\n\n\nAll animations are handled by a global timer that is shared between Ractive instances (and which only runs if there are one or more animations still in progress), so you can trigger as many separate animations as you like without worrying about timer congestion. Where possible, \nrequestAnimationFrame\n is used rather than \nsetTimeout\n.\n\n\nNumeric values and strings that can be parsed as numeric values can be interpolated. Objects and arrays containing numeric values (or other objects and arrays which themselves contain numeric values, and so on recursively) are also interpolated.\n\n\nNote that there is currently no mechanism for detecting cyclical structures! Animating to a value that indirectly references itself will cause an infinite loop.\n\n\nFuture versions of Ractive may include string interpolators - e.g. for SVG paths, colours, transformations and so on, a la D3 - and the ability to pass in your own interpolator.\n\n\nIf an animation is started on a \nkeypath\n which is \nalready\n being animated, the first animation is cancelled. (Currently, there is no mechanism in place to prevent collisions between e.g. \nractive.animate('foo', { bar: 1 })\n and \nractive.animate('foo.bar', 0)\n.)\n\n\nSyntax\n\n\n\n\nractive.animate(keypath, value[, options])\n\n\nractive.animate(map[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n to animate.\n\n\nvalue (number|string|Object|Array)\n: The value to animate to.\n\n\nmap (Object)\n: A key-value hash of \nkeypath\n and value.\n\n\n[options] (Object)\n:\n\n\n[duration] (number)\n: How many milliseconds the animation should run for. Defaults to \n400\n.\n\n\n[easing] (string|Function)\n: The name of an easing function or the easing function itself. Defaults to \nlinear\n.\n\n\n[step] (Function)\n: A function to be called on each step of the animation. Receives \nt\n and \nvalue\n as arguments, where \nt\n is the animation progress (between \n0\n and \n1\n, as determined by the easing function) and \nvalue\n is the intermediate value at \nt\n.\n\n\n[complete] (Function)\n: A function to be called when the animation completes, with the same argument signature as \nstep\n (i.e. \nt\n is \n1\n, and \nvalue\n is the destination value)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a Promise with an additional \nstop\n method, which cancels the animation.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.detach()\n\n\nDetaches the instance from the DOM, returning a document fragment. You can reinsert it, possibly in a different place, with \nractive.insert()\n (note that if you are reinserting it immediately you don't need to detach it first - it will happen automatically).\n\n\nSyntax\n\n\n\n\nractive.detach()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(DocumentFragment)\n: A document fragment.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.find()\n\n\nReturns the first element inside a given Ractive instance matching a CSS selector. This is similar to doing \nthis.el.querySelector(selector)\n (though it doesn't actually use \nquerySelector()\n).\n\n\nSyntax\n\n\n\n\nractive.find(selector[, options])\n\n\n\n\nArguments\n\n\n\n\nselector (string)\n: A CSS selector representing the element to find.\n\n\n[options] (Object)\n:\n\n\n\n\nReturns\n\n\n\n\n(Node)\n: A Node.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.findAll()\n\n\nThis method is similar to \nractive.find()\n, with two important differences. Firstly, it returns a list of elements matching the selector, rather than a single node. Secondly, it can return a \nlive\n list, which will stay in sync with the DOM as it continues to update.\n\n\nSyntax\n\n\n\n\nractive.findAll(selector[, options])\n\n\n\n\nArguments\n\n\n\n\nselector (string)\n: A CSS selector representing the elements to find.\n\n\n[options] (Object)\n\n\n[live] (boolean)\n: Whether to return a live list or a static one. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Array\nNode\n)\n: An array of nodes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.findAllComponents()\n\n\nReturns all components inside a given Ractive instance with the given \nname\n (or all components of any kind if no name is given).\n\n\nSyntax\n\n\n\n\nractive.findAllComponents([name[, options]])\n\n\n\n\nArguments\n\n\n\n\n[name] (string)\n: The name of the component to find.\n\n\n[options] (Object)\n\n\n[live] (boolean)\n: Whether to return a live list or a static one. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Array\nractive\n)\n: An array of ractive instances.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.findComponent()\n\n\nReturns the first component inside a given Ractive instance with the given \nname\n (or the first component of any kind if no name is given).\n\n\nSyntax\n\n\n\n\nractive.findComponent([name[, options]])\n\n\n\n\nArguments\n\n\n\n\n[name] (string)\n: The name of the component to find.\n\n\n[options] (Object)\n:\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: A ractive instance.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.findContainer()\n\n\nReturns the first container of this component instance with the given \nname\n.\n\n\nSyntax\n\n\n\n\nractive.findContainer(name)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the container to find.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the first container of this component with the given \nname\n.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.findParent()\n\n\nReturns the first parent of this component instance with the given \nname\n.\n\n\nSyntax\n\n\n\n\nractive.findParent(name)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the parent to find.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the first parent of this component with the given \nname\n.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.fire()\n\n\nFires an event, which will be received by handlers that were bound using \nractive.on\n. In practical terms, you would mostly likely use this with \nRactive.extend()\n, to allow applications to hook into your subclass.\n\n\nSyntax\n\n\n\n\nractive.fire(eventName[, arg1[, ...argN])\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the event.\n\n\n[arg] (any)\n: The arguments that event handlers will be called with.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.get()\n\n\nReturns the value at \nkeypath\n. If the \nkeypath\n is omitted, returns a shallow copy of all the data in the instance. This data includes mappings introduced by enclosing components, but excludes computed properties.\n\n\nSyntax\n\n\n\n\nractive.get([keypath])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The \nkeypath\n of the data to retrieve.\n\n\n\n\nReturns\n\n\n\n\n(any)\n: Returns whatever data was on the keypath, or all if no \nkeypath\n was provided.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.getNodeInfo()\n\n\nThis is an instance specific version of \nRactive.getNodeInfo()\n that will only search the local instance DOM for a matching node when a selector is given. If the given value is not a string, then it is passed directly through to the static version of this method.\n\n\nSyntax\n\n\n\n\nractive.getNodeInfo(node)\n\n\n\n\nArguments\n\n\n\n\nnode (string|Node)\n: The DOM node or a CSS selector of a target node for which you wish to retrieve the Ractive instance or view details.\n\n\n\n\nReturns\n\n\n\n\n(NodeInfo)\n: Returns an \nNodeInfo\n object with helper methods to interact with the Ractive instance and context associated with the given node.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.insert()\n\n\nInserts the instance to a different location. If the instance is currently in the DOM, it will be detached first. See also \nractive.detach()\n.\n\n\nSyntax\n\n\n\n\nractive.insert(target[, anchor])\n\n\n\n\nArguments\n\n\n\n\ntarget (string|Node|array-like)\n: The new parent element.\n\n\n[anchor] (string|Node|array-like)\n: The sibling element to insert the instance before. If omitted, the instance will be inserted as the last child of the parent.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.link()\n\n\nCreates a link between two \nkeypaths\n that keeps them in sync. Since Ractive can't always watch the contents of objects, copying an object to two different \nkeypaths\n in your data usually leads to one or both of them getting out of sync. \nlink\n creates a sort of symlink between the two paths so that Ractive knows they are actually the same object. This is particularly useful for master/detail scenarios where you have a complex list of data and you want to be able to select an item to edit in a detail form.\n\n\nSyntax\n\n\n\n\nractive.link(source, destination)\n\n\n\n\nArguments\n\n\n\n\nsource (string)\n: The \nkeypath\n of the source item.\n\n\ndestination (string)\n: The \nkeypath\n to use as the destination - or where you'd like the data 'copied'.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise.\n\n\n\n\nExamples\n\n\nractive.link( 'some.nested.0.list.25.item', 'current' );\nractive.set( 'current.name', 'Rich' ); // some.nested.0.list.25.item.name is also updated to be 'Rich'\n\n\n\n\nThis can be used to great effect with method events and the \n@keypath\n special ref:\n\n\n{{#each some.nested}}\n  {{#each list}}\n    {{#with item}}\n      {{.name}}\n      \nbutton on-click=\nevent.link('.', 'current')\nSelect\n/button\n\n    {{/with}}\n  {{/each}}\n{{/each}}\n\nName: \ninput value=\n{{~/current.name}}\n /\n\n\n\n\n\nLinks can be removed using \nractive.unlink()\n.\n\n\n\n\nractive.merge()\n\n\nSets the indicated \nkeypath\n to the new array value, but \"merges\" the existing rendered nodes representing the data into the newly rendered array, inserting and removing nodes from the DOM as necessary. Where necessary, items are moved from their current location in the array (and, therefore, in the DOM) to their new location.\n\n\nThis is an efficient way to (for example) handle data from a server. It also helps to control \nintro\n and \noutro\n \ntransitions\n which might not otherwise happen with a basic \nractive.set()\n operation.\n\n\nTo determine whether the first item of \n['foo', 'bar', 'baz']\n is the same as the last item of \n['bar', 'baz', 'foo']\n, by default we do a strict equality (\n===\n) check.\n\n\nIn some situations that won't work, because the arrays contain objects, which may \nlook\n the same but not be identical. To deal with these, we use the \ncompare\n option detailed below.\n\n\nMerge can also be used to created a context block that uses transitions when the context changes.\n\n\nSyntax\n\n\n\n\nractive.merge(keypath, value[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array we're updating.\n\n\nvalue (Array)\n: The new data to merge in.\n\n\n[options] (Object)\n\n\n[compare] (boolean)\n: If \ntrue\n, values will be stringified (with \nJSON.stringify\n) before comparison.\n\n\n[compare] (string)\n: A property name that will be used to compare the array elements.\n\n\n[compare] (Function)\n: A function that returns a value with which to compare array members.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - Returns a promise.\n\n\n\n\nExamples\n\n\n{{#user}}\n\ndiv intro='fade'\n{{first}} {{last}}\n/div\n\n{{/}}\n\n\n\n\nvar r = new Ractive({\n    el: document.body,\n    template: '#template',\n    data: {\n        user: [{\n            first: 'sam',\n            last: 'smith'\n        }]\n    },\n    complete: function(){\n        this.merge('user', [{\n            first: 'jane',\n            last: 'johnson'\n        }])\n    }\n})\n\n\n\n\n\n\nractive.observe()\n\n\nObserves the data at a particular \nkeypath\n. Unless specified otherwise, the callback will be fired immediately, with \nundefined\n as \noldValue\n. Thereafter it will be called whenever the \nobserved keypath\n changes.\n\n\nSyntax\n\n\n\n\nractive.observe(keypath, callback[, options])\n\n\nractive.observe(map[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (String)\n: The \nkeypath\n to observe, or a group of space-separated keypaths. Any of the keys can be a \n*\n character, which is treated as a wildcard.\n\n\ncallback (Function)\n: The function that will be called, with \nnewValue\n, \noldValue\n and \nkeypath\n as arguments (see \nObservers\n for more nuance regarding these arguments), whenever the observed \nkeypath\n changes value. By default the function will be called with \nractive\n as \nthis\n. Any wildcards in the \nkeypath\n will have their matches passed to the callback at the end of the arguments list as well.\n\n\nmap (Object)\n: A map of keypath-observer pairs.\n\n\n[options] (Object)\n:\n\n\n[init] (boolean)\n: Defaults to \ntrue\n. Whether or not to initialise the observer, i.e. call the function with the current value of \nkeypath\n as the first argument and \nundefined\n as the second.\n\n\n[defer] (boolean)\n: Defaults to \nfalse\n, in which case \nobservers\n will fire before any DOM changes take place. If \ntrue\n, the \nobserver\n will fire once the DOM has been updated.\n\n\n[context] (any)\n: Defaults to \nractive\n. The context the \nobserver\n is called in (i.e. the value of \nthis\n)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: An object with a \ncancel\n method, for cancelling all observers\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nNote that you can observe \nkeypath\n \npatterns\n...\n\n\nractive.observe( 'items.*.status', function ( newValue, oldValue, [keypath](../Concepts/Templates/Keypaths.md) ) {\n    var index = /items.(\\d+).status/.exec( [keypath](../Concepts/Templates/Keypaths.md) )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\n...or multiple space-separated \nkeypaths\n simultaneously:\n\n\nractive.observe( 'foo bar baz', function ( newValue, oldValue, [keypath](../Concepts/Templates/Keypaths.md) ) {\n    alert( [keypath](../Concepts/Templates/Keypaths.md) + ' changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\nSee \nObservers\n for more detail.\n\n\n\n\nractive.observeOnce()\n\n\nObserves the data at a particular \nkeypath\n until the first change. After the handler has been called, it will be unsubscribed from any future changes.\n\n\nSyntax\n\n\n\n\nractive.observeOnce(keypath, callback[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n to observe, or a group of space-separated keypaths. Any of the keys can be a \n*\n character, which is treated as a wildcard.\n\n\ncallback (Function)\n: The function that will be called, with \nnewValue\n, \noldValue\n and \nkeypath\n as arguments (see \nObservers\n for more nuance regarding these arguments), whenever the observed \nkeypath\n changes value. By default the function will be called with \nractive\n as \nthis\n. Any wildcards in the \nkeypath\n will have their matches passed to the callback at the end of the arguments list as well.\n\n\n[options] (Object)\n:\n\n\n[defer] (boolean)\n: Defaults to \nfalse\n, in which case \nobservers\n will fire before any DOM changes take place. If \ntrue\n, the \nobserver\n will fire once the DOM has been updated.\n\n\n[context] (any)\n: Defaults to \nractive\n. The context the \nobserver\n is called in (i.e. the value of \nthis\n)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: An object with a \ncancel\n method, for cancelling the observer.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nNote that you can observe \nkeypath\n \npatterns\n...\n\n\nractive.observeOnce( 'items.*.status', function ( newValue, oldValue, [keypath](../Concepts/Templates/Keypaths.md) ) {\n    var index = /items.(\\d+).status/.exec( [keypath](../Concepts/Templates/Keypaths.md) )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\n...or multiple space-separated \nkeypaths\n simultaneously:\n\n\nractive.observeOnce( 'foo bar baz', function ( newValue, oldValue, [keypath](../Concepts/Templates/Keypaths.md) ) {\n    alert( [keypath](../Concepts/Templates/Keypaths.md) + ' changed from ' + oldValue + ' to ' + newValue );\n});\n\n\n\n\nSee \nObservers\n for more detail.\n\n\n\n\nractive.off()\n\n\nRemoves an event handler, several event handlers, or all event handlers.\n\n\nTo remove a single handler, you must specify both the event name and the handler. If you only specify the event name, all handlers bound to that event name will be removed. If you specify neither event name nor handler, \nall\n event handlers will be removed.\n\n\nAn alternative way to remove event handlers is to use the \ncancel\n method of the return value of a call to \nractive.on()\n.\n\n\nSyntax\n\n\n\n\nractive.off([eventName[, handler]])\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The event name to which this handler is currently bound.\n\n\nhandler (Function)\n: The handler to remove.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the \nractive\n instance to allow this call to be chainable.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.on()\n\n\nSubscribe to \nevents\n.\n\n\nSyntax\n\n\n\n\nractive.on(eventName, handler)\n\n\nractive.on(obj)\n\n\n\n\nArguments\n\n\n\n\neventName (String)\n: The name of the event to subscribe to\n\n\nhandler (Function)\n: The function that will be called, with \nractive\n as \nthis\n. The arguments depend on the event. Returning \nfalse\n from the handler will stop propagation and prevent default of DOM events and cancel \nevent bubbling\n.\n\n\nobj (Object)\n: An object with keys named for each event to subscribe to. The value at each key is the handler function for that event.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n - An \nObject\n with a \ncancel\n method, which removes the handler.\n\n\n(Object)\n - An \nObject\n with a \ncancel\n method, which removes all handlers in the passed-in \nobj\n.\n\n\n\n\nExamples\n\n\n// single handler to function\nractive.on( 'activate', function () {...});\n\n// wildcard pattern matching\nractive.on( 'foo.*', function () {...} );\n\n// multiple handlers to one function\nractive.on( 'activate select', function () {...} );\n\n// map of handler/function pairs\nractive.on({\n    activate: function () {...},\n    select: function () {...}\n});\n\n// knock yourself out:\nractive.on({\n    activate: function () {...},\n    'bip bop boop': function () {...},\n    'select foo.* bar': function () {...}\n});\n\n\n\n\n\n\nractive.once()\n\n\nSubscribe to an event for a single firing. This is a convenience function on top of \nractive.on()\n.\n\n\nSyntax\n\n\n\n\nractive.once(eventName, handler)\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The name of the event to subscribe to.\n\n\nhandler (Function)\n: The function that will be called, with \nractive\n as \nthis\n. The arguments depend on the event. Returning \nfalse\n from the handler will stop propagation and prevent default of DOM events and cancel \nevent bubbling\n.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: Returns an \nObject\n with a \ncancel\n method, which removes the handler.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.pop()\n\n\nThe Ractive equivalent to \nArray.pop\n that removes an element from the end of the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.pop(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve with the removed element after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.push()\n\n\nThe Ractive equivalent to \nArray.push\n that appends one or more elements to the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.push(keypath, value[, ...valueN])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nvalue (any)\n: The value to append to the end of the array. One or more values may be supplied.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - Returns a Promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.render()\n\n\nRenders the component into a DOM element.\n\n\nSyntax\n\n\n\n\nractive.render(target)\n\n\n\n\nArguments\n\n\n\n\ntarget (Node|String|array-like)\n: The DOM element to render to.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when rendering completes or when the instance is already rendered.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.reset()\n\n\nResets the entire \nractive.data\n object and updates the DOM.\n\n\nSyntax\n\n\n\n\nractive.reset(data)\n\n\n\n\nArguments\n\n\n\n\ndata (Object)\n: The data to reset with. Defaults to \n{}\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\nThis differs from \nractive.set()\n in the following way:\n\n\nractive = new Ractive({\n  // ...,\n  data: { foo: 1 }\n});\n\nractive.set({ bar: 2 });\nconsole.log( ractive.get() ); // { foo: 1, bar: 2 }\n\nractive.reset({ bar: 2 });\nconsole.log( ractive.get() ); // { bar: 2 }\n\n\n\n\n\n\nractive.resetPartial()\n\n\nResets a partial and re-renders all of its use-sites, including in any components that have inherited it. If a component has a partial with a same name that is its own, that partial will not be affected.\n\n\nInline partials that don't belong directly to a Ractive instance aren't affected by \nresetPartial\n.\n\n\nSyntax\n\n\n\n\nractive.resetPartial(name, partial)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The partial to reset.\n\n\npartial (string|Object|Function)\n: A template string, pre-parsed template or a function that returns either.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\nractive = new Ractive({\n  // ...,\n  partials: { foo: 'foo' }\n});\n\n// {{\nfoo}} will be replaced with 'foo'\n\nractive.resetPartial('foo', 'bar');\n\n// {{\nfoo}} will be replaced with 'bar'\n\n\n\n\n\n\nractive.reverse()\n\n\nThe Ractive equivalent to \nArray.reverse\n reverses the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.reverse(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (String)\n: The \nkeypath\n of the array to reverse, e.g. \nlist\n or \norder.items\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - A promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.set()\n\n\nUpdates data and triggers a re-render of any mustaches that are affected (directly or indirectly) by the change. Any \nobservers\n of affected \nkeypaths\n will be notified.\n\n\nA \nchange\n \nevent\n will be fired with \nkeypath\n and \nvalue\n as arguments\n(or \nmap\n, if you set multiple options at once).\n\n\nWhen setting an array value, ractive will reuse the existing DOM nodes for the new array, adding or removing nodes as necessary. This can impact nodes with \ntransitions\n. See \nractive.merge()\n for setting a new array value while retaining existing nodes corresponding to individual array item values.\n\n\nSyntax\n\n\n\n\nractive.set(keypath, value)\n\n\nractive.set(map)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the data we're changing, e.g. \nuser\n or \nuser.name\n or \nuser.friends[1]\n or \nusers.*.status\n.\n\n\nvalue (any)\n: The value we're changing it to. Can be a primitive or an object (or array), in which case dependants of \ndownstream keypaths\n will also be re-rendered (if they have changed).\n\n\nmap (Object)\n: A map of \nkeypath: value\n pairs, as above.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will be called after the set operation and any transitions are complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nThe \nkeypath\n can also contain wildcards \npattern-observers\n. All matching \nkeypaths\n will be set with the supplied values:\n\n\nractive.on('selectAll', function(){\n    ractive.set('items.*.selected', true);\n})\n\n\n\n\n\n\nractive.shift()\n\n\nThe Ractive equivalent to \nArray.shift\n that removes an element from the beginning of the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.shift(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that will resolve with the removed element after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.sort()\n\n\nThe Ractive equivalent to \nArray.sort\n sorts the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.sort(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to sort, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.splice()\n\n\nThe Ractive equivalent to \nArray.splice\n that can add new elements to the array while removing existing elements.\n\n\nIf the given \nkeypath\n does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.splice(keypath, index, [removeCount[, add]])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nindex (number)\n: The index at which to start the operation.\n\n\n[removeCount] (number)\n: The number of elements to remove starting with the element at \nindex\n. This may be 0 if you don't want to remove any elements.\n\n\n[add] (any)\n: Any elements to insert into the array starting at \nindex\n. There can be 0 or more elements passed to add to the array.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve with the removed elements after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.subtract()\n\n\nDecrements the selected \nkeypath\n.\n\n\nSyntax\n\n\n\n\nractive.subtract(keypath[, number])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the number we're decrementing.\n\n\n[number] (number)\n: Defaults to \n1\n. The number to decrement by.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.teardown()\n\n\nUnrenders this Ractive instance, removing any event handlers that were bound automatically by Ractive.\n\n\nCalling \nractive.teardown()\n causes a \nteardown\n \nevent\n to be fired - this is most useful with \nRactive.extend()\n as it allows you to clean up anything else (event listeners and other bindings) that are part of the subclass.\n\n\nSyntax\n\n\n\n\nractive.teardown()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.toCSS()\n\n\nReturns the scoped CSS of the current instance and its descendants.\n\n\nAt the moment, this will not work on a direct instance of Ractive and will log a warning. You can only use this method on an instance of a subclass.\n\n\nSyntax\n\n\n\n\nractive.toCSS()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The scoped CSS of the instance.\n\n\n\n\nExamples\n\n\nconst Subclass = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\nconst subclassInstance = new Subclass({...});\n\n// Contains the scoped version of div{ color: red }\nsubclassInstance.toCSS();\n\n\n\n\n\n\nractive.toHTML()\n\n\nReturns a chunk of HTML representing the current state of the instance. This is most useful when you're using Ractive in node.js, as it allows you to serve fully-rendered pages (good for SEO and initial pageload performance) to the client.\n\n\nSyntax\n\n\n\n\nractive.toHTML()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The instance HTML.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.toggle()\n\n\nToggles the selected \nkeypath\n. In other words, if \nfoo\n is \ntruthy\n, then \nractive.toggle('foo')\n will make it \nfalse\n, and vice-versa.\n\n\nSyntax\n\n\n\n\nractive.toggle(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n to toggle the value of. If \nkeypath\n is a pattern, then all matching \nkeypaths\n will be toggled.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.transition()\n\n\nTriggers a transition on a node managed by this Ractive instance.\n\n\nSyntax\n\n\n\n\nractive.transition(transition, node, options)\n\n\n\n\nArguments\n\n\n\n\ntransition (string|Function)\n: A transition function or a name of a transition function.\n\n\nnode (HTMLElement)\n: The node on which to start the transition - optional if called from within a Ractive event handler, as it will be retrieved from the event if not supplied.\n\n\noptions (Object)\n: Options supplied to the transition.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the transition completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.unlink()\n\n\nRemoves a link set up by \nractive.link()\n.\n\n\nSyntax\n\n\n\n\nractive.unlink(destination)\n\n\n\n\nArguments\n\n\n\n\ndestination (string)\n: The destination supplied to [\nractive.link()\n].\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.unrender()\n\n\n\n\nUnrenders this Ractive instance, throwing away any DOM nodes associated with this instance. This is the counterpart to \nractive.render()\n. The rest of the ractive instance is left intact, unlike \nractive.teardown()\n.\n\n\nSyntax\n\n\n\n\nractive.unrender()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.unshift()\n\n\nThe Ractive equivalent to \nArray.unshift\n that prepends one or more elements to the array at the given \nkeypath\n and triggers an update event.\n\n\nIf the given \nkeypath\n does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given \nkeypath\n does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.unshift(keypath, value)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nvalue (any)\n: The value to prepend to the beginning of the array. One or more values may be supplied.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nractive.update()\n\n\nForces everything that depends on the specified \nkeypaths\n (whether directly or indirectly) to be 'dirty checked'. This is useful if you manipulate data without using the built in setter methods (i.e. \nractive.set()\n, \nractive.animate()\n, or array modification):\n\n\nIf no \nkeypath\n is specified, all mustaches and \nobservers\n will be checked.\n\n\nSyntax\n\n\n\n\nractive.update([keypath])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The \nkeypath\n to treat as 'dirty'. Any mustaches or \nobservers\n that depend (directly or indirectly) on this \nkeypath\n will be checked to see if they need to update\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise. If a \nkeypath\n is not supplied, this 'dirty checks' everything.\n\n\n\n\nExamples\n\n\nractive.observe( 'foo', function ( foo ) {\n    alert( foo );\n});\n\nmodel.foo = 'changed';\nractive.update( 'foo' ); // causes [observer](../Concepts/Events/Publish-Subscribe.md) to alert 'changed'\n\n\n\n\n\n\nractive.updateModel()\n\n\nIf you programmatically manipulate inputs and other elements that have \ntwo\u2010way binding\n set up, your model can get out of sync. In these cases, we need to force a resync with \nractive.updateModel()\n:\n\n\nSyntax\n\n\n\n\nractive.updateModel([keypath[, cascade]])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The \nkeypath\n to treat as 'dirty'. Any two-way bindings linked to this \nkeypath\n will be checked to see if the model is out of date\n\n\ncascade (boolean)\n: If true, bindings that are \ndownstream\n of \nkeypath\n will also be checked - e.g. \nractive.updateModel( 'items', true )\n would check \nitems.0.foo\n and \nitems.1.foo\n and so on. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise. If a \nkeypath\n is not specified, all two-way bindings will be checked.\n\n\n\n\nExamples\n\n\nractive = new Ractive({\n  el: 'container',\n  template: '\ninput value=\n{{name}}\n'\n  data: { name: 'Bob' }\n});\n\nractive.find( 'input' ).value = 'Jim';\nalert( ractive.get( 'name' ) ); // alerts 'Bob', not 'Jim'\n\nractive.updateModel();\nalert( ractive.get( 'name' ) ); // alerts 'Jim'", 
            "title": "Instance Methods"
        }, 
        {
            "location": "/API/Instance Methods/#instance-methods", 
            "text": "", 
            "title": "Instance Methods"
        }, 
        {
            "location": "/API/Instance Methods/#ractive_super", 
            "text": "Calls the parent method from a child method of the same name.  ractive._super()  is not always available. Only when Ractive detects its use does it make this reference to the parent method.  Syntax   ractive._super([arg[, ...argN]])   Arguments   [arg] (any) : One or more arguments to pass to the function.   Returns   (any) : Depends on the method called.   Examples  const MyComponentSubclass = MyComponent.exten({\n  // Overrides the oninit of MyComponent\n  oninit: function(...args){\n    // Call MyComponent's oninit\n    this._super(...args);\n  }\n});", 
            "title": "ractive._super()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveadd", 
            "text": "Increments the selected keypath.  Syntax   ractive.add(keypath[, number])   Arguments   keypath (string) : The  keypath  of the number we're incrementing.  [number] (number) : The number to increment by. Defaults to  1 .   Returns   (Promise) : A promise that resolves when the operation completes.   Examples  // TODO", 
            "title": "ractive.add()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveanimate", 
            "text": "Similar to  ractive.set() , this will update the data and re-render any affected mustaches and notify  observers .  All animations are handled by a global timer that is shared between Ractive instances (and which only runs if there are one or more animations still in progress), so you can trigger as many separate animations as you like without worrying about timer congestion. Where possible,  requestAnimationFrame  is used rather than  setTimeout .  Numeric values and strings that can be parsed as numeric values can be interpolated. Objects and arrays containing numeric values (or other objects and arrays which themselves contain numeric values, and so on recursively) are also interpolated.  Note that there is currently no mechanism for detecting cyclical structures! Animating to a value that indirectly references itself will cause an infinite loop.  Future versions of Ractive may include string interpolators - e.g. for SVG paths, colours, transformations and so on, a la D3 - and the ability to pass in your own interpolator.  If an animation is started on a  keypath  which is  already  being animated, the first animation is cancelled. (Currently, there is no mechanism in place to prevent collisions between e.g.  ractive.animate('foo', { bar: 1 })  and  ractive.animate('foo.bar', 0) .)  Syntax   ractive.animate(keypath, value[, options])  ractive.animate(map[, options])   Arguments   keypath (string) : The  keypath  to animate.  value (number|string|Object|Array) : The value to animate to.  map (Object) : A key-value hash of  keypath  and value.  [options] (Object) :  [duration] (number) : How many milliseconds the animation should run for. Defaults to  400 .  [easing] (string|Function) : The name of an easing function or the easing function itself. Defaults to  linear .  [step] (Function) : A function to be called on each step of the animation. Receives  t  and  value  as arguments, where  t  is the animation progress (between  0  and  1 , as determined by the easing function) and  value  is the intermediate value at  t .  [complete] (Function) : A function to be called when the animation completes, with the same argument signature as  step  (i.e.  t  is  1 , and  value  is the destination value)     Returns   (Promise) : Returns a Promise with an additional  stop  method, which cancels the animation.   Examples  // TODO", 
            "title": "ractive.animate()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivedetach", 
            "text": "Detaches the instance from the DOM, returning a document fragment. You can reinsert it, possibly in a different place, with  ractive.insert()  (note that if you are reinserting it immediately you don't need to detach it first - it will happen automatically).  Syntax   ractive.detach()   Arguments   None   Returns   (DocumentFragment) : A document fragment.   Examples  // TODO", 
            "title": "ractive.detach()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivefind", 
            "text": "Returns the first element inside a given Ractive instance matching a CSS selector. This is similar to doing  this.el.querySelector(selector)  (though it doesn't actually use  querySelector() ).  Syntax   ractive.find(selector[, options])   Arguments   selector (string) : A CSS selector representing the element to find.  [options] (Object) :   Returns   (Node) : A Node.   Examples  // TODO", 
            "title": "ractive.find()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivefindall", 
            "text": "This method is similar to  ractive.find() , with two important differences. Firstly, it returns a list of elements matching the selector, rather than a single node. Secondly, it can return a  live  list, which will stay in sync with the DOM as it continues to update.  Syntax   ractive.findAll(selector[, options])   Arguments   selector (string) : A CSS selector representing the elements to find.  [options] (Object)  [live] (boolean) : Whether to return a live list or a static one. Defaults to  false .     Returns   (Array Node ) : An array of nodes.   Examples  // TODO", 
            "title": "ractive.findAll()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivefindallcomponents", 
            "text": "Returns all components inside a given Ractive instance with the given  name  (or all components of any kind if no name is given).  Syntax   ractive.findAllComponents([name[, options]])   Arguments   [name] (string) : The name of the component to find.  [options] (Object)  [live] (boolean) : Whether to return a live list or a static one. Defaults to  false .     Returns   (Array ractive ) : An array of ractive instances.   Examples  // TODO", 
            "title": "ractive.findAllComponents()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivefindcomponent", 
            "text": "Returns the first component inside a given Ractive instance with the given  name  (or the first component of any kind if no name is given).  Syntax   ractive.findComponent([name[, options]])   Arguments   [name] (string) : The name of the component to find.  [options] (Object) :   Returns   (Ractive) : A ractive instance.   Examples  // TODO", 
            "title": "ractive.findComponent()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivefindcontainer", 
            "text": "Returns the first container of this component instance with the given  name .  Syntax   ractive.findContainer(name)   Arguments   name (string) : The name of the container to find.   Returns   (Ractive) : Returns the first container of this component with the given  name .   Examples  // TODO", 
            "title": "ractive.findContainer()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivefindparent", 
            "text": "Returns the first parent of this component instance with the given  name .  Syntax   ractive.findParent(name)   Arguments   name (string) : The name of the parent to find.   Returns   (Ractive) : Returns the first parent of this component with the given  name .   Examples  // TODO", 
            "title": "ractive.findParent()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivefire", 
            "text": "Fires an event, which will be received by handlers that were bound using  ractive.on . In practical terms, you would mostly likely use this with  Ractive.extend() , to allow applications to hook into your subclass.  Syntax   ractive.fire(eventName[, arg1[, ...argN])   Arguments   name (string) : The name of the event.  [arg] (any) : The arguments that event handlers will be called with.   Returns   (boolean)   Examples  // TODO", 
            "title": "ractive.fire()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveget", 
            "text": "Returns the value at  keypath . If the  keypath  is omitted, returns a shallow copy of all the data in the instance. This data includes mappings introduced by enclosing components, but excludes computed properties.  Syntax   ractive.get([keypath])   Arguments   [keypath] (string) : The  keypath  of the data to retrieve.   Returns   (any) : Returns whatever data was on the keypath, or all if no  keypath  was provided.   Examples  // TODO", 
            "title": "ractive.get()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivegetnodeinfo", 
            "text": "This is an instance specific version of  Ractive.getNodeInfo()  that will only search the local instance DOM for a matching node when a selector is given. If the given value is not a string, then it is passed directly through to the static version of this method.  Syntax   ractive.getNodeInfo(node)   Arguments   node (string|Node) : The DOM node or a CSS selector of a target node for which you wish to retrieve the Ractive instance or view details.   Returns   (NodeInfo) : Returns an  NodeInfo  object with helper methods to interact with the Ractive instance and context associated with the given node.   Examples  // TODO", 
            "title": "ractive.getNodeInfo()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveinsert", 
            "text": "Inserts the instance to a different location. If the instance is currently in the DOM, it will be detached first. See also  ractive.detach() .  Syntax   ractive.insert(target[, anchor])   Arguments   target (string|Node|array-like) : The new parent element.  [anchor] (string|Node|array-like) : The sibling element to insert the instance before. If omitted, the instance will be inserted as the last child of the parent.   Returns   (undefined)   Examples  // TODO", 
            "title": "ractive.insert()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivelink", 
            "text": "Creates a link between two  keypaths  that keeps them in sync. Since Ractive can't always watch the contents of objects, copying an object to two different  keypaths  in your data usually leads to one or both of them getting out of sync.  link  creates a sort of symlink between the two paths so that Ractive knows they are actually the same object. This is particularly useful for master/detail scenarios where you have a complex list of data and you want to be able to select an item to edit in a detail form.  Syntax   ractive.link(source, destination)   Arguments   source (string) : The  keypath  of the source item.  destination (string) : The  keypath  to use as the destination - or where you'd like the data 'copied'.   Returns   (Promise) : Returns a promise.   Examples  ractive.link( 'some.nested.0.list.25.item', 'current' );\nractive.set( 'current.name', 'Rich' ); // some.nested.0.list.25.item.name is also updated to be 'Rich'  This can be used to great effect with method events and the  @keypath  special ref:  {{#each some.nested}}\n  {{#each list}}\n    {{#with item}}\n      {{.name}}\n       button on-click= event.link('.', 'current') Select /button \n    {{/with}}\n  {{/each}}\n{{/each}}\n\nName:  input value= {{~/current.name}}  /   Links can be removed using  ractive.unlink() .", 
            "title": "ractive.link()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivemerge", 
            "text": "Sets the indicated  keypath  to the new array value, but \"merges\" the existing rendered nodes representing the data into the newly rendered array, inserting and removing nodes from the DOM as necessary. Where necessary, items are moved from their current location in the array (and, therefore, in the DOM) to their new location.  This is an efficient way to (for example) handle data from a server. It also helps to control  intro  and  outro   transitions  which might not otherwise happen with a basic  ractive.set()  operation.  To determine whether the first item of  ['foo', 'bar', 'baz']  is the same as the last item of  ['bar', 'baz', 'foo'] , by default we do a strict equality ( === ) check.  In some situations that won't work, because the arrays contain objects, which may  look  the same but not be identical. To deal with these, we use the  compare  option detailed below.  Merge can also be used to created a context block that uses transitions when the context changes.  Syntax   ractive.merge(keypath, value[, options])   Arguments   keypath (string) : The  keypath  of the array we're updating.  value (Array) : The new data to merge in.  [options] (Object)  [compare] (boolean) : If  true , values will be stringified (with  JSON.stringify ) before comparison.  [compare] (string) : A property name that will be used to compare the array elements.  [compare] (Function) : A function that returns a value with which to compare array members.     Returns   (Promise)  - Returns a promise.   Examples  {{#user}} div intro='fade' {{first}} {{last}} /div \n{{/}}  var r = new Ractive({\n    el: document.body,\n    template: '#template',\n    data: {\n        user: [{\n            first: 'sam',\n            last: 'smith'\n        }]\n    },\n    complete: function(){\n        this.merge('user', [{\n            first: 'jane',\n            last: 'johnson'\n        }])\n    }\n})", 
            "title": "ractive.merge()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveobserve", 
            "text": "Observes the data at a particular  keypath . Unless specified otherwise, the callback will be fired immediately, with  undefined  as  oldValue . Thereafter it will be called whenever the  observed keypath  changes.  Syntax   ractive.observe(keypath, callback[, options])  ractive.observe(map[, options])   Arguments   keypath (String) : The  keypath  to observe, or a group of space-separated keypaths. Any of the keys can be a  *  character, which is treated as a wildcard.  callback (Function) : The function that will be called, with  newValue ,  oldValue  and  keypath  as arguments (see  Observers  for more nuance regarding these arguments), whenever the observed  keypath  changes value. By default the function will be called with  ractive  as  this . Any wildcards in the  keypath  will have their matches passed to the callback at the end of the arguments list as well.  map (Object) : A map of keypath-observer pairs.  [options] (Object) :  [init] (boolean) : Defaults to  true . Whether or not to initialise the observer, i.e. call the function with the current value of  keypath  as the first argument and  undefined  as the second.  [defer] (boolean) : Defaults to  false , in which case  observers  will fire before any DOM changes take place. If  true , the  observer  will fire once the DOM has been updated.  [context] (any) : Defaults to  ractive . The context the  observer  is called in (i.e. the value of  this )     Returns   (Object) : An object with a  cancel  method, for cancelling all observers   Examples  // TODO  Note that you can observe  keypath   patterns ...  ractive.observe( 'items.*.status', function ( newValue, oldValue, [keypath](../Concepts/Templates/Keypaths.md) ) {\n    var index = /items.(\\d+).status/.exec( [keypath](../Concepts/Templates/Keypaths.md) )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});  ...or multiple space-separated  keypaths  simultaneously:  ractive.observe( 'foo bar baz', function ( newValue, oldValue, [keypath](../Concepts/Templates/Keypaths.md) ) {\n    alert( [keypath](../Concepts/Templates/Keypaths.md) + ' changed from ' + oldValue + ' to ' + newValue );\n});  See  Observers  for more detail.", 
            "title": "ractive.observe()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveobserveonce", 
            "text": "Observes the data at a particular  keypath  until the first change. After the handler has been called, it will be unsubscribed from any future changes.  Syntax   ractive.observeOnce(keypath, callback[, options])   Arguments   keypath (string) : The  keypath  to observe, or a group of space-separated keypaths. Any of the keys can be a  *  character, which is treated as a wildcard.  callback (Function) : The function that will be called, with  newValue ,  oldValue  and  keypath  as arguments (see  Observers  for more nuance regarding these arguments), whenever the observed  keypath  changes value. By default the function will be called with  ractive  as  this . Any wildcards in the  keypath  will have their matches passed to the callback at the end of the arguments list as well.  [options] (Object) :  [defer] (boolean) : Defaults to  false , in which case  observers  will fire before any DOM changes take place. If  true , the  observer  will fire once the DOM has been updated.  [context] (any) : Defaults to  ractive . The context the  observer  is called in (i.e. the value of  this )     Returns   (Object) : An object with a  cancel  method, for cancelling the observer.   Examples  // TODO  Note that you can observe  keypath   patterns ...  ractive.observeOnce( 'items.*.status', function ( newValue, oldValue, [keypath](../Concepts/Templates/Keypaths.md) ) {\n    var index = /items.(\\d+).status/.exec( [keypath](../Concepts/Templates/Keypaths.md) )[1];\n    alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue );\n});  ...or multiple space-separated  keypaths  simultaneously:  ractive.observeOnce( 'foo bar baz', function ( newValue, oldValue, [keypath](../Concepts/Templates/Keypaths.md) ) {\n    alert( [keypath](../Concepts/Templates/Keypaths.md) + ' changed from ' + oldValue + ' to ' + newValue );\n});  See  Observers  for more detail.", 
            "title": "ractive.observeOnce()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveoff", 
            "text": "Removes an event handler, several event handlers, or all event handlers.  To remove a single handler, you must specify both the event name and the handler. If you only specify the event name, all handlers bound to that event name will be removed. If you specify neither event name nor handler,  all  event handlers will be removed.  An alternative way to remove event handlers is to use the  cancel  method of the return value of a call to  ractive.on() .  Syntax   ractive.off([eventName[, handler]])   Arguments   eventName (string) : The event name to which this handler is currently bound.  handler (Function) : The handler to remove.   Returns   (Ractive) : Returns the  ractive  instance to allow this call to be chainable.   Examples  // TODO", 
            "title": "ractive.off()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveon", 
            "text": "Subscribe to  events .  Syntax   ractive.on(eventName, handler)  ractive.on(obj)   Arguments   eventName (String) : The name of the event to subscribe to  handler (Function) : The function that will be called, with  ractive  as  this . The arguments depend on the event. Returning  false  from the handler will stop propagation and prevent default of DOM events and cancel  event bubbling .  obj (Object) : An object with keys named for each event to subscribe to. The value at each key is the handler function for that event.   Returns   (Object)  - An  Object  with a  cancel  method, which removes the handler.  (Object)  - An  Object  with a  cancel  method, which removes all handlers in the passed-in  obj .   Examples  // single handler to function\nractive.on( 'activate', function () {...});\n\n// wildcard pattern matching\nractive.on( 'foo.*', function () {...} );\n\n// multiple handlers to one function\nractive.on( 'activate select', function () {...} );\n\n// map of handler/function pairs\nractive.on({\n    activate: function () {...},\n    select: function () {...}\n});\n\n// knock yourself out:\nractive.on({\n    activate: function () {...},\n    'bip bop boop': function () {...},\n    'select foo.* bar': function () {...}\n});", 
            "title": "ractive.on()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveonce", 
            "text": "Subscribe to an event for a single firing. This is a convenience function on top of  ractive.on() .  Syntax   ractive.once(eventName, handler)   Arguments   eventName (string) : The name of the event to subscribe to.  handler (Function) : The function that will be called, with  ractive  as  this . The arguments depend on the event. Returning  false  from the handler will stop propagation and prevent default of DOM events and cancel  event bubbling .   Returns   (Object) : Returns an  Object  with a  cancel  method, which removes the handler.   Examples  // TODO", 
            "title": "ractive.once()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivepop", 
            "text": "The Ractive equivalent to  Array.pop  that removes an element from the end of the array at the given  keypath  and triggers an update event.  If the given  keypath  does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.pop(keypath)   Arguments   keypath (string) : The  keypath  of the array to change, e.g.  list  or  order.items .   Returns   (Promise) : Returns a promise that will resolve with the removed element after the update is complete.   Examples  // TODO", 
            "title": "ractive.pop()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivepush", 
            "text": "The Ractive equivalent to  Array.push  that appends one or more elements to the array at the given  keypath  and triggers an update event.  If the given  keypath  does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.push(keypath, value[, ...valueN])   Arguments   keypath (string) : The  keypath  of the array to change, e.g.  list  or  order.items .  value (any) : The value to append to the end of the array. One or more values may be supplied.   Returns   (Promise)  - Returns a Promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.push()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiverender", 
            "text": "Renders the component into a DOM element.  Syntax   ractive.render(target)   Arguments   target (Node|String|array-like) : The DOM element to render to.   Returns   (Promise) : A promise that resolves when rendering completes or when the instance is already rendered.   Examples  // TODO", 
            "title": "ractive.render()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivereset", 
            "text": "Resets the entire  ractive.data  object and updates the DOM.  Syntax   ractive.reset(data)   Arguments   data (Object) : The data to reset with. Defaults to  {} .   Returns   (Promise) : A promise.   Examples  This differs from  ractive.set()  in the following way:  ractive = new Ractive({\n  // ...,\n  data: { foo: 1 }\n});\n\nractive.set({ bar: 2 });\nconsole.log( ractive.get() ); // { foo: 1, bar: 2 }\n\nractive.reset({ bar: 2 });\nconsole.log( ractive.get() ); // { bar: 2 }", 
            "title": "ractive.reset()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveresetpartial", 
            "text": "Resets a partial and re-renders all of its use-sites, including in any components that have inherited it. If a component has a partial with a same name that is its own, that partial will not be affected.  Inline partials that don't belong directly to a Ractive instance aren't affected by  resetPartial .  Syntax   ractive.resetPartial(name, partial)   Arguments   name (string) : The partial to reset.  partial (string|Object|Function) : A template string, pre-parsed template or a function that returns either.   Returns   (Promise) : A promise.   Examples  ractive = new Ractive({\n  // ...,\n  partials: { foo: 'foo' }\n});\n\n// {{ foo}} will be replaced with 'foo'\n\nractive.resetPartial('foo', 'bar');\n\n// {{ foo}} will be replaced with 'bar'", 
            "title": "ractive.resetPartial()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivereverse", 
            "text": "The Ractive equivalent to  Array.reverse  reverses the array at the given  keypath  and triggers an update event.  If the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.reverse(keypath)   Arguments   keypath (String) : The  keypath  of the array to reverse, e.g.  list  or  order.items   Returns   (Promise)  - A promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.reverse()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveset", 
            "text": "Updates data and triggers a re-render of any mustaches that are affected (directly or indirectly) by the change. Any  observers  of affected  keypaths  will be notified.  A  change   event  will be fired with  keypath  and  value  as arguments\n(or  map , if you set multiple options at once).  When setting an array value, ractive will reuse the existing DOM nodes for the new array, adding or removing nodes as necessary. This can impact nodes with  transitions . See  ractive.merge()  for setting a new array value while retaining existing nodes corresponding to individual array item values.  Syntax   ractive.set(keypath, value)  ractive.set(map)   Arguments   keypath (string) : The  keypath  of the data we're changing, e.g.  user  or  user.name  or  user.friends[1]  or  users.*.status .  value (any) : The value we're changing it to. Can be a primitive or an object (or array), in which case dependants of  downstream keypaths  will also be re-rendered (if they have changed).  map (Object) : A map of  keypath: value  pairs, as above.   Returns   (Promise) : Returns a promise that will be called after the set operation and any transitions are complete.   Examples  // TODO  The  keypath  can also contain wildcards  pattern-observers . All matching  keypaths  will be set with the supplied values:  ractive.on('selectAll', function(){\n    ractive.set('items.*.selected', true);\n})", 
            "title": "ractive.set()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveshift", 
            "text": "The Ractive equivalent to  Array.shift  that removes an element from the beginning of the array at the given  keypath  and triggers an update event.  If the given  keypath  does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.shift(keypath)   Arguments   keypath (string) : The  keypath  of the array to change, e.g.  list  or  order.items .   Returns   (Promise) : A promise that will resolve with the removed element after the update is complete.   Examples  // TODO", 
            "title": "ractive.shift()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivesort", 
            "text": "The Ractive equivalent to  Array.sort  sorts the array at the given  keypath  and triggers an update event.  If the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.sort(keypath)   Arguments   keypath (string) : The  keypath  of the array to sort, e.g.  list  or  order.items .   Returns   (Promise) : Returns a promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.sort()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivesplice", 
            "text": "The Ractive equivalent to  Array.splice  that can add new elements to the array while removing existing elements.  If the given  keypath  does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.splice(keypath, index, [removeCount[, add]])   Arguments   keypath (string) : The  keypath  of the array to change, e.g.  list  or  order.items .  index (number) : The index at which to start the operation.  [removeCount] (number) : The number of elements to remove starting with the element at  index . This may be 0 if you don't want to remove any elements.  [add] (any) : Any elements to insert into the array starting at  index . There can be 0 or more elements passed to add to the array.   Returns   (Promise) : Returns a promise that will resolve with the removed elements after the update is complete.   Examples  // TODO", 
            "title": "ractive.splice()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivesubtract", 
            "text": "Decrements the selected  keypath .  Syntax   ractive.subtract(keypath[, number])   Arguments   keypath (string) : The  keypath  of the number we're decrementing.  [number] (number) : Defaults to  1 . The number to decrement by.   Returns   (Promise) : Returns a promise.   Examples  // TODO", 
            "title": "ractive.subtract()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveteardown", 
            "text": "Unrenders this Ractive instance, removing any event handlers that were bound automatically by Ractive.  Calling  ractive.teardown()  causes a  teardown   event  to be fired - this is most useful with  Ractive.extend()  as it allows you to clean up anything else (event listeners and other bindings) that are part of the subclass.  Syntax   ractive.teardown()   Arguments   None   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.teardown()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivetocss", 
            "text": "Returns the scoped CSS of the current instance and its descendants.  At the moment, this will not work on a direct instance of Ractive and will log a warning. You can only use this method on an instance of a subclass.  Syntax   ractive.toCSS()   Arguments   None   Returns   (string) : The scoped CSS of the instance.   Examples  const Subclass = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n});\n\nconst subclassInstance = new Subclass({...});\n\n// Contains the scoped version of div{ color: red }\nsubclassInstance.toCSS();", 
            "title": "ractive.toCSS()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivetohtml", 
            "text": "Returns a chunk of HTML representing the current state of the instance. This is most useful when you're using Ractive in node.js, as it allows you to serve fully-rendered pages (good for SEO and initial pageload performance) to the client.  Syntax   ractive.toHTML()   Arguments   None   Returns   (string) : The instance HTML.   Examples  // TODO", 
            "title": "ractive.toHTML()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivetoggle", 
            "text": "Toggles the selected  keypath . In other words, if  foo  is  truthy , then  ractive.toggle('foo')  will make it  false , and vice-versa.  Syntax   ractive.toggle(keypath)   Arguments   keypath (string) : The  keypath  to toggle the value of. If  keypath  is a pattern, then all matching  keypaths  will be toggled.   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.toggle()"
        }, 
        {
            "location": "/API/Instance Methods/#ractivetransition", 
            "text": "Triggers a transition on a node managed by this Ractive instance.  Syntax   ractive.transition(transition, node, options)   Arguments   transition (string|Function) : A transition function or a name of a transition function.  node (HTMLElement) : The node on which to start the transition - optional if called from within a Ractive event handler, as it will be retrieved from the event if not supplied.  options (Object) : Options supplied to the transition.   Returns   (Promise) : A promise that resolves when the transition completes.   Examples  // TODO", 
            "title": "ractive.transition()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveunlink", 
            "text": "Removes a link set up by  ractive.link() .  Syntax   ractive.unlink(destination)   Arguments   destination (string) : The destination supplied to [ ractive.link() ].   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.unlink()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveunrender", 
            "text": "Unrenders this Ractive instance, throwing away any DOM nodes associated with this instance. This is the counterpart to  ractive.render() . The rest of the ractive instance is left intact, unlike  ractive.teardown() .  Syntax   ractive.unrender()   Arguments   None   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.unrender()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveunshift", 
            "text": "The Ractive equivalent to  Array.unshift  that prepends one or more elements to the array at the given  keypath  and triggers an update event.  If the given  keypath  does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given  keypath  does not resolve to an array, an error will be thrown.  Syntax   ractive.unshift(keypath, value)   Arguments   keypath (string) : The  keypath  of the array to change, e.g.  list  or  order.items .  value (any) : The value to prepend to the beginning of the array. One or more values may be supplied.   Returns   (Promise) : Returns a promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.unshift()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveupdate", 
            "text": "Forces everything that depends on the specified  keypaths  (whether directly or indirectly) to be 'dirty checked'. This is useful if you manipulate data without using the built in setter methods (i.e.  ractive.set() ,  ractive.animate() , or array modification):  If no  keypath  is specified, all mustaches and  observers  will be checked.  Syntax   ractive.update([keypath])   Arguments   [keypath] (string) : The  keypath  to treat as 'dirty'. Any mustaches or  observers  that depend (directly or indirectly) on this  keypath  will be checked to see if they need to update   Returns   (Promise) : A promise. If a  keypath  is not supplied, this 'dirty checks' everything.   Examples  ractive.observe( 'foo', function ( foo ) {\n    alert( foo );\n});\n\nmodel.foo = 'changed';\nractive.update( 'foo' ); // causes [observer](../Concepts/Events/Publish-Subscribe.md) to alert 'changed'", 
            "title": "ractive.update()"
        }, 
        {
            "location": "/API/Instance Methods/#ractiveupdatemodel", 
            "text": "If you programmatically manipulate inputs and other elements that have  two\u2010way binding  set up, your model can get out of sync. In these cases, we need to force a resync with  ractive.updateModel() :  Syntax   ractive.updateModel([keypath[, cascade]])   Arguments   keypath (string) : The  keypath  to treat as 'dirty'. Any two-way bindings linked to this  keypath  will be checked to see if the model is out of date  cascade (boolean) : If true, bindings that are  downstream  of  keypath  will also be checked - e.g.  ractive.updateModel( 'items', true )  would check  items.0.foo  and  items.1.foo  and so on. Defaults to  false .   Returns   (Promise) : A promise. If a  keypath  is not specified, all two-way bindings will be checked.   Examples  ractive = new Ractive({\n  el: 'container',\n  template: ' input value= {{name}} '\n  data: { name: 'Bob' }\n});\n\nractive.find( 'input' ).value = 'Jim';\nalert( ractive.get( 'name' ) ); // alerts 'Bob', not 'Jim'\n\nractive.updateModel();\nalert( ractive.get( 'name' ) ); // alerts 'Jim'", 
            "title": "ractive.updateModel()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/", 
            "text": "Node Info\n\n\nThe nodeinfo object is the type of object you receive when calling \nNode Info\n. This object contains various properties and methods that allow you to obtain information about the Ractive instance, the node associated with it and the context surrounding it.\n\n\nHelper methods that take a \nkeypath\n will resolve relative to that node's context. Special references, template aliases, and key and index aliases are supported.\n\n\n\n\nnodeinfo.add()\n\n\nSee \nractive.add()\n.\n\n\n\n\nnodeinfo.animate()\n\n\nSee \nractive.animate()\n.\n\n\n\n\nnodeinfo.context\n\n\n(any)\n\n\nThe data context of the node.\n\n\n\n\nnodeinfo.get()\n\n\nSee \nractive.get()\n.\n\n\n\n\nnodeinfo.getBinding()\n\n\nReturns the value of the binding if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\nnodeinfo.getBinding()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(any)\n: The value of the binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\ninput id=\nfindMe\n value=\n{{.baz}}\n /\n{{/with}}\n\n\n\n\nRactive.getNodeInfo('#findMe').getBinding(); // returns value of foo.bar.baz\n\n\n\n\nnodeinfo.getBindingPath()\n\n\nReturns the \nkeypath\n of the binding if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\nnodeinfo.getBindingPath([ractive])\n\n\n\n\nArguments\n\n\n\n\n[ractive] (Ractive)\n: The instance to resolve the \nkeypath\n against.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The \nkeypath\n of the node binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\ninput id=\nfindMe\n value=\n{{.baz}}\n /\n{{/with}}\n\n\n\n\nRactive.getNodeInfo('#findMe').getBindingPath(); // Returns \nfoo.bar.baz\n\n\n\n\n\n\n\nnodeinfo.index\n\n\n(number|undefined)\n\n\nThe index of \ncontext\n if it's in an array. If not in an array, the value is \nundefined\n.\n\n\n\n\nnodeinfo.isBound()\n\n\nReturns \ntrue\n if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\nnodeinfo.isBound()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: \ntrue\n if the node represented has a two-way binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\n  \ninput id=\nfoo\n value=\n{{.baz}}\n /\n\n  \ninput id=\nbar\n value=\n /\n\n{{/with}}\n\n\n\n\nRactive.getNodeInfo('#foo').isBound(); // Returns true\nRactive.getNodeInfo('#bar').isBound(); // Returns false\n\n\n\n\n\n\nnodeinfo.keypath\n\n\n(string)\n\n\nThe \nkeypath\n to \ncontext\n.\n\n\n\n\nnodeinfo.link()\n\n\nSee \nractive.link()\n.\n\n\n\n\nnodeinfo.merge()\n\n\nSee \nractive.merge()\n.\n\n\n\n\nnodeinfo.node\n\n\n(Node|undefined)\n\n\nThe node the event originated from. Normally present when the event is a Ractive DOM. May be \nundefined\n on custom events or events from event plugins.\n\n\n\n\nnodeinfo.original\n\n\n(Event|undefined)\n\n\nThe original DOM event object. Normally present when the event is a Ractive DOM event. May be \nundefined\n on custom events or events from event plugins.\n\n\n\n\nnodeinfo.pop()\n\n\nSee \nractive.pop()\n.\n\n\n\n\nnodeinfo.push()\n\n\nSee \nractive.push()\n.\n\n\n\n\nnodeinfo.ractive\n\n\n(Ractive)\n\n\nThis property holds a reference to the Ractive instance that controls the node represented by this info object.\n\n\n\n\nnodeinfo.resolve()\n\n\nResolves the given \nkeypath\n to a full keypath. If a Ractive instance is supplied, the resolved path will also account for any mappings defined for the instance.\n\n\nSyntax\n\n\n\n\nnodeinfo.resolve([keypath[, ractive]])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The \nkeypath\n to resolve.\n\n\n[ractive] (Ractive)\n: The instance to resolve the \nkeypath\n against.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The resolved keypath.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nnodeinfo.reverse()\n\n\nSee \nractive.reverse()\n.\n\n\n\n\nnodeinfo.set()\n\n\nSee \nractive.set()\n.\n\n\n\n\nnodeinfo.setBinding()\n\n\nSets the binding of the node represented by this info object to the specified value.\n\n\nSyntax\n\n\n\n\nnodeinfo.setBinding(value)\n\n\n\n\nArguments\n\n\n\n\nvalue (any)\n. The value to set.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nnodeinfo.shift()\n\n\nSee \nractive.shift()\n.\n\n\n\n\nnodeinfo.splice()\n\n\nSee \nractive.splice()\n.\n\n\n\n\nnodeinfo.sort()\n\n\nSee \nractive.sort()\n.\n\n\n\n\nnodeinfo.subtract()\n\n\nSee \nractive.subtract()\n.\n\n\n\n\nnodeinfo.toggle()\n\n\nSee \nractive.toggle()\n.\n\n\n\n\nnodeinfo.unlink()\n\n\nSee \nractive.unlink()\n.\n\n\n\n\nnodeinfo.unshift()\n\n\nSee \nractive.unshift()\n.\n\n\n\n\nnodeinfo.update()\n\n\nSee \nractive.update()\n.\n\n\n\n\nnodeinfo.updateModel()\n\n\nSee \nractive.updateModel()\n.", 
            "title": "Node Info"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#node-info", 
            "text": "The nodeinfo object is the type of object you receive when calling  Node Info . This object contains various properties and methods that allow you to obtain information about the Ractive instance, the node associated with it and the context surrounding it.  Helper methods that take a  keypath  will resolve relative to that node's context. Special references, template aliases, and key and index aliases are supported.", 
            "title": "Node Info"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfoadd", 
            "text": "See  ractive.add() .", 
            "title": "nodeinfo.add()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfoanimate", 
            "text": "See  ractive.animate() .", 
            "title": "nodeinfo.animate()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfocontext", 
            "text": "(any)  The data context of the node.", 
            "title": "nodeinfo.context"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfoget", 
            "text": "See  ractive.get() .", 
            "title": "nodeinfo.get()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfogetbinding", 
            "text": "Returns the value of the binding if the node represented by this info object has a two-way binding.  Syntax   nodeinfo.getBinding()   Arguments   None   Returns   (any) : The value of the binding.   Examples  {{#with foo.bar}} input id= findMe  value= {{.baz}}  / {{/with}}  Ractive.getNodeInfo('#findMe').getBinding(); // returns value of foo.bar.baz", 
            "title": "nodeinfo.getBinding()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfogetbindingpath", 
            "text": "Returns the  keypath  of the binding if the node represented by this info object has a two-way binding.  Syntax   nodeinfo.getBindingPath([ractive])   Arguments   [ractive] (Ractive) : The instance to resolve the  keypath  against.   Returns   (string) : The  keypath  of the node binding.   Examples  {{#with foo.bar}} input id= findMe  value= {{.baz}}  / {{/with}}  Ractive.getNodeInfo('#findMe').getBindingPath(); // Returns  foo.bar.baz", 
            "title": "nodeinfo.getBindingPath()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfoindex", 
            "text": "(number|undefined)  The index of  context  if it's in an array. If not in an array, the value is  undefined .", 
            "title": "nodeinfo.index"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfoisbound", 
            "text": "Returns  true  if the node represented by this info object has a two-way binding.  Syntax   nodeinfo.isBound()   Arguments   None   Returns   (boolean) :  true  if the node represented has a two-way binding.   Examples  {{#with foo.bar}}\n   input id= foo  value= {{.baz}}  / \n   input id= bar  value=  / \n{{/with}}  Ractive.getNodeInfo('#foo').isBound(); // Returns true\nRactive.getNodeInfo('#bar').isBound(); // Returns false", 
            "title": "nodeinfo.isBound()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfokeypath", 
            "text": "(string)  The  keypath  to  context .", 
            "title": "nodeinfo.keypath"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfolink", 
            "text": "See  ractive.link() .", 
            "title": "nodeinfo.link()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfomerge", 
            "text": "See  ractive.merge() .", 
            "title": "nodeinfo.merge()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfonode", 
            "text": "(Node|undefined)  The node the event originated from. Normally present when the event is a Ractive DOM. May be  undefined  on custom events or events from event plugins.", 
            "title": "nodeinfo.node"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfooriginal", 
            "text": "(Event|undefined)  The original DOM event object. Normally present when the event is a Ractive DOM event. May be  undefined  on custom events or events from event plugins.", 
            "title": "nodeinfo.original"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfopop", 
            "text": "See  ractive.pop() .", 
            "title": "nodeinfo.pop()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfopush", 
            "text": "See  ractive.push() .", 
            "title": "nodeinfo.push()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinforactive", 
            "text": "(Ractive)  This property holds a reference to the Ractive instance that controls the node represented by this info object.", 
            "title": "nodeinfo.ractive"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinforesolve", 
            "text": "Resolves the given  keypath  to a full keypath. If a Ractive instance is supplied, the resolved path will also account for any mappings defined for the instance.  Syntax   nodeinfo.resolve([keypath[, ractive]])   Arguments   [keypath] (string) : The  keypath  to resolve.  [ractive] (Ractive) : The instance to resolve the  keypath  against.   Returns   (string) : The resolved keypath.   Examples  // TODO", 
            "title": "nodeinfo.resolve()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinforeverse", 
            "text": "See  ractive.reverse() .", 
            "title": "nodeinfo.reverse()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfoset", 
            "text": "See  ractive.set() .", 
            "title": "nodeinfo.set()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfosetbinding", 
            "text": "Sets the binding of the node represented by this info object to the specified value.  Syntax   nodeinfo.setBinding(value)   Arguments   value (any) . The value to set.   Returns   (Promise)   Examples  // TODO", 
            "title": "nodeinfo.setBinding()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfoshift", 
            "text": "See  ractive.shift() .", 
            "title": "nodeinfo.shift()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfosplice", 
            "text": "See  ractive.splice() .", 
            "title": "nodeinfo.splice()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfosort", 
            "text": "See  ractive.sort() .", 
            "title": "nodeinfo.sort()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfosubtract", 
            "text": "See  ractive.subtract() .", 
            "title": "nodeinfo.subtract()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfotoggle", 
            "text": "See  ractive.toggle() .", 
            "title": "nodeinfo.toggle()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfounlink", 
            "text": "See  ractive.unlink() .", 
            "title": "nodeinfo.unlink()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfounshift", 
            "text": "See  ractive.unshift() .", 
            "title": "nodeinfo.unshift()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfoupdate", 
            "text": "See  ractive.update() .", 
            "title": "nodeinfo.update()"
        }, 
        {
            "location": "/API/Helper Objects/Node Info/#nodeinfoupdatemodel", 
            "text": "See  ractive.updateModel() .", 
            "title": "nodeinfo.updateModel()"
        }, 
        {
            "location": "/API/Helper Objects/Parse/", 
            "text": "Parse\n\n\nThe parse object is an object you receive as the second argument in \nfunction templates\n. This helper object provides you with essential functions to dissect markup before turning over the template for use.\n\n\n\n\np.fromId()\n\n\nRetrieves the template from the DOM \nscript\n tag specified by \nid\n. Make sure to set \ntype='text/ractive'\n on the \nscript\n tag to prevent the browser from running the template as a script.\n\n\nSyntax\n\n\n\n\np.fromId(id)\n\n\n\n\nArguments\n\n\n\n\nid (string)\n: The id of the \nscript\n tag containing the template. The leading \n#\n is optional.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The template inside the specified element.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\np.isParsed()\n\n\nTest whether the supplied template is already parsed and is in its object form.\n\n\nSyntax\n\n\n\n\np.isParsed(template)\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The template, either in its string form or object form.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: Returns \ntrue\n if the template is already parsed, \nfalse\n if otherwise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\np.parse()\n\n\nParses the template using \nRactive.parse()\n. Full Ractive runtime must be loaded.\n\n\nSyntax\n\n\n\n\np.parse(template[, parseOptions])\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The template in its string form or object form.\n\n\n[parseOptions] (Object)\n: Template parser options. See \nRactive.parse()\n for all available options. If \nparseOptions\n is not specified, it defaults to those of the current instance.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: The parsed template.\n\n\n\n\nExamples\n\n\n// TODO", 
            "title": "Parse"
        }, 
        {
            "location": "/API/Helper Objects/Parse/#parse", 
            "text": "The parse object is an object you receive as the second argument in  function templates . This helper object provides you with essential functions to dissect markup before turning over the template for use.", 
            "title": "Parse"
        }, 
        {
            "location": "/API/Helper Objects/Parse/#pfromid", 
            "text": "Retrieves the template from the DOM  script  tag specified by  id . Make sure to set  type='text/ractive'  on the  script  tag to prevent the browser from running the template as a script.  Syntax   p.fromId(id)   Arguments   id (string) : The id of the  script  tag containing the template. The leading  #  is optional.   Returns   (string) : The template inside the specified element.   Examples  // TODO", 
            "title": "p.fromId()"
        }, 
        {
            "location": "/API/Helper Objects/Parse/#pisparsed", 
            "text": "Test whether the supplied template is already parsed and is in its object form.  Syntax   p.isParsed(template)   Arguments   template (string|Object) : The template, either in its string form or object form.   Returns   (boolean) : Returns  true  if the template is already parsed,  false  if otherwise.   Examples  // TODO", 
            "title": "p.isParsed()"
        }, 
        {
            "location": "/API/Helper Objects/Parse/#pparse", 
            "text": "Parses the template using  Ractive.parse() . Full Ractive runtime must be loaded.  Syntax   p.parse(template[, parseOptions])   Arguments   template (string|Object) : The template in its string form or object form.  [parseOptions] (Object) : Template parser options. See  Ractive.parse()  for all available options. If  parseOptions  is not specified, it defaults to those of the current instance.   Returns   (Object) : The parsed template.   Examples  // TODO", 
            "title": "p.parse()"
        }, 
        {
            "location": "/API/Helper Objects/Transition/", 
            "text": "Transition\n\n\nThe transition object is an object you receive when writing transitions. It has a few properties and methods designed to make creating transitions easier.\n\n\n\n\nt.animateStyle()\n\n\nAnimates CSS properties to a certain value.\n\n\nSyntax\n\n\n\n\nt.animateStyle(prop, value, options[, complete])\n\n\nt.animateStyle(props, options[, complete])\n\n\n\n\nArguments\n\n\n\n\nprops (Object)\n: A map of animation properties and values.\n\n\nprop (string)\n: The style to animate.\n\n\nvalue (any)\n: The value to animate it to.\n\n\noptions (Object)\n: Animation options.\n\n\nduration (number)\n: The duration of the animation.\n\n\neasing (string)\n: The easing function of the animation.\n\n\ndelay (number)\n: The number of milliseconds before the animation starts.\n\n\n[complete] (Function)\n: A function that is executed when the animation completes, or immediately if no changes were made.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the animation completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.complete()\n\n\nSignals Ractive that the transition is complete.\n\n\nSyntax\n\n\n\n\nt.complete[noReset])\n\n\n\n\nArguments\n\n\n\n\n[noReset] (boolean)\n: If \ntrue\n, \nt.resetStyle()\n is not called. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.getStyle()\n\n\nRetrieve a CSS property value from \nt.node\n.\n\n\nSyntax\n\n\n\n\nt.getStyle(prop)\n\n\n\n\nArguments\n\n\n\n\nprop (string)\n: An unprefixed CSS property either in camelCase or kebab-case.\n\n\nprop (Array)\n: An array of CSS properties.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The value of the specified style property.\n\n\n(Object)\n: A key-value pair of properties and their respective values.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.isIntro\n\n\n(boolean)\n\n\nShould be self-explanatory...\n\n\n\n\nt.name\n\n\n(string)\n\n\nThe name of the transition.\n\n\n\n\nt.node\n\n\n(Node)\n\n\nThe node that's entering or leaving the DOM\n\n\n\n\nt.processParams()\n\n\nBuilds a map of parameters whose values are taken from the provided arguments. When used with a single number or string argument, serves as a shorthand for creating a map with a \nduration\n property.\n\n\nSyntax\n\n\n\n\nt.processParams(params[, defaults])\n\n\n\n\nArguments\n\n\n\n\nparams (number)\n: Numeric shorthand for the \nduration\n parameter. Expressed in milliseconds.\n\n\nparams (string)\n: String shorthand for the \nduration\n parameter. Valid values are:\n\n\n\"fast\" - 200ms\n\n\n\"slow\" - 600ms\n\n\nAny other string - 400ms\n\n\n\n\n\n\nparams (Object)\n: A map of parameters and their values.\n\n\n[defaults] (Object)\n: A map of parameters and their default values.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: A map of parameters and their values.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\n\n\nt.setStyle()\n\n\nSets a CSS property on \nt.node\n to a value.\n\n\nSyntax\n\n\n\n\nt.setStyle(prop, value)\n\n\nt.setStyle(props)\n\n\n\n\nArguments\n\n\n\n\nprop (string)\n: An unprefixed CSS property either in camelCase or kebab-case.\n\n\nprops (Object)\n: A key-value pair of CSS properties and their respective values.\n\n\nvalue (string)\n: A valid value for the specified CSS property.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO", 
            "title": "Transition"
        }, 
        {
            "location": "/API/Helper Objects/Transition/#transition", 
            "text": "The transition object is an object you receive when writing transitions. It has a few properties and methods designed to make creating transitions easier.", 
            "title": "Transition"
        }, 
        {
            "location": "/API/Helper Objects/Transition/#tanimatestyle", 
            "text": "Animates CSS properties to a certain value.  Syntax   t.animateStyle(prop, value, options[, complete])  t.animateStyle(props, options[, complete])   Arguments   props (Object) : A map of animation properties and values.  prop (string) : The style to animate.  value (any) : The value to animate it to.  options (Object) : Animation options.  duration (number) : The duration of the animation.  easing (string) : The easing function of the animation.  delay (number) : The number of milliseconds before the animation starts.  [complete] (Function) : A function that is executed when the animation completes, or immediately if no changes were made.   Returns   (Promise) : A promise that resolves when the animation completes.   Examples  // TODO", 
            "title": "t.animateStyle()"
        }, 
        {
            "location": "/API/Helper Objects/Transition/#tcomplete", 
            "text": "Signals Ractive that the transition is complete.  Syntax   t.complete[noReset])   Arguments   [noReset] (boolean) : If  true ,  t.resetStyle()  is not called. Defaults to  false .   Returns   (undefined)   Examples  // TODO", 
            "title": "t.complete()"
        }, 
        {
            "location": "/API/Helper Objects/Transition/#tgetstyle", 
            "text": "Retrieve a CSS property value from  t.node .  Syntax   t.getStyle(prop)   Arguments   prop (string) : An unprefixed CSS property either in camelCase or kebab-case.  prop (Array) : An array of CSS properties.   Returns   (string) : The value of the specified style property.  (Object) : A key-value pair of properties and their respective values.   Examples  // TODO", 
            "title": "t.getStyle()"
        }, 
        {
            "location": "/API/Helper Objects/Transition/#tisintro", 
            "text": "(boolean)  Should be self-explanatory...", 
            "title": "t.isIntro"
        }, 
        {
            "location": "/API/Helper Objects/Transition/#tname", 
            "text": "(string)  The name of the transition.", 
            "title": "t.name"
        }, 
        {
            "location": "/API/Helper Objects/Transition/#tnode", 
            "text": "(Node)  The node that's entering or leaving the DOM", 
            "title": "t.node"
        }, 
        {
            "location": "/API/Helper Objects/Transition/#tprocessparams", 
            "text": "Builds a map of parameters whose values are taken from the provided arguments. When used with a single number or string argument, serves as a shorthand for creating a map with a  duration  property.  Syntax   t.processParams(params[, defaults])   Arguments   params (number) : Numeric shorthand for the  duration  parameter. Expressed in milliseconds.  params (string) : String shorthand for the  duration  parameter. Valid values are:  \"fast\" - 200ms  \"slow\" - 600ms  Any other string - 400ms    params (Object) : A map of parameters and their values.  [defaults] (Object) : A map of parameters and their default values.   Returns   (Object) : A map of parameters and their values.   Examples  // TODO", 
            "title": "t.processParams()"
        }, 
        {
            "location": "/API/Helper Objects/Transition/#tsetstyle", 
            "text": "Sets a CSS property on  t.node  to a value.  Syntax   t.setStyle(prop, value)  t.setStyle(props)   Arguments   prop (string) : An unprefixed CSS property either in camelCase or kebab-case.  props (Object) : A key-value pair of CSS properties and their respective values.  value (string) : A valid value for the specified CSS property.   Returns   (undefined)   Examples  // TODO", 
            "title": "t.setStyle()"
        }, 
        {
            "location": "/API/Errors/", 
            "text": "Errors\n\n\nThis document outlines all the debug messages that you may encounter in Ractive. You probably ended up on this page by clicking on the link on one of the error messages.\n\n\nLOG_CONSTANT_HERE\n\n\nLog summary message here\n\n\nExplanation here.\n\n\nANOTHER_LOG_CONSTANT_HERE\n\n\nLog summary message here\n\n\nExplanation here.\n\n\nYET_ANOTHER_LOG_CONSTANT_HERE\n\n\nLog summary message here\n\n\nExplanation here.", 
            "title": "Errors"
        }, 
        {
            "location": "/API/Errors/#errors", 
            "text": "This document outlines all the debug messages that you may encounter in Ractive. You probably ended up on this page by clicking on the link on one of the error messages.", 
            "title": "Errors"
        }, 
        {
            "location": "/API/Errors/#log_constant_here", 
            "text": "Log summary message here  Explanation here.", 
            "title": "LOG_CONSTANT_HERE"
        }, 
        {
            "location": "/API/Errors/#another_log_constant_here", 
            "text": "Log summary message here  Explanation here.", 
            "title": "ANOTHER_LOG_CONSTANT_HERE"
        }, 
        {
            "location": "/API/Errors/#yet_another_log_constant_here", 
            "text": "Log summary message here  Explanation here.", 
            "title": "YET_ANOTHER_LOG_CONSTANT_HERE"
        }, 
        {
            "location": "/Integrations/Plugins/", 
            "text": "Plugins\n\n\nIt may not be apparent but Ractive is actually built with extreme extensibility in mind. Plugins allow you to augment Ractive with extra functionality. Whether you're a JavaScript developer, an interface designer or just trying to get away from your framework overlords, Ractive can accomodate one and all.\n\n\nAdaptors\n\n\nInterface with different backends.\n\n\n\n\nBackbone\n\n\nBacon.js\n\n\nModella\n by \n@staygrimm\n\n\nPromises\n by \n@lluchs\n\n\nPromise-alt\n by \n@rstacruz\n\n\nRxJS\n\n\nRactive\n by \n@rstacruz\n - Synchronise several Ractive instances.\n\n\nss-ractive\n by Robert Hall \n@arxpoetica\n - Ractive Template Engine wrapper for \nSocketStream\n.\n\n\n\n\nComponents\n\n\nEncapsulate functionality behind the guise of a custom element.\n\n\n\n\nRactive-Require\n\n\nCodeMirror\n\n\nBootstrap\n\n\nDatatable\n\n\nSelect\n - A \nselect\n replacement component.\n\n\nStepper\n - A numeric stepper component.\n\n\n\n\nDecorators\n\n\nAugment the DOM with more functionality.\n\n\n\n\nChosen\n by \n@rahulcs\n (\n@kalcifer\n)\n\n\nminmaxwidth\n by \n@cfenzo\n\n\nSelect2\n by \n@sandermarechal\n (\n@Prezent\n)\n\n\nSortable\n\n\nTooltip\n\n\n\n\nEasings\n\n\nCustom animation progressions.\n\n\nEvents\n\n\nAugment the DOM with custom events beyond those supported by the browser.\n\n\n\n\nDrag and Drop (HTML5)\n by \n@Nijikokun\n\n\nDrag and Drop (non-HTML5)\n by \n@smallhadroncollider\n\n\nDrag and Drop Sortable List\n by \n@Nijikokun\n\n\nResize\n by \n@smallhadroncollider\n\n\nHover\n\n\nKeys\n\n\nMousewheel\n\n\nTap\n\n\nTouch\n by \n@rstacruz\n\n\nTyping\n by \n@svapreddy\n\n\nViewport\n by \n@svapreddy\n\n\n\n\nPartials\n\n\nReusable pieces of markup.\n\n\nTransitions\n\n\nApply custom animation.\n\n\n\n\nFade\n\n\nFly\n\n\nScale\n by \n@1N50MN14\n\n\nSlide\n\n\nTypewriter\n\n\n\n\nAnd so much more!\n\n\nDue to the nature of how easy it is to write and distribute plugins as well as how diverse the distribution channels are, we cannot possibly know what other Ractive plugins exist in the wild.\n\n\nTo discover more, try searching your favorite package manager, search engine, or code hosting service for the keyword \"ractive\". I guarantee you'll be surprised.\n\n\nNote: Like any other open-source project, these plugins may not have been maintained for a while. Should bugs arise, we highly encourage reporting the issue to relevant parties so that it can be addressed.", 
            "title": "Plugins"
        }, 
        {
            "location": "/Integrations/Plugins/#plugins", 
            "text": "It may not be apparent but Ractive is actually built with extreme extensibility in mind. Plugins allow you to augment Ractive with extra functionality. Whether you're a JavaScript developer, an interface designer or just trying to get away from your framework overlords, Ractive can accomodate one and all.", 
            "title": "Plugins"
        }, 
        {
            "location": "/Integrations/Plugins/#adaptors", 
            "text": "Interface with different backends.   Backbone  Bacon.js  Modella  by  @staygrimm  Promises  by  @lluchs  Promise-alt  by  @rstacruz  RxJS  Ractive  by  @rstacruz  - Synchronise several Ractive instances.  ss-ractive  by Robert Hall  @arxpoetica  - Ractive Template Engine wrapper for  SocketStream .", 
            "title": "Adaptors"
        }, 
        {
            "location": "/Integrations/Plugins/#components", 
            "text": "Encapsulate functionality behind the guise of a custom element.   Ractive-Require  CodeMirror  Bootstrap  Datatable  Select  - A  select  replacement component.  Stepper  - A numeric stepper component.", 
            "title": "Components"
        }, 
        {
            "location": "/Integrations/Plugins/#decorators", 
            "text": "Augment the DOM with more functionality.   Chosen  by  @rahulcs  ( @kalcifer )  minmaxwidth  by  @cfenzo  Select2  by  @sandermarechal  ( @Prezent )  Sortable  Tooltip", 
            "title": "Decorators"
        }, 
        {
            "location": "/Integrations/Plugins/#easings", 
            "text": "Custom animation progressions.", 
            "title": "Easings"
        }, 
        {
            "location": "/Integrations/Plugins/#events", 
            "text": "Augment the DOM with custom events beyond those supported by the browser.   Drag and Drop (HTML5)  by  @Nijikokun  Drag and Drop (non-HTML5)  by  @smallhadroncollider  Drag and Drop Sortable List  by  @Nijikokun  Resize  by  @smallhadroncollider  Hover  Keys  Mousewheel  Tap  Touch  by  @rstacruz  Typing  by  @svapreddy  Viewport  by  @svapreddy", 
            "title": "Events"
        }, 
        {
            "location": "/Integrations/Plugins/#partials", 
            "text": "Reusable pieces of markup.", 
            "title": "Partials"
        }, 
        {
            "location": "/Integrations/Plugins/#transitions", 
            "text": "Apply custom animation.   Fade  Fly  Scale  by  @1N50MN14  Slide  Typewriter", 
            "title": "Transitions"
        }, 
        {
            "location": "/Integrations/Plugins/#and-so-much-more", 
            "text": "Due to the nature of how easy it is to write and distribute plugins as well as how diverse the distribution channels are, we cannot possibly know what other Ractive plugins exist in the wild.  To discover more, try searching your favorite package manager, search engine, or code hosting service for the keyword \"ractive\". I guarantee you'll be surprised.  Note: Like any other open-source project, these plugins may not have been maintained for a while. Should bugs arise, we highly encourage reporting the issue to relevant parties so that it can be addressed.", 
            "title": "And so much more!"
        }, 
        {
            "location": "/Integrations/Tools/", 
            "text": "Tools\n\n\nBrowserify\n\n\nBrowserify\n is a way of using \nnode-style\n requires in the browser, bundling your scripts into a single file for efficient deployment.\n\n\nThere are three Browserify transforms available that you can use for Ractive.js:\n\n\n\n\nRactivate\n, a transform that will pre-parse templates. Contributed by \njrajav\n. \n(Github repository)\n\n\nRactify\n, a transform that will pre-compile components. Contributed by \nmarcello3d\n. \n(Github repository)\n\n\nRactiveify\n, a transform that will pre-compile components with support for compiling embedded scripts and style tags (with Livescript, CoffeeScript, Sass, etc). Inspired by ractify. Contributed by \nnorcalli\n. \n(Github repository)\n\n\n\n\nA \nstarter project\n is available for using Ractivate with \ngulp.js\n build system.\n\n\nUsing plugins with Ractive and Browserify\n\n\nPlugins\n typically include a Universal Module Definition (UMD) block that, in a node.js or Browserify environment, calls \nrequire('ractive')\n. If you want to be explicit about \nwhich\n version of Ractive gets loaded, you can do it when you configure browserify like so:\n\n\nbrowserify.require('./my-copy-of-ractive.js', { expose: 'ractive' });\n\n\n\n\nRequireJS\n\n\nPsst! Looking for the \nRactive + RequireJS sample application\n?\n\n\nIf Ractive detects that you're using an \nAMD\n module loader (in other words, if \ntypeof define !== 'undefined' \n define.amd\n) such as \nRequireJS\n, it will register itself as an AMD module rather than as a browser global.\n\n\nYou'd then use Ractive the same as you'd use any other module, such as in this (contrived, oversimple) example:\n\n\n// define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'jquery', 'Ractive' ], function ( $, Ractive ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // load our template with jQuery AJAX\n      $.ajax( 'templates/main.html' ).then( function ( mainTemplate ) {\n\n        // render our main view\n        this.mainView = new Ractive({\n          el: 'container',\n          template: mainTemplate\n        });\n      });\n    }\n  };\n\n  return app;\n\n});\n\n\n\n\nLoading templates without AJAX\n\n\nWe can do one better than that. Rather than stuffing our code full of asynchronous logic, we can use AMD to do the donkey work for us.\n\n\nInclude the \nRequireJS text loader plugin\n in the root of your project (or whatever you've specified as the RequireJS \nbaseUrl\n) - you can now do this (note we no longer require jQuery):\n\n\n// define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'text!templates/main.html' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});\n\n\n\n\nBut we can do even better. If you use the \nRactive RequireJS loader plugin\n, it will pre-parse the template for us. We'll see in a moment why that's useful.\n\n\nPut the plugin in the same folder as the text loader plugin (which the Ractive plugin depends on). Note that we can omit the \n'.html'\n file extension:\n\n\n// define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'rv!templates/main' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});\n\n\n\n\nUsing the RequireJS optimiser\n\n\nYou might wonder why the third example is better than the second - after all, we've basically just added another middleman, right?\n\n\nThe answer is that you can now use the \nRequireJS optimiser\n to parse your template as part of your build process. The optimiser converts your project into a single minified file, which in most cases makes your app much quicker to load for the end user (because the browser only needs to make one HTTP request, and the total file size is reduced).\n\n\nBy pre-parsing templates, we save browsers having to do it, which shaves a few milliseconds off at render time.\n\n\nSo you get the best of both worlds - your templates stay neatly organised in their own files, where you can easily edit them, and the user gets the best possible experience.\n\n\nIf you're \nreally\n anal about performance, you can tweak things further still. We don't need the loader plugins any more (because everything has been inlined), but they're still there in our optimised file. We can instruct the optimiser to 'stub them out', saving ourselves a few precious bytes. In your optimiser config, add the following option:\n\n\n({\n    stubModules: [ 'rv', 'text' ]\n})\n\n\n\n\n(This assumes you're using a \nbuild.js\n file, or a build system like Grunt. If you're using the optimiser on the command line it will be different - consult the \ndocumentation\n for more info.)\n\n\nGetting to grips with AMD and RequireJS can be tricky at first, but it's worth the effort. Good luck!\n\n\nYeoman\n\n\nYeoman\n is a tool for scaffolding webapps. \nJorge Colindres\n has created \ngenerator-ractive\n, a Yeoman generator to quickly set up a Ractive application.\n\n\nRollup\n\n\nTODO\n\n\nBabel\n\n\nTODO", 
            "title": "Tools"
        }, 
        {
            "location": "/Integrations/Tools/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/Integrations/Tools/#browserify", 
            "text": "Browserify  is a way of using  node-style  requires in the browser, bundling your scripts into a single file for efficient deployment.  There are three Browserify transforms available that you can use for Ractive.js:   Ractivate , a transform that will pre-parse templates. Contributed by  jrajav .  (Github repository)  Ractify , a transform that will pre-compile components. Contributed by  marcello3d .  (Github repository)  Ractiveify , a transform that will pre-compile components with support for compiling embedded scripts and style tags (with Livescript, CoffeeScript, Sass, etc). Inspired by ractify. Contributed by  norcalli .  (Github repository)   A  starter project  is available for using Ractivate with  gulp.js  build system.", 
            "title": "Browserify"
        }, 
        {
            "location": "/Integrations/Tools/#using-plugins-with-ractive-and-browserify", 
            "text": "Plugins  typically include a Universal Module Definition (UMD) block that, in a node.js or Browserify environment, calls  require('ractive') . If you want to be explicit about  which  version of Ractive gets loaded, you can do it when you configure browserify like so:  browserify.require('./my-copy-of-ractive.js', { expose: 'ractive' });", 
            "title": "Using plugins with Ractive and Browserify"
        }, 
        {
            "location": "/Integrations/Tools/#requirejs", 
            "text": "Psst! Looking for the  Ractive + RequireJS sample application ?  If Ractive detects that you're using an  AMD  module loader (in other words, if  typeof define !== 'undefined'   define.amd ) such as  RequireJS , it will register itself as an AMD module rather than as a browser global.  You'd then use Ractive the same as you'd use any other module, such as in this (contrived, oversimple) example:  // define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'jquery', 'Ractive' ], function ( $, Ractive ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // load our template with jQuery AJAX\n      $.ajax( 'templates/main.html' ).then( function ( mainTemplate ) {\n\n        // render our main view\n        this.mainView = new Ractive({\n          el: 'container',\n          template: mainTemplate\n        });\n      });\n    }\n  };\n\n  return app;\n\n});", 
            "title": "RequireJS"
        }, 
        {
            "location": "/Integrations/Tools/#loading-templates-without-ajax", 
            "text": "We can do one better than that. Rather than stuffing our code full of asynchronous logic, we can use AMD to do the donkey work for us.  Include the  RequireJS text loader plugin  in the root of your project (or whatever you've specified as the RequireJS  baseUrl ) - you can now do this (note we no longer require jQuery):  // define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'text!templates/main.html' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});  But we can do even better. If you use the  Ractive RequireJS loader plugin , it will pre-parse the template for us. We'll see in a moment why that's useful.  Put the plugin in the same folder as the text loader plugin (which the Ractive plugin depends on). Note that we can omit the  '.html'  file extension:  // define our main application, with an 'init' method to call when\n// the DOM is ready etc\ndefine([ 'Ractive', 'rv!templates/main' ], function ( Ractive, mainTemplate ) {\n\n  'use strict';\n\n  var app = {\n    init: function () {\n\n      // render our main view\n      this.mainView = new Ractive({\n        el: 'container',\n        template: mainTemplate\n      });\n    }\n  };\n\n  return app;\n\n});", 
            "title": "Loading templates without AJAX"
        }, 
        {
            "location": "/Integrations/Tools/#using-the-requirejs-optimiser", 
            "text": "You might wonder why the third example is better than the second - after all, we've basically just added another middleman, right?  The answer is that you can now use the  RequireJS optimiser  to parse your template as part of your build process. The optimiser converts your project into a single minified file, which in most cases makes your app much quicker to load for the end user (because the browser only needs to make one HTTP request, and the total file size is reduced).  By pre-parsing templates, we save browsers having to do it, which shaves a few milliseconds off at render time.  So you get the best of both worlds - your templates stay neatly organised in their own files, where you can easily edit them, and the user gets the best possible experience.  If you're  really  anal about performance, you can tweak things further still. We don't need the loader plugins any more (because everything has been inlined), but they're still there in our optimised file. We can instruct the optimiser to 'stub them out', saving ourselves a few precious bytes. In your optimiser config, add the following option:  ({\n    stubModules: [ 'rv', 'text' ]\n})  (This assumes you're using a  build.js  file, or a build system like Grunt. If you're using the optimiser on the command line it will be different - consult the  documentation  for more info.)  Getting to grips with AMD and RequireJS can be tricky at first, but it's worth the effort. Good luck!", 
            "title": "Using the RequireJS optimiser"
        }, 
        {
            "location": "/Integrations/Tools/#yeoman", 
            "text": "Yeoman  is a tool for scaffolding webapps.  Jorge Colindres  has created  generator-ractive , a Yeoman generator to quickly set up a Ractive application.", 
            "title": "Yeoman"
        }, 
        {
            "location": "/Integrations/Tools/#rollup", 
            "text": "TODO", 
            "title": "Rollup"
        }, 
        {
            "location": "/Integrations/Tools/#babel", 
            "text": "TODO", 
            "title": "Babel"
        }, 
        {
            "location": "/Integrations/Libraries/", 
            "text": "Libraries\n\n\nWe heard that you love your framework so much, we put Ractive in your framework!\n\n\njQuery Mobile\n\n\nSergio Castillo\n has made a jQuery mobile plugin, which you can \nsee in action on this JSFiddle\n.", 
            "title": "Libraries"
        }, 
        {
            "location": "/Integrations/Libraries/#libraries", 
            "text": "We heard that you love your framework so much, we put Ractive in your framework!", 
            "title": "Libraries"
        }, 
        {
            "location": "/Integrations/Libraries/#jquery-mobile", 
            "text": "Sergio Castillo  has made a jQuery mobile plugin, which you can  see in action on this JSFiddle .", 
            "title": "jQuery Mobile"
        }, 
        {
            "location": "/Extend/Adaptors/", 
            "text": "Adaptors\n\n\nIn some cases you want to write your UI in Ractive but have a custom back-end manage the data. \nAdaptors\n allow you to teach Ractive how to talk to those custom data sources without having to change the way you write Ractive or having to write a lot of connector code up front.\n\n\nWriting\n\n\nRactive.adaptors.myAdaptor = {\n  filter: function ( object, keypath, ractive ) {\n    // return `true` if a particular object is of the type we want to adapt.\n  },\n  wrap: function ( ractive, object, keypath, prefixer ) {\n    // Setup\n    return {\n      teardown: function(){\n        // Code executed on teardown.\n      },\n      get: function(){\n        // Returns POJO version of your data backend.\n      },\n      set: function(property, value){\n        // Data setter for POJO property keypaths.\n      },\n      reset: function(value){\n        // Data setter for POJO keypath.\n      }\n    }\n  }\n};\n\n\n\n\nAdaptors are simply the translation and sync layers between your custom data source and Ractive instances. The basic principle of an \nadaptor\n is as follows:\n\n\n\n\nProvides an POJO version of your data source to Ractive.\n\n\nCaptures data changes on your data source and mirror them to the data in Ractive.\n\n\nCaptures data changes on the data in Ractive and mirror them to the data source.\n\n\n\n\nWhether it's a third-party data modelling library, a RESTful service, a socket server, browser storage, or whatever, as long as all of the three can be done, it can be adapted.\n\n\nfilter\n is a function that gets called to check if \nobject\n needs to use an adaptor.\n\n\nobject\n is the data source to adapt.\n\n\nkeypath\n is the \nkeypath\n to \nobject\n.\n\n\nractive\n is the ractive instance that is currently using the adaptor.\n\n\nwrap\n is a function that gets called to set up the \nadaptor\n on \nobject\n.\n\n\nprefixer\n is a helper function that accepts an object and automatically prefixes \nkeypath\n to the object's keys.\n\n\nget\n is a function that gets called when Ractive needs the adapted representation of the \nobject\n.\n\n\nset\n is a function that is called when \nractive.set()\n updates a \nkeypath\n to a property of the adapted data. This function allows you to update the same property on \nobject\n.\n\n\nproperty\n is the \nkeypath\n to the property being updated, relative to \nkeypath\n.\n\n\nvalue\n is the value being passed into \nractive.set()\n.\n\n\nreset\n is a function that is called when \nractive.set()\n updates a \nkeypath\n to the adapted data. This function allows you to either update \nobject\n or tear down the adaptor.\n\n\nteardown\n is a function called when the \nadaptor\n is being removed. This function allows you to do cleanup work on anything that was done during the \nadaptor\n setup.\n\n\nAdaptors\n only adapt one level\n\n\nAn \nadaptor\n only adapts an object's immediate properties. Updating nested data via Ractive or via the data source will not update the other.\n\n\nNo built-in infinite loop detection\n\n\nThere is no built-in mechanism for avoiding infinite loops. If your \nadaptor\n calls \nractive.set()\n on adapted data, which in turn will call the adaptor's \nset()\n method, which may directly or indirectly trigger another \nractive.set()\n on the same adapted data, a stack overflow error might occur.\n\n\nThis isn't a problem with primitive values since Ractive doesn't bother calling \nset()\n if a value hasn't changed. But with objects and arrays, there's no easy and performant way to tell if the contents have changed. So \nset()\n gets called \nin case something changed\n rather than \nbecause something changed\n.\n\n\nDifferent for every back-end\n\n\nThe \nadaptor\n structure only provides you with the means to talk to and listen from a custom back-end. It does not impose any rules on how to write an \nadaptor\n for a certain back-end. For instance, an \nadaptor\n for a constructor-based object may be written differently from an \nadaptor\n meant to interact with a socket server.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register adaptors:\n\n\nGlobally, via the \nRactive.adaptors\n static property.\n\n\nRactive.adaptors.myAdaptor = myAdaptor;\n\n\n\n\nPer component, via the component's \nadaptors\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  adaptors: {\n    myAdaptor: myAdaptor\n  }\n});\n\n\n\n\nPer instance, via the instance's \nadaptors\n initialization property.\n\n\nconst ractive = new Ractive({\n  adaptors: {\n    myAdaptor: myAdaptor\n  }\n});\n\n\n\n\nUsing\n\n\nIn order to use an adaptor, you must tell the component or an instance to use it using the \nadapt\n \ninitialization option\n.\n\n\nconst ractive = new Ractive({\n  adapt: [ 'myAdaptor', myAdaptor ]\n})\n\n\n\n\nExamples\n\n\nIn the following example, we have a \nBox\n constructor that uses accessors to get and set its \nwidth\n and \nheight\n properties. Since an instance of \nBox\n will have no publicly visible properties, Ractive cannot bind to them directly.\n\n\nfunction Box(width, height){\n  var _width = width;\n  var _height = height;\n\n  this.getWidth = function(){ return _width; };\n  this.setWidth = function(width){ _width = width; };\n  this.getHeight = function(){ return _height; };\n  this.setHeight = function(height){ _height = height };\n}\n\n\n\n\nIn order for Ractive to properly use a \nBox\n instance, we build an \nadaptor\n for \nBox\n.\n\n\nRactive.adaptors.boxAdaptor = {\n  filter: function ( object ) {\n    // Checks if the piece of data is an instance of Box.\n    return object instanceof Box;\n  },\n  wrap: function ( ractive, box, keypath, prefixer ) {\n\n    // We keep a reference to the original functions before monkey-patching.\n    const setWidth = box.setWidth;\n    const setHeight = box.setHeight;\n\n    // Use ractive.set on the the adapted data whenever the setters are used.\n    box.setWidth = function(width){\n      ractive.set(prefixer({\n        width: width\n      }));\n    };\n\n    box.setHeight = function(height){\n      ractive.set(prefixer({\n        height: height\n      }));\n    };\n\n    return {\n      // Return a POJO representation of an instance of Box.\n      get: function(){\n        return {\n          width: box.getWidth(),\n          height: box.getHeight();\n        };\n      },\n      // Update the adapted object's properties\n      set: function(property, value){\n        if(property === 'width') setWidth.call(box, value);\n        if(property === 'height') setHeight.call(box, value);\n      },\n      // Update the adapted object.\n      reset: function(data){\n        // We don't adapt non-objects. And if the new data is an instance of Box\n        // there's a high chance that its a new instance. In either case, we\n        // need to tear down this adapter and have Ractive set it up again if\n        // necessary.\n        if(typeof data !== 'object' || data instanceof Box) return false;\n\n        // Otherwise, we just parse through the data and update the existing box\n        // instance.\n        if(data.width !== undefined) setWidth.call(box, data.width);\n        if(data.height !== undefined) setHeight.call(box, data.height);\n      },\n      // Delete the monkey-patched methods.\n      teardown: function(){\n        delete box.setWidth;\n        delete box.setHeight;\n      }\n    };\n  }\n};\n\n\n\n\nThen we use \nboxAdaptor\n on an instance. The data can now be treated like regular Ractive data. Updates done directly on \nbox\n will reflect on Ractive. Any changes via Ractive will reflect on \nbox\n.\n\n\nconst ractive = new Ractive({\n  el: 'body',\n  // Tell the instance we'll be using boxAdaptor\n  adapt: [ 'boxAdaptor' ],\n  // We write Ractive like normal.\n  template: `\n    \ndiv\nBox is {{ box.width }}x{{ box.height }}\n/div\n,\n    \ndiv\ninput type=\ntext\n value=\n{{ box.width }}\n/div\n\n    \ndiv\ninput type=\ntext\n value=\n{{ box.height }}\n/div\n\n  `\n});\n\nconst box = new Box(3, 4);\n\n// Set the Box instance as if it were a POJO.\nractive.set('box', box);\n\n// Both box instance and box object will have 7 width and 11 height and will\n// be rendered in the UI accordingly.\nbox.setWidth(7);\nractive.set('box.height', 11);", 
            "title": "Adaptors"
        }, 
        {
            "location": "/Extend/Adaptors/#adaptors", 
            "text": "In some cases you want to write your UI in Ractive but have a custom back-end manage the data.  Adaptors  allow you to teach Ractive how to talk to those custom data sources without having to change the way you write Ractive or having to write a lot of connector code up front.", 
            "title": "Adaptors"
        }, 
        {
            "location": "/Extend/Adaptors/#writing", 
            "text": "Ractive.adaptors.myAdaptor = {\n  filter: function ( object, keypath, ractive ) {\n    // return `true` if a particular object is of the type we want to adapt.\n  },\n  wrap: function ( ractive, object, keypath, prefixer ) {\n    // Setup\n    return {\n      teardown: function(){\n        // Code executed on teardown.\n      },\n      get: function(){\n        // Returns POJO version of your data backend.\n      },\n      set: function(property, value){\n        // Data setter for POJO property keypaths.\n      },\n      reset: function(value){\n        // Data setter for POJO keypath.\n      }\n    }\n  }\n};  Adaptors are simply the translation and sync layers between your custom data source and Ractive instances. The basic principle of an  adaptor  is as follows:   Provides an POJO version of your data source to Ractive.  Captures data changes on your data source and mirror them to the data in Ractive.  Captures data changes on the data in Ractive and mirror them to the data source.   Whether it's a third-party data modelling library, a RESTful service, a socket server, browser storage, or whatever, as long as all of the three can be done, it can be adapted.  filter  is a function that gets called to check if  object  needs to use an adaptor.  object  is the data source to adapt.  keypath  is the  keypath  to  object .  ractive  is the ractive instance that is currently using the adaptor.  wrap  is a function that gets called to set up the  adaptor  on  object .  prefixer  is a helper function that accepts an object and automatically prefixes  keypath  to the object's keys.  get  is a function that gets called when Ractive needs the adapted representation of the  object .  set  is a function that is called when  ractive.set()  updates a  keypath  to a property of the adapted data. This function allows you to update the same property on  object .  property  is the  keypath  to the property being updated, relative to  keypath .  value  is the value being passed into  ractive.set() .  reset  is a function that is called when  ractive.set()  updates a  keypath  to the adapted data. This function allows you to either update  object  or tear down the adaptor.  teardown  is a function called when the  adaptor  is being removed. This function allows you to do cleanup work on anything that was done during the  adaptor  setup.", 
            "title": "Writing"
        }, 
        {
            "location": "/Extend/Adaptors/#adaptors-only-adapt-one-level", 
            "text": "An  adaptor  only adapts an object's immediate properties. Updating nested data via Ractive or via the data source will not update the other.", 
            "title": "Adaptors only adapt one level"
        }, 
        {
            "location": "/Extend/Adaptors/#no-built-in-infinite-loop-detection", 
            "text": "There is no built-in mechanism for avoiding infinite loops. If your  adaptor  calls  ractive.set()  on adapted data, which in turn will call the adaptor's  set()  method, which may directly or indirectly trigger another  ractive.set()  on the same adapted data, a stack overflow error might occur.  This isn't a problem with primitive values since Ractive doesn't bother calling  set()  if a value hasn't changed. But with objects and arrays, there's no easy and performant way to tell if the contents have changed. So  set()  gets called  in case something changed  rather than  because something changed .", 
            "title": "No built-in infinite loop detection"
        }, 
        {
            "location": "/Extend/Adaptors/#different-for-every-back-end", 
            "text": "The  adaptor  structure only provides you with the means to talk to and listen from a custom back-end. It does not impose any rules on how to write an  adaptor  for a certain back-end. For instance, an  adaptor  for a constructor-based object may be written differently from an  adaptor  meant to interact with a socket server.", 
            "title": "Different for every back-end"
        }, 
        {
            "location": "/Extend/Adaptors/#registering", 
            "text": "Like other plugins, there's 3 ways you can register adaptors:", 
            "title": "Registering"
        }, 
        {
            "location": "/Extend/Adaptors/#globally-via-the-ractiveadaptors-static-property", 
            "text": "Ractive.adaptors.myAdaptor = myAdaptor;", 
            "title": "Globally, via the Ractive.adaptors static property."
        }, 
        {
            "location": "/Extend/Adaptors/#per-component-via-the-components-adaptors-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  adaptors: {\n    myAdaptor: myAdaptor\n  }\n});", 
            "title": "Per component, via the component's adaptors initialization property."
        }, 
        {
            "location": "/Extend/Adaptors/#per-instance-via-the-instances-adaptors-initialization-property", 
            "text": "const ractive = new Ractive({\n  adaptors: {\n    myAdaptor: myAdaptor\n  }\n});", 
            "title": "Per instance, via the instance's adaptors initialization property."
        }, 
        {
            "location": "/Extend/Adaptors/#using", 
            "text": "In order to use an adaptor, you must tell the component or an instance to use it using the  adapt   initialization option .  const ractive = new Ractive({\n  adapt: [ 'myAdaptor', myAdaptor ]\n})", 
            "title": "Using"
        }, 
        {
            "location": "/Extend/Adaptors/#examples", 
            "text": "In the following example, we have a  Box  constructor that uses accessors to get and set its  width  and  height  properties. Since an instance of  Box  will have no publicly visible properties, Ractive cannot bind to them directly.  function Box(width, height){\n  var _width = width;\n  var _height = height;\n\n  this.getWidth = function(){ return _width; };\n  this.setWidth = function(width){ _width = width; };\n  this.getHeight = function(){ return _height; };\n  this.setHeight = function(height){ _height = height };\n}  In order for Ractive to properly use a  Box  instance, we build an  adaptor  for  Box .  Ractive.adaptors.boxAdaptor = {\n  filter: function ( object ) {\n    // Checks if the piece of data is an instance of Box.\n    return object instanceof Box;\n  },\n  wrap: function ( ractive, box, keypath, prefixer ) {\n\n    // We keep a reference to the original functions before monkey-patching.\n    const setWidth = box.setWidth;\n    const setHeight = box.setHeight;\n\n    // Use ractive.set on the the adapted data whenever the setters are used.\n    box.setWidth = function(width){\n      ractive.set(prefixer({\n        width: width\n      }));\n    };\n\n    box.setHeight = function(height){\n      ractive.set(prefixer({\n        height: height\n      }));\n    };\n\n    return {\n      // Return a POJO representation of an instance of Box.\n      get: function(){\n        return {\n          width: box.getWidth(),\n          height: box.getHeight();\n        };\n      },\n      // Update the adapted object's properties\n      set: function(property, value){\n        if(property === 'width') setWidth.call(box, value);\n        if(property === 'height') setHeight.call(box, value);\n      },\n      // Update the adapted object.\n      reset: function(data){\n        // We don't adapt non-objects. And if the new data is an instance of Box\n        // there's a high chance that its a new instance. In either case, we\n        // need to tear down this adapter and have Ractive set it up again if\n        // necessary.\n        if(typeof data !== 'object' || data instanceof Box) return false;\n\n        // Otherwise, we just parse through the data and update the existing box\n        // instance.\n        if(data.width !== undefined) setWidth.call(box, data.width);\n        if(data.height !== undefined) setHeight.call(box, data.height);\n      },\n      // Delete the monkey-patched methods.\n      teardown: function(){\n        delete box.setWidth;\n        delete box.setHeight;\n      }\n    };\n  }\n};  Then we use  boxAdaptor  on an instance. The data can now be treated like regular Ractive data. Updates done directly on  box  will reflect on Ractive. Any changes via Ractive will reflect on  box .  const ractive = new Ractive({\n  el: 'body',\n  // Tell the instance we'll be using boxAdaptor\n  adapt: [ 'boxAdaptor' ],\n  // We write Ractive like normal.\n  template: `\n     div Box is {{ box.width }}x{{ box.height }} /div ,\n     div input type= text  value= {{ box.width }} /div \n     div input type= text  value= {{ box.height }} /div \n  `\n});\n\nconst box = new Box(3, 4);\n\n// Set the Box instance as if it were a POJO.\nractive.set('box', box);\n\n// Both box instance and box object will have 7 width and 11 height and will\n// be rendered in the UI accordingly.\nbox.setWidth(7);\nractive.set('box.height', 11);", 
            "title": "Examples"
        }, 
        {
            "location": "/Extend/Components/", 
            "text": "Components\n\n\nIn many situations, you want to encapsulate behaviour and markup into a single reusable \ncomponent\n, which can be dropped into Ractive applications.\n\n\nWriting\n\n\nRactive.components.MyComponent = Ractive.extend({ ... });\n\n\n\n\nComponents are simply custom-configured \"subclasses\" of Ractive (analogous, but technically incorrect). This configuration sets it apart from regular instances in that you can define different behavior based on what \ninitialization options\n are defined on it.\n\n\nTo declare components, one simply extends Ractive using \nRactive.extend()\n. In turn, these subclasses can also be subclassed.\n\n\n// A regular instance of Ractive\nconst ractive = new Ractive({ ... });\n\n// A subclass of Ractive\nconst MyComponent = Ractive.extend({ ... });\n\n// A subclass of our subclass\nconst MyComponentSubclass = MyComponent.extend({ ... });\n\n\n\n\nAs with other inheritance mechanisms, overriding a method essentially replace the method. In order to call the parent of the overridden method, simply call \nractive._super()\n.\n\n\nconst MyComponentSubclass = MyComponent.extend({\n  // Overrides the oninit of MyComponent\n  oninit: function(...args){\n    // Call MyComponent's oninit\n    this._super(...args);\n  }\n});\n\n\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register components:\n\n\nGlobally, via the \nRactive.components\n static property:\n\n\n// Available to all instances of Ractive.\nRactive.components.MyComponent = Ractive.extend({ ... });\n\n\n\n\nPer component, via the component's \ncomponents\n initialization property.\n\n\n// Only available for instances of AnotherComponent.\nconst AnotherComponent = Ractive.extend({\n  components: {\n    MyComponent\n  }\n});\n\n\n\n\nPer instance, via the instance's \ncomponents\n initialization property.\n\n\n// Only available to this specific instance.\nconst ractive = new Ractive({\n  components: {\n    MyComponent\n  }\n});\n\n\n\n\nUsing\n\n\nComponents are simply subclasses of Ractive, which means the are instatiable via the \nnew\n keyword.\n\n\nconst ractive = new MyComponent({ ... });\n\n\n\n\nBut where components really shine is when they're used on templates. They are written like \ncustom elements\n. Each custom element notation represents one instance of the component.\n\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n    \ndiv\n\n      \nMyComponent /\n \n!-- One instance of MyComponent --\n\n      \nMyComponent /\n \n!-- Another instance of MyComponent --\n\n      \nMyComponent /\n \n!-- Yet another instance of MyComponent --\n\n    \n/div\n\n  `\n});\n\n\n\n\nThe component's tag name depends on the name used upon registration. The same component can be registered more than once using different names.\n\n\nconst MyComponent = Ractive.extend({...});\nRactive.components.MyComponent = MyComponent;\nRactive.components.MyComponentOtherName = MyComponent;\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n    \ndiv\n\n      \nMyComponent /\n          \n!-- Using MyComponent --\n\n      \nMyComponentOtherName /\n \n!-- Using MyComponent's other name --\n\n    \n/div\n\n  `\n});\n\n\n\n\nIsolation\n\n\nA unique behavior in Ractive is \nthe resolver's ability to \"climb\" up the data context\n if a \nkeypath\n doesn't resolve in the current data context. It takes this behavior a step further and also climbs to the parent component's data context if it does not resolve on the child data context.\n\n\nIn the following example, the instance of \nChildComponent\n prints \"Hello World!\" even when the data is set on the outer-most instance. The resolver \"climbed up\" to the outer-most instance to resolve \nmessage\n.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    Child: {{ message }}\n  `\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.set('message', 'Hello World!');\n\n\n\n\nWhile this is handy, sometimes you will want full component isolation and only resolve references within the component. The \nisolated\ninitialization option\ndoes just that. When set to \ntrue\n, the resolver stops resolution up to the component with \nisolated:true\n.\n\n\nIn the following example, the instance of \nChildComponent\n will not print anything due to the \nisolated: true\n set on it.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  isolated: true,\n  template: `\n    Child: {{ message }}\n  `\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.set('message', 'Hello World!');\n\n\n\n\nBinding\n\n\nBindings connect a piece of data on the parent instance to data on the child instance. Changes on one side will reflect on the other. The syntax is similar to how one would write HTML element attributes.\n\n\nThe following example binds \ntext\n on the instance to \nMyComponent\n's \nmessage\n. Updates on the value of \ntext\n will update \nmessage\n. Typing on the \ninput\n bound to \nmessage\n will update \ntext\n.\n\n\nRactive.components.MyComponent = Ractive.extend({\n  template: `\n    \ninput type=\ntext\n value=\n{{ message }}\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: '\nMyComponent message=\n{{ text }} /\n'\n});\n\nractive.set('text', 'Hello World!');\n\n\n\n\nData context\n\n\nEach component instance comes with its own data context so that parameters don't pollute the primary data. Bindings will still update across both contexts.\n\n\nIn the following example, we have an instance that has \nname\n and \ncolors\n. We bind bind \ncolors\n and set an \noption1\n to \nMyComponent\n. Upon inspection, the data context is just as described. \nname\n doesn't cross over to \nMyComponent\n nor does \noption1\n cross over to the instance. However, since we bound \ncolors\n to \nshades\n, updating one updates the other.\n\n\nRactive.components.MyComponent = Ractive.extend({});\n\nconst ractive = new Ractive({\n  template: `\n    \nMyComponent shades='{{colors}}' option1='A' /\n\n  `,\n  data: {\n    name: 'Colors',\n    colors: ['red', 'blue', 'yellow']\n  }\n});\n\nconst widget = ractive.findComponent('MyComponent')\n\nractive.get(); // {\ncolors\n:[\nred\n,\nblue\n,\nyellow\n], \nname\n:\nColors\n}\nwidget.get();  // {\nshades\n:[\nred\n,\nblue\n,\nyellow\n], \noption1\n:\nA\n}\n\nractive.set('colors.1', 'green');\n\nractive.get(); // {\ncolors\n:[\nred\n,\ngreen\n,\nyellow\n], \nname\n:\nColors\n}\nwidget.get();  // {\nshades\n:[\nred\n,\ngreen\n,\nyellow\n], \noption1\n:\nA\n}\n\nwidget.set('colors.2', 'blue');\n\nractive.get(); // {\ncolors\n:[\nred\n,\ngreen\n,\nblue\n], \nname\n:\nColors\n}\nwidget.get();  // {\nshades\n:[\nred\n,\ngreen\n,\nblue\n], \noption1\n:\nA\n}\n\n\n\n\nEvents\n\n\nComponents can fire events like regular elements using \nractive.fire()\n. Enclosing instances can listen for events using the same \non-*\n event notation. There are two ways to handle component events.\n\n\nThe first is using the method call syntax which is similar to how you would write inline JavaScript.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent on-boringeventname=\n@this.greetz()\n /\n\n  `,\n  greetz: function(){\n    console.log('Hello World');\n  }\n});\n\n\n\n\nThe other is using the proxy event syntax. It's called \"proxy\" in the sense that the component event is assigned another name which is actually listened to by the enclosing instance.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent on-boringeventname=\ngreetz\n /\n\n  `,\n  oninit: function(){\n    this.on('greetz', function(){\n      console.log('Hello World')\n    });\n  }\n});\n\n\n\n\nBubbling\n\n\nEvents fired from within components will also \"bubble\" up the component hierarchy with their component name attached as a namespace. This can be used to avoid having to re-fire events at each level in a deeply nested component hierarchy.\n\n\nIn the following example, the event from the \nChildComponent\n instance can be listened to from the outer Ractive instance.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('Hello World!');\n});\n\n\n\n\nTo listen to the same event name regardless of the component that's firing the event, an \n*\n can be used as the namespace.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('*.sameevent', function(){\n  console.log('This will fire two times, one for each component.');\n});\n\n\n\n\nThe namespace is not bound to the component definition but rather to the name of the component.\n\n\nIn the following example, \nChildComponent\n is registered onto the \nParentComponent\n as \nChildComponent1\n and \nChildComponent2\n. Even with the same definition, there will be two namespaces, one for \nChildComponent1\n and \nChildComponent2\n.\n\n\nconst ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent1 /\n\n    \nChildComponent2 /\n\n  `,\n  components: {\n    ChildComponent1: ChildComponent,\n    ChildComponent2: ChildComponent\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent1.sameevent', function(){\n  console.log('Same component definition, instance with name 1.');\n});\n\nractive.on('ChildComponent2.sameevent', function(){\n  console.log('Same component definition, instance with name 2.');\n});\n\n\n\n\nStopping propagation\n\n\nIn order to stop bubbling, simply return \nfalse\n from an event handler. Should the event come from a DOM event, it will call \nstopPropagation()\n and \npreventDefault()\n automatically.\n\n\nIn the following example, \nParentComponent\n listens to \nchildevent\n and returns false to in its handler. This prevents the outer instance from receiving the event.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent /\n\n  `,\n  oninit: function(){\n    this.on('ChildComponent.childevent', function(){\n      return false;\n    });\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('This will not fire');\n});\n\n\n\n\nEvents that have been assigned a handler using \non-*\n will also prevent the bubbling of the original event. A proxy event is assigned, will bubble in its place.\n\n\nIn the following example, \nchildevent1\n is prevented by not assigning a handle. \nchildevent2\n is prevented by having a proxy event \nchildevent2proxy\n assigned to it, which will also bubble in its place. \nchildevent3\n is prevented by a method call.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv\n/div\n\n  `,\n  oncomplete: function() {\n    this.fire('childevent1');\n    this.fire('childevent2');\n    this.fire('childevent3');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n    \nChildComponent on-childevent1=\n on-childevent2=\nchildevent2proxy\n on-childevent3=\n@this.parentMethod()\n /\n\n  `,\n  oninit: function() {\n    this.on('childevent2proxy', function() {\n      console.log('childevent2 handled and will no longer bubble.');\n      console.log('childevent2proxy will take its place.');\n    });\n  },\n  parentMethod: function(){\n    console.log('childevent3 handled by a method')\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nParentComponent /\n\n  `\n});\n\nractive.on('ChildComponent.childevent1', function() {\n  console.log('childevent1 stopped');\n});\n\nractive.on('ChildComponent.childevent2', function() {\n  console.log('childevent2 stopped');\n});\n\nractive.on('ParentComponent.childevent2proxy', function() {\n  console.log('childevent2proxy fired');\n});\n\nractive.on('ChildComponent.childevent3', function() {\n  console.log('childevent3 fired');\n});\n\n\n\n\n{{\ncontent}}\n\n\n{{\ncontent}}\n renders the inner HTML in the context of the component. Partials, components, and any other valid template items can be used as inner HTML. \n{{\ncontent}}\n can be thought of as a special partial.\n\n\nIn the following example, the result will print \"Lorem Ipsum\" because the inner HTML's context is the component, whose \nmessage\n is set to \"Lorem Ipsum\".\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n{{\ncontent}}\n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        \ndiv class=\ninner-content\n{{ message }}\n/div\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\nPartials defined in the inner HTML can be used to override partials defined on the component. This can be used to allow easy customization of each instance using partials.\n\n\nIn the following example, \nChildComponent\n's default template for the \nmessageWrapper\n partial is a \nstrong\n. Upon use of \nChildComponent\n in the instance, it overrides the partial to use an \nem\n instead.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  partials: {\n    messageWrapper: '\nstrong\n{{message}}\n/strong\n'\n  },\n  template: `\n    \ndiv class=\nchild-component\n{{\ncontent}}\n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n\n        {{#partial messageWrapper}}\nem\n{{message}}\n/em\n{{/}}\n\n        \ndiv class=\ninner-content\n\n          {{\n messageWrapper }}\n        \n/div\n\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\n{{yield}}\n\n\n{{yield}}\n renders the inner HTML in the context of the parent component. Partials, components, and any other valid template items can be used as inner HTML. A common use case of \n{{yield}}\n is to provide wrapper markup transparently.\n\n\nIn the following example, the result will print \"Hello World!\" because the inner HTML's context is the parent component's, whose \nmessage\n is \"Hello World!\".\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n{{ yield }}\n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        \ndiv class=\ninner-content\n{{ message }}\n/div\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\nYields can also be customized using named yields. Instead of rendering with the component's inner HTML, a named yield will look for a partial in the inner HTML with the same name and use that to render the yielded content.\n\n\nIn the following example, \nChildComponent\n renders the yield content 3 times. However, the last two yields will look for \nitalicYield\n and \nboldYield\n partials in the inner HTML and use that to render. What's rendered is three \"Hello World!\"s in regular, italic and bold.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n\n      {{ yield }}\n      {{ yield italicYield }}\n      {{ yield boldYield }}\n    \n/div\n\n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        {{#partial italicYield }}\nem\n{{message}}\n/em\n{{/}}\n        {{#partial boldYield }}\nstrong\n{{message}}\n/strong\n{{/}}\n        {{message}}\n      \n/ChildComponent\n\n    \n/div\n\n  `\n});\n\n\n\n\nExamples", 
            "title": "Components"
        }, 
        {
            "location": "/Extend/Components/#components", 
            "text": "In many situations, you want to encapsulate behaviour and markup into a single reusable  component , which can be dropped into Ractive applications.", 
            "title": "Components"
        }, 
        {
            "location": "/Extend/Components/#writing", 
            "text": "Ractive.components.MyComponent = Ractive.extend({ ... });  Components are simply custom-configured \"subclasses\" of Ractive (analogous, but technically incorrect). This configuration sets it apart from regular instances in that you can define different behavior based on what  initialization options  are defined on it.  To declare components, one simply extends Ractive using  Ractive.extend() . In turn, these subclasses can also be subclassed.  // A regular instance of Ractive\nconst ractive = new Ractive({ ... });\n\n// A subclass of Ractive\nconst MyComponent = Ractive.extend({ ... });\n\n// A subclass of our subclass\nconst MyComponentSubclass = MyComponent.extend({ ... });  As with other inheritance mechanisms, overriding a method essentially replace the method. In order to call the parent of the overridden method, simply call  ractive._super() .  const MyComponentSubclass = MyComponent.extend({\n  // Overrides the oninit of MyComponent\n  oninit: function(...args){\n    // Call MyComponent's oninit\n    this._super(...args);\n  }\n});", 
            "title": "Writing"
        }, 
        {
            "location": "/Extend/Components/#registering", 
            "text": "Like other plugins, there's 3 ways you can register components:", 
            "title": "Registering"
        }, 
        {
            "location": "/Extend/Components/#globally-via-the-ractivecomponents-static-property", 
            "text": "// Available to all instances of Ractive.\nRactive.components.MyComponent = Ractive.extend({ ... });", 
            "title": "Globally, via the Ractive.components static property:"
        }, 
        {
            "location": "/Extend/Components/#per-component-via-the-components-components-initialization-property", 
            "text": "// Only available for instances of AnotherComponent.\nconst AnotherComponent = Ractive.extend({\n  components: {\n    MyComponent\n  }\n});", 
            "title": "Per component, via the component's components initialization property."
        }, 
        {
            "location": "/Extend/Components/#per-instance-via-the-instances-components-initialization-property", 
            "text": "// Only available to this specific instance.\nconst ractive = new Ractive({\n  components: {\n    MyComponent\n  }\n});", 
            "title": "Per instance, via the instance's components initialization property."
        }, 
        {
            "location": "/Extend/Components/#using", 
            "text": "Components are simply subclasses of Ractive, which means the are instatiable via the  new  keyword.  const ractive = new MyComponent({ ... });  But where components really shine is when they're used on templates. They are written like  custom elements . Each custom element notation represents one instance of the component.  const AnotherComponent = Ractive.extend({\n  template: `\n     div \n       MyComponent /   !-- One instance of MyComponent -- \n       MyComponent /   !-- Another instance of MyComponent -- \n       MyComponent /   !-- Yet another instance of MyComponent -- \n     /div \n  `\n});  The component's tag name depends on the name used upon registration. The same component can be registered more than once using different names.  const MyComponent = Ractive.extend({...});\nRactive.components.MyComponent = MyComponent;\nRactive.components.MyComponentOtherName = MyComponent;\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n     div \n       MyComponent /            !-- Using MyComponent -- \n       MyComponentOtherName /   !-- Using MyComponent's other name -- \n     /div \n  `\n});", 
            "title": "Using"
        }, 
        {
            "location": "/Extend/Components/#isolation", 
            "text": "A unique behavior in Ractive is  the resolver's ability to \"climb\" up the data context  if a  keypath  doesn't resolve in the current data context. It takes this behavior a step further and also climbs to the parent component's data context if it does not resolve on the child data context.  In the following example, the instance of  ChildComponent  prints \"Hello World!\" even when the data is set on the outer-most instance. The resolver \"climbed up\" to the outer-most instance to resolve  message .  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n    Child: {{ message }}\n  `\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.set('message', 'Hello World!');  While this is handy, sometimes you will want full component isolation and only resolve references within the component. The  isolated initialization option does just that. When set to  true , the resolver stops resolution up to the component with  isolated:true .  In the following example, the instance of  ChildComponent  will not print anything due to the  isolated: true  set on it.  Ractive.components.ChildComponent = Ractive.extend({\n  isolated: true,\n  template: `\n    Child: {{ message }}\n  `\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.set('message', 'Hello World!');", 
            "title": "Isolation"
        }, 
        {
            "location": "/Extend/Components/#binding", 
            "text": "Bindings connect a piece of data on the parent instance to data on the child instance. Changes on one side will reflect on the other. The syntax is similar to how one would write HTML element attributes.  The following example binds  text  on the instance to  MyComponent 's  message . Updates on the value of  text  will update  message . Typing on the  input  bound to  message  will update  text .  Ractive.components.MyComponent = Ractive.extend({\n  template: `\n     input type= text  value= {{ message }} \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: ' MyComponent message= {{ text }} / '\n});\n\nractive.set('text', 'Hello World!');", 
            "title": "Binding"
        }, 
        {
            "location": "/Extend/Components/#data-context", 
            "text": "Each component instance comes with its own data context so that parameters don't pollute the primary data. Bindings will still update across both contexts.  In the following example, we have an instance that has  name  and  colors . We bind bind  colors  and set an  option1  to  MyComponent . Upon inspection, the data context is just as described.  name  doesn't cross over to  MyComponent  nor does  option1  cross over to the instance. However, since we bound  colors  to  shades , updating one updates the other.  Ractive.components.MyComponent = Ractive.extend({});\n\nconst ractive = new Ractive({\n  template: `\n     MyComponent shades='{{colors}}' option1='A' / \n  `,\n  data: {\n    name: 'Colors',\n    colors: ['red', 'blue', 'yellow']\n  }\n});\n\nconst widget = ractive.findComponent('MyComponent')\n\nractive.get(); // { colors :[ red , blue , yellow ],  name : Colors }\nwidget.get();  // { shades :[ red , blue , yellow ],  option1 : A }\n\nractive.set('colors.1', 'green');\n\nractive.get(); // { colors :[ red , green , yellow ],  name : Colors }\nwidget.get();  // { shades :[ red , green , yellow ],  option1 : A }\n\nwidget.set('colors.2', 'blue');\n\nractive.get(); // { colors :[ red , green , blue ],  name : Colors }\nwidget.get();  // { shades :[ red , green , blue ],  option1 : A }", 
            "title": "Data context"
        }, 
        {
            "location": "/Extend/Components/#events", 
            "text": "Components can fire events like regular elements using  ractive.fire() . Enclosing instances can listen for events using the same  on-*  event notation. There are two ways to handle component events.  The first is using the method call syntax which is similar to how you would write inline JavaScript.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent on-boringeventname= @this.greetz()  / \n  `,\n  greetz: function(){\n    console.log('Hello World');\n  }\n});  The other is using the proxy event syntax. It's called \"proxy\" in the sense that the component event is assigned another name which is actually listened to by the enclosing instance.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('boringeventname');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent on-boringeventname= greetz  / \n  `,\n  oninit: function(){\n    this.on('greetz', function(){\n      console.log('Hello World')\n    });\n  }\n});", 
            "title": "Events"
        }, 
        {
            "location": "/Extend/Components/#bubbling", 
            "text": "Events fired from within components will also \"bubble\" up the component hierarchy with their component name attached as a namespace. This can be used to avoid having to re-fire events at each level in a deeply nested component hierarchy.  In the following example, the event from the  ChildComponent  instance can be listened to from the outer Ractive instance.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('Hello World!');\n});  To listen to the same event name regardless of the component that's firing the event, an  *  can be used as the namespace.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('*.sameevent', function(){\n  console.log('This will fire two times, one for each component.');\n});  The namespace is not bound to the component definition but rather to the name of the component.  In the following example,  ChildComponent  is registered onto the  ParentComponent  as  ChildComponent1  and  ChildComponent2 . Even with the same definition, there will be two namespaces, one for  ChildComponent1  and  ChildComponent2 .  const ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('sameevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent1 / \n     ChildComponent2 / \n  `,\n  components: {\n    ChildComponent1: ChildComponent,\n    ChildComponent2: ChildComponent\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent1.sameevent', function(){\n  console.log('Same component definition, instance with name 1.');\n});\n\nractive.on('ChildComponent2.sameevent', function(){\n  console.log('Same component definition, instance with name 2.');\n});", 
            "title": "Bubbling"
        }, 
        {
            "location": "/Extend/Components/#stopping-propagation", 
            "text": "In order to stop bubbling, simply return  false  from an event handler. Should the event come from a DOM event, it will call  stopPropagation()  and  preventDefault()  automatically.  In the following example,  ParentComponent  listens to  childevent  and returns false to in its handler. This prevents the outer instance from receiving the event.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function(){\n    this.fire('childevent');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent / \n  `,\n  oninit: function(){\n    this.on('ChildComponent.childevent', function(){\n      return false;\n    });\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent.childevent', function(){\n  console.log('This will not fire');\n});  Events that have been assigned a handler using  on-*  will also prevent the bubbling of the original event. A proxy event is assigned, will bubble in its place.  In the following example,  childevent1  is prevented by not assigning a handle.  childevent2  is prevented by having a proxy event  childevent2proxy  assigned to it, which will also bubble in its place.  childevent3  is prevented by a method call.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div /div \n  `,\n  oncomplete: function() {\n    this.fire('childevent1');\n    this.fire('childevent2');\n    this.fire('childevent3');\n  }\n});\n\nRactive.components.ParentComponent = Ractive.extend({\n  template: `\n     ChildComponent on-childevent1=  on-childevent2= childevent2proxy  on-childevent3= @this.parentMethod()  / \n  `,\n  oninit: function() {\n    this.on('childevent2proxy', function() {\n      console.log('childevent2 handled and will no longer bubble.');\n      console.log('childevent2proxy will take its place.');\n    });\n  },\n  parentMethod: function(){\n    console.log('childevent3 handled by a method')\n  }\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     ParentComponent / \n  `\n});\n\nractive.on('ChildComponent.childevent1', function() {\n  console.log('childevent1 stopped');\n});\n\nractive.on('ChildComponent.childevent2', function() {\n  console.log('childevent2 stopped');\n});\n\nractive.on('ParentComponent.childevent2proxy', function() {\n  console.log('childevent2proxy fired');\n});\n\nractive.on('ChildComponent.childevent3', function() {\n  console.log('childevent3 fired');\n});", 
            "title": "Stopping propagation"
        }, 
        {
            "location": "/Extend/Components/#content", 
            "text": "{{ content}}  renders the inner HTML in the context of the component. Partials, components, and any other valid template items can be used as inner HTML.  {{ content}}  can be thought of as a special partial.  In the following example, the result will print \"Lorem Ipsum\" because the inner HTML's context is the component, whose  message  is set to \"Lorem Ipsum\".  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component {{ content}} /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n         div class= inner-content {{ message }} /div \n       /ChildComponent \n     /div \n  `\n});  Partials defined in the inner HTML can be used to override partials defined on the component. This can be used to allow easy customization of each instance using partials.  In the following example,  ChildComponent 's default template for the  messageWrapper  partial is a  strong . Upon use of  ChildComponent  in the instance, it overrides the partial to use an  em  instead.  Ractive.components.ChildComponent = Ractive.extend({\n  partials: {\n    messageWrapper: ' strong {{message}} /strong '\n  },\n  template: `\n     div class= child-component {{ content}} /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n\n        {{#partial messageWrapper}} em {{message}} /em {{/}}\n\n         div class= inner-content \n          {{  messageWrapper }}\n         /div \n\n       /ChildComponent \n     /div \n  `\n});", 
            "title": "{{&gt;content}}"
        }, 
        {
            "location": "/Extend/Components/#yield", 
            "text": "{{yield}}  renders the inner HTML in the context of the parent component. Partials, components, and any other valid template items can be used as inner HTML. A common use case of  {{yield}}  is to provide wrapper markup transparently.  In the following example, the result will print \"Hello World!\" because the inner HTML's context is the parent component's, whose  message  is \"Hello World!\".  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component {{ yield }} /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n         div class= inner-content {{ message }} /div \n       /ChildComponent \n     /div \n  `\n});  Yields can also be customized using named yields. Instead of rendering with the component's inner HTML, a named yield will look for a partial in the inner HTML with the same name and use that to render the yielded content.  In the following example,  ChildComponent  renders the yield content 3 times. However, the last two yields will look for  italicYield  and  boldYield  partials in the inner HTML and use that to render. What's rendered is three \"Hello World!\"s in regular, italic and bold.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component \n      {{ yield }}\n      {{ yield italicYield }}\n      {{ yield boldYield }}\n     /div \n  `\n});\n\nconst ractive = new Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n        {{#partial italicYield }} em {{message}} /em {{/}}\n        {{#partial boldYield }} strong {{message}} /strong {{/}}\n        {{message}}\n       /ChildComponent \n     /div \n  `\n});", 
            "title": "{{yield}}"
        }, 
        {
            "location": "/Extend/Components/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/Extend/Decorators/", 
            "text": "Decorators\n\n\nA decorator is a simple way to add behaviour to a node when it is rendered, or to augment it in some way. Decorators are a good way to integrate DOM manipulation libraries with Ractive, such as \njQuery UI\n or \nBootstrap\n.\n\n\nWriting\n\n\nfunction MyDecorator(node[, ...args]) {\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    },\n    update: function([...args]){\n      // Update code\n    }\n  };\n};\n\n\n\n\nDecorators are simply functions that are called upon to setup the decorator once Ractive detects its use. It takes a \nnode\n argument and returns an object with a \nteardown\n and \nupdate\n property.\n\n\nnode\n is the element to which the decorator is applied to.\n\n\nargs\n are optional arguments provided by the decorator directive.\n\n\nteardown\n is a function that gets called when the decorator is torn down.\n\n\nupdate\n is an optional function that gets called when the arguments update.\n\n\nAny updates to the arguments will call the decorator's \nteardown\n and run the decorator function again, essentially setting up the decorator again. If an \nupdate\n function is provided on the return object, that will be called instead of the \nteardown\n and setup function.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register decorators:\n\n\nGlobally, via the \nRactive.decorators\n static property.\n\n\nRactive.decorators.mydecorator = MyDecorator;\n\n\n\n\nPer component, via the component's \ndecorators\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  decorators: {\n    mydecorator: MyDecorator\n  }\n});\n\n\n\n\nPer instance, via the instance's \ndecorators\n initialization property.\n\n\nconst ractive = new Ractive({\n  decorators: {\n    mydecorator: MyDecorator\n  }\n});\n\n\n\n\nUsing\n\n\nYou can invoke one or more decorators on your elements by using a decorator directive. Arguments are optional. Argument-less decorators can simply use the directive without value. Decorators with arguments take a comma-separated set of expressions that resolve to the element's context.\n\n\n!-- without arguments --\n\n\ndiv as-mydecorator\n...\n/div\n\n\n\n!-- with arguments --\n\n\ndiv as-mydecorator=\narg1, .some.other.arg2, 10 * @index\n as-somethingElseToo\n...\n/div\n\n\n\n\n\nExamples\n\n\nThe following example builds a decorator that updates the time.\n\n\nRactive.decorators.timer = function(node, time) {\n  node.innerHTML = 'Hello World!';\n\n  return {\n    teardown: function() {\n      node.innerHTML = '';\n    },\n    update: function(time) {\n      node.innerHTML = time;\n    }\n  }\n};\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n    \nspan as-timer=\ntime\n/span\n\n  `,\n  data: {\n    time: 0\n  }\n});\n\nsetInterval(function() {\n  ractive.set('time', Date.now())\n}, 1000);", 
            "title": "Decorators"
        }, 
        {
            "location": "/Extend/Decorators/#decorators", 
            "text": "A decorator is a simple way to add behaviour to a node when it is rendered, or to augment it in some way. Decorators are a good way to integrate DOM manipulation libraries with Ractive, such as  jQuery UI  or  Bootstrap .", 
            "title": "Decorators"
        }, 
        {
            "location": "/Extend/Decorators/#writing", 
            "text": "function MyDecorator(node[, ...args]) {\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    },\n    update: function([...args]){\n      // Update code\n    }\n  };\n};  Decorators are simply functions that are called upon to setup the decorator once Ractive detects its use. It takes a  node  argument and returns an object with a  teardown  and  update  property.  node  is the element to which the decorator is applied to.  args  are optional arguments provided by the decorator directive.  teardown  is a function that gets called when the decorator is torn down.  update  is an optional function that gets called when the arguments update.  Any updates to the arguments will call the decorator's  teardown  and run the decorator function again, essentially setting up the decorator again. If an  update  function is provided on the return object, that will be called instead of the  teardown  and setup function.", 
            "title": "Writing"
        }, 
        {
            "location": "/Extend/Decorators/#registering", 
            "text": "Like other plugins, there's 3 ways you can register decorators:", 
            "title": "Registering"
        }, 
        {
            "location": "/Extend/Decorators/#globally-via-the-ractivedecorators-static-property", 
            "text": "Ractive.decorators.mydecorator = MyDecorator;", 
            "title": "Globally, via the Ractive.decorators static property."
        }, 
        {
            "location": "/Extend/Decorators/#per-component-via-the-components-decorators-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  decorators: {\n    mydecorator: MyDecorator\n  }\n});", 
            "title": "Per component, via the component's decorators initialization property."
        }, 
        {
            "location": "/Extend/Decorators/#per-instance-via-the-instances-decorators-initialization-property", 
            "text": "const ractive = new Ractive({\n  decorators: {\n    mydecorator: MyDecorator\n  }\n});", 
            "title": "Per instance, via the instance's decorators initialization property."
        }, 
        {
            "location": "/Extend/Decorators/#using", 
            "text": "You can invoke one or more decorators on your elements by using a decorator directive. Arguments are optional. Argument-less decorators can simply use the directive without value. Decorators with arguments take a comma-separated set of expressions that resolve to the element's context.  !-- without arguments --  div as-mydecorator ... /div  !-- with arguments --  div as-mydecorator= arg1, .some.other.arg2, 10 * @index  as-somethingElseToo ... /div", 
            "title": "Using"
        }, 
        {
            "location": "/Extend/Decorators/#examples", 
            "text": "The following example builds a decorator that updates the time.  Ractive.decorators.timer = function(node, time) {\n  node.innerHTML = 'Hello World!';\n\n  return {\n    teardown: function() {\n      node.innerHTML = '';\n    },\n    update: function(time) {\n      node.innerHTML = time;\n    }\n  }\n};\n\nconst ractive = new Ractive({\n  el: 'body',\n  template: `\n     span as-timer= time /span \n  `,\n  data: {\n    time: 0\n  }\n});\n\nsetInterval(function() {\n  ractive.set('time', Date.now())\n}, 1000);", 
            "title": "Examples"
        }, 
        {
            "location": "/Extend/Easings/", 
            "text": "Easings\n\n\nEasing functions are used by \nractive.animate\n and some transitions. They describe the animation's progression from start to finish.\n\n\nWriting\n\n\nRactive.easing.MyEasingFunction = function ( x ) {\n  // Calculation\n  return y;\n};\n\n\n\n\nEasing functions are simply functions that accept one argument, a numeric value \nx\n between 0 and 1 representing progress along a timeline. The function must return a numeric \ny\n value to represent its progression.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register an easing function:\n\n\nGlobally via the \nRactive.easing\n static property.\n\n\nRactive.easing.MyEasingFunction = function(){ ... };\n\n\n\n\nPer component via the component's \neasing\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  easing: {\n    MyEasingFunction: function(){ ... }\n  }\n});\n\n\n\n\nPer instance, via the instance's \neasing\n initialization property.\n\n\nconst ractive = new Ractive({\n  easing: {\n    MyEasingFunction: function(){ ... }\n  }\n});\n\n\n\n\nUsing\n\n\nEasing functions don't work alone. They are utilized by \nractive.animate()\n and \nTransitions\n to dictate animations.\n\n\nractive.animate('foo.bar', 1, {\n  easing: 'MyEasingFunction'\n});\n\n\n\n\nExamples\n\n\nHere's an \nelastic\n easing function taken from \ndanro\n's excellent \neasing.js\n library.\n\n\nRactive.easing.elastic = function ( x ) {\n  return -1 * Math.pow(4,-8*x) * Math.sin((x*6-1)*(2*Math.PI)/2) + 1;\n};", 
            "title": "Easings"
        }, 
        {
            "location": "/Extend/Easings/#easings", 
            "text": "Easing functions are used by  ractive.animate  and some transitions. They describe the animation's progression from start to finish.", 
            "title": "Easings"
        }, 
        {
            "location": "/Extend/Easings/#writing", 
            "text": "Ractive.easing.MyEasingFunction = function ( x ) {\n  // Calculation\n  return y;\n};  Easing functions are simply functions that accept one argument, a numeric value  x  between 0 and 1 representing progress along a timeline. The function must return a numeric  y  value to represent its progression.", 
            "title": "Writing"
        }, 
        {
            "location": "/Extend/Easings/#registering", 
            "text": "Like other plugins, there's 3 ways you can register an easing function:", 
            "title": "Registering"
        }, 
        {
            "location": "/Extend/Easings/#globally-via-the-ractiveeasing-static-property", 
            "text": "Ractive.easing.MyEasingFunction = function(){ ... };", 
            "title": "Globally via the Ractive.easing static property."
        }, 
        {
            "location": "/Extend/Easings/#per-component-via-the-components-easing-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  easing: {\n    MyEasingFunction: function(){ ... }\n  }\n});", 
            "title": "Per component via the component's easing initialization property."
        }, 
        {
            "location": "/Extend/Easings/#per-instance-via-the-instances-easing-initialization-property", 
            "text": "const ractive = new Ractive({\n  easing: {\n    MyEasingFunction: function(){ ... }\n  }\n});", 
            "title": "Per instance, via the instance's easing initialization property."
        }, 
        {
            "location": "/Extend/Easings/#using", 
            "text": "Easing functions don't work alone. They are utilized by  ractive.animate()  and  Transitions  to dictate animations.  ractive.animate('foo.bar', 1, {\n  easing: 'MyEasingFunction'\n});", 
            "title": "Using"
        }, 
        {
            "location": "/Extend/Easings/#examples", 
            "text": "Here's an  elastic  easing function taken from  danro 's excellent  easing.js  library.  Ractive.easing.elastic = function ( x ) {\n  return -1 * Math.pow(4,-8*x) * Math.sin((x*6-1)*(2*Math.PI)/2) + 1;\n};", 
            "title": "Examples"
        }, 
        {
            "location": "/Extend/Events/", 
            "text": "Events\n\n\nEvents allow custom-named events on DOM elements. Common use cases for custom DOM events include normalizing cross-browser events, normalizing cross-device events, implementing custom events, and so much more.\n\n\nWriting\n\n\nRactive.events.MyEvent = function(node, fire){\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    }\n  };\n}\n\n\n\n\nEvents are simply functions that are called to set up the event on a DOM element. The event function accepts two arguments: \nnode\n and \nfire\n, and returns an object containing a \nteardown\n property.\n\n\nnode\n is the element to which the event is being applied.\n\n\nfire\n is the function that must be called when the event has taken place. \nfire\n takes a single argument, the event object received by handlers. The minimum requirement for the event object is a \nnode\n property that references DOM node the event is attached to, and an \noriginal\n property which references the native DOM \nevent\n object supplied by the native handler, if available.\n\n\nThe event object will be augmented with \ncontext\n, \nkeypath\n and \nindex\n properties, whose values depend on the data context the node is in. \ncontext\n references the data context that surrounds the node, \nkeypath\n is a string that leads to the current data context and \nindex\n is a number that references the index number of the data, should the data context be in an array.\n\n\nteardown\n is a function that gets called once the element is torn down. This allows the event to clean up after itself.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register events:\n\n\nGlobally, via the \nRactive.events\n static property.\n\n\nRactive.events.myevent = MyEvent;\n\n\n\n\nPer component, via the component's \nevents\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  events: {\n    myevent: MyEvent\n  }\n});\n\n\n\n\nPer instance, via the instance's \nevents\n initialization property.\n\n\nconst ractive = new Ractive({\n  events: {\n    myevent: MyEvent\n  }\n});\n\n\n\n\nUsing\n\n\nEvents use the same \non-*\n attribute syntax as component and DOM events. When Ractive encounters an \non-*\n attribute on a DOM element, it looks for a registered event and applies it on the element. If no matching event name was found, Ractive will think the event name is a native DOM event and will attach one accordingly.\n\n\n// This will apply the \nmyevent\n custom event if one is registered.\n// Otherwise, Ractive will think it's a DOM event. You have been warned!\n\nspan on-myevent=\nfoo()\nClick me!\n/span\n\n\n\n\n\nExamples\n\n\nHere's an example of a \"long press\" event which fires when the mouse is clicked and held for 1 second.\n\n\n// Definition\nRactive.events.longpress = function(node, fire){\n  let timer = null;\n\n  function clearTimer(){\n    if(timer) clearTimeout(timer);\n    timer = null;\n  }\n\n  function mouseDownHandler(event){\n    clearTimer();\n\n    timer = setTimeout(function(){\n      fire({\n        node: node,\n        original: event\n      });\n    }, 1000);\n  }\n\n  function mouseUpHandler(){\n    clearTimer();\n  }\n\n  node.addEventListener('mousedown', mouseDownHandler);\n  node.addEventListener('mouseup', mouseUpHandler);\n\n  return {\n    teardown: function(){\n      node.removeEventListener('mousedown', mouseDownHandler);\n      node.removeEventListener('mouseup', mouseUpHandler);\n    }\n  };\n};\n\n// Usage:\nnew Ractive({\n  el: 'body',\n  template: `\n    \nbutton type=\nbutton\n on-longpress=\n@this.greetz()\nClick Me!\n/button\n\n  `,\n  greetz: function(){\n    console.log('Hello World!');\n  }\n});", 
            "title": "Events"
        }, 
        {
            "location": "/Extend/Events/#events", 
            "text": "Events allow custom-named events on DOM elements. Common use cases for custom DOM events include normalizing cross-browser events, normalizing cross-device events, implementing custom events, and so much more.", 
            "title": "Events"
        }, 
        {
            "location": "/Extend/Events/#writing", 
            "text": "Ractive.events.MyEvent = function(node, fire){\n  // Setup code\n  return {\n    teardown: function(){\n      // Cleanup code\n    }\n  };\n}  Events are simply functions that are called to set up the event on a DOM element. The event function accepts two arguments:  node  and  fire , and returns an object containing a  teardown  property.  node  is the element to which the event is being applied.  fire  is the function that must be called when the event has taken place.  fire  takes a single argument, the event object received by handlers. The minimum requirement for the event object is a  node  property that references DOM node the event is attached to, and an  original  property which references the native DOM  event  object supplied by the native handler, if available.  The event object will be augmented with  context ,  keypath  and  index  properties, whose values depend on the data context the node is in.  context  references the data context that surrounds the node,  keypath  is a string that leads to the current data context and  index  is a number that references the index number of the data, should the data context be in an array.  teardown  is a function that gets called once the element is torn down. This allows the event to clean up after itself.", 
            "title": "Writing"
        }, 
        {
            "location": "/Extend/Events/#registering", 
            "text": "Like other plugins, there's 3 ways you can register events:", 
            "title": "Registering"
        }, 
        {
            "location": "/Extend/Events/#globally-via-the-ractiveevents-static-property", 
            "text": "Ractive.events.myevent = MyEvent;", 
            "title": "Globally, via the Ractive.events static property."
        }, 
        {
            "location": "/Extend/Events/#per-component-via-the-components-events-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  events: {\n    myevent: MyEvent\n  }\n});", 
            "title": "Per component, via the component's events initialization property."
        }, 
        {
            "location": "/Extend/Events/#per-instance-via-the-instances-events-initialization-property", 
            "text": "const ractive = new Ractive({\n  events: {\n    myevent: MyEvent\n  }\n});", 
            "title": "Per instance, via the instance's events initialization property."
        }, 
        {
            "location": "/Extend/Events/#using", 
            "text": "Events use the same  on-*  attribute syntax as component and DOM events. When Ractive encounters an  on-*  attribute on a DOM element, it looks for a registered event and applies it on the element. If no matching event name was found, Ractive will think the event name is a native DOM event and will attach one accordingly.  // This will apply the  myevent  custom event if one is registered.\n// Otherwise, Ractive will think it's a DOM event. You have been warned! span on-myevent= foo() Click me! /span", 
            "title": "Using"
        }, 
        {
            "location": "/Extend/Events/#examples", 
            "text": "Here's an example of a \"long press\" event which fires when the mouse is clicked and held for 1 second.  // Definition\nRactive.events.longpress = function(node, fire){\n  let timer = null;\n\n  function clearTimer(){\n    if(timer) clearTimeout(timer);\n    timer = null;\n  }\n\n  function mouseDownHandler(event){\n    clearTimer();\n\n    timer = setTimeout(function(){\n      fire({\n        node: node,\n        original: event\n      });\n    }, 1000);\n  }\n\n  function mouseUpHandler(){\n    clearTimer();\n  }\n\n  node.addEventListener('mousedown', mouseDownHandler);\n  node.addEventListener('mouseup', mouseUpHandler);\n\n  return {\n    teardown: function(){\n      node.removeEventListener('mousedown', mouseDownHandler);\n      node.removeEventListener('mouseup', mouseUpHandler);\n    }\n  };\n};\n\n// Usage:\nnew Ractive({\n  el: 'body',\n  template: `\n     button type= button  on-longpress= @this.greetz() Click Me! /button \n  `,\n  greetz: function(){\n    console.log('Hello World!');\n  }\n});", 
            "title": "Examples"
        }, 
        {
            "location": "/Extend/Interpolators/", 
            "text": "Interpolators\n\n\nTODO\n\n\nWriting\n\n\nTODO\n\n\nRegistering\n\n\nTODO\n\n\nUsing\n\n\nTODO\n\n\nExamples\n\n\nTODO", 
            "title": "Interpolators"
        }, 
        {
            "location": "/Extend/Interpolators/#interpolators", 
            "text": "TODO", 
            "title": "Interpolators"
        }, 
        {
            "location": "/Extend/Interpolators/#writing", 
            "text": "TODO", 
            "title": "Writing"
        }, 
        {
            "location": "/Extend/Interpolators/#registering", 
            "text": "TODO", 
            "title": "Registering"
        }, 
        {
            "location": "/Extend/Interpolators/#using", 
            "text": "TODO", 
            "title": "Using"
        }, 
        {
            "location": "/Extend/Interpolators/#examples", 
            "text": "TODO", 
            "title": "Examples"
        }, 
        {
            "location": "/Extend/Partials/", 
            "text": "Partials\n\n\nA partial is a template snippet which can be reused in templates or in other partials. They help to keep templates uncluttered, non-repetetive and easy to read.\n\n\nWriting\n\n\nRactive.partials.myPartial = '\n!-- template --\n';\n\n\n\n\nPartials are simply Ractive templates.\n\n\nRegistering\n\n\nUnlike other plugins, partials have more than 3 registration options.\n\n\nGlobally via the \nRactive.partials\n static property.\n\n\nRactive.partials.myPartial = MyPartial;\n\n\n\n\nGlobally, via a non-executing script tag on the current page.\n\n\nscript type=\nractive/template\n id=\nmyPartial\n\n  ...\n\n/script\n\n\n\n\n\ntext/html\n is another good choice for \ntype\n because many editors will highlight the content of the tag as HTML. Anything other than \ntext/javascript\n, \napplication/javascript\n, or no \ntype\n at all will do.\n\n\nPer component, via the component's \npartials\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  events: {\n    myPartial: myPartial\n  }\n});\n\n\n\n\nPer instance, via the instance's \npartials\n initialization property.\n\n\nconst ractive = new Ractive({\n  events: {\n    myPartial: myPartial\n  }\n});\n\n\n\n\nInline, using the \n{{#partial}}\n mustache.\n\n\nAvailability depends on whoever uses the template containing the inline partial, whether it's a component, an instance or another partial. Inline partials are scoped to the nearest tag, be it component or element, and are available to any child of that element.\n\n\n{{#partial myPartial}}\n  ...\n{{/}}\n\n\n\n\nUsing\n\n\nPartials can be used using the \n{{\npartialName}}\n syntax. Partials work where any template would work. It works as if the partial template is manually put into where the partial mustache is positioned.\n\n\n{{#partial myPartial}}\n  \ndiv class=\nmessage\n{{message}}\n/div\n\n{{/}}\n\n\ndiv class=\napp\n\n  {{\nmyPartial}}\n\n/div\n\n\n\n\n\nValid names\n\n\nPartials may be named with the same rules as any other identifier in Ractive or JavaScript, but since there isn't much danger of trying to do math in a partial name, they enjoy relaxed naming requirements that allow otherwise reserved globals and keywords to be used for partial names.\n\n\nPartial names may also contain \n-\n and \n/\n characters as long as they are surrounded by other valid characters e.g. \ntemplates/some-partial-template\n.\n\n\nPartial context\n\n\nBy default, a partial's context is the context of wherever it is positioned.\n\n\nIn the following example, the context of the partial is the current item in the list.\n\n\n{{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{\nmyPartial}}\n{{/}}\n\n\n\n\n\nHowever, partials may be given explicit context using the \n{{\n[name expression] [context expression]}}\n syntax. It's similar to wrapping the partial with a \n{{#with}}\n mustache. Ancestor references, members, object literals, and any other expressions that resolve to an object may be used as a context expression.\n\n\nIn the following example, context of the partial is the current item's \nfoo.bar\n value.\n\n\n{{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{\nmyPartial .foo.bar}}\n{{/}}\n\n\n\n\nExplicit contexts can also be aliased. In the case of plain refereces, it can be used for two-way binding.\n\n\nIn the following example, the current item's \nfoo.bar\n path is aliased with \nitem\n. In the partial, \n.label\n refers to the current item's \nlabel\n property. However, \nitem\n is essentially the current item's \n{{.foo.bar.item}}\n. The \nitem\n binds two-way and updates the current item's \n.foo.bar\n.\n\n\n{{#partial myPartial}}\n  \nlabel\n{{.label}}\n/label\n\n  \ninput type=\ntext\n value=\n{{item}}\n\n{{/}}\n\n{{# list }}\n  {{\nmyPartial .foo.bar as item}}\n{{/}}\n\n\n\n\nRecursive partials\n\n\nPartials can be used recursively. A common use case for this is when reusing partials on a tree-like structure, like a directory listing.\n\n\ndiv class='fileSystem'\n\n  {{#root}}\n    {{\nfolder}}\n  {{/root}}\n\n/div\n\n\n{{#partial folder}}\n\nul class='folder'\n\n  {{#files}}\n    {{\nfile}}\n  {{/files}}\n\n/ul\n\n{{/partial}}\n\n{{#partial file}}\n\nli class='file'\n\n  \nimg class='icon-{{type}}'\n\n  \nspan\n{{filename}}\n/span\n\n\n  \n!-- if this is actually a folder, embed the folder partial --\n\n  {{# type === 'folder' }}\n    {{\nfolder}}\n  {{/ type === 'folder' }}\n\n/li\n\n{{/partial}}\n\n\n\n\nrv = new Ractive({\n  el: 'container',\n  template: '#myTemplate',\n  data: {\n    root: {\n      files: [\n        { type: 'jpg', filename: 'hello.jpg' },\n        { type: 'mp3', filename: 'NeverGonna.mp3' },\n        { type: 'folder', filename: 'subfolder', files: [\n          { type: 'txt', filename: 'README.txt' },\n          { type: 'folder', filename: 'rabbithole', files: [\n            { type: 'txt', filename: 'Inception.txt' }\n          ]}\n        ]}\n      ]\n    }\n  }\n});\n\n\n\n\nIn the example above, subfolders use the \n{{\nfolder}}\n partial, which uses the \n{{\nfile}}\n partial for each file, and if any of those files are folders, the \n{{\nfolder}}\n partial will be invoked again, and so on until there are no more files.\n\n\nBeware of cyclical data structures! Ractive makes no attempt to detect cyclicality, and will happily continue rendering partials until the \nBig Crunch\n (or your browser exceeds its maximum call stack size. Whichever is sooner).\n\n\nInjecting partials\n\n\nOne good use of partials is to vary the shape of a template according to some condition, the same way you might use \ndependency injection\n elsewhere in your code.\n\n\nFor example, you might offer a different view to mobile users:\n\n\ndiv class='main'\n\n  \ndiv class='content'\n\n    {{\ncontent}}\n  \n/div\n\n\n  \ndiv class='sidebar'\n\n    {{\nsidebar}}\n  \n/div\n\n\n/div\n\n\n\n\n\nisMobile = /mobile/i.test( navigator.userAgent ); // please don't do this in real life!\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  partials: {\n    content: isMobile ? mobileContentPartial : desktopContentPartial,\n    sidebar: isMobile ? mobileSidebarPartial : desktopSidebarPartial\n  }\n});\n\n\n\n\nOr you might make it possible to \nextend\n a subclass without overriding its template:\n\n\ndiv class='modal-background'\n\n  \ndiv class='modal'\n\n    {{\nmodalContent}}\n  \n/div\n\n\n/div\n\n\n\n\n\n// Create a Modal subclass\nModal = Ractive.extend({\n  template: modalTemplate,\n  init: function () {\n    var self = this, resizeHandler;\n\n    resizeHandler = function () {\n      self.center();\n    };\n\n    // when the window resizes, keep the modal horizontally and vertically centred\n    window.addEventListener( 'resize', resizeHandler );\n\n    // clean up after ourselves later\n    this.on( 'teardown', function () {\n      window.removeEventListener( 'resize', resizeHandler );\n    });\n\n    // manually call this.center() the first time\n    this.center();\n  },\n  center: function () {\n    // centering logic goes here\n  }\n});\n\nhelloModal = new Modal({\n  el: document.body,\n  partials: {\n    modalContent: '\np\nHello!\n/p\na class=\nmodal-button\n proxy-tap=\nclose\nClose\n/a\n'\n  }\n});\n\nhelloModal.on( 'close', function () {\n  this.teardown();\n});\n\n\n\n\nPartial expressions\n\n\nExpressions can also be used to reference a partial instead of fixed partial names. Ractive will evaluate the expression and use its return value to select a partial. This is useful when you want the data to indicate what type of partial it should render with.\n\n\nIn the following example, \norganisms\n contains a list of organisms whose \ntype\n can either be \nperson\n or \nanimal\n. Partials for each type is defined and the list uses the \ntype\n of each item to determine which partial to use.\n\n\n{{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n\nul\n\n  {{# organisms }}\n    \nli\n{{\n type }}\n/li\n\n  {{/}}\n\n/ul\n\n\n\n\n\nIn the case where there's a collision between the expression and a partial of the same name, Ractive will not evaluate the expression and instead, will immediately resolve to that partial.\n\n\nIn the following example, a partial named \ntype\n is defined. Instead of evaluating \ntype\n's value, it will resolve to the partial named \ntype\n.\n\n\n{{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n{{#partial type}}Hi! I am {{.name}}{{/}}\n\n\nul\n\n  {{# organisms }}\n    \nli\n{{\n type }}\n/li\n\n  {{/}}\n\n/ul\n\n\n\n\n\nPartials can also be registered on-the-fly as well as have functions determine the partial to use.\n\n\nIn the following example, \nmakePartial\n registers a partial on the fly using \ntemplate\n and \nid\n, and returns the partial name for use in the template.\n\n\nnew Ractive({\n  el: 'main',\n  template: `\n    \nspan\nAdd a partial:\n/span\n\n    \ntextarea value=\n{{tpl}}\n /\n/div\n\n    \nbutton on-click=\n@this.add()\nAdd\n/button\nbr/\n\n\n    {{#list}}\n      {{\n @this.makePartial(.id, .template) }}\n    {{/}}\n  `,\n  data: {\n    list: [],\n    tpl: '',\n\n  },\n  add: function() {\n    this.push('list', {\n      id: Math.random(),\n      template: this.get('tpl')\n    });\n    this.set('tpl', '');\n  },\n  makePartial: function(id, template) {\n    const name = 'partial-' + id;\n    this.partials[name] = this.partials[name] || template;\n    return name;\n  }\n});\n\n\n\n\nUpdating Partials\n\n\nPartials may be reset after they are rendered using \nractive.resetPartial()\n. A reset partial will update everywhere it is referenced, so if it is used multiple times or inherited by a component, those instances will be updated as well. If a component has a partial with the same name as a parent partial, partial resets will not affect it since it is a different partial.\n\n\nIt should be noted that partials evaluate lazily, so it is possible to cause a single partial to update by wrapping it in a conditional section and causing the section to be hidden and re-shown.\n\n\n{{^toggle}}{{\nrickroll}}{{/}}\n\n\n\n\nractive.partials.rickroll = 'I wouldn\\'t do that to you, chum.';\nractive.set('toggle', true);\nractive.set('toggle', false);\n\n\n\n\nExamples\n\n\nHere's an example of a gallery using a partial for its thumbnail information:\n\n\n!-- The partial called \nthumbnail\n --\n\n\nfigure class='thumbnail'\n\n  \nimg src='assets/thumbnails/{{id}}.jpg'\n\n  \nfigcaption\n{{description}}\n/figcaption\n\n\n/figure\n\n\n\n!-- The template that uses the partial --\n\n\ndiv class='gallery'\n\n  {{#items}}\n    {{\nthumbnail}}\n  {{/items}}\n\n/div", 
            "title": "Partials"
        }, 
        {
            "location": "/Extend/Partials/#partials", 
            "text": "A partial is a template snippet which can be reused in templates or in other partials. They help to keep templates uncluttered, non-repetetive and easy to read.", 
            "title": "Partials"
        }, 
        {
            "location": "/Extend/Partials/#writing", 
            "text": "Ractive.partials.myPartial = ' !-- template -- ';  Partials are simply Ractive templates.", 
            "title": "Writing"
        }, 
        {
            "location": "/Extend/Partials/#registering", 
            "text": "Unlike other plugins, partials have more than 3 registration options.", 
            "title": "Registering"
        }, 
        {
            "location": "/Extend/Partials/#globally-via-the-ractivepartials-static-property", 
            "text": "Ractive.partials.myPartial = MyPartial;", 
            "title": "Globally via the Ractive.partials static property."
        }, 
        {
            "location": "/Extend/Partials/#globally-via-a-non-executing-script-tag-on-the-current-page", 
            "text": "script type= ractive/template  id= myPartial \n  ... /script   text/html  is another good choice for  type  because many editors will highlight the content of the tag as HTML. Anything other than  text/javascript ,  application/javascript , or no  type  at all will do.", 
            "title": "Globally, via a non-executing script tag on the current page."
        }, 
        {
            "location": "/Extend/Partials/#per-component-via-the-components-partials-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  events: {\n    myPartial: myPartial\n  }\n});", 
            "title": "Per component, via the component's partials initialization property."
        }, 
        {
            "location": "/Extend/Partials/#per-instance-via-the-instances-partials-initialization-property", 
            "text": "const ractive = new Ractive({\n  events: {\n    myPartial: myPartial\n  }\n});", 
            "title": "Per instance, via the instance's partials initialization property."
        }, 
        {
            "location": "/Extend/Partials/#inline-using-the-partial-mustache", 
            "text": "Availability depends on whoever uses the template containing the inline partial, whether it's a component, an instance or another partial. Inline partials are scoped to the nearest tag, be it component or element, and are available to any child of that element.  {{#partial myPartial}}\n  ...\n{{/}}", 
            "title": "Inline, using the {{#partial}} mustache."
        }, 
        {
            "location": "/Extend/Partials/#using", 
            "text": "Partials can be used using the  {{ partialName}}  syntax. Partials work where any template would work. It works as if the partial template is manually put into where the partial mustache is positioned.  {{#partial myPartial}}\n   div class= message {{message}} /div \n{{/}} div class= app \n  {{ myPartial}} /div", 
            "title": "Using"
        }, 
        {
            "location": "/Extend/Partials/#valid-names", 
            "text": "Partials may be named with the same rules as any other identifier in Ractive or JavaScript, but since there isn't much danger of trying to do math in a partial name, they enjoy relaxed naming requirements that allow otherwise reserved globals and keywords to be used for partial names.  Partial names may also contain  -  and  /  characters as long as they are surrounded by other valid characters e.g.  templates/some-partial-template .", 
            "title": "Valid names"
        }, 
        {
            "location": "/Extend/Partials/#partial-context", 
            "text": "By default, a partial's context is the context of wherever it is positioned.  In the following example, the context of the partial is the current item in the list.  {{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{ myPartial}}\n{{/}}  However, partials may be given explicit context using the  {{ [name expression] [context expression]}}  syntax. It's similar to wrapping the partial with a  {{#with}}  mustache. Ancestor references, members, object literals, and any other expressions that resolve to an object may be used as a context expression.  In the following example, context of the partial is the current item's  foo.bar  value.  {{#partial myPartial}}\n  {{this}}\n{{/}}\n\n{{# list }}\n  {{ myPartial .foo.bar}}\n{{/}}  Explicit contexts can also be aliased. In the case of plain refereces, it can be used for two-way binding.  In the following example, the current item's  foo.bar  path is aliased with  item . In the partial,  .label  refers to the current item's  label  property. However,  item  is essentially the current item's  {{.foo.bar.item}} . The  item  binds two-way and updates the current item's  .foo.bar .  {{#partial myPartial}}\n   label {{.label}} /label \n   input type= text  value= {{item}} \n{{/}}\n\n{{# list }}\n  {{ myPartial .foo.bar as item}}\n{{/}}", 
            "title": "Partial context"
        }, 
        {
            "location": "/Extend/Partials/#recursive-partials", 
            "text": "Partials can be used recursively. A common use case for this is when reusing partials on a tree-like structure, like a directory listing.  div class='fileSystem' \n  {{#root}}\n    {{ folder}}\n  {{/root}} /div \n\n{{#partial folder}} ul class='folder' \n  {{#files}}\n    {{ file}}\n  {{/files}} /ul \n{{/partial}}\n\n{{#partial file}} li class='file' \n   img class='icon-{{type}}' \n   span {{filename}} /span \n\n   !-- if this is actually a folder, embed the folder partial -- \n  {{# type === 'folder' }}\n    {{ folder}}\n  {{/ type === 'folder' }} /li \n{{/partial}}  rv = new Ractive({\n  el: 'container',\n  template: '#myTemplate',\n  data: {\n    root: {\n      files: [\n        { type: 'jpg', filename: 'hello.jpg' },\n        { type: 'mp3', filename: 'NeverGonna.mp3' },\n        { type: 'folder', filename: 'subfolder', files: [\n          { type: 'txt', filename: 'README.txt' },\n          { type: 'folder', filename: 'rabbithole', files: [\n            { type: 'txt', filename: 'Inception.txt' }\n          ]}\n        ]}\n      ]\n    }\n  }\n});  In the example above, subfolders use the  {{ folder}}  partial, which uses the  {{ file}}  partial for each file, and if any of those files are folders, the  {{ folder}}  partial will be invoked again, and so on until there are no more files.  Beware of cyclical data structures! Ractive makes no attempt to detect cyclicality, and will happily continue rendering partials until the  Big Crunch  (or your browser exceeds its maximum call stack size. Whichever is sooner).", 
            "title": "Recursive partials"
        }, 
        {
            "location": "/Extend/Partials/#injecting-partials", 
            "text": "One good use of partials is to vary the shape of a template according to some condition, the same way you might use  dependency injection  elsewhere in your code.  For example, you might offer a different view to mobile users:  div class='main' \n   div class='content' \n    {{ content}}\n   /div \n\n   div class='sidebar' \n    {{ sidebar}}\n   /div  /div   isMobile = /mobile/i.test( navigator.userAgent ); // please don't do this in real life!\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  partials: {\n    content: isMobile ? mobileContentPartial : desktopContentPartial,\n    sidebar: isMobile ? mobileSidebarPartial : desktopSidebarPartial\n  }\n});  Or you might make it possible to  extend  a subclass without overriding its template:  div class='modal-background' \n   div class='modal' \n    {{ modalContent}}\n   /div  /div   // Create a Modal subclass\nModal = Ractive.extend({\n  template: modalTemplate,\n  init: function () {\n    var self = this, resizeHandler;\n\n    resizeHandler = function () {\n      self.center();\n    };\n\n    // when the window resizes, keep the modal horizontally and vertically centred\n    window.addEventListener( 'resize', resizeHandler );\n\n    // clean up after ourselves later\n    this.on( 'teardown', function () {\n      window.removeEventListener( 'resize', resizeHandler );\n    });\n\n    // manually call this.center() the first time\n    this.center();\n  },\n  center: function () {\n    // centering logic goes here\n  }\n});\n\nhelloModal = new Modal({\n  el: document.body,\n  partials: {\n    modalContent: ' p Hello! /p a class= modal-button  proxy-tap= close Close /a '\n  }\n});\n\nhelloModal.on( 'close', function () {\n  this.teardown();\n});", 
            "title": "Injecting partials"
        }, 
        {
            "location": "/Extend/Partials/#partial-expressions", 
            "text": "Expressions can also be used to reference a partial instead of fixed partial names. Ractive will evaluate the expression and use its return value to select a partial. This is useful when you want the data to indicate what type of partial it should render with.  In the following example,  organisms  contains a list of organisms whose  type  can either be  person  or  animal . Partials for each type is defined and the list uses the  type  of each item to determine which partial to use.  {{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}} ul \n  {{# organisms }}\n     li {{  type }} /li \n  {{/}} /ul   In the case where there's a collision between the expression and a partial of the same name, Ractive will not evaluate the expression and instead, will immediately resolve to that partial.  In the following example, a partial named  type  is defined. Instead of evaluating  type 's value, it will resolve to the partial named  type .  {{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n{{#partial type}}Hi! I am {{.name}}{{/}} ul \n  {{# organisms }}\n     li {{  type }} /li \n  {{/}} /ul   Partials can also be registered on-the-fly as well as have functions determine the partial to use.  In the following example,  makePartial  registers a partial on the fly using  template  and  id , and returns the partial name for use in the template.  new Ractive({\n  el: 'main',\n  template: `\n     span Add a partial: /span \n     textarea value= {{tpl}}  / /div \n     button on-click= @this.add() Add /button br/ \n\n    {{#list}}\n      {{  @this.makePartial(.id, .template) }}\n    {{/}}\n  `,\n  data: {\n    list: [],\n    tpl: '',\n\n  },\n  add: function() {\n    this.push('list', {\n      id: Math.random(),\n      template: this.get('tpl')\n    });\n    this.set('tpl', '');\n  },\n  makePartial: function(id, template) {\n    const name = 'partial-' + id;\n    this.partials[name] = this.partials[name] || template;\n    return name;\n  }\n});", 
            "title": "Partial expressions"
        }, 
        {
            "location": "/Extend/Partials/#updating-partials", 
            "text": "Partials may be reset after they are rendered using  ractive.resetPartial() . A reset partial will update everywhere it is referenced, so if it is used multiple times or inherited by a component, those instances will be updated as well. If a component has a partial with the same name as a parent partial, partial resets will not affect it since it is a different partial.  It should be noted that partials evaluate lazily, so it is possible to cause a single partial to update by wrapping it in a conditional section and causing the section to be hidden and re-shown.  {{^toggle}}{{ rickroll}}{{/}}  ractive.partials.rickroll = 'I wouldn\\'t do that to you, chum.';\nractive.set('toggle', true);\nractive.set('toggle', false);", 
            "title": "Updating Partials"
        }, 
        {
            "location": "/Extend/Partials/#examples", 
            "text": "Here's an example of a gallery using a partial for its thumbnail information:  !-- The partial called  thumbnail  --  figure class='thumbnail' \n   img src='assets/thumbnails/{{id}}.jpg' \n   figcaption {{description}} /figcaption  /figure  !-- The template that uses the partial --  div class='gallery' \n  {{#items}}\n    {{ thumbnail}}\n  {{/items}} /div", 
            "title": "Examples"
        }, 
        {
            "location": "/Extend/Transitions/", 
            "text": "Transitions\n\n\nTransitions allow you to control how enter the DOM and how they leave the DOM. This allows you to define intro and outro behavior, particularly animations, when elements go in and out of the page.\n\n\nWriting\n\n\nRactive.transitions.myTransition = function ( t, params ) {\n  // Manipulate the DOM.\n  // Call t.complete() when completed.\n};\n\n\n\n\nTransitions are simply functions that get called to animate a specified element.\n\n\nt\n is a helper object that aids in the implementation of the transition. See the Transition Object for details.\n\n\nparams\n is the parameters passed in via the transition directive.\n\n\nTransitions are expected to be asynchronous. In order to signal Ractive that a transition has completed, the transition must call the \nt.complete()\n.\n\n\nNote that transitions control the element's arrival and departure to the page. That means upon completion, any styling done to the element will be removed automatically.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register transitions:\n\n\nGlobally, via the \nRactive.transitions\n static property.\n\n\nRactive.transitions.myTransition = myTransition;\n\n\n\n\nPer component, via the component's \ntransitions\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  transitions: {\n    myTransition: myTransition\n  }\n});\n\n\n\n\nPer instance, via the instance's \ntransitions\n initialization property.\n\n\nconst ractive = new Ractive({\n  decorators: {\n    myTransition: myTransition\n  }\n});\n\n\n\n\nUsing\n\n\nTransitions are added to an element via a transition directive. The directive starts with the transition name followed by one or more suffixes. The transition may be intro-only (upon rendering) using the suffix \n-in\n, outro-only (upon removal) using the suffix \n-out\n, or both using the suffix \n-in-out\n.\n\n\ndiv myTransition-in\nIntro-only\n/div\n\n\ndiv myTransition-out\nOutro-only\n/div\n\n\ndiv myTransition-in-out\nIntro and outro\n/div\n\n\n\n\n\nTo pass arguments to the transition, simply provide an expression as the directive's value. This will be passed as the second argument of the transition function.\n\n\ndiv myTransition-in=\n{ /*params */ }\nIntro-only\n/div\n\n\ndiv myTransition-out=\n{ /*params */ }\nOutro-only\n/div\n\n\ndiv myTransition-in-out=\n{ /*params */ }\nIntro and outro\n/div\n\n\n\n\n\nExamples\n\n\nThe following example demonstrates a \"flash\" transition which colors the element green upon attachment, and red prior to removal.\n\n\nRactive.transitions.flash = function(t, params) {\n  // Process params and declaring defaults.\n  const options = t.processParams(params, {\n    color: t.isIntro ? '#0f0' : '#f00',\n    duration: 400\n  });\n\n  // The \ntransition\n\n  t.setStyle('color', options.color);\n\n  // Signal Ractive that the transition is complete.\n  setTimeout(t.complete, options.duration);\n};\n\nnew Ractive({\n  el: 'body',\n  template: `\n    \nbutton on-click='@this.insert()'\nInsert item\n/button\n\n    \nbutton on-click='@this.remove()'\nRemove item\n/button\n\n    \nul\n\n      {{#items}}\n      \nli flash-in-out\n{{this}}\n/li\n\n      {{/items}}\n    \n/ul\n\n  `,\n  data: {\n    items: []\n  },\n  insert() {\n    this.push('items', Date.now());\n  },\n  remove() {\n    this.splice('items', 0, 1);\n  }\n});", 
            "title": "Transitions"
        }, 
        {
            "location": "/Extend/Transitions/#transitions", 
            "text": "Transitions allow you to control how enter the DOM and how they leave the DOM. This allows you to define intro and outro behavior, particularly animations, when elements go in and out of the page.", 
            "title": "Transitions"
        }, 
        {
            "location": "/Extend/Transitions/#writing", 
            "text": "Ractive.transitions.myTransition = function ( t, params ) {\n  // Manipulate the DOM.\n  // Call t.complete() when completed.\n};  Transitions are simply functions that get called to animate a specified element.  t  is a helper object that aids in the implementation of the transition. See the Transition Object for details.  params  is the parameters passed in via the transition directive.  Transitions are expected to be asynchronous. In order to signal Ractive that a transition has completed, the transition must call the  t.complete() .  Note that transitions control the element's arrival and departure to the page. That means upon completion, any styling done to the element will be removed automatically.", 
            "title": "Writing"
        }, 
        {
            "location": "/Extend/Transitions/#registering", 
            "text": "Like other plugins, there's 3 ways you can register transitions:", 
            "title": "Registering"
        }, 
        {
            "location": "/Extend/Transitions/#globally-via-the-ractivetransitions-static-property", 
            "text": "Ractive.transitions.myTransition = myTransition;", 
            "title": "Globally, via the Ractive.transitions static property."
        }, 
        {
            "location": "/Extend/Transitions/#per-component-via-the-components-transitions-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  transitions: {\n    myTransition: myTransition\n  }\n});", 
            "title": "Per component, via the component's transitions initialization property."
        }, 
        {
            "location": "/Extend/Transitions/#per-instance-via-the-instances-transitions-initialization-property", 
            "text": "const ractive = new Ractive({\n  decorators: {\n    myTransition: myTransition\n  }\n});", 
            "title": "Per instance, via the instance's transitions initialization property."
        }, 
        {
            "location": "/Extend/Transitions/#using", 
            "text": "Transitions are added to an element via a transition directive. The directive starts with the transition name followed by one or more suffixes. The transition may be intro-only (upon rendering) using the suffix  -in , outro-only (upon removal) using the suffix  -out , or both using the suffix  -in-out .  div myTransition-in Intro-only /div  div myTransition-out Outro-only /div  div myTransition-in-out Intro and outro /div   To pass arguments to the transition, simply provide an expression as the directive's value. This will be passed as the second argument of the transition function.  div myTransition-in= { /*params */ } Intro-only /div  div myTransition-out= { /*params */ } Outro-only /div  div myTransition-in-out= { /*params */ } Intro and outro /div", 
            "title": "Using"
        }, 
        {
            "location": "/Extend/Transitions/#examples", 
            "text": "The following example demonstrates a \"flash\" transition which colors the element green upon attachment, and red prior to removal.  Ractive.transitions.flash = function(t, params) {\n  // Process params and declaring defaults.\n  const options = t.processParams(params, {\n    color: t.isIntro ? '#0f0' : '#f00',\n    duration: 400\n  });\n\n  // The  transition \n  t.setStyle('color', options.color);\n\n  // Signal Ractive that the transition is complete.\n  setTimeout(t.complete, options.duration);\n};\n\nnew Ractive({\n  el: 'body',\n  template: `\n     button on-click='@this.insert()' Insert item /button \n     button on-click='@this.remove()' Remove item /button \n     ul \n      {{#items}}\n       li flash-in-out {{this}} /li \n      {{/items}}\n     /ul \n  `,\n  data: {\n    items: []\n  },\n  insert() {\n    this.push('items', Date.now());\n  },\n  remove() {\n    this.splice('items', 0, 1);\n  }\n});", 
            "title": "Examples"
        }, 
        {
            "location": "/Concepts/Architecture/Overview/", 
            "text": "Ractive General Overview\n\n\nThere are three major sections in the Ractive source to handle each of data, the DOM and virtual DOM, and parsing template strings to Ractive's template AST. Each of those sections mostly lives in its own folder in the \nsrc\n tree: \nmodel\n, \nview\n, and \nparse\n, respectively. This document aims to give a general overview of what each section does so that you can hopefully find what you need to fix a bug, add a feature, or just understand how something works internally.\n\n\nData and Models\n\n\nRactive wraps any data given to it into a tree-like hierarchy of \nModel\n. Any data that is rendered into a template will be bound to a \nModel\n. Access to read and write data in Ractive is handled through the model hierarchy based on keypaths, which are, generally, a list of object properties that one would need to follow to reach a leaf of the data tree starting from the root. Each key along the keypath has its own corresponding model.\n\n\nModels allow entities that depend upon them to register themeselves to receive change notifications when the model value changes. This is how Ractive keeps track of exactly which parts of the view need to be updated when values change.\n\n\nRead more about models in the \nmodel overview\n.\n\n\nVirtual DOM\n\n\nEvery piece of DOM that Ractive can manage has a corresponding class in the virtual DOM to handle the DOM node, which generally end up being either Elements or Text Nodes. View items are grouped together as Fragments of view, which may then be owned by other fragments or items. At the root of every ractive instance is a Fragment instance that contains its entire virtual DOM tree. Each Ractive template construct has at least one analog in the virtual DOM. The bulk of Ractive's view functionality is implemented in the Section, Interpolator, and Element items, with there being a number of specialized element classes to handle special types of HTML element.\n\n\nAll virtual DOM items go through roughly the same lifecycle: creation, binding, rendering, bubbling, updating, unrendering, and unbinding. Creation is basically just the constructor call and almost always is immediately followed by binding. Binding is the point at which the item resolves and registers with its data references. Rendering is the point at which the item inserts an actual DOM node into the DOM. Bubbling and updating are the two halves of the update process, which is discussed in the next section. Unrendering is the point at which the item should no longer be present in the DOM, and it often occurs at the same point as unbinding, which is the point at which the item unregisters with the viewmodel and is effectively destroyed.\n\n\nThere a number of other members, such as events and decorators, and processes, such as change propagation, which are described in detail in the \nview overview\n.\n\n\nParsing\n\n\nRactive's parser is responsible for taking the (mostly :wink:) human-friendly mustachioed HTML of templates and turning it into an AST that can be turned into vDOM at runtime. Ractive's parser is somewhat unique among its peers in that it handles reading not only the mustache templates, but a fair amount of ES5 and ES6 syntax for expressions.\n\n\nEach item expressable in Ractive-flavored mustache has its own parsing function that may also be comprised of other parsing functions. Each bit of ES syntax that Ractive understands for expressions also has its own parsing function. The parser starts at the beginning of the template string and starts applying each parsing function in precedence order. Each function will then consume as much of the template as needed to return an item, like an element, a section, a partial, a bit of text, or an interpolator. It may also return nothing. Most items can also contain children, including items of the same type as themselves, and will thus recurse by trying to parse their content.\n\n\nThere is more information about Ractive's parsing in the \nparser overview\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/Concepts/Architecture/Overview/#ractive-general-overview", 
            "text": "There are three major sections in the Ractive source to handle each of data, the DOM and virtual DOM, and parsing template strings to Ractive's template AST. Each of those sections mostly lives in its own folder in the  src  tree:  model ,  view , and  parse , respectively. This document aims to give a general overview of what each section does so that you can hopefully find what you need to fix a bug, add a feature, or just understand how something works internally.", 
            "title": "Ractive General Overview"
        }, 
        {
            "location": "/Concepts/Architecture/Overview/#data-and-models", 
            "text": "Ractive wraps any data given to it into a tree-like hierarchy of  Model . Any data that is rendered into a template will be bound to a  Model . Access to read and write data in Ractive is handled through the model hierarchy based on keypaths, which are, generally, a list of object properties that one would need to follow to reach a leaf of the data tree starting from the root. Each key along the keypath has its own corresponding model.  Models allow entities that depend upon them to register themeselves to receive change notifications when the model value changes. This is how Ractive keeps track of exactly which parts of the view need to be updated when values change.  Read more about models in the  model overview .", 
            "title": "Data and Models"
        }, 
        {
            "location": "/Concepts/Architecture/Overview/#virtual-dom", 
            "text": "Every piece of DOM that Ractive can manage has a corresponding class in the virtual DOM to handle the DOM node, which generally end up being either Elements or Text Nodes. View items are grouped together as Fragments of view, which may then be owned by other fragments or items. At the root of every ractive instance is a Fragment instance that contains its entire virtual DOM tree. Each Ractive template construct has at least one analog in the virtual DOM. The bulk of Ractive's view functionality is implemented in the Section, Interpolator, and Element items, with there being a number of specialized element classes to handle special types of HTML element.  All virtual DOM items go through roughly the same lifecycle: creation, binding, rendering, bubbling, updating, unrendering, and unbinding. Creation is basically just the constructor call and almost always is immediately followed by binding. Binding is the point at which the item resolves and registers with its data references. Rendering is the point at which the item inserts an actual DOM node into the DOM. Bubbling and updating are the two halves of the update process, which is discussed in the next section. Unrendering is the point at which the item should no longer be present in the DOM, and it often occurs at the same point as unbinding, which is the point at which the item unregisters with the viewmodel and is effectively destroyed.  There a number of other members, such as events and decorators, and processes, such as change propagation, which are described in detail in the  view overview .", 
            "title": "Virtual DOM"
        }, 
        {
            "location": "/Concepts/Architecture/Overview/#parsing", 
            "text": "Ractive's parser is responsible for taking the (mostly :wink:) human-friendly mustachioed HTML of templates and turning it into an AST that can be turned into vDOM at runtime. Ractive's parser is somewhat unique among its peers in that it handles reading not only the mustache templates, but a fair amount of ES5 and ES6 syntax for expressions.  Each item expressable in Ractive-flavored mustache has its own parsing function that may also be comprised of other parsing functions. Each bit of ES syntax that Ractive understands for expressions also has its own parsing function. The parser starts at the beginning of the template string and starts applying each parsing function in precedence order. Each function will then consume as much of the template as needed to return an item, like an element, a section, a partial, a bit of text, or an interpolator. It may also return nothing. Most items can also contain children, including items of the same type as themselves, and will thus recurse by trying to parse their content.  There is more information about Ractive's parsing in the  parser overview .", 
            "title": "Parsing"
        }, 
        {
            "location": "/Concepts/Architecture/Parser/", 
            "text": "Ractive uses a recursive descent parser that is comprised of a number readers and converters that are responsible for parsing individual bits of the template AST. The root-level parsers are text, mustache, and element.\n\n\nMustaches\n\n\nEach type of mustache has its own reader that calls the appropriate expression or reference readers internally. For instance, the partial reader reads the current open mustache delimiter (defaults to \n{{\n) followed by a \n. It then expects to find a relaxed reference, meaning it may contain dashes and slashes among other usually-forbidden characters. It may then optionally read a context expression or series of alias definitions\n\n\nExpressions\n\n\nThe expression readers are set arranged such that they can read valid ES expressions with the correct operator precedence by starting with ternary conditionals and trying different expression types from there. Once the expression tree has been parsed, it is flattened into an expression string and a list of references that are used within that string. If the parsing is done with \ncsp\n (Content Security Policy) support enabled, then the expression strings are also turned into functions and attached to the output template structure so that the template can be used as-is from a script tag without \neval\ning.\n\n\nCleanup\n\n\nAfter all of the nodes have been parsed from the template, the template is cleaned up in a process that, among other things, merges adjacent text nodes and forms individual conditional sections out of \nelseif\n/\nelse\n trees.", 
            "title": "Parser"
        }, 
        {
            "location": "/Concepts/Architecture/Parser/#mustaches", 
            "text": "Each type of mustache has its own reader that calls the appropriate expression or reference readers internally. For instance, the partial reader reads the current open mustache delimiter (defaults to  {{ ) followed by a  . It then expects to find a relaxed reference, meaning it may contain dashes and slashes among other usually-forbidden characters. It may then optionally read a context expression or series of alias definitions", 
            "title": "Mustaches"
        }, 
        {
            "location": "/Concepts/Architecture/Parser/#expressions", 
            "text": "The expression readers are set arranged such that they can read valid ES expressions with the correct operator precedence by starting with ternary conditionals and trying different expression types from there. Once the expression tree has been parsed, it is flattened into an expression string and a list of references that are used within that string. If the parsing is done with  csp  (Content Security Policy) support enabled, then the expression strings are also turned into functions and attached to the output template structure so that the template can be used as-is from a script tag without  eval ing.", 
            "title": "Expressions"
        }, 
        {
            "location": "/Concepts/Architecture/Parser/#cleanup", 
            "text": "After all of the nodes have been parsed from the template, the template is cleaned up in a process that, among other things, merges adjacent text nodes and forms individual conditional sections out of  elseif / else  trees.", 
            "title": "Cleanup"
        }, 
        {
            "location": "/Concepts/Architecture/Model/", 
            "text": "All of the data managed by Ractive is represented by its model hierarchy.\n\n\nModel\n\n\nAlmost every type of Model is a subclass of \nModel\n, so it seems a good place to start. Each model typically has a parent model, a key that is used to access its value from its parent, and a value. Most models also have children of some sort, which are tracked by key such that \n{ foo: { bar: 'baz' } }\n would have a model with a \nchildByKey['foo']\n, which would also have a model at \nchildByKey['bar']\n. The value of each of the models listed there would be the object containing \nfoo: { bar:\nbaz\n}\n, its \nfoo\n child would be the object \nbar: 'baz'\n, and its \nbar\n child would be the string \n'baz'\n. Where children of a model are other models, dependents (\ndeps\n) of a model may be anything that wants to be notified of changes, and each model will typically have a number of dependents, too.\n\n\nEach model has a unique keypath that is assembled by taking its key and each of its parents keys up to the root and joining them with a \n.\n.\n\n\nModels are also inherently lazy, meaning their value is not necessarily available when the are created. A value is retrieved from a model using its \nget\n method which may have the side effect of computing the value. Once a value has been computed, it is generally cached until a change happens that would cause the cache to be invalidated. In most models, there isn't really an opportunity for that change outside of normal change propagation.\n\n\nChange propagation\n\n\nWhen a change is supplied to a model, its \nset\n method is called, which usually delegates to \napplyValue\n. \napplyValue\n checks to see that the value has actually changed in some way (hint: setting to the same object or array is considered a change because something may have changed further in), and if it has, it will start change notification for all of the model's children and dependents. If the model has resolvers registered with it trying to get an unresolved value, then this is where the unresolved value will be resolved and the resolver satisfied and cleared. Next, any children will be notified that their parent has had a value change and that they may need to update accordingly, which may trigger further cascades of resolution and change notification. Next, any dependents of the model will be notified that the model has had a value change as their \nhandleChange\n methods are called. Finally, upstream models (parents) are notified that a change has taken place somewhere among its children.\n\n\nThe child notification of the propagation is handled by the model's \nmark\n method. \nmark\n also checks to see that the value has actually changed, and if it has, will notify its children and dependents that it has had a value change. This is also the method called when the user signals that they have changed some data externally by calling \nractive.update()\n.\n\n\nShuffling\n\n\nThere is a special form of change wherein an array is modified without being swapped out, which is triggered by array methods like \nsplice\n, \npush\n, and \npop\n. When an array modification happens, change propagation takes a special path through the model that allows more precise DOM manipulation rather than throwing all of the DOM out and replacing it with a new result. This is achieved by having the special array method handlers compute which indexes are actually changed and having the array model's deps that can actally handle a shuffle ignore any untouched indices.\n\n\nThe instance method \nmerge\n does something similar, but instead of modifying the underlying array, it compares the members of the new supplied array against the model array to compute the index changes. It the swaps in the new array and triggers a shuffle based on the computed index changes.\n\n\nAdaptation\n\n\nBetween the change check and the change propagation during \napplyValue\n, there is a step that handles part of adaptation so that external objects with special behaviors, like backbone models, can be used as data sources. An adaptors takes the special object, wraps it up, and returns the wrapper that also has a value that represents the object for consumption by Ractive. Most adaptors also have methods to update values in their source data as well, and those methods are called when an update is applied to an adapted model.\n\n\nRootModel\n\n\nEvery tree needs a root, and \nRootModel\n serves that purpose here. Each Ractive instance gets its own \nRootModel\n that is stored at its \nviewmodel\n property. This special model is also the storage point for computations and mappings.\n\n\nComputations\n\n\nA computation is exactly what is sounds like: a getter and optional setter function that are used to provide read and optional write access to some non-fixed piece of data. Each computation is stored in the root model \ncomputations\n hash by its keypath. Computations can be created in two places:\n\n\n\n\nExplicitly when a \ncomputed\n map is passed to a Ractive instantiation or when an entry is later added to a instance's computed map. These may be read/write and have a keypath that mirrors their name.\n\n\nImplicitly when an expression is used in a template. These are read-only and have a keypath that is an expanded representation of their expression.\n\n\n\n\nA computation is also a form of model, so anything that depends on it will subscribe to it as if it were a regular model. Change propagation happens in the same way as a regular model as well.\n\n\nSince computations may depend on other bits of data controlled by Ractive, while they are being retrieved, any references to other models will cause the extra references to be \ncapture\nd. When the computation is complete, the computation will register with each of its captured dependencies so that it will be notified when it needs to invalidate and notify its dependents of the change.\n\n\nMappings\n\n\nWhen a Ractive instance has children, typically components, it may supply a handles to its own data to them in the form of mappings. The child instance stores a reference to the parent model at its mapped name and uses it when its dependents request access to keypaths that start with the mapped name. This allows child instances, which may be isolated, to stay in sync with portions of their parents data easily, because the parent still controls the data (single source of truth) and there is no syncing involved. So if a parent has a component \nComponent foo=\"{{bar.baz.bat.bippy}}\" /\n, then the component instance will get a mapping \nfoo\n that references the parent model at \nbar.baz.bat.bippy\n.\n\n\nOther models\n\n\nThere are a few other types of \nModel\n in the code, such as the \nRactiveModel\n, which represents a Ractive instance, and the \nGlobalModel\n, which represents the global object of the current environment a.k.a. \nwindow\n for browsers and \nglobal\n for Node.js.\n\n\nKeyModel\n\n\nThe last major model remaining is the \nKeyModel\n. Instances of this represent indices of arrays and keys of objects during iteration. The key flavor never is immutable, becuase the keys of  objects never change (they may be removed, but that doesn't change the key itself). The index flavor \ndoes\n change, but only when the array represented by its parent model is shuffled.", 
            "title": "Model"
        }, 
        {
            "location": "/Concepts/Architecture/Model/#model", 
            "text": "Almost every type of Model is a subclass of  Model , so it seems a good place to start. Each model typically has a parent model, a key that is used to access its value from its parent, and a value. Most models also have children of some sort, which are tracked by key such that  { foo: { bar: 'baz' } }  would have a model with a  childByKey['foo'] , which would also have a model at  childByKey['bar'] . The value of each of the models listed there would be the object containing  foo: { bar: baz } , its  foo  child would be the object  bar: 'baz' , and its  bar  child would be the string  'baz' . Where children of a model are other models, dependents ( deps ) of a model may be anything that wants to be notified of changes, and each model will typically have a number of dependents, too.  Each model has a unique keypath that is assembled by taking its key and each of its parents keys up to the root and joining them with a  . .  Models are also inherently lazy, meaning their value is not necessarily available when the are created. A value is retrieved from a model using its  get  method which may have the side effect of computing the value. Once a value has been computed, it is generally cached until a change happens that would cause the cache to be invalidated. In most models, there isn't really an opportunity for that change outside of normal change propagation.", 
            "title": "Model"
        }, 
        {
            "location": "/Concepts/Architecture/Model/#change-propagation", 
            "text": "When a change is supplied to a model, its  set  method is called, which usually delegates to  applyValue .  applyValue  checks to see that the value has actually changed in some way (hint: setting to the same object or array is considered a change because something may have changed further in), and if it has, it will start change notification for all of the model's children and dependents. If the model has resolvers registered with it trying to get an unresolved value, then this is where the unresolved value will be resolved and the resolver satisfied and cleared. Next, any children will be notified that their parent has had a value change and that they may need to update accordingly, which may trigger further cascades of resolution and change notification. Next, any dependents of the model will be notified that the model has had a value change as their  handleChange  methods are called. Finally, upstream models (parents) are notified that a change has taken place somewhere among its children.  The child notification of the propagation is handled by the model's  mark  method.  mark  also checks to see that the value has actually changed, and if it has, will notify its children and dependents that it has had a value change. This is also the method called when the user signals that they have changed some data externally by calling  ractive.update() .", 
            "title": "Change propagation"
        }, 
        {
            "location": "/Concepts/Architecture/Model/#shuffling", 
            "text": "There is a special form of change wherein an array is modified without being swapped out, which is triggered by array methods like  splice ,  push , and  pop . When an array modification happens, change propagation takes a special path through the model that allows more precise DOM manipulation rather than throwing all of the DOM out and replacing it with a new result. This is achieved by having the special array method handlers compute which indexes are actually changed and having the array model's deps that can actally handle a shuffle ignore any untouched indices.  The instance method  merge  does something similar, but instead of modifying the underlying array, it compares the members of the new supplied array against the model array to compute the index changes. It the swaps in the new array and triggers a shuffle based on the computed index changes.", 
            "title": "Shuffling"
        }, 
        {
            "location": "/Concepts/Architecture/Model/#adaptation", 
            "text": "Between the change check and the change propagation during  applyValue , there is a step that handles part of adaptation so that external objects with special behaviors, like backbone models, can be used as data sources. An adaptors takes the special object, wraps it up, and returns the wrapper that also has a value that represents the object for consumption by Ractive. Most adaptors also have methods to update values in their source data as well, and those methods are called when an update is applied to an adapted model.", 
            "title": "Adaptation"
        }, 
        {
            "location": "/Concepts/Architecture/Model/#rootmodel", 
            "text": "Every tree needs a root, and  RootModel  serves that purpose here. Each Ractive instance gets its own  RootModel  that is stored at its  viewmodel  property. This special model is also the storage point for computations and mappings.", 
            "title": "RootModel"
        }, 
        {
            "location": "/Concepts/Architecture/Model/#computations", 
            "text": "A computation is exactly what is sounds like: a getter and optional setter function that are used to provide read and optional write access to some non-fixed piece of data. Each computation is stored in the root model  computations  hash by its keypath. Computations can be created in two places:   Explicitly when a  computed  map is passed to a Ractive instantiation or when an entry is later added to a instance's computed map. These may be read/write and have a keypath that mirrors their name.  Implicitly when an expression is used in a template. These are read-only and have a keypath that is an expanded representation of their expression.   A computation is also a form of model, so anything that depends on it will subscribe to it as if it were a regular model. Change propagation happens in the same way as a regular model as well.  Since computations may depend on other bits of data controlled by Ractive, while they are being retrieved, any references to other models will cause the extra references to be  capture d. When the computation is complete, the computation will register with each of its captured dependencies so that it will be notified when it needs to invalidate and notify its dependents of the change.", 
            "title": "Computations"
        }, 
        {
            "location": "/Concepts/Architecture/Model/#mappings", 
            "text": "When a Ractive instance has children, typically components, it may supply a handles to its own data to them in the form of mappings. The child instance stores a reference to the parent model at its mapped name and uses it when its dependents request access to keypaths that start with the mapped name. This allows child instances, which may be isolated, to stay in sync with portions of their parents data easily, because the parent still controls the data (single source of truth) and there is no syncing involved. So if a parent has a component  Component foo=\"{{bar.baz.bat.bippy}}\" / , then the component instance will get a mapping  foo  that references the parent model at  bar.baz.bat.bippy .", 
            "title": "Mappings"
        }, 
        {
            "location": "/Concepts/Architecture/Model/#other-models", 
            "text": "There are a few other types of  Model  in the code, such as the  RactiveModel , which represents a Ractive instance, and the  GlobalModel , which represents the global object of the current environment a.k.a.  window  for browsers and  global  for Node.js.", 
            "title": "Other models"
        }, 
        {
            "location": "/Concepts/Architecture/Model/#keymodel", 
            "text": "The last major model remaining is the  KeyModel . Instances of this represent indices of arrays and keys of objects during iteration. The key flavor never is immutable, becuase the keys of  objects never change (they may be removed, but that doesn't change the key itself). The index flavor  does  change, but only when the array represented by its parent model is shuffled.", 
            "title": "KeyModel"
        }, 
        {
            "location": "/Concepts/Architecture/View/", 
            "text": "Ractive views are structured virtual DOM trees that are assembled from template AST and manage DOM nodes on the page when they are rendered. Virtual DOM items are grouped together in \nFragment\ns, which contain them, and they may also own \nFragment\ns that contain other items. Each item may contain a reference to a DOM node when rendered, though every item doesn not have a DOM analog.\n\n\nStates\n\n\nItems generally follow a fixed lifecycle.\n\n\n\n\nConstruction - the item is created and knows about its parent and the template chunk from which it was created. Its template may also indicate what its children should look like if it has them.\n\n\nbind\n - the item looks up any references is may have and registers with the model(s) that they represent. At this point, the item may create child items and bind them as well.\n\n\nrender\n - the item may create an actual DOM node and tell its children to create their DOM nodes as necessary. The resulting nodes will be inserted into the document.\n\n\nunrender\n - thie item is no longer needed and will be removed from the document immediately or in the near future.\n\n\nunbind\n - this typically goes along with \nunrender\n and tells the models on which this item depends that they should no longer send change notifications to it.\n\n\n\n\nThere is a sixth floating step \nrebind\n that happens any time one dependency models shuffles (and in certain other very special circumstances) that causes the items to re-resolve their models and re-register if necessary.\n\n\nVirtual DOM Items\n\n\nText\n\n\nText is the simplest item. It simply holds a string that it turns into a \nTextNode\n when rendered.\n\n\nInterpolator\n\n\nThis is the next simplest item. It resolves a model for its reference or expression and renders the value of the model as a text node if needed. Interpolators don't necessarily render directly, as they may be used for values by other items, such as attributes, mappings, and bindings.\n\n\nElement\n\n\nAn \nElement\n represents a DOM element. It also contains a number of other items in the form of \nAttribute\ns, \nDecorator\ns, \nTransition\ns, \nEventDirective\ns, and its children in a \nFragment\n.\n\n\nAttributes\n\n\nThere are actually several different items that are treated as attributes for \nElement\ns, event though only two of them actually may render into the DOM.\n\n\n\n\nAttribute\ns - maybe obvious, they these represent a DOM attribute on their parent element. There are a number of different handlers for updating attributes depending on the element and attribute name. The \nupdateDelegate\n for a particular attribute can be found in \ngetUpdateDelegate.js\n.\n\n\nConditionalAttribute\ns - render as a string and are parsed into actual DOM attributes using a \ndiv\n or an \nsvg\n depending on their parent element.\n\n\nMapping\ns - when rendered add a mapping to their component, and when unrendered, remove it. These aren't attached to \nElement\ns, but instead, are attached to \nComponent\ns (see below).\n\n\nEventDirective\ns - when rendered attach an event listener to their parent, and when unrenedered, remove it. Event parameters are kept in sync with their bindings and are evaluated when the event fires.\n\n\nBindingDirective\ns - when rendered and unrendered update their parent element's bindings, if they exist.\n\n\nDecorator\ns - when rendered call the named decorator with their parent element, and when unrenedered, remove it. \nDecorator\ns also have an update cycle related to their parameters.\n\n\nTransition\ns - are a sort of weird case. When rendered, they attach a transition handler to their element, and when the element renders or unrenders, if an appropriate transition handler is registered, will trigger the transition. Transition parameters are also kept in sync with their bindings.\n\n\n\n\nBindings\n\n\nCertain attributes may also trigger a binding to be created on their parent element. For instance, if two-way binding is enabled on the parent element, and the parent element is an \ninput\n, a \nvalue\n attribute with a single \nInterpolator\n as its content will cause a two-way binding to be created between the value of the \ninput\n and the model of the \nInterpolator\n. This binding will handle updating the model when the input \nvalue\n has changed. There are a few other types of bindings for managing check values, content editables, name-bound lists of checkboxes, and other miscellaneous special values.\n\n\nA \nlazy\n binding directive will cause any associated two-way bindings to fire either after a timeout or on blur, depending on the value of the \nlazy\n directive.\n\n\nSection\n\n\nSection\ns come in many flavors, depending on the chunk of template from which they are created. A section may provide context, be conditional (positive or negative), or be iterative. Generic sections (\n{{#something}}...{{/}}\n in template) will adjust their type, to a certain extent, based on the value of their model. A generic section will always provide context in the form of their model. An \nif\n-style conditional section, including \nelseif\n, \nelse\n, and \nunless\n do not provide context. An \neach\n section will always provide context in the form of the current iteration. A \nwith\n section will always provide context as its model, but it will only render if its model is considered truthy by Ractive, which is pretty much the same as JS truthy except \n{}\n and \n[]\n are falsey. A generic section will be context/conditional if it is anything other than an array, which will make it iterative.\n\n\nSections that provide context do so by binding their \nFragment\ns with their model so that the reference resolution process can find the appropriate contexts when resolving.\n\n\nContext/Conditional\n\n\nContext and conditional sections will render and unrender their child fragment as their model changes truthiness. Conditional sections always stand alone, even it they have \nelseif\n or \nelse\n branches nested within them, because those branches are turned into independent sections during parsing.\n\n\nIterative\n\n\nIf section is designated iterative (\n{{#each ...}}\n) or is a general section with an array value resolution, the section will create a special form of fragment for each index or key in the value. The special form \nRepeatedFragment\n handles mapping of indices, keys, and references to those to a corresponding model. Iterative sections also have special handling for shuffles so that DOM is not wholesale destroyed and recreated when the array shuffles.\n\n\nIterative sections may supply an alias for their context, so that referencing the iterated value is a little bit easier. See \nAliases\n below for more info, as this is just a slightly specialized form of that.\n\n\nIterative sections may also supply key and/or index aliases so that their keys and/or indices may be referenced by a name from within their child fragments.\n\n\nAlias\n\n\nAlias sections simply resolve their models and act as a lookup endpoint for reference resolution. Aliasing happens entirely in the view.\n\n\nComponent\n\n\nA component is a sort-of special form of \nElement\n that, instead of creating a DOM element, creates a new Ractive instance. The child instance will be rendered and unrendered in place of the component placeholder in the DOM.\n\n\nAny plain \nAttribute\ns with a single \nInterpolator\n as content in a component's template are turned into \nMapping\ns.\n\n\nResolution\n\n\nThe resolution process for references requires a keypath and a \nFragment\n as a starting point.\n\n\n\n\nIf the reference is a special reference (\n@index\n, \n@this\n, etc), the appropriate model is looked up and returned.\n\n\nIf the reference is relative (starts with \n~/\n, \n.\n, or \n../\n) the appropriate base model is retrieved and the rest of the keypath is joined onto it and the resulting model is returned.\n\n\nIf the reference is non-relative and the base of the keypath is a member of the current context, then the context is joined to the keypath and the resulting model is returned.\n\n\nThe reference is ambiguous, so the following loop until resolution or no fragments are left, starting with the given fragment:\n\n\nIf the fragment is an iteration, check to see if there is an index or key alias that matches the root of the reference, and if so, return it.\n\n\nIf the fragment has aliases, check to see if there is one that matches the root of the reference, and if so, return it.\n\n\nIf the fragment has context:\n\n\nIf the fragment is the root of an instance, note it\n\n\nIf the context has a child matching the root of the reference:\n\n\nIf we crossed a component boundary, create an implicit mapping the to the newly discovered model in the current component.\n\n\nReturn it\n\n\n\n\n\n\nIf the fragment belongs to a component, use the component's parent fragment and loop.\n\n\nUse the fragment's parent and loop.\n\n\n\n\nThe resolution process is no longer happens strictly the vDOM, as the result of \nRactive.getNodeInfo\n also uses the target \nElement\n's fragment to resolve relative references. Event objects are also extended with methods from the same helper.\n\n\nUpdates\n\n\nThe \nrunloop\n controls when the DOM is actually updated and when transitions start in \nbatch\nes. It also handles resolving promises when transitions have completed and the DOM is completely up to date.\n\n\nAs changes propagate through the viewmodel, view items are notified of the change through their \nhandleChange\n method. Most items just set a dirty flag and notify their parent, via their \nbubble\n method, that they will need to be updated at the completion of the runloop turn. The root fragment of each instance affected will then register with the runloop. Once the changes are ready to be flushed to the view, each fragment registered with the runloop is called on to update, where the process happens in reverse, with each parent fragment checking to see if there is a change it needs to respond to and propagating the update downward to its children.", 
            "title": "View"
        }, 
        {
            "location": "/Concepts/Architecture/View/#states", 
            "text": "Items generally follow a fixed lifecycle.   Construction - the item is created and knows about its parent and the template chunk from which it was created. Its template may also indicate what its children should look like if it has them.  bind  - the item looks up any references is may have and registers with the model(s) that they represent. At this point, the item may create child items and bind them as well.  render  - the item may create an actual DOM node and tell its children to create their DOM nodes as necessary. The resulting nodes will be inserted into the document.  unrender  - thie item is no longer needed and will be removed from the document immediately or in the near future.  unbind  - this typically goes along with  unrender  and tells the models on which this item depends that they should no longer send change notifications to it.   There is a sixth floating step  rebind  that happens any time one dependency models shuffles (and in certain other very special circumstances) that causes the items to re-resolve their models and re-register if necessary.", 
            "title": "States"
        }, 
        {
            "location": "/Concepts/Architecture/View/#virtual-dom-items", 
            "text": "", 
            "title": "Virtual DOM Items"
        }, 
        {
            "location": "/Concepts/Architecture/View/#text", 
            "text": "Text is the simplest item. It simply holds a string that it turns into a  TextNode  when rendered.", 
            "title": "Text"
        }, 
        {
            "location": "/Concepts/Architecture/View/#interpolator", 
            "text": "This is the next simplest item. It resolves a model for its reference or expression and renders the value of the model as a text node if needed. Interpolators don't necessarily render directly, as they may be used for values by other items, such as attributes, mappings, and bindings.", 
            "title": "Interpolator"
        }, 
        {
            "location": "/Concepts/Architecture/View/#element", 
            "text": "An  Element  represents a DOM element. It also contains a number of other items in the form of  Attribute s,  Decorator s,  Transition s,  EventDirective s, and its children in a  Fragment .", 
            "title": "Element"
        }, 
        {
            "location": "/Concepts/Architecture/View/#attributes", 
            "text": "There are actually several different items that are treated as attributes for  Element s, event though only two of them actually may render into the DOM.   Attribute s - maybe obvious, they these represent a DOM attribute on their parent element. There are a number of different handlers for updating attributes depending on the element and attribute name. The  updateDelegate  for a particular attribute can be found in  getUpdateDelegate.js .  ConditionalAttribute s - render as a string and are parsed into actual DOM attributes using a  div  or an  svg  depending on their parent element.  Mapping s - when rendered add a mapping to their component, and when unrendered, remove it. These aren't attached to  Element s, but instead, are attached to  Component s (see below).  EventDirective s - when rendered attach an event listener to their parent, and when unrenedered, remove it. Event parameters are kept in sync with their bindings and are evaluated when the event fires.  BindingDirective s - when rendered and unrendered update their parent element's bindings, if they exist.  Decorator s - when rendered call the named decorator with their parent element, and when unrenedered, remove it.  Decorator s also have an update cycle related to their parameters.  Transition s - are a sort of weird case. When rendered, they attach a transition handler to their element, and when the element renders or unrenders, if an appropriate transition handler is registered, will trigger the transition. Transition parameters are also kept in sync with their bindings.", 
            "title": "Attributes"
        }, 
        {
            "location": "/Concepts/Architecture/View/#bindings", 
            "text": "Certain attributes may also trigger a binding to be created on their parent element. For instance, if two-way binding is enabled on the parent element, and the parent element is an  input , a  value  attribute with a single  Interpolator  as its content will cause a two-way binding to be created between the value of the  input  and the model of the  Interpolator . This binding will handle updating the model when the input  value  has changed. There are a few other types of bindings for managing check values, content editables, name-bound lists of checkboxes, and other miscellaneous special values.  A  lazy  binding directive will cause any associated two-way bindings to fire either after a timeout or on blur, depending on the value of the  lazy  directive.", 
            "title": "Bindings"
        }, 
        {
            "location": "/Concepts/Architecture/View/#section", 
            "text": "Section s come in many flavors, depending on the chunk of template from which they are created. A section may provide context, be conditional (positive or negative), or be iterative. Generic sections ( {{#something}}...{{/}}  in template) will adjust their type, to a certain extent, based on the value of their model. A generic section will always provide context in the form of their model. An  if -style conditional section, including  elseif ,  else , and  unless  do not provide context. An  each  section will always provide context in the form of the current iteration. A  with  section will always provide context as its model, but it will only render if its model is considered truthy by Ractive, which is pretty much the same as JS truthy except  {}  and  []  are falsey. A generic section will be context/conditional if it is anything other than an array, which will make it iterative.  Sections that provide context do so by binding their  Fragment s with their model so that the reference resolution process can find the appropriate contexts when resolving.", 
            "title": "Section"
        }, 
        {
            "location": "/Concepts/Architecture/View/#contextconditional", 
            "text": "Context and conditional sections will render and unrender their child fragment as their model changes truthiness. Conditional sections always stand alone, even it they have  elseif  or  else  branches nested within them, because those branches are turned into independent sections during parsing.", 
            "title": "Context/Conditional"
        }, 
        {
            "location": "/Concepts/Architecture/View/#iterative", 
            "text": "If section is designated iterative ( {{#each ...}} ) or is a general section with an array value resolution, the section will create a special form of fragment for each index or key in the value. The special form  RepeatedFragment  handles mapping of indices, keys, and references to those to a corresponding model. Iterative sections also have special handling for shuffles so that DOM is not wholesale destroyed and recreated when the array shuffles.  Iterative sections may supply an alias for their context, so that referencing the iterated value is a little bit easier. See  Aliases  below for more info, as this is just a slightly specialized form of that.  Iterative sections may also supply key and/or index aliases so that their keys and/or indices may be referenced by a name from within their child fragments.", 
            "title": "Iterative"
        }, 
        {
            "location": "/Concepts/Architecture/View/#alias", 
            "text": "Alias sections simply resolve their models and act as a lookup endpoint for reference resolution. Aliasing happens entirely in the view.", 
            "title": "Alias"
        }, 
        {
            "location": "/Concepts/Architecture/View/#component", 
            "text": "A component is a sort-of special form of  Element  that, instead of creating a DOM element, creates a new Ractive instance. The child instance will be rendered and unrendered in place of the component placeholder in the DOM.  Any plain  Attribute s with a single  Interpolator  as content in a component's template are turned into  Mapping s.", 
            "title": "Component"
        }, 
        {
            "location": "/Concepts/Architecture/View/#resolution", 
            "text": "The resolution process for references requires a keypath and a  Fragment  as a starting point.   If the reference is a special reference ( @index ,  @this , etc), the appropriate model is looked up and returned.  If the reference is relative (starts with  ~/ ,  . , or  ../ ) the appropriate base model is retrieved and the rest of the keypath is joined onto it and the resulting model is returned.  If the reference is non-relative and the base of the keypath is a member of the current context, then the context is joined to the keypath and the resulting model is returned.  The reference is ambiguous, so the following loop until resolution or no fragments are left, starting with the given fragment:  If the fragment is an iteration, check to see if there is an index or key alias that matches the root of the reference, and if so, return it.  If the fragment has aliases, check to see if there is one that matches the root of the reference, and if so, return it.  If the fragment has context:  If the fragment is the root of an instance, note it  If the context has a child matching the root of the reference:  If we crossed a component boundary, create an implicit mapping the to the newly discovered model in the current component.  Return it    If the fragment belongs to a component, use the component's parent fragment and loop.  Use the fragment's parent and loop.   The resolution process is no longer happens strictly the vDOM, as the result of  Ractive.getNodeInfo  also uses the target  Element 's fragment to resolve relative references. Event objects are also extended with methods from the same helper.", 
            "title": "Resolution"
        }, 
        {
            "location": "/Concepts/Architecture/View/#updates", 
            "text": "The  runloop  controls when the DOM is actually updated and when transitions start in  batch es. It also handles resolving promises when transitions have completed and the DOM is completely up to date.  As changes propagate through the viewmodel, view items are notified of the change through their  handleChange  method. Most items just set a dirty flag and notify their parent, via their  bubble  method, that they will need to be updated at the completion of the runloop turn. The root fragment of each instance affected will then register with the runloop. Once the changes are ready to be flushed to the view, each fragment registered with the runloop is called on to update, where the process happens in reverse, with each parent fragment checking to see if there is a change it needs to respond to and propagating the update downward to its children.", 
            "title": "Updates"
        }, 
        {
            "location": "/Concepts/Data Binding/Array Modification/", 
            "text": "Ractive can intercept the \nmutator methods\n (\npop\n, \npush\n, \nshift\n, \nunshift\n, \nsplice\n, \nsort\n and \nreverse\n) of arrays that it \ndepends on\n for more convenient data binding.\n\n\nConsider the following:\n\n\nul\n\n  {{#list}}\n    \nli\n{{this}}\n/li\n\n  {{/list}}\n\n/ul\n\n\n\n\n\nlist = [ 'a', 'b', 'c' ];\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: { list: list }\n});\n\nlist.push( 'd' ); // adds a new list item - \nli\nd\n/li\n\n\n\n\n\nYou can enable this behaviour by passing in \nmodifyArrays: true\n as an \ninitialisation options\n.\n\n\nHow it works\n\n\nDon't worry, we're not modifying \nArray.prototype\n. (What do you think this is, \nEmber\n? :-)\n\n\nInstead, we're using a technique called \nprototype chain injection\n, which allows us to remain performant and memory-efficient without mucking about extending native objects.\n\n\nThis uses the non-standard (but very unlikely to disappear!) \n__proto__\n property. That might seem kludgy, but if \nMike Bostock thinks it's okay\n then that's good enough for us.\n\n\nOlder browsers (I'm looking at you, IE8) don't support \n__proto__\n - in these cases, we simply add the wrapped methods as properties of the array itself.\n\n\nAs well as intercepting or wrapping the mutator methods, Ractive adds a (non-enumerable, in modern browsers) \n_ractive\n property to arrays, which contains information about which Ractive instances depend on the array, and which keypaths it is assigned to.\n\n\nHygiene\n\n\nWhen an array is no longer depended on by any Ractive instances, we can revert it to its normal state - resetting its prototype (if we used prototype chain injection) or deleting the wrapped methods (if we're in a crap browser), and removing the \n_ractive\n property.\n\n\nPerformance and UI benefits\n\n\nAs well as convenience, using arrays like this helps Ractive make smart decisions about how to update the DOM. Continuing the example above, compare these two alternative methods of inserting a new item at the \nstart\n of our list:\n\n\n// at the moment, list = [ 'a', 'b', 'c', 'd' ]\n\n// 1. Reset the list:\nractive.set( 'list', [ 'z', 'a', 'b', 'c', 'd' ] )\n\n// 2. Use `unshift`:\nlist.unshift( 'z' );\n\n\n\n\nIn the first example, Ractive will see that the content of the first list item has changed from \n'a'\n to \n'z'\n, and that the second has changed from \n'b'\n to \n'a'\n, and so on, and update the DOM accordingly. It will also see that there is now a fifth item, so will append \nli\nd\n/li\n to the list.\n\n\nIn the second example, Ractive will understand that all it needs to do is insert \nli\nz\n/li\n at the start of the list, leaving everything else untouched.\n\n\nThis is particularly important if you're using \ntransitions\n, as it will be obvious to the user which elements are being added and removed.\n\n\nNote that if \nlist.unshift('z')\n isn't an option, you could use \nractive.merge()\n to achieve the same effect.", 
            "title": "Array Modification"
        }, 
        {
            "location": "/Concepts/Data Binding/Array Modification/#how-it-works", 
            "text": "Don't worry, we're not modifying  Array.prototype . (What do you think this is,  Ember ? :-)  Instead, we're using a technique called  prototype chain injection , which allows us to remain performant and memory-efficient without mucking about extending native objects.  This uses the non-standard (but very unlikely to disappear!)  __proto__  property. That might seem kludgy, but if  Mike Bostock thinks it's okay  then that's good enough for us.  Older browsers (I'm looking at you, IE8) don't support  __proto__  - in these cases, we simply add the wrapped methods as properties of the array itself.  As well as intercepting or wrapping the mutator methods, Ractive adds a (non-enumerable, in modern browsers)  _ractive  property to arrays, which contains information about which Ractive instances depend on the array, and which keypaths it is assigned to.", 
            "title": "How it works"
        }, 
        {
            "location": "/Concepts/Data Binding/Array Modification/#hygiene", 
            "text": "When an array is no longer depended on by any Ractive instances, we can revert it to its normal state - resetting its prototype (if we used prototype chain injection) or deleting the wrapped methods (if we're in a crap browser), and removing the  _ractive  property.", 
            "title": "Hygiene"
        }, 
        {
            "location": "/Concepts/Data Binding/Array Modification/#performance-and-ui-benefits", 
            "text": "As well as convenience, using arrays like this helps Ractive make smart decisions about how to update the DOM. Continuing the example above, compare these two alternative methods of inserting a new item at the  start  of our list:  // at the moment, list = [ 'a', 'b', 'c', 'd' ]\n\n// 1. Reset the list:\nractive.set( 'list', [ 'z', 'a', 'b', 'c', 'd' ] )\n\n// 2. Use `unshift`:\nlist.unshift( 'z' );  In the first example, Ractive will see that the content of the first list item has changed from  'a'  to  'z' , and that the second has changed from  'b'  to  'a' , and so on, and update the DOM accordingly. It will also see that there is now a fifth item, so will append  li d /li  to the list.  In the second example, Ractive will understand that all it needs to do is insert  li z /li  at the start of the list, leaving everything else untouched.  This is particularly important if you're using  transitions , as it will be obvious to the user which elements are being added and removed.  Note that if  list.unshift('z')  isn't an option, you could use  ractive.merge()  to achieve the same effect.", 
            "title": "Performance and UI benefits"
        }, 
        {
            "location": "/Concepts/Data Binding/Computed Properties/", 
            "text": "The idea is fairly simple: you can define computed properties that update reactively based on their dependencies. In previous versions you may have done something as follows.\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '{{width}} * {{height}} = {{ area() }}', // note the function invocation\n  data: {\n    width: 100,\n    height: 100,\n    area: function () { return this.get( 'width' ) * this.get( 'height' ); }\n  }\n});\n\n\n\n\nThat's nice and all - the \n{{ area() }}\n mustache updates reactively as \nwidth\n and \nheight\n change - but it's limited. To get the area value programmatically you'd have to do something like...\n\n\narea = ractive.get('area').call(ractive);\n\n\n\n\n...which effectively prevents you from composing computed values together in any meaningful way. And you can't 'observe' the area outside of the template, without doing something like this:\n\n\nractive.observe( 'width height', function () {\n    var area = this.get( 'width' ) * this.get( 'height' );\n    doSomething( area );\n});\n\n\n\n\nComputed properties to the rescue\n\n\nNow, you can do\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '{{width}} * {{height}} = {{area}}', // `area` looks like a regular property\n  data: {\n    width: 100,\n    height: 100\n  },\n  computed: {\n    area: function () { return this.get( 'width' ) * this.get( 'height' ); }\n  }\n});\n\n\n\n\nWith this, the \narea\n property can be treated like any other. It will update reactively (because the calls to \nractive.get()\n tell Ractive that it should be recomputed when \nwidth\n or \nheight\n change), so you can do...\n\n\nractive.observe( 'area', doSomething );\n\n\n\n\n...instead of manually recalculating it. And computed values can depend on other computed values, and so on (before anyone asks, we're not doing a topological sort or anything fancy like that - in real world scenarios I'd expect the overhead of doing the sort to be greater than the cost of occasionally recomputing a node in the dependency graph more times than is required).\n\n\nCompact syntax\n\n\nThe syntax used above, where each computed property is defined as a function, gives you a lot of flexibility. But there's a more compact string syntax you can use:\n\n\nractive = new Ractive({\n  ...,\n  computed: {\n    area: '${width} * ${height}'\n  }\n});\n\n\n\n\nThis string is turned into a function with the \nFunction\n constructor (which unfortunately means it isn't \nCSP compliant\n) - any \n${...}\n blocks are basically turned into \nractive.get('...')\n, so it works exactly the same way. Needless to say you can use any JavaScript here - \n${foo}.toUpperCase()\n, \nMath.round(${num})\n, and so on.\n\n\nSetting computed values\n\n\nBy default, computed values are read-only, and if you try to \nractive.set('someComputedProperty')\n an error will be thrown. But you can use a third syntax option which allows you to declare a \nset()\n method:\n\n\nractive = new Ractive({\n  data: { firstname: 'Douglas', lastname: 'Crockford' },\n  computed: {\n    fullname: {\n      get: '${firstname} + \n \n + ${lastname}', // or use the function syntax\n      set: function ( fullname ) {\n        var names = fullname.split( ' ' );\n\n        this.set({\n          firstname: names[0] || '',\n          lastname: names[1] || ''\n        });\n      }\n    }\n  }\n});\n\nractive.set( 'fullname', 'Rich Harris' );\n\nractive.get( 'firstname' ); // Rich\nractive.get( 'lastname' ); // Harris\n\n\n\n\nComponents\n\n\nYou can, of course, declare computed values on components:\n\n\nBox = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nbox = new Box({\n  ...,\n  data: { width: 20, height: 40 }\n});\n\nbox.get( 'area' ); // 800\n\n\n\n\nAdditional computed properties can be declared on the instance:\n\n\nbox2 = new Box({\n  ...,\n  data: { width: 20, height: 40, depth: 60 },\n  computed: { volume: '${area} * ${depth}' }\n});\n\nbox2.get( 'area' ); // 800\nbox2.get( 'volume' ); // 48000\n\n\n\n\nData context for computed properties\n\n\nComputed properties can only be calculated for the instance context as a whole. You can't, for example, directly\ncompute a value for each member of an array:\n\n\nnew Ractive({\n  template: '{{#boxes}}{{area}}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  // there's no way to specify this for \neach\n box :(\n  computed: { area: '${width} * ${height}' }\n});\n\n\n\n\nThe solution is to either use a function that calculates the value for each member:\n\n\n  template: '{{#boxes:b}}{{ getArea(b) }}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ],\n    getArea: function ( i ) {\n      var box = this.get( 'boxes.' + i );\n      return box.width * box.area;\n    }\n  }\n\n\n\n\nOr leverage a component to \"scope\" the data to each item:\n\n\nBox = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nnew Ractive({\n  template: '{{#boxes}}\nbox/\n{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  components: { box: Box }\n});", 
            "title": "Computed Properties"
        }, 
        {
            "location": "/Concepts/Data Binding/Computed Properties/#computed-properties-to-the-rescue", 
            "text": "Now, you can do  ractive = new Ractive({\n  el: 'body',\n  template: '{{width}} * {{height}} = {{area}}', // `area` looks like a regular property\n  data: {\n    width: 100,\n    height: 100\n  },\n  computed: {\n    area: function () { return this.get( 'width' ) * this.get( 'height' ); }\n  }\n});  With this, the  area  property can be treated like any other. It will update reactively (because the calls to  ractive.get()  tell Ractive that it should be recomputed when  width  or  height  change), so you can do...  ractive.observe( 'area', doSomething );  ...instead of manually recalculating it. And computed values can depend on other computed values, and so on (before anyone asks, we're not doing a topological sort or anything fancy like that - in real world scenarios I'd expect the overhead of doing the sort to be greater than the cost of occasionally recomputing a node in the dependency graph more times than is required).", 
            "title": "Computed properties to the rescue"
        }, 
        {
            "location": "/Concepts/Data Binding/Computed Properties/#compact-syntax", 
            "text": "The syntax used above, where each computed property is defined as a function, gives you a lot of flexibility. But there's a more compact string syntax you can use:  ractive = new Ractive({\n  ...,\n  computed: {\n    area: '${width} * ${height}'\n  }\n});  This string is turned into a function with the  Function  constructor (which unfortunately means it isn't  CSP compliant ) - any  ${...}  blocks are basically turned into  ractive.get('...') , so it works exactly the same way. Needless to say you can use any JavaScript here -  ${foo}.toUpperCase() ,  Math.round(${num}) , and so on.", 
            "title": "Compact syntax"
        }, 
        {
            "location": "/Concepts/Data Binding/Computed Properties/#setting-computed-values", 
            "text": "By default, computed values are read-only, and if you try to  ractive.set('someComputedProperty')  an error will be thrown. But you can use a third syntax option which allows you to declare a  set()  method:  ractive = new Ractive({\n  data: { firstname: 'Douglas', lastname: 'Crockford' },\n  computed: {\n    fullname: {\n      get: '${firstname} +     + ${lastname}', // or use the function syntax\n      set: function ( fullname ) {\n        var names = fullname.split( ' ' );\n\n        this.set({\n          firstname: names[0] || '',\n          lastname: names[1] || ''\n        });\n      }\n    }\n  }\n});\n\nractive.set( 'fullname', 'Rich Harris' );\n\nractive.get( 'firstname' ); // Rich\nractive.get( 'lastname' ); // Harris", 
            "title": "Setting computed values"
        }, 
        {
            "location": "/Concepts/Data Binding/Computed Properties/#components", 
            "text": "You can, of course, declare computed values on components:  Box = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nbox = new Box({\n  ...,\n  data: { width: 20, height: 40 }\n});\n\nbox.get( 'area' ); // 800  Additional computed properties can be declared on the instance:  box2 = new Box({\n  ...,\n  data: { width: 20, height: 40, depth: 60 },\n  computed: { volume: '${area} * ${depth}' }\n});\n\nbox2.get( 'area' ); // 800\nbox2.get( 'volume' ); // 48000", 
            "title": "Components"
        }, 
        {
            "location": "/Concepts/Data Binding/Computed Properties/#data-context-for-computed-properties", 
            "text": "Computed properties can only be calculated for the instance context as a whole. You can't, for example, directly\ncompute a value for each member of an array:  new Ractive({\n  template: '{{#boxes}}{{area}}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  // there's no way to specify this for  each  box :(\n  computed: { area: '${width} * ${height}' }\n});  The solution is to either use a function that calculates the value for each member:    template: '{{#boxes:b}}{{ getArea(b) }}{{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ],\n    getArea: function ( i ) {\n      var box = this.get( 'boxes.' + i );\n      return box.width * box.area;\n    }\n  }  Or leverage a component to \"scope\" the data to each item:  Box = Ractive.extend({\n  template: boxTemplate,\n  computed: { area: '${width} * ${height}' }\n});\n\nnew Ractive({\n  template: '{{#boxes}} box/ {{/}}',\n  data: {\n    boxes: [\n      { width: 20, height: 40 },\n      { width: 30, height: 45 },\n      { width: 20, height: 20 }\n    ]\n  },\n  components: { box: Box }\n});", 
            "title": "Data context for computed properties"
        }, 
        {
            "location": "/Concepts/Data Binding/Dependents/", 
            "text": "Ractive maintains a \ndependency graph\n in order to do the minimum amount of work necessary to keep the DOM up-to-date.\n\n\nIf you inspect a Ractive instance in your console, you'll see a property called \n_deps\n. This is where all dependants are listed, indexed by their dependency.\n\n\nThere is also a concept of 'priority', which exists to save us some work. If, for example, a section needs to be removed (perhaps it's a conditional section, and the condition just went from truthy to falsy), there is no point in updating all its children, so we make sure that we teardown the section first. As part of that teardown process, the children - which all have lower priority - unregister themselves as dependants before they get a chance to update.\n\n\nIndirect dependencies\n\n\nIf you have a mustache which depends on \nfoo.bar\n, and \nfoo\n changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an \nindirect dependency\n on \nfoo\n, or that it has a \ndirect dependency on a downstream keypath\n of \nfoo\n.\n\n\nThis relationship is expressed through the \n_depsMap\n property of a Ractive instance - whenever \nfoo\n changes, as well as dealing with direct \nfoo\n dependants we check the map for those indirect dependants.\n\n\nIn the case of \nexpressions\n and \nobservers\n, we also need to consider dependants of \nupstream keypaths\n. For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:\n\n\n{{#( sort( list, 'name' ) )}}\n  \np\n{{name}}\n/p\n\n{{/()}}\n\n\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],\n    sort: function ( list, property ) {\n      return list.slice().sort( function ( a, b ) {\n        return a[ property ] \n b[ property ] ? -1 : 1;\n      });\n    }\n  }\n});\n\n// renders Alice, Bob, Charles\n\nractive.set( 'list[0].name', 'Zebediah' );\n\n// updates to Alice, Charles, Zebediah\n\n\n\n\nIn the example, setting \nlist[0].name\n causes dependants of \nlist\n to be updated.\n\n\nAs well as \nexpressions\n, \nObservers\n respond to both upstream and downstream changes.\n\n\nExpressions with multiple dependencies\n\n\nThe expression \n{{ a + b }}\n has two dependencies - \na\n and \nb\n (or more accurately, whatever those \nreferences\n resolve to). The \n_deps\n graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.\n\n\nBecause the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing \nractive.set({ a: 1, b: 2 })\n will only trigger one update, not two.", 
            "title": "Dependents"
        }, 
        {
            "location": "/Concepts/Data Binding/Dependents/#indirect-dependencies", 
            "text": "If you have a mustache which depends on  foo.bar , and  foo  changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an  indirect dependency  on  foo , or that it has a  direct dependency on a downstream keypath  of  foo .  This relationship is expressed through the  _depsMap  property of a Ractive instance - whenever  foo  changes, as well as dealing with direct  foo  dependants we check the map for those indirect dependants.  In the case of  expressions  and  observers , we also need to consider dependants of  upstream keypaths . For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:  {{#( sort( list, 'name' ) )}}\n   p {{name}} /p \n{{/()}}  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],\n    sort: function ( list, property ) {\n      return list.slice().sort( function ( a, b ) {\n        return a[ property ]   b[ property ] ? -1 : 1;\n      });\n    }\n  }\n});\n\n// renders Alice, Bob, Charles\n\nractive.set( 'list[0].name', 'Zebediah' );\n\n// updates to Alice, Charles, Zebediah  In the example, setting  list[0].name  causes dependants of  list  to be updated.  As well as  expressions ,  Observers  respond to both upstream and downstream changes.", 
            "title": "Indirect dependencies"
        }, 
        {
            "location": "/Concepts/Data Binding/Dependents/#expressions-with-multiple-dependencies", 
            "text": "The expression  {{ a + b }}  has two dependencies -  a  and  b  (or more accurately, whatever those  references  resolve to). The  _deps  graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.  Because the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing  ractive.set({ a: 1, b: 2 })  will only trigger one update, not two.", 
            "title": "Expressions with multiple dependencies"
        }, 
        {
            "location": "/Concepts/Data Binding/Magic Mode/", 
            "text": "Normally, you would update data using \narray mutator methods\n.\n\n\nIf you're fortunate enough to be developing for modern browsers only, however, you have another option: magic mode. Magic mode uses ES5 accessors to allow you to do this:\n\n\nvar model = { message: 'hello' };\n\nvar ractive = new Ractive({\n  el: container,\n  template: 'message: {{message}}',\n  magic: true,\n  data: model\n});\n\n// instead of doing `ractive.set( 'message', 'goodbye' )`...\nmodel.message = 'goodbye';\n\n\n\n\nES what?\n\n\nECMAScript 5 is the current version of the language more commonly known as JavaScript. Most ES5 features are widely supported in all current browsers.\n\n\nOne feature in particular, \nObject.defineProperty\n, allows us to define \naccessors\n, which are functions that get called when you get or set the value of a property on an object. For those curious, \nMDN has comprehensive docs\n.\n\n\n(If you have to support IE8, or particularly old versions of Firefox or Opera, you may as well stop reading unfortunately. There's a \ncompatibility table here\n. Don't be fooled by the 'yes' under IE8 - it's a broken implementation. Shocking, I know. Attempting to use magic mode in one of these browsers will cause Ractive to throw an error.)\n\n\nRactive, in magic mode, will \nwrap\n properties with accessors where necessary, saving you the work.\n\n\nWhy not to use it\n\n\nAside from the compatibility issue, there is a performance implication to be aware of. Wrapping and unwrapping properties isn't completely free, and using accessors (instead of direct property access) has a slight cost as well.\n\n\nIn the vast majority of cases this won't matter - we're talking fractions of milliseconds - but if you're \nreally\n into performance, you might want to use the explicit \nractive.set()\n approach. (Of course, you can still use the explicit methods when you're in magic mode.)\n\n\nAlso, be aware that if you have a situation like this...\n\n\ndiv style='color: {{color}}; opacity: {{opacity}};'\nsome content\n/div\n\n\n\n\n\n...then using \nractive.set({ color: 'red', opacity: 0.5 })\n would only cause one DOM update, whereas \nmodel.color = 'red'\n followed by \nmodel.opacity = 0.5\n would cause two. Again, in most real-world situations that's not a problem.\n\n\nUsing magic mode with arrays\n\n\nMagic mode only works with properties that Ractive already knows about. Which means that if you do this...\n\n\nul\n\n  {{#items}}\n    \nli\n{{.}}\n/li\n\n  {{/items}}\n\n/ul\n\n\n\n\n\nvar items = [ 'a', 'b', 'c' ];\n\nvar ractive = new Ractive({\n  el: container,\n  template: myTemplate,\n  magic: true,\n  data: { items: items }\n});\n\n\n\n\n...you can't add items to the list by doing \nitems[3] = 'd'\n, for example. Instead, do \nitems.push('d')\n, so Ractive becomes aware of the \nitems[3]\n property.", 
            "title": "Magic Mode"
        }, 
        {
            "location": "/Concepts/Data Binding/Magic Mode/#es-what", 
            "text": "ECMAScript 5 is the current version of the language more commonly known as JavaScript. Most ES5 features are widely supported in all current browsers.  One feature in particular,  Object.defineProperty , allows us to define  accessors , which are functions that get called when you get or set the value of a property on an object. For those curious,  MDN has comprehensive docs .  (If you have to support IE8, or particularly old versions of Firefox or Opera, you may as well stop reading unfortunately. There's a  compatibility table here . Don't be fooled by the 'yes' under IE8 - it's a broken implementation. Shocking, I know. Attempting to use magic mode in one of these browsers will cause Ractive to throw an error.)  Ractive, in magic mode, will  wrap  properties with accessors where necessary, saving you the work.", 
            "title": "ES what?"
        }, 
        {
            "location": "/Concepts/Data Binding/Magic Mode/#why-not-to-use-it", 
            "text": "Aside from the compatibility issue, there is a performance implication to be aware of. Wrapping and unwrapping properties isn't completely free, and using accessors (instead of direct property access) has a slight cost as well.  In the vast majority of cases this won't matter - we're talking fractions of milliseconds - but if you're  really  into performance, you might want to use the explicit  ractive.set()  approach. (Of course, you can still use the explicit methods when you're in magic mode.)  Also, be aware that if you have a situation like this...  div style='color: {{color}}; opacity: {{opacity}};' some content /div   ...then using  ractive.set({ color: 'red', opacity: 0.5 })  would only cause one DOM update, whereas  model.color = 'red'  followed by  model.opacity = 0.5  would cause two. Again, in most real-world situations that's not a problem.", 
            "title": "Why not to use it"
        }, 
        {
            "location": "/Concepts/Data Binding/Magic Mode/#using-magic-mode-with-arrays", 
            "text": "Magic mode only works with properties that Ractive already knows about. Which means that if you do this...  ul \n  {{#items}}\n     li {{.}} /li \n  {{/items}} /ul   var items = [ 'a', 'b', 'c' ];\n\nvar ractive = new Ractive({\n  el: container,\n  template: myTemplate,\n  magic: true,\n  data: { items: items }\n});  ...you can't add items to the list by doing  items[3] = 'd' , for example. Instead, do  items.push('d') , so Ractive becomes aware of the  items[3]  property.", 
            "title": "Using magic mode with arrays"
        }, 
        {
            "location": "/Concepts/Data Binding/Observers/", 
            "text": "Like publish/subscribe, but different\n\n\nA common pattern in modern JavaScript is to make models \nobservable\n, using the traditional \npublish/subscribe\n mechanism.\n\n\nFor example, you can observe changes to attributes within a Backbone Model like so:\n\n\nmodel = Backbone.Model({ myValue: 1 });\n\nmodel.on( 'change:myValue', function ( model, value, options ) {\n  alert( 'myValue changed to ' + value );\n});\n\nmodel.set( 'myValue', 2 ); // alerts 'myValue changed to 2'\n\n\n\n\nThis works because \nBackbone.Model.prototype\n inherits from \nBackbone.Events\n.\n\n\nRactive implements pub/sub with \nractive.on()\n, \nractive.off()\n and \nractive.fire()\n, \nractive.off()\n and \nractive.fire\n - see \nEvents\n for more info.\n\n\nObserving models with nested properties\n\n\nBut the normal pub/sub mechanism won't work for monitoring data changes with Ractive, because our data can contain nested properties. It's no good subscribing to a \nchange:foo.bar\n event, if \nfoo.bar\n can change as a result of \nfoo\n changing.\n\n\nSo instead, we introduce the concept of \nobservers\n.\n\n\nAn observer observes a particular \nkeypath\n, and is \nnotified\n when the value of its keypath changes, whether directly or indirectly (because an \nupstream\n or \ndownstream\n keypath changed). You create one with \nractive.observe()\n (see \nractive.observe()\n for full method\nAPI).\n\n\nHere's an example:\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    foo: { bar: 1 }\n  }\n});\n\n// The observer will be initialised with ( currentValue, undefined ) unless\n// we pass a third `options` argument in which `init` is `false`. In other\n// words this will alert 'foo.bar changed to 1'\nobserver = ractive.observe( 'foo.bar', function ( newValue, oldValue, keypath ) {\n  alert( keypath + ' changed to ' + newValue );\n});\n\nractive.set( 'foo.bar', 2 ); // alerts 'foo.bar changed to 2'\nractive.get( 'foo' ); // returns { bar: 2 }\n\nractive.set( 'foo', { bar: 3 }); // alerts 'foo.bar changed to 3'\nractive.get( 'foo.bar' ); // returns 3\n\nobserver.cancel();\n\nractive.set( 'foo.bar', 4 ); // alerts nothing; the observer was cancelled\n\n\n\n\nObservers are most useful in the context of \ntwo\u2010way binding\n.\n\n\nPattern Observers\n\n\nIt is useful to observe on specific keypaths but in the event your data contains array, or a set of dynamic data it isn't logical to bind to every potential keypath that could exist. Pattern observers use a \n*\n to indicate to Ractive that you would like to be notified whenever anything changes in your data at a particular depth as well as below the specified depth.\n\n\nThere are a few caveats when it comes to observing on array data, when observing on keypath \npeople.*\n you are observing on the length of the array. This means that the \nnewValue\n will be the index at which the new object was pushed. However when you use \nset\n to change an item at a particular index or a key that is on an object in the array then it will provide the object as the \nnewValue\n.\n\n\nvar ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    people: [\n      {name: 'Rich Harris'},\n      {name: 'Marty Nelson'}\n    ]\n  }\n});\n\nractive.observe('people.*', function(newValue, oldValue, keypath) {\n\n});\n\nvar people = ractive.get('people');\npeople.push({name: 'Jason Brown'});\n//newValue will equal 3, and the keypath will be people.length\n\nractive.set('people.3', {name: 'Jack Black'});\n//newValue will be {name: 'Jack Black'} and the keypath will be people.3\n\nractive.set('people.3.isACelebrity', true);\n//newValue will be {name: 'Jack Black', isACelebrity: true} and the keypath will be people.3\n\nractive.set('people.0.info.isCreator', true);\n//newValue will be the object for index 0 and the keypath will be people.0\n\n\n\n\n\nNotice that because you are observing at the array level that \nnewValue\n will be set as the entire object. What if you were only interested in knowing when a user became a celebrity? Simply tell Ractive you only want to observe dynamically on the array but only be notified when the \nisACelebrity\n key changes, \npeople.*.isACelebrity\n.\n\n\nractive.observe('people.*.isACelebrity', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('people.0.isACelebrity', true); //Rich Harris is a celebrity\n//newValue will be `true` and the keypath will be people.0.isACelebrity\n\n\n\n\n\nYou are not limited to just one \n*\n for your pattern, you can use as many as you would like and in any particular order.\n\n\n\nractive.observe('people.*.comments.*', function(newValue, oldValue, keypath) {\n\n});\n\n//even arrays of arrays\n\nractive.observe('people.*.*', function(newValue, oldValue, keypath) {\n\n});\n\n\n\n\n\nFurthermore it works on objects as well \nconfig.*\n will notify you when a value is changed on any key on the config object. However this differs from observing on an array in that it will provide the value set and keypath to the key that was set.\n\n\nvar ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  }\n});\n\nractive.observe('config.*', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('config.allowEdit', true);\n//newValue will be true and the keypath will be config.allowEdit\n\n\n\n\n\nIn addition to \nnewValue\n, \noldValue\n, and \nkeypath\n, any widlcards that are matched in the \nkeypath\n will be passed to the callback. Each additional wildcard will cause an extra parameter to be passed to the callback. For instance:\n\n\nractive.observe('items.*.*', function(newValue, oldValue, keypath, idx, key) {\n  console.log('item', idx, key, 'is now', newValue);\n});\nractive.set('items.1.foo', 'bar');\n// logs 'item 1 foo is now bar'\n\n\n\n\nPattern observers are a simple and flexible that will allow you to observe your data any way that you want.\n\n\nSpace Delimited Observers\n\n\nSpace delimited observers are useful when different keypaths should trigger the same function. In previous version you would have had to bind each keypath individually to the function.\n\n\nThis is a contrived example but for examples sake bare with us.\n\n\nvar ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    user: {username: 'browniefed'},\n    config: {isAdmin: false},\n    commentCount: 0\n  }\n});\n\nfunction updateServer() {\n  //Make call to server because something in user, config, comments changed\n}\n\nractive.observe('user.username', updateServer);\nractive.observe('config.isAdmin', updateServer);\nractive.observe('commentCount', updateServer);\n\n\n\n\n\nThis is unecessarily verbose, now with space delimited observers this becomes a single line.\n\n\nractive.observe('user.username config.isAdmin commentCount', updateServer);\n\n\n\n\n\nThis will work with patterns observers as well.\n\n\nractive.observe('user.* config.* commentCount', updateServer);\n\n\n\n\n\nA 'gotcha' to be aware of\n\n\nObservers will be notified whenever the new value is not equal to the old value - \nsort of\n.\n\n\nWhat does 'not equal' mean? Well, with \nprimitive values\n such as strings and numbers, that's easy - they're either identical (in the \n===\n sense) or they're not.\n\n\nWith objects and arrays (hereafter, just 'objects', since that's what arrays technically are), it's not so straightforward:\n\n\na = { one: 1, two: 2, three: 3 };\nb = { one: 1, two: 2, three: 3 };\n\nalert( a === b ); // alerts 'false' - they look the same, but they ain't\n\nb = a;\nb.four = 4;\n\nalert( a === b ); // alerts 'true'. Hang on, `a` didn't have a 'four' property?\nalert( a.four ); // alerts '4'. Oh. Right.\n\n\n\n\nSo one the one hand, objects which look identical aren't. On the other, you can set a property of an object and have no idea whether doing so resulted in a change.\n\n\nThere are two possible responses to this problem. First, we could do a 'deep clone' of an object whenever we do \nractive.set(keypath, object)\n, using an algorithm similar to \njQuery extend\n. That would mean any references you held to \nobject\n would become irrelevant. It would also mean a whole load of extra computation, and probably some very strange behaviour with cyclical data structures. No thanks.\n\n\nThe second is to sidestep the issue, and simply state that for the purposes of determining whether to notify observers, \nno two objects are equal, even when they're identical\n (unless they're both \nnull\n, of course - since \ntypeof null === 'object'\n due to a \nbug in the language\n).\n\n\nThis is the safest, sanest behaviour, but it can lead to unexpected behaviour in one situation - accessing properties within an observer:\n\n\nobj = { a: { b: { c: 1 } } };\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: { obj: obj }\n});\n\n// We observe 'obj.a.b.c' indirectly, and directly\nractive.observe({\n  'obj': function ( newObj, oldObj ) {\n    alert( 'Indirect observer: changed from ' + oldObj.a.b.c + ' to ' + newObj.a.b.c );\n  },\n  'obj.a.b.c': function ( newC, oldC ) {\n    alert( 'Direct observer: changed from ' + oldC + ' to ' + newC );\n  }\n});\n\nobj.a.b.c = 2;\n\n// The next line will cause two alerts:\n//   'Direct observer: changed from 1 to 2'\n//   'Indirect observer: changed from 2 to 2' - because oldObj === newObj\nractive.set( 'obj', obj );\n\n\n\n\nThis is definitely an edge case, but one that it's worth being aware of.", 
            "title": "Observers"
        }, 
        {
            "location": "/Concepts/Data Binding/Observers/#like-publishsubscribe-but-different", 
            "text": "A common pattern in modern JavaScript is to make models  observable , using the traditional  publish/subscribe  mechanism.  For example, you can observe changes to attributes within a Backbone Model like so:  model = Backbone.Model({ myValue: 1 });\n\nmodel.on( 'change:myValue', function ( model, value, options ) {\n  alert( 'myValue changed to ' + value );\n});\n\nmodel.set( 'myValue', 2 ); // alerts 'myValue changed to 2'  This works because  Backbone.Model.prototype  inherits from  Backbone.Events .  Ractive implements pub/sub with  ractive.on() ,  ractive.off()  and  ractive.fire() ,  ractive.off()  and  ractive.fire  - see  Events  for more info.", 
            "title": "Like publish/subscribe, but different"
        }, 
        {
            "location": "/Concepts/Data Binding/Observers/#observing-models-with-nested-properties", 
            "text": "But the normal pub/sub mechanism won't work for monitoring data changes with Ractive, because our data can contain nested properties. It's no good subscribing to a  change:foo.bar  event, if  foo.bar  can change as a result of  foo  changing.  So instead, we introduce the concept of  observers .  An observer observes a particular  keypath , and is  notified  when the value of its keypath changes, whether directly or indirectly (because an  upstream  or  downstream  keypath changed). You create one with  ractive.observe()  (see  ractive.observe()  for full method\nAPI).  Here's an example:  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    foo: { bar: 1 }\n  }\n});\n\n// The observer will be initialised with ( currentValue, undefined ) unless\n// we pass a third `options` argument in which `init` is `false`. In other\n// words this will alert 'foo.bar changed to 1'\nobserver = ractive.observe( 'foo.bar', function ( newValue, oldValue, keypath ) {\n  alert( keypath + ' changed to ' + newValue );\n});\n\nractive.set( 'foo.bar', 2 ); // alerts 'foo.bar changed to 2'\nractive.get( 'foo' ); // returns { bar: 2 }\n\nractive.set( 'foo', { bar: 3 }); // alerts 'foo.bar changed to 3'\nractive.get( 'foo.bar' ); // returns 3\n\nobserver.cancel();\n\nractive.set( 'foo.bar', 4 ); // alerts nothing; the observer was cancelled  Observers are most useful in the context of  two\u2010way binding .", 
            "title": "Observing models with nested properties"
        }, 
        {
            "location": "/Concepts/Data Binding/Observers/#pattern-observers", 
            "text": "It is useful to observe on specific keypaths but in the event your data contains array, or a set of dynamic data it isn't logical to bind to every potential keypath that could exist. Pattern observers use a  *  to indicate to Ractive that you would like to be notified whenever anything changes in your data at a particular depth as well as below the specified depth.  There are a few caveats when it comes to observing on array data, when observing on keypath  people.*  you are observing on the length of the array. This means that the  newValue  will be the index at which the new object was pushed. However when you use  set  to change an item at a particular index or a key that is on an object in the array then it will provide the object as the  newValue .  var ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    people: [\n      {name: 'Rich Harris'},\n      {name: 'Marty Nelson'}\n    ]\n  }\n});\n\nractive.observe('people.*', function(newValue, oldValue, keypath) {\n\n});\n\nvar people = ractive.get('people');\npeople.push({name: 'Jason Brown'});\n//newValue will equal 3, and the keypath will be people.length\n\nractive.set('people.3', {name: 'Jack Black'});\n//newValue will be {name: 'Jack Black'} and the keypath will be people.3\n\nractive.set('people.3.isACelebrity', true);\n//newValue will be {name: 'Jack Black', isACelebrity: true} and the keypath will be people.3\n\nractive.set('people.0.info.isCreator', true);\n//newValue will be the object for index 0 and the keypath will be people.0  Notice that because you are observing at the array level that  newValue  will be set as the entire object. What if you were only interested in knowing when a user became a celebrity? Simply tell Ractive you only want to observe dynamically on the array but only be notified when the  isACelebrity  key changes,  people.*.isACelebrity .  ractive.observe('people.*.isACelebrity', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('people.0.isACelebrity', true); //Rich Harris is a celebrity\n//newValue will be `true` and the keypath will be people.0.isACelebrity  You are not limited to just one  *  for your pattern, you can use as many as you would like and in any particular order.  \nractive.observe('people.*.comments.*', function(newValue, oldValue, keypath) {\n\n});\n\n//even arrays of arrays\n\nractive.observe('people.*.*', function(newValue, oldValue, keypath) {\n\n});  Furthermore it works on objects as well  config.*  will notify you when a value is changed on any key on the config object. However this differs from observing on an array in that it will provide the value set and keypath to the key that was set.  var ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  }\n});\n\nractive.observe('config.*', function(newValue, oldValue, keypath) {\n\n});\n\nractive.set('config.allowEdit', true);\n//newValue will be true and the keypath will be config.allowEdit  In addition to  newValue ,  oldValue , and  keypath , any widlcards that are matched in the  keypath  will be passed to the callback. Each additional wildcard will cause an extra parameter to be passed to the callback. For instance:  ractive.observe('items.*.*', function(newValue, oldValue, keypath, idx, key) {\n  console.log('item', idx, key, 'is now', newValue);\n});\nractive.set('items.1.foo', 'bar');\n// logs 'item 1 foo is now bar'  Pattern observers are a simple and flexible that will allow you to observe your data any way that you want.", 
            "title": "Pattern Observers"
        }, 
        {
            "location": "/Concepts/Data Binding/Observers/#space-delimited-observers", 
            "text": "Space delimited observers are useful when different keypaths should trigger the same function. In previous version you would have had to bind each keypath individually to the function.  This is a contrived example but for examples sake bare with us.  var ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    user: {username: 'browniefed'},\n    config: {isAdmin: false},\n    commentCount: 0\n  }\n});\n\nfunction updateServer() {\n  //Make call to server because something in user, config, comments changed\n}\n\nractive.observe('user.username', updateServer);\nractive.observe('config.isAdmin', updateServer);\nractive.observe('commentCount', updateServer);  This is unecessarily verbose, now with space delimited observers this becomes a single line.  ractive.observe('user.username config.isAdmin commentCount', updateServer);  This will work with patterns observers as well.  ractive.observe('user.* config.* commentCount', updateServer);", 
            "title": "Space Delimited Observers"
        }, 
        {
            "location": "/Concepts/Data Binding/Observers/#a-gotcha-to-be-aware-of", 
            "text": "Observers will be notified whenever the new value is not equal to the old value -  sort of .  What does 'not equal' mean? Well, with  primitive values  such as strings and numbers, that's easy - they're either identical (in the  ===  sense) or they're not.  With objects and arrays (hereafter, just 'objects', since that's what arrays technically are), it's not so straightforward:  a = { one: 1, two: 2, three: 3 };\nb = { one: 1, two: 2, three: 3 };\n\nalert( a === b ); // alerts 'false' - they look the same, but they ain't\n\nb = a;\nb.four = 4;\n\nalert( a === b ); // alerts 'true'. Hang on, `a` didn't have a 'four' property?\nalert( a.four ); // alerts '4'. Oh. Right.  So one the one hand, objects which look identical aren't. On the other, you can set a property of an object and have no idea whether doing so resulted in a change.  There are two possible responses to this problem. First, we could do a 'deep clone' of an object whenever we do  ractive.set(keypath, object) , using an algorithm similar to  jQuery extend . That would mean any references you held to  object  would become irrelevant. It would also mean a whole load of extra computation, and probably some very strange behaviour with cyclical data structures. No thanks.  The second is to sidestep the issue, and simply state that for the purposes of determining whether to notify observers,  no two objects are equal, even when they're identical  (unless they're both  null , of course - since  typeof null === 'object'  due to a  bug in the language ).  This is the safest, sanest behaviour, but it can lead to unexpected behaviour in one situation - accessing properties within an observer:  obj = { a: { b: { c: 1 } } };\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: { obj: obj }\n});\n\n// We observe 'obj.a.b.c' indirectly, and directly\nractive.observe({\n  'obj': function ( newObj, oldObj ) {\n    alert( 'Indirect observer: changed from ' + oldObj.a.b.c + ' to ' + newObj.a.b.c );\n  },\n  'obj.a.b.c': function ( newC, oldC ) {\n    alert( 'Direct observer: changed from ' + oldC + ' to ' + newC );\n  }\n});\n\nobj.a.b.c = 2;\n\n// The next line will cause two alerts:\n//   'Direct observer: changed from 1 to 2'\n//   'Indirect observer: changed from 2 to 2' - because oldObj === newObj\nractive.set( 'obj', obj );  This is definitely an edge case, but one that it's worth being aware of.", 
            "title": "A 'gotcha' to be aware of"
        }, 
        {
            "location": "/Concepts/Data Binding/Parallel DOM/", 
            "text": "Ractive works by maintaining a simplified model of the part of the DOM that it's responsible for. This model contains all the information - about data-binding, event handling and so on - that it needs to keep things up-to-date.\n\n\nYou can inspect the parallel DOM to understand what's going on under the hood, if you're into that sort of thing. Each Ractive instance, once rendered, has a \nfragment\n property. Each fragment has a number of properties:\n\n\n\n\ncontextStack\n - the context stack in which mustache \nreferences\n should be evaluated\n\n\nroot\n - a reference to the Ractive instance to which it belongs\n\n\nowner\n - the \nitem\n that owns this fragment (in the case of the root fragment, the same as \nroot\n)\n\n\nitems\n - the items belonging to this fragment\n\n\n\n\nItems\n means elements, text nodes, and mustaches. Elements may have fragments of their own (i.e. if they have children). A partial mustache will have a fragment, and a section mustache will have zero or more fragments depending on the value of its keypath.\n\n\nElements may also have attributes, which have a different kind of fragment (a \ntext fragment\n as opposed to a \nDOM fragment\n), containing text and mustaches.\n\n\nEach item has a \ndescriptor\n, which is something like DNA. This comes straight from the \nparsed template\n.\n\n\nThis is the briefest of overviews - if you want to gain a deeper understanding of what's going on under the hood, \nuse the source\n.", 
            "title": "Parallel DOM"
        }, 
        {
            "location": "/Concepts/Data Binding/Two-Way Binding/", 
            "text": "By default, a Ractive instance will update its internal model based on user input, if you have \ninput\n, \ntextarea\n or \nselect\n elements.\n\n\nIf that's unhelpful for your app, you can disable it by passing \ntwoway: false\n as an \ninitialisation option\n.\n\n\nTwo-way vinding can also be overridden on a per-element basis using the \ntwoway\n directive e.g. \ninput value=\"{{foo}}\" twoway=\"false\"\n. If the \ntwoway\n option is set to false, it can be overridden on a per-element bases using \ntwoway\n as a boolean attribute e.g. \ninput value=\"{{foo}}\" twoway\n or \ninput value=\"{{foo}}\" twoway=\"true\"\n.\n\n\ninput\n elements\n\n\nTwo-way binding works with \ninput\n elements of any type, including the new HTML5 types such as \ncolor\n or \nemail\n. In most cases, you just add a mustache as the \nvalue\n attribute - this must be a single, standard \ninterpolator\n mustache, like this:\n\n\ninput placeholder='Type your name' value='{{user.name}}'\n\n\n\n\n\nIn the example above, any changes the user makes to the input will be reflected in the \nuser.name\n property.\n\n\nCheckboxes\n\n\nCheckboxes are used to flag a property as \ntrue\n or \nfalse\n. Rather than binding the \nvalue\n attribute, we bind the \nchecked\n attribute:\n\n\nlabel\n\n    \ninput type='checkbox' checked='{{on}}'\n\n    The lights are {{ on ? 'on' : 'off' }}\n\n/label\n\n\n\n\n\n(True HTML nerds will recognise that \nboolean attributes\n such as checked don't have a value, as such - they either exist on an element or they don't. This makes life unnecessarily difficult; Ractive treats dynamic (i.e., controlled by a mustache) boolean attributes as present if the mustache is \ntrue\n, absent if \nfalse\n.)\n\n\nCheckboxes may also be bound by the \nname\n attribute, which will result in the value specified in the \nname\n attribute containing an array of selected checkbox values.\n\n\n{{#colors}}\n  \nlabel\n\n    \ninput type='checkbox' name='{{selected}}' value='{{.}}' /\n{{.}}\n  \n/label\n\n{{/}}\n\n\n\n\nIf \ncolors\n is an array, \n['Red', 'Yellow', 'Green', 'Blue']\n, then checking the first box will result in \nselected\n becoming \n['Red']\n. Checking the third box will result in \nselected\n becoming \n['Red', 'Green']\n. The array may also be updated from code using \nset\n or any of the array modification methods available to Ractive, and the checkboxes will be updated to reflect the contents of the array in the Ractive viewmodel.\n\n\nNote\n that checkboxes with both a \nchecked\n and \nname\n binding will \nonly\n bind on \nchecked\n, not both. The \nname\n binding will be treated\nas a normal mustache variable.\n\n\nRadios\n\n\nRadio buttons can be controlled in the same way as checkboxes. However the chances are, if you're using radio buttons, you have a set of mutually exclusive options to choose between. In this case, if you set the \nname\n attribute on a radio input to e.g. \n{{someValue}}\n, \nsomeValue\n will reflect the \nvalue\n of the currently checked option:\n\n\nlabel\ninput type='radio' name='{{color}}' value='red' checked\n Red\n/label\n\n\nlabel\ninput type='radio' name='{{color}}' value='green'\n Green\n/label\n\n\nlabel\ninput type='radio' name='{{color}}' value='blue'\n Blue\n/label\n\n\n\np\nThe currently selected color is \nspan style='color: {{color}};'\n{{color}}\n/span\n/p\n\n\n\n\n\nIn the example above, the value of \ncolor\n will initially be \n'red'\n (because that input is checked in the template), and will update as and when the user selects another option.\n\n\ntextarea\n elements\n\n\nTextareas work exactly the same as standard text inputs - slap a dynamic \nvalue\n attribute on them, and you're done:\n\n\ntextarea value='{{content}}'\n/textarea\n\n\n\n\n\nselect\n elements\n\n\nDrop-down select menus are good when you have many options to choose from. They're straightforward to use in Ractive:\n\n\nselect value='{{selectedCountry}}'\n\n    \noption selected disabled\nSelect a country\n/option\n\n    {{#countries}}\n        \noption value='{{id}}'\n{{name}}\n/option\n\n    {{/countries}}\n\n/select\n\n\n\n\n\nractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        countries: [\n            { id: 'AFG', name: 'Afghanistan' },\n            { id: 'ALB', name: 'Albania' },\n            { id: 'DZA', name: 'Algeria' },\n            { id: 'ASM', name: 'American Samoa' }\n            // and so on...\n        ]\n    }\n});\n\n\n\n\nIn the example above, no country will initially be selected. If the user were to select Afghanistan from the list, the value of \nselectedCountry\n would change to \n'AFG'\n.\n\n\ncontenteditable\n\n\nRactive can two-way data bind contenteditable elements.\n\n\nvar ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        content: 'Edit me'\n    }\n});\n\nractive.observe('content', function(newValue, oldValue, keypath) {\n    //newValue will contain the new content of the div\n});\n\n\n\n\nmyTemplate\n\n\ndiv contenteditable=\ntrue\n value=\n{{content}}\n/div\n\n\n\n\n\nThis will be rendered as\n\n\ndiv contenteditable=\ntrue\nEdit Me\n/div\n\n\n\n\n\nAs the user edits the data the \ncontent\n will update, and observe will fire.\n\n\nThere are a few caveats that you need to know. Despite the value binding with only two curly braces \n{{content}}\n (double curly braces are required for two way data binding) the returned content may or may not be a string of HTML. If a user presses enter after most browsers will insert a \nbr /\n. The \ncontent\n would be set to \nEdit Me\nbr/\n. Additionally anything you set to \ncontent\n would be rendered as HTML and not escaped despite the lack of triple curly braces(\n{{{content}}}\n).\n\n\nractive.set('content', '\nul\nli\nEdit Me\n/li\n/ul\n');\n\n\n\n\nThis would actually render an editable unordered list.\n\n\nBe aware that not all browsers actually operate the same way when it comes to interacting with contenteditable. HTML generated by one browser may differ from another.\n\n\nAmbiguous references\n\n\nA mustache used in a two-way binding context must have an \nunambiguous reference\n. Consider the following:\n\n\n{{#foo}}\n    \ninput value='{{bar}}'\n\n{{/foo}}\n\n\n\n\nractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: { foo: {} }\n});\n\n\n\n\nRactive must decide, straight away, what \nkeypath\n to bind the input's \nvalue\n attribute to. It will first see if it can \nreference\n (\n'bar'\n) given the current context stack (which includes a single context - \n'foo'\n). It can't, so it is forced to make an assumption - that the \n'bar'\n reference should resolve to the \n'bar'\n keypath.\n\n\nBut this might not be what you want - maybe you \ndid\n want it to resolve to \n'foo.bar'\n.\n\n\nYou have two options - either use a \nrestricted reference\n, i.e. \ninput value='{{.bar}}'\n, or ensure that \nfoo\n has a \nbar\n property (even if the initial value is \nundefined\n).\n\n\nLazy updates\n\n\nUnder the hood, Ractive always binds to the \nchange\n event (and the \nclick\n event in IE, in the case of checkboxes, due to an IE bug). By default, it will also bind to the \ninput\n event, which means the model is updated instantly when the user enters data (the \nchange\n event fires when a change is \n'committed by the user'\n). In some situations, that's not what you want - if you want to only bind to \nchange\n, pass in \nlazy: true\n as an \ninitialisation option\n.\n\n\nAs with \ntwoway\n, laziness may be specified on a per-element basis. Besides \ntrue\n (or simply having the attribute preset) and \nfalse\n values, the \nlazy\n directive may also be a number that specifies the number of milliseconds to wait after the last \ninput\n event fires with subsequent \ninput\n events resetting the timeout. For instance \ninput value=\"{{foo}}\" lazy\n will trigger updates to \nfoo\n on \nchange\n and \ninput value=\"{{foo}}\" lazy=\"1000\"\n will trigger updates 1 second after the last keypress.\n\n\nObserving changes\n\n\nTo use user input elsewhere in your app, you'll need to observe it using \nractive.observe()\n:\n\n\ninput placeholder='Type your name' value='{{user.name}}'\n\n\n\n\n\nractive = new Ractive({\n    el: myContainer,\n    template: myTemplate\n});\n\nractive.observe( 'user.name', function ( newValue ) {\n    app.user.name = newValue;\n    triggerSomeBehaviour();\n});", 
            "title": "Two-Way Binding"
        }, 
        {
            "location": "/Concepts/Data Binding/Two-Way Binding/#input-elements", 
            "text": "Two-way binding works with  input  elements of any type, including the new HTML5 types such as  color  or  email . In most cases, you just add a mustache as the  value  attribute - this must be a single, standard  interpolator  mustache, like this:  input placeholder='Type your name' value='{{user.name}}'   In the example above, any changes the user makes to the input will be reflected in the  user.name  property.", 
            "title": "&lt;input&gt; elements"
        }, 
        {
            "location": "/Concepts/Data Binding/Two-Way Binding/#checkboxes", 
            "text": "Checkboxes are used to flag a property as  true  or  false . Rather than binding the  value  attribute, we bind the  checked  attribute:  label \n     input type='checkbox' checked='{{on}}' \n    The lights are {{ on ? 'on' : 'off' }} /label   (True HTML nerds will recognise that  boolean attributes  such as checked don't have a value, as such - they either exist on an element or they don't. This makes life unnecessarily difficult; Ractive treats dynamic (i.e., controlled by a mustache) boolean attributes as present if the mustache is  true , absent if  false .)  Checkboxes may also be bound by the  name  attribute, which will result in the value specified in the  name  attribute containing an array of selected checkbox values.  {{#colors}}\n   label \n     input type='checkbox' name='{{selected}}' value='{{.}}' / {{.}}\n   /label \n{{/}}  If  colors  is an array,  ['Red', 'Yellow', 'Green', 'Blue'] , then checking the first box will result in  selected  becoming  ['Red'] . Checking the third box will result in  selected  becoming  ['Red', 'Green'] . The array may also be updated from code using  set  or any of the array modification methods available to Ractive, and the checkboxes will be updated to reflect the contents of the array in the Ractive viewmodel.  Note  that checkboxes with both a  checked  and  name  binding will  only  bind on  checked , not both. The  name  binding will be treated\nas a normal mustache variable.", 
            "title": "Checkboxes"
        }, 
        {
            "location": "/Concepts/Data Binding/Two-Way Binding/#radios", 
            "text": "Radio buttons can be controlled in the same way as checkboxes. However the chances are, if you're using radio buttons, you have a set of mutually exclusive options to choose between. In this case, if you set the  name  attribute on a radio input to e.g.  {{someValue}} ,  someValue  will reflect the  value  of the currently checked option:  label input type='radio' name='{{color}}' value='red' checked  Red /label  label input type='radio' name='{{color}}' value='green'  Green /label  label input type='radio' name='{{color}}' value='blue'  Blue /label  p The currently selected color is  span style='color: {{color}};' {{color}} /span /p   In the example above, the value of  color  will initially be  'red'  (because that input is checked in the template), and will update as and when the user selects another option.", 
            "title": "Radios"
        }, 
        {
            "location": "/Concepts/Data Binding/Two-Way Binding/#textarea-elements", 
            "text": "Textareas work exactly the same as standard text inputs - slap a dynamic  value  attribute on them, and you're done:  textarea value='{{content}}' /textarea", 
            "title": "&lt;textarea&gt; elements"
        }, 
        {
            "location": "/Concepts/Data Binding/Two-Way Binding/#select-elements", 
            "text": "Drop-down select menus are good when you have many options to choose from. They're straightforward to use in Ractive:  select value='{{selectedCountry}}' \n     option selected disabled Select a country /option \n    {{#countries}}\n         option value='{{id}}' {{name}} /option \n    {{/countries}} /select   ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        countries: [\n            { id: 'AFG', name: 'Afghanistan' },\n            { id: 'ALB', name: 'Albania' },\n            { id: 'DZA', name: 'Algeria' },\n            { id: 'ASM', name: 'American Samoa' }\n            // and so on...\n        ]\n    }\n});  In the example above, no country will initially be selected. If the user were to select Afghanistan from the list, the value of  selectedCountry  would change to  'AFG' .", 
            "title": "&lt;select&gt; elements"
        }, 
        {
            "location": "/Concepts/Data Binding/Two-Way Binding/#contenteditable", 
            "text": "Ractive can two-way data bind contenteditable elements.  var ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: {\n        content: 'Edit me'\n    }\n});\n\nractive.observe('content', function(newValue, oldValue, keypath) {\n    //newValue will contain the new content of the div\n});  myTemplate  div contenteditable= true  value= {{content}} /div   This will be rendered as  div contenteditable= true Edit Me /div   As the user edits the data the  content  will update, and observe will fire.  There are a few caveats that you need to know. Despite the value binding with only two curly braces  {{content}}  (double curly braces are required for two way data binding) the returned content may or may not be a string of HTML. If a user presses enter after most browsers will insert a  br / . The  content  would be set to  Edit Me br/ . Additionally anything you set to  content  would be rendered as HTML and not escaped despite the lack of triple curly braces( {{{content}}} ).  ractive.set('content', ' ul li Edit Me /li /ul ');  This would actually render an editable unordered list.  Be aware that not all browsers actually operate the same way when it comes to interacting with contenteditable. HTML generated by one browser may differ from another.", 
            "title": "contenteditable"
        }, 
        {
            "location": "/Concepts/Data Binding/Two-Way Binding/#ambiguous-references", 
            "text": "A mustache used in a two-way binding context must have an  unambiguous reference . Consider the following:  {{#foo}}\n     input value='{{bar}}' \n{{/foo}}  ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate,\n    data: { foo: {} }\n});  Ractive must decide, straight away, what  keypath  to bind the input's  value  attribute to. It will first see if it can  reference  ( 'bar' ) given the current context stack (which includes a single context -  'foo' ). It can't, so it is forced to make an assumption - that the  'bar'  reference should resolve to the  'bar'  keypath.  But this might not be what you want - maybe you  did  want it to resolve to  'foo.bar' .  You have two options - either use a  restricted reference , i.e.  input value='{{.bar}}' , or ensure that  foo  has a  bar  property (even if the initial value is  undefined ).", 
            "title": "Ambiguous references"
        }, 
        {
            "location": "/Concepts/Data Binding/Two-Way Binding/#lazy-updates", 
            "text": "Under the hood, Ractive always binds to the  change  event (and the  click  event in IE, in the case of checkboxes, due to an IE bug). By default, it will also bind to the  input  event, which means the model is updated instantly when the user enters data (the  change  event fires when a change is  'committed by the user' ). In some situations, that's not what you want - if you want to only bind to  change , pass in  lazy: true  as an  initialisation option .  As with  twoway , laziness may be specified on a per-element basis. Besides  true  (or simply having the attribute preset) and  false  values, the  lazy  directive may also be a number that specifies the number of milliseconds to wait after the last  input  event fires with subsequent  input  events resetting the timeout. For instance  input value=\"{{foo}}\" lazy  will trigger updates to  foo  on  change  and  input value=\"{{foo}}\" lazy=\"1000\"  will trigger updates 1 second after the last keypress.", 
            "title": "Lazy updates"
        }, 
        {
            "location": "/Concepts/Data Binding/Two-Way Binding/#observing-changes", 
            "text": "To use user input elsewhere in your app, you'll need to observe it using  ractive.observe() :  input placeholder='Type your name' value='{{user.name}}'   ractive = new Ractive({\n    el: myContainer,\n    template: myTemplate\n});\n\nractive.observe( 'user.name', function ( newValue ) {\n    app.user.name = newValue;\n    triggerSomeBehaviour();\n});", 
            "title": "Observing changes"
        }, 
        {
            "location": "/Concepts/Events/Overview/", 
            "text": "Like many libraries, Ractive implements the \npublish/subscribe\n mechanism to allow you to respond to, or trigger, particular events.\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\nactivate\nclick me!\n/button\n'\n});\n\nractive.on( 'activate', function ( event ) {\n  alert( 'Activating!' );\n});\n\n\n\n\nThere are actually two-levels of event handling in Ractive:\n\n\n\n\nThe lower-level interaction with DOM events or \ncustom events\n. These are specified using \nEvent directives\n that also specify how the event is to be handled using either \nproxy events\n or \nmethod calls\n.\n\n\nThe \npublish-subscribe\n api and event system within Ractive and between components. Proxy events bridge the DOM event into a Ractive event, whereas method calls directly invoke the ractive instance and do not use the pub/sub infrastructure.\n\n\n\n\n\nThe \npublish-subscribe\n event handling in Ractive allows you to consistently handle three different categories of generated events:\n\n\n\n\nProxy events\n, mentioned above, proxy DOM and custom events defined in your template\n\n\nMethod calls\n are a more powerful alternative to proxy events that allow you to execute one or more expressions when an event fires.\n\n\nLifecycle events\n generated by each ractive instance - such as \ninit\n, \nrender\n and \nteardown\n\n\nCustom events\n fired in code using \nractive.fire()\n, which can be anything you like\n\n\n\n\nHygiene\n\n\nOne of the advantages of using Ractive events is that, in addition to being able to manually unsubscribe events, both DOM events and\nRactive Events will be automatically unsubscribed when the ractive instance or component is torndown.\n\n\nIn practice, this means adding a template directive like \non-click='select'\n is all that is needed to manage the DOM event.", 
            "title": "Overview"
        }, 
        {
            "location": "/Concepts/Events/Overview/#hygiene", 
            "text": "One of the advantages of using Ractive events is that, in addition to being able to manually unsubscribe events, both DOM events and\nRactive Events will be automatically unsubscribed when the ractive instance or component is torndown.  In practice, this means adding a template directive like  on-click='select'  is all that is needed to manage the DOM event.", 
            "title": "Hygiene"
        }, 
        {
            "location": "/Concepts/Events/Bubbling/", 
            "text": "Events that fire in components will bubble up the view hierarchy - \nsee this demonstration\n. Bubbling events are namespaced by the element name used for that component in the template:\n\n\nractive = new Ractive({\n    el: document.body,\n    template: '\nwidget/\n',\n    components: {\n        widget: Ractive.extend({\n            template: '\nbutton on-click=\nselect\nSelect Me\n/button\n'\n        })\n    },\n    oninit: function () {\n        this.on( 'widget.select', function () {\n            alert('selected!');\n        });\n    }\n});\n\n\n\n\nThe event will continue to bubble up under the name of the originating component, not the name of each parent component.\n\n\nCancelling\n\n\nReturning \nfalse\n from an event handler will prevent that event from bubbling further:\n\n\nthis.on( 'widget.select', function () {\n    return false;\n});\n\n\n\n\n\nSibling event handlers will still be called. Cancelling only applies to bubbling up to the next level of the view hierarchy.\n\n\nNote that returning \nfalse\n has a dual purpose of both cancelling the view hierarchy event bubbling \nand\n cancelling the DOM Event if the event was DOM-based.\n\n\nTemplate directives for handling component events \nimplicitly\n cancel bubbling of the subscribed event:\n\n\nwidget on-foo='bar'/\n\n\n\n\n\nIn this example, \nwidget.foo\n will not bubble. Instead a new event \nbar\n will be fired and bubbled, assuming the above template is also contained in a component, under the name of the new component.\n\n\nThe \nevent.component\n Property\n\n\nEvents that bubble add a \ncomponent\n property to the event object that is the component ractive instance raising the event:\n\n\nthis.on( 'widget.select', function ( event ) {\n    event.component.observe( 'foo', function ( n, o, k ) {\n        console.log( 'foo changed from', o, 'to', n );\n    });\n});", 
            "title": "Bubbling"
        }, 
        {
            "location": "/Concepts/Events/Bubbling/#cancelling", 
            "text": "Returning  false  from an event handler will prevent that event from bubbling further:  this.on( 'widget.select', function () {\n    return false;\n});  Sibling event handlers will still be called. Cancelling only applies to bubbling up to the next level of the view hierarchy.  Note that returning  false  has a dual purpose of both cancelling the view hierarchy event bubbling  and  cancelling the DOM Event if the event was DOM-based.  Template directives for handling component events  implicitly  cancel bubbling of the subscribed event:  widget on-foo='bar'/   In this example,  widget.foo  will not bubble. Instead a new event  bar  will be fired and bubbled, assuming the above template is also contained in a component, under the name of the new component.", 
            "title": "Cancelling"
        }, 
        {
            "location": "/Concepts/Events/Bubbling/#the-eventcomponent-property", 
            "text": "Events that bubble add a  component  property to the event object that is the component ractive instance raising the event:  this.on( 'widget.select', function ( event ) {\n    event.component.observe( 'foo', function ( n, o, k ) {\n        console.log( 'foo changed from', o, 'to', n );\n    });\n});", 
            "title": "The event.component Property"
        }, 
        {
            "location": "/Concepts/Events/Directives/", 
            "text": "DOM events are handled with template directives that take the form of element attributes, similar to global native DOM handlers, but are prefixed with \non-\n plus the name of the event:\n\n\nbutton on-click=\nactivate\nclick me!\n/button\n\n\n\n\n\nYou can assign multiple events by separating them with a hyphen:\n\n\ndiv on-mouseover-mousemove='@this.set( \nhover\n, true )'\n...\n/div\n\n\n\n\n\nThe structure of the attribute content will vary depending on whether you are using \nproxy events\n (the first example) or \nmethod calls\n (the second example). See each respective section for more details.\n\n\nDOM events can be any supported event on the element node. Touch events - \ntouchstart\n, \ntouchmove\n, \ntouchend\n, \ntouchcancel\n, and \ntouchleave\n (not w3c, but supported in some browsers) - can be used as well, and will be safely ignored if not supported by the current browser.\n\n\nDOM Events will be automatically unsubscribed when the ractive instance is torndown.\n\n\nCancelling DOM Events\n\n\nSee \npublish-subscribe\n for information on automatically stopping DOM event propagation and default action.\n\n\nCustom events\n\n\nIn addition to all the usual DOM events, you can use \ncustom events\n via \nevent plugins\n. These allow you to define what conditions on the node should generate a directive-level event.\n\n\nFor example, you could add gesture support to your app with \nractive-touch\n, which integrates \nHammer.js\n with Ractive.\n\n\nOnce defined, the custom event can then be used like any other event directive:\n\n\ndiv on-swipeleft=\nnextPage\n...\n/div\n\n\n\n\n\nBe aware that custom event names take precedence over native DOM event names.\n\n\nComponent event directives\n\n\nTemplate component elements can also have event directives:\n\n\nmy-widget on-foo=\nbar\n/\n\n\n\n\n\nHowever, there are some differences and limitations to component event directives:\n\n\n\n\nThese only respond to component raised events and are not DOM event or custom event subscriptions.\n\n\nArguments to proxy events are ignored\n\n\nMethod calls are not currently supported\n\n\nPattern matching \nis\n supported (see \npublish-subscribe\n):\n\n\n\n\nmy-widget on-foo.*=\nbar\n/", 
            "title": "Directives"
        }, 
        {
            "location": "/Concepts/Events/Directives/#cancelling-dom-events", 
            "text": "See  publish-subscribe  for information on automatically stopping DOM event propagation and default action.", 
            "title": "Cancelling DOM Events"
        }, 
        {
            "location": "/Concepts/Events/Directives/#custom-events", 
            "text": "In addition to all the usual DOM events, you can use  custom events  via  event plugins . These allow you to define what conditions on the node should generate a directive-level event.  For example, you could add gesture support to your app with  ractive-touch , which integrates  Hammer.js  with Ractive.  Once defined, the custom event can then be used like any other event directive:  div on-swipeleft= nextPage ... /div   Be aware that custom event names take precedence over native DOM event names.", 
            "title": "Custom events"
        }, 
        {
            "location": "/Concepts/Events/Directives/#component-event-directives", 
            "text": "Template component elements can also have event directives:  my-widget on-foo= bar /   However, there are some differences and limitations to component event directives:   These only respond to component raised events and are not DOM event or custom event subscriptions.  Arguments to proxy events are ignored  Method calls are not currently supported  Pattern matching  is  supported (see  publish-subscribe ):   my-widget on-foo.*= bar /", 
            "title": "Component event directives"
        }, 
        {
            "location": "/Concepts/Events/Method Calls/", 
            "text": "See also: \nproxy events\n\n\nNote:\n Unqualified event method calls are deprecated and have been replaced with event expressions that resolve the same way as every other expression in a Ractive template. This means that to call, for instance, \nset('foo', 'bar')\n in an event, you would now use \n@this.set('foo', 'bar')\n. Unfortunately, this adds a bit of boilerplate to common method calls, but it is also resolves the disparity between event directives and other template references, allows calling data methods from events, and allows executing multiple, possibly more complex, expressions when an event fires.\n\n\nAs an alternative to \nevent directive\n, right from your template:\n\n\np\nfoo is {{foo}}\n/p\n\n\nbutton on-click='@this.toggle(\nfoo\n)'\ntoggle foo\n/button\n\n\n\n\n\nIn this case, because \nractive.toggle()\n is a built-in method, clicking the button will toggle the value of \nfoo\n between \ntrue\n and \nfalse\n (\ndemo\n).\n\n\nThis also works with custom methods:\n\n\nvar ractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\n@this.klaxon()\nsound the klaxon\n/button\n',\n  audio: new Audio( 'klaxon.mp3' ),\n  klaxon: function () {\n    this.audio.play();\n  }\n});\n\n\n\n\nYou can pass as many arguments to the method as you like, including data references:\n\n\n{{#each items :i}}\n  \nbutton on-click='@this.select(this,i)'\nselect this item\n/button\n\n{{/each}}\n\n\n\n\nNotice that mustaches are \nnot\n used with data reference in method calls, i.e. \n{{i}}\n and will cause errors if they are. String literals need to be in quotes:\n\n\nbutton on-click='@this.set(\nfoo\n, true)'\nmake foo true\n/button\n\n\n\n\n\nYou can also pass the \nevent\n object, or properties thereof (\nevent.original\n is the original DOM event) (\ndemo\n):\n\n\ndiv\n  on-mousemove='@this.set({\n    x: event.original.clientX,\n    y: event.original.clientY\n  })'\n  on-mouseleave='@this.set({\n    x: \nunknown\n,\n    y: \nunknown\n\n  })'\n\n\n  \np\ncurrent mouse position: {{x}} x {{y}}\n/p\n\n\n/div\n\n\n\n\n\nThe \nevent\n object is also available within body of the method call function as \nthis.event\n. Note that methods on your Ractive instance that may handle your events are effectively part of your public API, and \nthis.event\n will only be available during invocations triggered by an event.\n\n\nThe \nevent\n argument is also extended with contextual helper methods. See \nhelpers\n.\n\n\nIf you need to evaluate multiple expressions from an event directive, simply separate them with a \n,\n. For instance:\n\n\n{{#each someList as item}}\n\ndiv\n\n  {{item.display}}\n  \na href=\n#\n on-click=\nevent.pop('../'), @this.notifyUser('item removed!'), false\n\n    Remove and Notify\n  \n/a\n\n\n/div\n\n{{/each}}\n\n\n\n\nNote that this is a list of independent expressions, and as long as one doesn't throw, they will all be evaluated.\n\n\nCancelling events\n\n\nAs with proxy events, you can cancel a DOM event by returning \nfalse\n from your event handler. Ractive with then call \npreventDefault()\n and \nstopPropagation()\n on the original DOM event. You can also call any methods on the original event by having it passed to your handler or accessing it using \nthis.event.original\n. With event expressions, you can force the cancellation regardless of the return from any methods you call by simply including \nfalse\n as the last expression in your list, as above in the 'Remove and Notify' example. You can also override cancellation in much the same way by using \ntrue\n instead of \nfalse\n.", 
            "title": "Method Calls"
        }, 
        {
            "location": "/Concepts/Events/Method Calls/#cancelling-events", 
            "text": "As with proxy events, you can cancel a DOM event by returning  false  from your event handler. Ractive with then call  preventDefault()  and  stopPropagation()  on the original DOM event. You can also call any methods on the original event by having it passed to your handler or accessing it using  this.event.original . With event expressions, you can force the cancellation regardless of the return from any methods you call by simply including  false  as the last expression in your list, as above in the 'Remove and Notify' example. You can also override cancellation in much the same way by using  true  instead of  false .", 
            "title": "Cancelling events"
        }, 
        {
            "location": "/Concepts/Events/Proxy Events/", 
            "text": "See also: \nmethod calls from templates\n\n\nRactive has a concept of \nproxy events\n, which translate a user \naction\n (e.g. a mouseclick) defined via an \nevent directive\n into an \nintention\n (e.g. 'select this option'). This allows you to handle user interaction in a readable, declarative fashion, without resorting to peppering your markup with class names to use as 'hooks' (which must then be kept consistent between your markup and your JavaScript code).\n\n\nAs with all events in Ractive, you subscribe with \nractive.on()\n (also see \npublish-subscribe\n). Proxy events declare the handler name of the event that will be fired, along with any optional arguments:\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\nactivate\nclick me!\n/button\n'\n});\n\nractive.on( 'activate', function ( event ) {\n  alert( 'Activating!' );\n});\n\n\n\n\nIn this example, it is \nactivate\n (and not \nclick\n!) that is the name of the handler event that will be fired for any registered handlers created via \nractive.on()\n.\n\n\nEvent arguments\n\n\nThe \nevent\n object\n\n\nThe first argument to a proxy event handler is always a Ractive \nevent\n object. It contains various properties:\n\n\n\n\nevent.name\n - the name of the event, in this case 'activate'\n\n\nevent.node\n - the DOM node in question\n\n\nevent.keypath\n - the \nkeypath\n of the current context\n\n\nevent.context\n - the value of \nthis.get(event.keypath)\n\n\nevent.index\n - a map of index references\n\n\nevent.component\n - the component that raised the event, only present on \nbubbled events\n\n\nevent.original\n - the original DOM event, if available\n\n\n\n\nIn the example above, \nevent.keypath\n might be \nitems.0\n for the first item in the list, \nitems.1\n for the second, and so on. The \nevent.index\n map would have a property \ni\n, which would correspond to those indices.\n\n\nThe event object is also available in event handlers using \nthis.event\n, see \npublish-subscribe\n for more details.\n\n\nCustom arguments\n\n\nNOTE:\n Arguments to proxy events have been deprecated because they are too easy to break. If you need to pass arguments with your event, you can use \n@this.fire('myEvent', event, arg1, arg2, etc)\n.\n\n\nWe might want to pass arguments to our handler in addition to the \nevent\n object. We can do that by listing them, comma-separated, after the event name:\n\n\nh1\nLet's shop!\n/h1\n\n\nul\n\n  {{#each items: i}}\n    \nli\n\n      \np\n{{i+1}}: {{description}}\n/p\n\n      \nlabel\ninput value='{{qty}}'\n Quantity\n/label\n\n\n      \n!-- when the user clicks this button, add {{qty}} of this item --\n\n      \nbutton on-click='addToCart:{{this}},{{qty}}'\nAdd to cart\n/button\n\n    \n/li\n\n  {{/each}}\n\n/ul\n\n\n\n\n\nractive.on( 'addToCart', function ( event, item, qty ) {\n  /* code goes here */\n});\n\n\n\n\nCancelling DOM events\n\n\nIf you return \nfalse\n from a proxy event handler, ractive will automatically call both \npreventDefault()\n and \nstopPropagation()\n on the original DOM event.\n\n\nNote that returning \nfalse\n has a dual purpose of both cancelling further bubbling up the view hierarchy \nevent bubbling\n \nas well as\n cancelling the DOM Event if the event was DOM-based.\n\n\nIf you only want to cancel the DOM event, you can call the appropriate methods directly on \nevent.original\n or \nthis.event.original\n, which are both references to the current DOM event object.\n\n\nReserved event names\n\n\nNote: the built-in \nlifecycle events\n are \nreserved\n, which means you can't use their names as proxy events.\n\n\nDynamic proxy event names\n\n\nMustache references\n can be used as proxy event names:\n\n\nbutton on-click=\n{{handler}}\nclick me!\n/button\n\n\n\n\n\nIn practive this is of limited value, but a more important side effect is that if no handler is specified (a falsey value) the DOM event is not subscribed and will unsubscribe or resubscribe as the handler value changes. Combined with a conditional section, this allows a proxy event to be conditionally subscribed \nat the DOM level\n:\n\n\nbutton on-click=\n{{#active}}select{{/}}\nclick me!\n/button\n\n\n\n\n\nIn this example, the DOM \nclick\n event is subscribed and unsubscribed as the value of \nactive\n is truthy or falsey.", 
            "title": "Proxy Events"
        }, 
        {
            "location": "/Concepts/Events/Proxy Events/#event-arguments", 
            "text": "", 
            "title": "Event arguments"
        }, 
        {
            "location": "/Concepts/Events/Proxy Events/#the-event-object", 
            "text": "The first argument to a proxy event handler is always a Ractive  event  object. It contains various properties:   event.name  - the name of the event, in this case 'activate'  event.node  - the DOM node in question  event.keypath  - the  keypath  of the current context  event.context  - the value of  this.get(event.keypath)  event.index  - a map of index references  event.component  - the component that raised the event, only present on  bubbled events  event.original  - the original DOM event, if available   In the example above,  event.keypath  might be  items.0  for the first item in the list,  items.1  for the second, and so on. The  event.index  map would have a property  i , which would correspond to those indices.  The event object is also available in event handlers using  this.event , see  publish-subscribe  for more details.", 
            "title": "The event object"
        }, 
        {
            "location": "/Concepts/Events/Proxy Events/#custom-arguments", 
            "text": "NOTE:  Arguments to proxy events have been deprecated because they are too easy to break. If you need to pass arguments with your event, you can use  @this.fire('myEvent', event, arg1, arg2, etc) .  We might want to pass arguments to our handler in addition to the  event  object. We can do that by listing them, comma-separated, after the event name:  h1 Let's shop! /h1  ul \n  {{#each items: i}}\n     li \n       p {{i+1}}: {{description}} /p \n       label input value='{{qty}}'  Quantity /label \n\n       !-- when the user clicks this button, add {{qty}} of this item -- \n       button on-click='addToCart:{{this}},{{qty}}' Add to cart /button \n     /li \n  {{/each}} /ul   ractive.on( 'addToCart', function ( event, item, qty ) {\n  /* code goes here */\n});", 
            "title": "Custom arguments"
        }, 
        {
            "location": "/Concepts/Events/Proxy Events/#cancelling-dom-events", 
            "text": "If you return  false  from a proxy event handler, ractive will automatically call both  preventDefault()  and  stopPropagation()  on the original DOM event.  Note that returning  false  has a dual purpose of both cancelling further bubbling up the view hierarchy  event bubbling   as well as  cancelling the DOM Event if the event was DOM-based.  If you only want to cancel the DOM event, you can call the appropriate methods directly on  event.original  or  this.event.original , which are both references to the current DOM event object.", 
            "title": "Cancelling DOM events"
        }, 
        {
            "location": "/Concepts/Events/Proxy Events/#reserved-event-names", 
            "text": "Note: the built-in  lifecycle events  are  reserved , which means you can't use their names as proxy events.", 
            "title": "Reserved event names"
        }, 
        {
            "location": "/Concepts/Events/Proxy Events/#dynamic-proxy-event-names", 
            "text": "Mustache references  can be used as proxy event names:  button on-click= {{handler}} click me! /button   In practive this is of limited value, but a more important side effect is that if no handler is specified (a falsey value) the DOM event is not subscribed and will unsubscribe or resubscribe as the handler value changes. Combined with a conditional section, this allows a proxy event to be conditionally subscribed  at the DOM level :  button on-click= {{#active}}select{{/}} click me! /button   In this example, the DOM  click  event is subscribed and unsubscribed as the value of  active  is truthy or falsey.", 
            "title": "Dynamic proxy event names"
        }, 
        {
            "location": "/Concepts/Events/Publish-Subscribe/", 
            "text": "Like many libraries, Ractive implements the \npublish/subscribe\n mechanism to allow you to respond to, or trigger, particular events.\n\n\nSubscribe\n\n\nTo subscribe to an event, use \nractive.on()\n:\n\n\nractive = new Ractive({\n  el: 'body',\n  template: '\nbutton on-click=\nactivate\nclick me!\n/button\n'\n});\n\nractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});\n\n\n\n\nThis can be used to subscribe to any of the following type of events:\n\n\n\n\nProxy events\n for DOM and custom events defined in your template\n\n\nLifecycle events\n generated by each ractive instance - such as \ninit\n, \nrender\n and \nteardown\n\n\nCustom events\n fired in code using \nractive.fire()\n, which can be anything you like, see below.\n\n\n\n\nMultiple events to one handler\n\n\nYou can subscribe a handler to more than one event by separating event names with a space:\n\n\nractive.on( 'activate select', function () {...} );\n\n\n\n\nThis example will fire for either an \nactivate\n event or a \nselect\n event.\n\n\nObject map of multiple event/handler pairs\n\n\nMultiple hander/function pairs can be subscribed using an object hash:\n\n\nractive.on({\n    activate: function () {...},\n    select: function () {...}\n});\n\n\n\n\nWildcard pattern handlers\n\n\nEvent names that use a keypath-like name can be subscribed using the pattern-matching wildcard \"\n*\n\" for any name path segment:\n\n\nractive.on( 'foo.*', function () {...} );\n\n\n\n\nThis example will fire on any event name that starts with \nfoo.\n - \nfoo.active\n, \nfoo.select\n, etc.\n\n\nThis is very useful with \nevent bubbling\n and auto-prefixed event names that bubble up from components.\n\n\nBe aware that handlers like \nwidget.*\n or \n*\n will fire for \nall\n matching events, including \nlifecycle events\n.\n\n\nAccessing the event object\n\n\nIn addition to the event argument that is passed with proxy events, the event object can be accessed using \nthis.event\n in the function body of any handler. This object is also present in non-proxy events including lifecycle events, though it includes a more limited set of properties.\n\n\nProperties on all \nthis.event\n objects:\n\n\n\n\nthis.event.name\n - the name of the event\n\n\nthis.event.context\n - the value of \nthis.get(event.keypath)\n or \nractive.get()\n for non-proxy events\n\n\nthis.event.component\n - the component that raised the event, only present on \nbubbled events\n\n\nthis.event.original\n - the original DOM event, if available\n\n\n\n\nProperties only on proxy events:\n\n \nthis.event.node\n - the DOM node in question\n\n \nthis.event.keypath\n - the \nkeypath\n of the current context\n* \nthis.event.index\n - a map of index references\n\n\nOne useful aspect of \nthis.event\n is that the name of the event can be determined when wildcards are used:\n\n\nractive.on( 'foo.*', function () {\n    console.log( this.event.name );\n});\n\n\n\n\nCancelling DOM events\n\n\nIf you return 'false' from a proxy event handler, ractive will automatically call both \npreventDefault()\n and \nstopPropagation()\n on the original DOM event.\n\n\nNote that returning \nfalse\n has a dual purpose of both cancelling the view hierarchy \nevent bubbling\n \nas well as\n cancelling the DOM Event if the event was DOM-based.\n\n\nUnsubscribe\n\n\nEvent handlers are automatically removed if the instance is torn down (e.g. with \nractive.teardown()\n) (which also happens as components are removed due to template/data logic).\n\n\nYou can also unsubscribe event handlers manually using one of two approaches:\n\n\nvar listener = ractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});\n\n// later...\nlistener.cancel();\n\n\n\n\nor...\n\n\nvar handler = function () {\n  alert( 'Activating!' );\n};\n\nractive.on( 'activate', handler );\n\n// later...\nractive.off( 'activate', handler );\n\n\n\n\nIn the second case, note that if you don't specify a handler, all 'activate' handlers will be removed. If you don't specify an event name, \nall\n event handlers will be removed from the instance. See \nractive.off()\n for more detail.\n\n\nThe \nractive.off()\n method is chainable for easily replacing subscribtions:\n\n\nractive.off( 'activate' ).on( 'activate', function () {...} );\n\n\n\n\nPublish\n\n\nIn addition to the built-in \nlifecycle events\n and \nproxy events\n, you can fire your own events with \nractive.fire()\n.\n\n\nThis is most useful in the context of a \ncomponent\n that needs to emit custom events. Here's a (somewhat contrived) example:\n\n\nvar Ticker = Ractive.extend({\n  oninit: function () {\n    var i = 1;\n\n    this.interval = setInterval( function () {\n      this.fire( 'tick', i++ );\n    }.bind( this ), 1000 );\n  },\n  onteardown: function () {\n    clearInterval( this.interval );\n  }\n});\n\nvar ticker = new Ticker();\n\nticker.on( 'tick', function ( i ) {\n  console.log( i % 2 ? 'tick' : 'tock' );\n});", 
            "title": "Publish-Subscribe"
        }, 
        {
            "location": "/Concepts/Events/Publish-Subscribe/#subscribe", 
            "text": "To subscribe to an event, use  ractive.on() :  ractive = new Ractive({\n  el: 'body',\n  template: ' button on-click= activate click me! /button '\n});\n\nractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});  This can be used to subscribe to any of the following type of events:   Proxy events  for DOM and custom events defined in your template  Lifecycle events  generated by each ractive instance - such as  init ,  render  and  teardown  Custom events  fired in code using  ractive.fire() , which can be anything you like, see below.", 
            "title": "Subscribe"
        }, 
        {
            "location": "/Concepts/Events/Publish-Subscribe/#multiple-events-to-one-handler", 
            "text": "You can subscribe a handler to more than one event by separating event names with a space:  ractive.on( 'activate select', function () {...} );  This example will fire for either an  activate  event or a  select  event.", 
            "title": "Multiple events to one handler"
        }, 
        {
            "location": "/Concepts/Events/Publish-Subscribe/#object-map-of-multiple-eventhandler-pairs", 
            "text": "Multiple hander/function pairs can be subscribed using an object hash:  ractive.on({\n    activate: function () {...},\n    select: function () {...}\n});", 
            "title": "Object map of multiple event/handler pairs"
        }, 
        {
            "location": "/Concepts/Events/Publish-Subscribe/#wildcard-pattern-handlers", 
            "text": "Event names that use a keypath-like name can be subscribed using the pattern-matching wildcard \" * \" for any name path segment:  ractive.on( 'foo.*', function () {...} );  This example will fire on any event name that starts with  foo.  -  foo.active ,  foo.select , etc.  This is very useful with  event bubbling  and auto-prefixed event names that bubble up from components.  Be aware that handlers like  widget.*  or  *  will fire for  all  matching events, including  lifecycle events .", 
            "title": "Wildcard pattern handlers"
        }, 
        {
            "location": "/Concepts/Events/Publish-Subscribe/#accessing-the-event-object", 
            "text": "In addition to the event argument that is passed with proxy events, the event object can be accessed using  this.event  in the function body of any handler. This object is also present in non-proxy events including lifecycle events, though it includes a more limited set of properties.  Properties on all  this.event  objects:   this.event.name  - the name of the event  this.event.context  - the value of  this.get(event.keypath)  or  ractive.get()  for non-proxy events  this.event.component  - the component that raised the event, only present on  bubbled events  this.event.original  - the original DOM event, if available   Properties only on proxy events:   this.event.node  - the DOM node in question   this.event.keypath  - the  keypath  of the current context\n*  this.event.index  - a map of index references  One useful aspect of  this.event  is that the name of the event can be determined when wildcards are used:  ractive.on( 'foo.*', function () {\n    console.log( this.event.name );\n});", 
            "title": "Accessing the event object"
        }, 
        {
            "location": "/Concepts/Events/Publish-Subscribe/#cancelling-dom-events", 
            "text": "If you return 'false' from a proxy event handler, ractive will automatically call both  preventDefault()  and  stopPropagation()  on the original DOM event.  Note that returning  false  has a dual purpose of both cancelling the view hierarchy  event bubbling   as well as  cancelling the DOM Event if the event was DOM-based.", 
            "title": "Cancelling DOM events"
        }, 
        {
            "location": "/Concepts/Events/Publish-Subscribe/#unsubscribe", 
            "text": "Event handlers are automatically removed if the instance is torn down (e.g. with  ractive.teardown() ) (which also happens as components are removed due to template/data logic).  You can also unsubscribe event handlers manually using one of two approaches:  var listener = ractive.on( 'activate', function () {\n  alert( 'Activating!' );\n});\n\n// later...\nlistener.cancel();  or...  var handler = function () {\n  alert( 'Activating!' );\n};\n\nractive.on( 'activate', handler );\n\n// later...\nractive.off( 'activate', handler );  In the second case, note that if you don't specify a handler, all 'activate' handlers will be removed. If you don't specify an event name,  all  event handlers will be removed from the instance. See  ractive.off()  for more detail.  The  ractive.off()  method is chainable for easily replacing subscribtions:  ractive.off( 'activate' ).on( 'activate', function () {...} );", 
            "title": "Unsubscribe"
        }, 
        {
            "location": "/Concepts/Events/Publish-Subscribe/#publish", 
            "text": "In addition to the built-in  lifecycle events  and  proxy events , you can fire your own events with  ractive.fire() .  This is most useful in the context of a  component  that needs to emit custom events. Here's a (somewhat contrived) example:  var Ticker = Ractive.extend({\n  oninit: function () {\n    var i = 1;\n\n    this.interval = setInterval( function () {\n      this.fire( 'tick', i++ );\n    }.bind( this ), 1000 );\n  },\n  onteardown: function () {\n    clearInterval( this.interval );\n  }\n});\n\nvar ticker = new Ticker();\n\nticker.on( 'tick', function ( i ) {\n  console.log( i % 2 ? 'tick' : 'tock' );\n});", 
            "title": "Publish"
        }, 
        {
            "location": "/Concepts/Rendering/Progressive Enhancement/", 
            "text": "Progressive Enhancement\n\n\nTODO", 
            "title": "Progressive Enhancement"
        }, 
        {
            "location": "/Concepts/Rendering/Progressive Enhancement/#progressive-enhancement", 
            "text": "TODO", 
            "title": "Progressive Enhancement"
        }, 
        {
            "location": "/Concepts/Rendering/Server-Side Rendering/", 
            "text": "Server-Side Rendering\n\n\nTODO", 
            "title": "Server-Side Rendering"
        }, 
        {
            "location": "/Concepts/Rendering/Server-Side Rendering/#server-side-rendering", 
            "text": "TODO", 
            "title": "Server-Side Rendering"
        }, 
        {
            "location": "/Concepts/Security/CSP/", 
            "text": "CSP\n\n\nTo use ractive with \nContent Security Policy\n, you'll currently need \n'unsafe-eval'\n specified for \nscriptSrc\n in your CSP header. This may change in future - see https://github.com/ractivejs/ractive/issues/1897 .", 
            "title": "CSP"
        }, 
        {
            "location": "/Concepts/Security/CSP/#csp", 
            "text": "To use ractive with  Content Security Policy , you'll currently need  'unsafe-eval'  specified for  scriptSrc  in your CSP header. This may change in future - see https://github.com/ractivejs/ractive/issues/1897 .", 
            "title": "CSP"
        }, 
        {
            "location": "/Concepts/Templates/Overview/", 
            "text": "In Ractive, templates (until they get \nparsed\n, at least) are just snippets of HTML, with a few differences. A template should be \nwell-formed\n - Ractive's parser is not quite as forgiving as the HTML parsers found in browsers (though it does allow things like implicitly closed elements).\n\n\nStrictly speaking, a Ractive template is not valid HTML (for one thing, 'valid HTML' describes an entire document, and we're only dealing with snippets), but \nit doesn't matter\n, even if you're the kind of obsessive who can't stand a single error in the \nW3C validator\n, because it all comes out as lovely standards-compliant DOM.\n\n\nFor reference, however, the differences between Ractive templates and HTML are listed on this page.\n\n\nMustaches\n\n\nThe most obvious difference is that Ractive templates contain \nmustaches\n to facilitate data binding.\n\n\nProxy event directives\n\n\nElements in a Ractive template can have \nevents\n, which look like attributes but don't get rendered to the DOM as attributes (they are intercepted, and used as event binding instructions instead):\n\n\nbutton on-click='activate'\nActivate!\n/button\n\n\n\n\n\nTransitions\n\n\nAnother item in the set of things-that-look-like-attributes-but-aren't, \ntransitions\n allow you to specify how elements should behave when they first get introduced to the DOM and when they get removed from it later:\n\n\ndiv intro='fade'\nThis element will fade in gradually when it renders\n/div", 
            "title": "Overview"
        }, 
        {
            "location": "/Concepts/Templates/Overview/#mustaches", 
            "text": "The most obvious difference is that Ractive templates contain  mustaches  to facilitate data binding.", 
            "title": "Mustaches"
        }, 
        {
            "location": "/Concepts/Templates/Overview/#proxy-event-directives", 
            "text": "Elements in a Ractive template can have  events , which look like attributes but don't get rendered to the DOM as attributes (they are intercepted, and used as event binding instructions instead):  button on-click='activate' Activate! /button", 
            "title": "Proxy event directives"
        }, 
        {
            "location": "/Concepts/Templates/Overview/#transitions", 
            "text": "Another item in the set of things-that-look-like-attributes-but-aren't,  transitions  allow you to specify how elements should behave when they first get introduced to the DOM and when they get removed from it later:  div intro='fade' This element will fade in gradually when it renders /div", 
            "title": "Transitions"
        }, 
        {
            "location": "/Concepts/Templates/Elements/", 
            "text": "Just about any useful template will contain at least one HTML element, and Ractive has a few directives and other constructs built into its element representation to make life easier. Some of these constructs have their own sections in the docs, such as \nEvents\n, \nTransitions\n, \nTwo-way binding\n, \nDecorators\n, and \nComponents\n.\n\n\nConditional attributes\n\n\nYou can wrap one or more attributes inside an element tag in a conditional section, and Ractive will add and remove those attributes as the conditional section is rendered and unrendered. For instance:\n\n\nul\n\n{{#each list as item}}\n    \nli {{#if ~/selectedItems.indexOf(item) !== -1}}class=\nselected\n{{/if}}\n\n        {{item.name}}\n    \n/li\n\n{{/each}}\n\n/ul\n\n\n\n\n\nIn this example, if the current \nitem\n in the \nlist\n iteration is also in the \nselectedItems\n array, then a class attribute will be added to the rendered li and set to \n\"selected\"\n.\n\n\nAny number of attributes can be used in a section, and other \nMustache\n constructs can be used to supply attributes.\n\n\nClass and style attributes\n\n\nRactive has special handlers for style and class attributes that only add and remove values for classes or style properties that are in the template. This allows external code to modify the element without Ractive overriding the change on its next update.\n\n\nThere are also two special classes of attributes for handling a single class or style property at a time.\n\n\nstyle-*\n attributes\n\n\nTo facilitate quick updates to a single style property of an element, Ractive supports using \nstyle-property-name=\"value\"\n or \nstyle-propertyName=\"value\"\n attributes. The value may be any text including any mustaches, and when the value is updated, the appropriate style property on the element will be updated with the new value. Any hyphens after the first will be removed and the subsequent letter capitalized so both \nstyle-text-align\n and \nstyle-textAlign\n will target the \ntextAlign\n property of the element's style.\n\n\nstyle-\n attributes are processed as text rather than expressions, so you can use mustaches to set values e.g. \ndiv style-left=\"{{x}}px\" style-top=\"{{y}}em\"\n...\n/div\n. Any mustaches can be used in the value, including interpolators, sections, and partials.\n\n\nclass-*\n attributes\n\n\nTo facilitate easily adding and removing a single class on an element, Ractive supports using \nclass-class-name\n and \nclass-className\n attributes. Unlike style attributes, no changes are made to the hyphenation of the attribute name, so \nclass-class-name\n and \nclass-className\n will target \nclass-name\n and \nclassName\n, respectively. The truthiness of the value assigned to a \nclass-\n attribute determines whether or not Ractive will add the class to the element. If the value is truthy, the class will be added. If the value becomes falsey, then the class will be removed. No other classes on the element will be affected by changes to a \nclass-\n attribute.\n\n\nclass-\n attributes, like \nstyle-\n attributes, not processed as expressions, so in order to supply the conditional to determine whether or not the class is set, you must use an interpolator e.g. \ndiv class-foo=\"{{someBoolean}}\" class-bar=\"{{num + 33 \n 42}}\"\n...\n/div\n.", 
            "title": "Elements"
        }, 
        {
            "location": "/Concepts/Templates/Elements/#conditional-attributes", 
            "text": "You can wrap one or more attributes inside an element tag in a conditional section, and Ractive will add and remove those attributes as the conditional section is rendered and unrendered. For instance:  ul \n{{#each list as item}}\n     li {{#if ~/selectedItems.indexOf(item) !== -1}}class= selected {{/if}} \n        {{item.name}}\n     /li \n{{/each}} /ul   In this example, if the current  item  in the  list  iteration is also in the  selectedItems  array, then a class attribute will be added to the rendered li and set to  \"selected\" .  Any number of attributes can be used in a section, and other  Mustache  constructs can be used to supply attributes.", 
            "title": "Conditional attributes"
        }, 
        {
            "location": "/Concepts/Templates/Elements/#class-and-style-attributes", 
            "text": "Ractive has special handlers for style and class attributes that only add and remove values for classes or style properties that are in the template. This allows external code to modify the element without Ractive overriding the change on its next update.  There are also two special classes of attributes for handling a single class or style property at a time.", 
            "title": "Class and style attributes"
        }, 
        {
            "location": "/Concepts/Templates/Elements/#style-attributes", 
            "text": "To facilitate quick updates to a single style property of an element, Ractive supports using  style-property-name=\"value\"  or  style-propertyName=\"value\"  attributes. The value may be any text including any mustaches, and when the value is updated, the appropriate style property on the element will be updated with the new value. Any hyphens after the first will be removed and the subsequent letter capitalized so both  style-text-align  and  style-textAlign  will target the  textAlign  property of the element's style.  style-  attributes are processed as text rather than expressions, so you can use mustaches to set values e.g.  div style-left=\"{{x}}px\" style-top=\"{{y}}em\" ... /div . Any mustaches can be used in the value, including interpolators, sections, and partials.", 
            "title": "style-* attributes"
        }, 
        {
            "location": "/Concepts/Templates/Elements/#class-attributes", 
            "text": "To facilitate easily adding and removing a single class on an element, Ractive supports using  class-class-name  and  class-className  attributes. Unlike style attributes, no changes are made to the hyphenation of the attribute name, so  class-class-name  and  class-className  will target  class-name  and  className , respectively. The truthiness of the value assigned to a  class-  attribute determines whether or not Ractive will add the class to the element. If the value is truthy, the class will be added. If the value becomes falsey, then the class will be removed. No other classes on the element will be affected by changes to a  class-  attribute.  class-  attributes, like  style-  attributes, not processed as expressions, so in order to supply the conditional to determine whether or not the class is set, you must use an interpolator e.g.  div class-foo=\"{{someBoolean}}\" class-bar=\"{{num + 33   42}}\" ... /div .", 
            "title": "class-* attributes"
        }, 
        {
            "location": "/Concepts/Templates/Expressions/", 
            "text": "Expressions allow you to use logic within a template. At their simplest, that may just mean a basic arithmetic operation, such as converting to percentages, or making your \nindex references\n start at 1 rather than 0:\n\n\ndiv class='bar-chart'\n\n  {{#bars:i}}\n    \ndiv style='width: {{ value * 100 }}%;'\n{{ i + 1 }}\n/div\n\n  {{/bars}}\n\n/div\n\n\n\n\n\nOr it could mean formatting a currency so that \n1.79\n renders as \n\u00a31.79p\n:\n\n\np\nPrice: \nstrong\n{{ format( price ) }}\n/strong\n/p\n\n\n\n\n\nOr it could mean adding a class based on some condition:\n\n\na class='button {{ active ? \non\n : \noff\n }}'\nswitch\n/a\n\n\n\n\n\nOr it could mean filtering a list to exclude certain records:\n\n\nul\n\n{{# exclude( list, 'N/A' ) }}\n  \nli\n{{author}}: {{title}}\n/li\n\n{{/ end of filter }}\n\n/ul\n\n\n\n\n\nThese are all examples casually plucked from the air - whether they would be useful or not in real life depends on what you're trying to do. The point is that you can include more of your view logic at the declarative layer - the template - where it's easier to \nreason about\n.\n\n\nFrequently Used Expressions\n\n\nIf you use a particular expression frequently, you can save time by adding it Ractive's default data. This way you won't have to set up the expressions on each individual \nractive\n instance.\n\n\nThe example below adds expressions for some frequenlty used parts of \nmoment.js\n to the default data:\n\n\nvar helpers = Ractive.defaults.data;\nhelpers.fromNow = function(timeString){\n    return moment(timeString).fromNow()\n}\nhelpers.formatTime = function(timeString){\n    return moment(timeString).format(\nddd, h:mmA\n);\n}\nhelpers.humanizeTime = function(timeString){\n    return moment.duration(timeString).humanize();\n}\n\n\n\n\nValid expressions\n\n\nThese are, of course, JavaScript expressions. Almost any valid JavaScript expression can be used, with a few exceptions:\n\n\n\n\nNo assignment operators (i.e. \na = b\n, \na += 1\n, \na--\n and so on)\n\n\nNo \nnew\n, \ndelete\n, or \nvoid\n operators\n\n\nNo function literals (i.e. anything that involves the \nfunction\n keyword)\n\n\n\n\nAside from a subset of global objects (e.g. \nMath\n, \nArray\n, \nparseInt\n, \nencodeURIComponent\n - full list below), any references must be to properties (however deeply nested) of the Ractive instance's data, rather than arbitrary variables. Reference resolution follows the \nnormal process\n.\n\n\nDoes this use \neval\n?\n\n\nYes and no. You've probably read that 'eval is evil', or some other such nonsense. The truth is that while it does get abused, and can theoretically introduce security risks when user input gets involved, there are some situations where it's both necessary and sensible.\n\n\nBut repeatedly \neval\ning the same code is a performance disaster. Instead, we use the \nFunction\n constructor, which is a form of \neval\n, except that the code gets compiled once instead of every time it executes.\n\n\nA note about efficiency\n\n\nUsing the \nFunction\n constructor instead of \neval\n is just one way that Ractive optimises expressions. Consider a case like this:\n\n\n{{a}} + {{b}} = {{ a + b }}\n{{c}} + {{d}} = {{ c+d }}\n\n\n\n\nAt \nparse time\n, Ractive generates an \nabstract syntax tree\n (AST) from these expressions, to verify that it's a valid expression and to extract any references that are used. It then 'stringifies' the AST, so that the expression can later be compiled into a function.\n\n\nAs anyone who has seen minified JavaScript can attest, JavaScript cares not one fig what your variables are called. It also doesn't care about whitespace. So both of the expressions can be stringified the same way:\n\n\n_0+_1\n\n\n\n\n\nWhen we \nevaluate\n \n{{ a + b }}\n or \n{{ c+d }}\n, we can therefore use the same function but with different arguments. Recognising this, the function only gets compiled once, after which it is cached. (The cache is shared between all Ractive instances on the page.) Further, the result of the evaluation is itself cached (until one or more of the dependencies change), so you can repeat expressions as often as you like without creating unnecessary work.\n\n\nAll of this means that you could have an expression within a list section that was repeated 10,000 times, and the corresponding function would be created once \nat most\n, and only called when necessary.\n\n\nThe \nthis\n reference\n\n\nWithin an expression, you can use \nthis\n to refer to the current \ncontext\n:\n\n\nul\n\n  {{#items}}\n    \n!-- here, `this` means 'the current array member' --\n\n    \nli\n{{this.toUpperCase()}}\n/li\n\n  {{/items}}\n\n/ul\n\n\n\n\n\nIn regular mustache, we have something called the \nimplicit iterator\n - \n{{.}}\n - which does the same thing. Ractive allows you to use \nthis\n in place of \n.\n for purely aesthetic reasons.\n\n\nSupported global objects\n\n\n\n\nArray\n\n\nDate\n\n\nJSON\n\n\nMath\n\n\nNaN\n\n\nRegExp\n\n\ndecodeURI\n\n\ndecodeURIComponent\n\n\nencodeURI\n\n\nencodeURIComponent\n\n\nisFinite\n\n\nisNaN\n\n\nnull\n\n\nparseFloat\n\n\nparseInt\n\n\nundefined\n\n\n\n\nFunctions\n\n\nAny functions that you want to call, outside of the available globals above, must be properties of the Ractive instance's data as well. Functions can also depend on other references and will be re-evaulated when one of their dependencies is changed.\n\n\nDepedendencies are determined by capturing references in the viewmodel while the function is executing. Dependencies for functions are re-captured each time the function is executed.\n\n\np\n{{ formattedName() }}\n/p\n\n\n\n\n\nvar ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    user: { firstName: 'John', lastName: 'Public' },\n    formattedName: function() {\n      return this.get('user.lastName') + ', ' + this.get('user.firstName');\n    }\n  }\n};\n\n\n\n\nResult:\n\n\np\nPublic, John\n/p\n\n\n\n\n\nIn this example, the function \nformattedName\n will depend on both \nuser.firstName\n and \nuser.lastName\n, and updating either (or \nuser\n) will cause any expressions referencing \nformattedName\n to be re-evaluated as well.\n\n\nractive.set('user.firstName', 'Jane')\n\n\n\n\nResult:\n\n\np\nPublic, Jane\n/p\n\n\n\n\n\nFunctions on helper objects and third-party libraries\n\n\nYou can also add helper objects to your data and call functions on those objects in expressions. For example, you could add a reference to \nunderscore.js\n:\n\n\nvar ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    items: [ 2, 10, 200, 3, 1, 4],\n    _: _\n  }\n};\n\n\n\n\nAnd use that to sort an array in your template:\n\n\n{{# _.sortBy(items) }}{{.}}, {{/}}\n\n\n!-- Result: --\n\n1, 2, 3, 4, 10, 200,", 
            "title": "Expressions"
        }, 
        {
            "location": "/Concepts/Templates/Expressions/#frequently-used-expressions", 
            "text": "If you use a particular expression frequently, you can save time by adding it Ractive's default data. This way you won't have to set up the expressions on each individual  ractive  instance.  The example below adds expressions for some frequenlty used parts of  moment.js  to the default data:  var helpers = Ractive.defaults.data;\nhelpers.fromNow = function(timeString){\n    return moment(timeString).fromNow()\n}\nhelpers.formatTime = function(timeString){\n    return moment(timeString).format( ddd, h:mmA );\n}\nhelpers.humanizeTime = function(timeString){\n    return moment.duration(timeString).humanize();\n}", 
            "title": "Frequently Used Expressions"
        }, 
        {
            "location": "/Concepts/Templates/Expressions/#valid-expressions", 
            "text": "These are, of course, JavaScript expressions. Almost any valid JavaScript expression can be used, with a few exceptions:   No assignment operators (i.e.  a = b ,  a += 1 ,  a--  and so on)  No  new ,  delete , or  void  operators  No function literals (i.e. anything that involves the  function  keyword)   Aside from a subset of global objects (e.g.  Math ,  Array ,  parseInt ,  encodeURIComponent  - full list below), any references must be to properties (however deeply nested) of the Ractive instance's data, rather than arbitrary variables. Reference resolution follows the  normal process .", 
            "title": "Valid expressions"
        }, 
        {
            "location": "/Concepts/Templates/Expressions/#does-this-use-eval", 
            "text": "Yes and no. You've probably read that 'eval is evil', or some other such nonsense. The truth is that while it does get abused, and can theoretically introduce security risks when user input gets involved, there are some situations where it's both necessary and sensible.  But repeatedly  eval ing the same code is a performance disaster. Instead, we use the  Function  constructor, which is a form of  eval , except that the code gets compiled once instead of every time it executes.", 
            "title": "Does this use eval?"
        }, 
        {
            "location": "/Concepts/Templates/Expressions/#a-note-about-efficiency", 
            "text": "Using the  Function  constructor instead of  eval  is just one way that Ractive optimises expressions. Consider a case like this:  {{a}} + {{b}} = {{ a + b }}\n{{c}} + {{d}} = {{ c+d }}  At  parse time , Ractive generates an  abstract syntax tree  (AST) from these expressions, to verify that it's a valid expression and to extract any references that are used. It then 'stringifies' the AST, so that the expression can later be compiled into a function.  As anyone who has seen minified JavaScript can attest, JavaScript cares not one fig what your variables are called. It also doesn't care about whitespace. So both of the expressions can be stringified the same way:  _0+_1   When we  evaluate   {{ a + b }}  or  {{ c+d }} , we can therefore use the same function but with different arguments. Recognising this, the function only gets compiled once, after which it is cached. (The cache is shared between all Ractive instances on the page.) Further, the result of the evaluation is itself cached (until one or more of the dependencies change), so you can repeat expressions as often as you like without creating unnecessary work.  All of this means that you could have an expression within a list section that was repeated 10,000 times, and the corresponding function would be created once  at most , and only called when necessary.", 
            "title": "A note about efficiency"
        }, 
        {
            "location": "/Concepts/Templates/Expressions/#the-this-reference", 
            "text": "Within an expression, you can use  this  to refer to the current  context :  ul \n  {{#items}}\n     !-- here, `this` means 'the current array member' -- \n     li {{this.toUpperCase()}} /li \n  {{/items}} /ul   In regular mustache, we have something called the  implicit iterator  -  {{.}}  - which does the same thing. Ractive allows you to use  this  in place of  .  for purely aesthetic reasons.", 
            "title": "The this reference"
        }, 
        {
            "location": "/Concepts/Templates/Expressions/#supported-global-objects", 
            "text": "Array  Date  JSON  Math  NaN  RegExp  decodeURI  decodeURIComponent  encodeURI  encodeURIComponent  isFinite  isNaN  null  parseFloat  parseInt  undefined", 
            "title": "Supported global objects"
        }, 
        {
            "location": "/Concepts/Templates/Expressions/#functions", 
            "text": "Any functions that you want to call, outside of the available globals above, must be properties of the Ractive instance's data as well. Functions can also depend on other references and will be re-evaulated when one of their dependencies is changed.  Depedendencies are determined by capturing references in the viewmodel while the function is executing. Dependencies for functions are re-captured each time the function is executed.  p {{ formattedName() }} /p   var ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    user: { firstName: 'John', lastName: 'Public' },\n    formattedName: function() {\n      return this.get('user.lastName') + ', ' + this.get('user.firstName');\n    }\n  }\n};  Result:  p Public, John /p   In this example, the function  formattedName  will depend on both  user.firstName  and  user.lastName , and updating either (or  user ) will cause any expressions referencing  formattedName  to be re-evaluated as well.  ractive.set('user.firstName', 'Jane')  Result:  p Public, Jane /p", 
            "title": "Functions"
        }, 
        {
            "location": "/Concepts/Templates/Expressions/#functions-on-helper-objects-and-third-party-libraries", 
            "text": "You can also add helper objects to your data and call functions on those objects in expressions. For example, you could add a reference to  underscore.js :  var ractive = new Ractive({\n  template: template,\n  el: output,\n  data: {\n    items: [ 2, 10, 200, 3, 1, 4],\n    _: _\n  }\n};  And use that to sort an array in your template:  {{# _.sortBy(items) }}{{.}}, {{/}} !-- Result: -- \n1, 2, 3, 4, 10, 200,", 
            "title": "Functions on helper objects and third-party libraries"
        }, 
        {
            "location": "/Concepts/Templates/Keypaths/", 
            "text": "The main way to interact with a Ractive instance is by setting \nkeypaths\n. A keypath is a string representing the location of a piece of data:\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    foo: {\n      bar: 'baz'\n    }\n  }\n});\n\n// Simple keypath\nractive.get( 'foo' ); // returns { bar: 'baz' }\n\n// Compound keypath\nractive.get( 'foo.bar' ); // returns 'baz'\n\n\n\n\nUpstream and downstream keypaths\n\n\nIn the example above, we say that \n'foo.bar'\n is a \ndownstream keypath\n of \n'foo'\n, while \n'foo'\n is an \nupstream keypath\n of \n'foo.bar'\n.\n\n\nArray versus dot notation\n\n\nThe \n'foo.bar'\n keypath is an example of \ndot notation\n. With arrays, you can use dot notation or \narray notation\n, which may feel more familiar (internally, it gets converted to dot notation):\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [ 'a', 'b', 'c' ]\n  }\n});\n\n// Array notation\nractive.get( 'list[0]' ); // returns 'a'\n\n// Dot notation\nractive.get( 'list.0' ); // also returns 'a'\n\n\n\n\nMissing properties\n\n\nOrdinarily in JavaScript, trying to access a child property of an object that didn't exist would cause an error:\n\n\ndata = { numbers: [ 1, 2, 3 ]};\ndata.letters[0]; // throws an error - cannot read property '0' of undefined\n\n\n\n\nWithin Ractive, this will simply return \nundefined\n:\n\n\nractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    numbers: [ 1, 2, 3 ]\n  }\n});\n\nractive.get( 'letters[0]' ); // returns undefined\n\n\n\n\nEscaping\n\n\nWhile not ideal, sometimes properties of objects have \n.\ns in name e.g. \nfoo['bar.baz']\n. Note that while numbers are supported in array notation, strings are not. To access a peypath with a literal \n.\n in one of the keys, you can escape it with a \n\\\n e.g. \nfoo.bar\\.baz\n. Any keys accessible in the template will be unescaped, so if you're trying to use them with simple string concatenation to access a keypath with a \n.\n in it, you'll need to make sure you escape it first.", 
            "title": "Keypaths"
        }, 
        {
            "location": "/Concepts/Templates/Keypaths/#upstream-and-downstream-keypaths", 
            "text": "In the example above, we say that  'foo.bar'  is a  downstream keypath  of  'foo' , while  'foo'  is an  upstream keypath  of  'foo.bar' .", 
            "title": "Upstream and downstream keypaths"
        }, 
        {
            "location": "/Concepts/Templates/Keypaths/#array-versus-dot-notation", 
            "text": "The  'foo.bar'  keypath is an example of  dot notation . With arrays, you can use dot notation or  array notation , which may feel more familiar (internally, it gets converted to dot notation):  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [ 'a', 'b', 'c' ]\n  }\n});\n\n// Array notation\nractive.get( 'list[0]' ); // returns 'a'\n\n// Dot notation\nractive.get( 'list.0' ); // also returns 'a'", 
            "title": "Array versus dot notation"
        }, 
        {
            "location": "/Concepts/Templates/Keypaths/#missing-properties", 
            "text": "Ordinarily in JavaScript, trying to access a child property of an object that didn't exist would cause an error:  data = { numbers: [ 1, 2, 3 ]};\ndata.letters[0]; // throws an error - cannot read property '0' of undefined  Within Ractive, this will simply return  undefined :  ractive = new Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    numbers: [ 1, 2, 3 ]\n  }\n});\n\nractive.get( 'letters[0]' ); // returns undefined", 
            "title": "Missing properties"
        }, 
        {
            "location": "/Concepts/Templates/Keypaths/#escaping", 
            "text": "While not ideal, sometimes properties of objects have  . s in name e.g.  foo['bar.baz'] . Note that while numbers are supported in array notation, strings are not. To access a peypath with a literal  .  in one of the keys, you can escape it with a  \\  e.g.  foo.bar\\.baz . Any keys accessible in the template will be unescaped, so if you're trying to use them with simple string concatenation to access a keypath with a  .  in it, you'll need to make sure you escape it first.", 
            "title": "Escaping"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/", 
            "text": "What is Mustache?\n\n\nMustache\n is one of the most popular templating languages. It's a very lightweight, readable syntax with a comprehensive specification - which means that implementations (such as Ractive) can test that they're doing things correctly.\n\n\nIf you've used \nHandlebars\n or \nAngular\n you'll also find mustaches familiar.\n\n\n\n\nWhat are mustaches?\n\n\nMustache basics\n\n\nVariables\n\n\nSections\n\n\nComments\n\n\nPartials\n\n\nCustom delimiters\n\n\nExtensions\n\n\nArray indices\n\n\nObject iteration\n\n\nSpecial references\n\n\nRestricted references\n\n\nExpressions\n\n\nHandlebars-style sections\n\n\nAliasing\n\n\nStatic mustaches\n\n\n{{else}}\n and \n{{elseif}}\n\n\nEscaping Mustaches\n\n\n\n\n\n\nWhat are mustaches?\n\n\nWithin this documentation, and within Ractive's code, 'mustache' means two things - a snippet of a template which uses mustache delimiters, such as \n{{name}}\n, and the object within our \nparallel DOM\n that is responsible for listening to data changes and updating the (real) DOM.\n\n\nWe say that the \n{{name}}\n mustache has a \nreference\n of \nname\n. When it gets rendered, and we create the object whose job it is to represent \nname\n in the DOM, we attempt to \nresolve the reference according to the current context stack\n. For example if we're in the \nuser\n context, and \nuser\n has a property of \nname\n, \nname\n will resolve to a \nkeypath\n of \nuser.name\n.\n\n\nAs soon as the mustache knows what its keypath is (which may not be at render time, if data has not yet been set), it registers itself as a \ndependant\n of the keypath. Then, whenever data changes, Ractive scans the dependency graph to see which mustaches need to update, and notifies them accordingly.\n\n\n\n\nMustache basics\n\n\nIf you already know Mustache, Ractive supports all the Mustache features - basic Mustache variables like \n{{name}}\n, as well as sections, partials, and even delimiter changes. If you're already familiar with Mustache, skip to the Extensions section below.\n\n\nYou can also check out the \ntutorials\n.\n\n\n\n\nVariables\n\n\nThe most basic mustache type is the variable. A \n{{name}}\n tag in a template will try to find the \nname\n key in the current context. If there is no \nname\n key in the current context, the parent contexts will be checked recursively. If the top context is reached and the name key is still not found, nothing will be rendered.\n\n\nAll variables are HTML escaped by default. If you want to return unescaped HTML, use the triple mustache: \n{{{name}}}\n.\n\n\nYou can also use \n to unescape a variable: \n{{\n name}}\n. This may be useful when changing delimiters (see \"Set Delimiter\" below).\n\n\nTemplate:\n\n\n * {{name}}\n * {{age}}\n * {{company}}\n * {{{company}}}\n\n\n\n\nWith the following data:\n\n\n{\n  \nname\n: \nChris\n,\n  \ncompany\n: \nb\nGitHub\n/b\n\n}\n\n\n\n\nWill generate the following output:\n\n\n * Chris\n *\n * \nlt;b\ngt;GitHub\nlt;/b\ngt;\n * \nb\nGitHub\n/b\n\n\n\n\n\n\n\nSections\n\n\nSections render blocks of text one or more times, depending on the value of the key in the current context.\n\n\nA section begins with a pound and ends with a slash. That is, \n{{#person}}\n begins a \"person\" section while \n{{/person}}\n ends it.\n\n\nThe behavior of the section is determined by the value of the key.\n\n\nFalse Values or Empty Lists\n\n\nIf the person key exists and has a value of false or an empty list, the HTML between the pound and slash will not be displayed.\n\n\nTemplate:\n\n\nShown.\n{{#person}}\n  Never shown!\n{{/person}}\n\n\n\n\nData:\n\n\n{\n  \nperson\n: false\n}\n\n\n\n\nOutput:\n\n\nShown.\n\n\n\n\nNon-Empty Lists\n\n\nIf the person key exists and has a non-false value, the HTML between the pound and slash will be rendered and displayed one or more times.\n\n\nWhen the value is a non-empty list, the text in the block will be displayed once for each item in the list. The context of the block will be set to the current item for each iteration. In this way we can loop over collections.\n\n\nTemplate:\n\n\n{{#repo}}\n  \nb\n{{name}}\n/b\n\n{{/repo}}\n\n\n\n\nData:\n\n\n{\n  \nrepo\n: [\n    { \nname\n: \nresque\n },\n    { \nname\n: \nhub\n },\n    { \nname\n: \nrip\n }\n  ]\n}\n\n\n\n\nOutput:\n\n\nb\nresque\n/b\n\n\nb\nhub\n/b\n\n\nb\nrip\n/b\n\n\n\n\n\nNon-False Values\n\n\nWhen the value is non-false but not a list, it will be used as the context for a single rendering of the block.\n\n\nTemplate:\n\n\n{{#person?}}\n  Hi {{name}}!\n{{/person?}}\n\n\n\n\nData:\n\n\n{\n  \nperson?\n: { \nname\n: \nJon\n }\n}\n\n\n\n\nOutput:\n\n\nHi Jon!\n\n\n\n\nInverted Sections\n\n\nAn inverted section begins with a caret (hat) and ends with a slash. That is  \n{{^person}}\n begins a \"person\" inverted section while \n{{/person}}\n ends it.\n\n\nWhile sections can be used to render text one or more times based on the value of the key, inverted sections may render text once based on the inverse value of the key. That is, they will be rendered if the key doesn't exist, is false, or is an empty list.\n\n\nTemplate:\n\n\n{{#repo}}\n  \nb\n{{name}}\n/b\n\n{{/repo}}\n{{^repo}}\n  No repos :(\n{{/repo}}\n\n\n\n\nAttributes\n\n\nSections may also be used within attribute values and around attribute values. Using a conditional section around an attribute or group of attributes will exclude those attributes from the DOM when the conditional is \nfalse\n and include them when it is \ntrue\n. Using a conditional section within an attribute only affects the value of the attribute, and there may be multiple sections within an attribute value.\n\n\nIn the following terribly contrived example, if \nbig\n is truthy, then the button will have a class \nbig\n in addition to the fixed class \nbutton\n. If \nplanetsAligned\n is truthy, the button will also get an annoying \nonmousemove\n attribute. \nNote\n that ractive directives cannot currently be placed within a section, but that may change in the future.\n\n\nbutton class=\n{{#big}}big {{/}}button\n {{#planetsAligned}}onmousemove=\nalert('I am annoying...')\n{{/}}\nI sure hope the planets aren't aligned...\n/button\n\n\n\n\n\n\n\nComments\n\n\nComments begin with a bang and are ignored. The following template:\n\n\nh1\nToday{{! ignore me }}.\n/h1\n\n\n\n\n\nWill render as follows:\n\n\nh1\nToday.\n/h1\n\n\n\n\n\nIf you'd like the comments to show up, just use html comments and set \nstripComments\n to \nfalse\n.\nComments may contain newlines.\n\n\n\n\nPartials\n\n\nPartials begin with a greater than sign:\n\n\n{{\n box}}\n\n\n\n\nRecursive partials are possible. Just avoid infinite loops.\n\n\nThey also inherit the calling context. For example:\n\n\n{{\n next_more}}\n\n\n\n\nIn this case, \nnext_more.mustache\n file will inherit the size and start methods from the calling context.\n\n\nIn this way you may want to think of partials as includes, or template expansion:\n\n\nFor example, this template and partial:\n\n\nbase.mustache:\n\n\nh2\nNames\n/h2\n\n{{#names}}\n  {{\n user}}\n{{/names}}\n\n\n\n\nWith \nuser.mustache\n containing:\n\n\nstrong\n{{name}}\n/strong\n\n\n\n\n\nCan be thought of as a single, expanded template:\n\n\nh2\nNames\n/h2\n\n{{#names}}\n  \nstrong\n{{name}}\n/strong\n\n{{/names}}\n\n\n\n\nPartials are a very useful construct, and you can find out more about them on the \npartials\n page.\n\n\n\n\nCustom delimiters\n\n\nCustom delimiters are set with a 'Set delimiter' tag. Set delimiter tags start with an equal sign and change the tag delimiters from \n{{\n and \n}}\n to custom strings.\n\n\n{{foo}}\n  {{=[[ ]]=}}\n[[bar]]\n\n\n\n\nCustom delimiters may not contain whitespace or the equals sign.\n\n\nYou can also set custom delimiters using the \ndelimiters\n and \ntripleDelimiters\n options in your Ractive instance.\n\n\nvar ractive = new Ractive({\n  el: whatever,\n  template: myTemplate,\n  data: {\n    greeting: 'Hello',\n    greeted: 'world',\n    triple: '\nstrong\nThis is a triple-stache\n/strong\n'\n  },\n  delimiters: [ '[[', ']]' ],\n  tripleDelimiters: [ '[[[', ']]]' ]\n});\n\n\n\n\n\n\nExtensions\n\n\nRactive is 99% backwards-compatible with Mustache, but adds several additional features.\n\n\n\n\nArray index references\n\n\nIndex references are a way of determining where we are within a list section. It's best explained with an example:\n\n\n{{#items:i}}\n  \n!-- within here, {{i}} refers to the current index --\n\n  \np\nItem {{i}}: {{content}}\n/p\n\n{{/items}}\n\n\n\n\nIf you then set \nitems\n to \n[{content: 'zero'}, {content: 'one'}, {content: 'two'}]\n, the result would be\n\n\np\nItem 0: zero\n/p\n\n\np\nItem 1: one\n/p\n\n\np\nItem 2: two\n/p\n\n\n\n\n\nThis is particularly useful when you need to respond to user interaction. For example you could add a \ndata-index='{{i}}'\n attribute, then easily find which item a user clicked on.\n\n\n\n\nObject iteration\n\n\nMustache can also iterate over objects, rather than array. The syntax is the same as for Array indices. Given the following ractive:\n\n\nractive = new Ractive({\n  el: container,\n  template: template,\n  data: {\n    users: {\n      'Joe': { email: 'joe@example.com' },\n      'Jane': { email: 'jane@example.com' },\n      'Mary': { email: 'mary@example.com' }\n    }\n  }\n});\n\n\n\n\nWe can iterate over the users object with the following:\n\n\nul\n\n  {{#users:name}}\n    \nli\n{{name}}: {{email}}\n/li\n\n  {{/users}}\n\n/ul\n\n\n\n\n\nto create:\n\n\nul\n\n  \nli\nJoe: joe@example.com\n/li\n\n  \nli\nJane: jane@example.com\n/li\n\n  \nli\nMary: mary@example.com\n/li\n\n\n/ul\n\n\n\n\n\nIn previous versions of Ractive it was required to close a section with the opening keypath. In the example above \n{{#users}}\n is closed by \n{{/users}}\n. This is no longer the case, you can now simply close an iterator with \n{{/}}\n. Ractive will attempt to warn you in the event of a mismatch, \n{{#users}}\n cannot be closed by \n{{/comments}}\n. This will not effect \nExpressions\n as they have always been able to be closed by \n{{/}}\n.\n\n\n!--- valid markup --\n\n{{#users}}\n\n{{/users}}\n\n{{#users:i}}\n\n{{/users}}\n\n{{#users}}\n\n{{/}}\n\n{{#users.topUsers}}\n\n!-- still matches the first part of the keypath, thus a valid closing tag --\n\n{{/users}}\n\n\n!-- invalid markup --\n\n{{#users}}\n\n{{/comments}}\n\n\n\n\n\n\nSpecial references\n\n\nThere are a few implicit variables that are available anywhere within a ractive template.\n\n\n\n\n\n\n@index\n is a reference to the index or key name of the nearest iterative section. It is available even if an index name is not supplied for the section.\n\n\nhtml\n{{#items}}{{@index + 1}} - {{.}}{{/}}\n\n\n\n\n\n\n@key\n is a reference to the current key in the nearest object iterator section.\n\n\n\n\n\n\n@keypath\n is the current context used to resolve references.\n\n\nhtml\n{{#foo}}{{#bar}}{{@keypath}} - foo.bar{{/}}{{/}}\n{{#items}}{{#.condition}}{{@keypath}} - for the first item will be items.0.condition{{/}}{{/}}\n\n\n\n\n\n\n@keypath\n is particularly useful when aliasing is used and the current context outside of the aliasing is hidden.\n\n\n\n\nRestricted references\n\n\nNormally, references are resolved according to a specific algorithm, which involves \nmoving up the context stack\n until a property matching the reference is found. In the vast majority of cases this is exactly what you want, but occasionally (for example when dealing with \nrecursive partials\n) it is useful to be able to specify more specific directives about the context of a property being referenced.\n\n\nSee \nReferences\n for all available reference restrictions.\n\n\n\n\nExpressions\n\n\nExpressions are a big topic, so they have a \npage of their own\n. But this section is about explaining the difference between vanilla Mustache and Ractive Mustache, so they deserve a mention here.\n\n\nExpressions look like any normal mustache. For example this expression converts \nnum\n to a percentage:\n\n\np\n{{ num * 100 }}%\n/p\n\n\n\n\n\nThe neat part is that this expression will recognise it has a dependency on whatever keypath \nnum\n resolves to, and will re-evaluate whenever the value of \nnum\n changes.\n\n\nMustache fans may bristle at expressions - after all, the whole point is that mustache templates are \nlogic-less\n, right? But what that really means is that the logic is \nembedded in the syntax\n (what are conditionals and iterators if not forms of logic?) rather than being language dependent. Expressions just allow you to add a little more, and in so doing make complex tasks simple.\n\n\n\n\nHandlebars-style sections\n\n\nIn addition to Mustache-style conditional and iterative sections, Ractive adds Handlebars-style \nif\n, \nunless\n, \neach\n, and \nwith\n to handle branching, iteration, and context control. For \nif\n, \nwith\n, and \neach\n, \n{{elseif}}\n and \n{{else}}\n may be used to provide alternate branches for false conditions, missing contexts, or empty iterables.\n\n\nbutton on-click=\nflip\nFlip Coin\n/button\n\n\np\nCoin flip result: {{#if heads}}heads{{else}}tails{{/if}}\n/p\n\n\nul\n\n  {{#each result}}\n    \nli\n{{.}}\n/li\n\n  {{else}}\n    \nli\nNo results yet...\n/li\n\n  {{/each}}\n\n/ul\n\n\np\nHere is a {{#with some.nested.value}}{{.}}{{/with}} value.\n/p\n\n\n\n\n\nvar ractive = new Ractive({\n  el: document.body,\n  template: myTemplate,\n  data: {\n    results: [],\n    heads: true,\n    some: { nested: { value: 'nested' } }\n  }\n});\n\nractive.on('flip', function() {\n  var sadRandom = Math.floor(Math.random() * 2) === 1;\n  this.set('heads', sadRandom);\n  this.unshift('results', sadRandom ? 'heads' : 'tails');\n});\n\n\n\n\nIn this example, clicking the button gets a \"random\" coin flip result, sets it in an \nif\n conditional section, and prepends it in an \neach\n iterative section. There is also a \nwith\n context section throw in for good measure.\n\n\n\n\nAliasing\n\n\nAny section (or \n{{#with}}\n section) provides its own context to the template that falls within it, and any references within the section will be resolved against the section context. Ambiguous references are resolved up the model hierarchy \nand\n the context hierarchy. Given a data structure that looks like\n\n\n{\n  foo: {\n    baz: 99,\n    bar: {\n      baz: 42\n    }\n  },\n  list: [\n    baz: 198,\n    bar: {\n      baz: 84\n    }\n  ]\n}\n\n\n\n\nand a template\n\n\n{{#each list}}\n  explicit 1: {{.bar.baz}}\n  {{#with .bar}}\n    implicit 1: {{baz}}\n    {{#with ~/foo}}\n      explicit 2: {{.bar.baz}}\n      implicit 2: {{baz}}\n    {{/with}}\n  {{/with}}\n{{/each}}\n\n\n\n\nthere is no way to reference \n~/list.0.baz\n from the second implicit site because the site has a different context (\n~/foo\n) and using an ambiguous reference (\nbaz\n) results in \n~/foo.baz\n  being used. Aliasing offers an escape hatch for similarly complex scenarios where ambiguity can cause the wrong reference to be used or performance issues to arise, because ambiguity is expensive.\n\n\nAlias block use the existing \n{{#with}}\n mustache, but instead of setting a context, they set names for one or more keypaths. Aliases follow the form \ndestination as alias\n, where destination is any valid reference at that point in the template e.g. \n{{#with .foo as myFoo, @key as someKey, 10 * @index + ~/offset as someCalculation, .baz.bat as lastOne}}\n. Because plain reference aliases, like the \nmyFoo\n and \nlastOne\n aliases in the example, refer to exactly one non-computed keypath, they can also be used for two-way binding deeper in the template. For example, \ninput value=\"{{myFoo}}\" /\n as a child of the alias block would bind to \n.foo\n in the context where the alias block is defined.\n\n\nAliasing is also extended to \n{{#each}}\n blocks so that the iterated item can be named rather than just referred to as \nthis\n or \n.\n. For instance, \n{{#each list as item}}\n would make \nitem\n equivalent to \nthis\n directly within the \neach\n block, but \nitem\n would still refer to same value in further nested contexts. Index and key aliases can still be used with an aliased iteration e.g. \n{{#each object as item: key, index}}\n.\n\n\nFinally, partials can also be used with alias shorthand in much the same way that they can be passed context e.g. \n{{\nsomePartial .foo.bar as myBar, 20 * @index + baz as myComp}}\n.\n\n\n\n\nStatic mustaches\n\n\nSometimes it is useful to have portions of a template render once and stay the same even if their references change. A static mustache will be updated only when its template is rendered and not when its keypath is updated. So, if a static mustache is a child of a section or partial that get re-rendered, the mustache will also be re-rendered using the current value of its keypath.\n\n\nThe default static mustache delimiters are \n[[ ]]\n for escaped values and \n[[[ ]]]\n for unescaped values.\n\n\n[[ foo ]] {{ foo }}\n{{^flag}}\n  [[ foo ]]\n{{/}}\n\n\n\n\nvar ractive = new Ractive({\n  data: { foo: 'bar' },\n  ...\n});\nractive.set('foo', 'bippy');\nractive.set('flag', true);\nractive.set('flag', false);\n\n\n\n\nOutput:\n\n\nbar bippy bippy\n\n\n\n\nStatic mustaches may also be used for sections that should only be updated on render.\n\n\n[[# if admin ]]\nHello, admin\n[[else]]\nHello, normal user\n[[/if]]\n\n\n\n\nvar ractive = new Ractive({\n  data: { admin: false },\n  ...\n});\nractive.set('admin', true);\n\n\n\n\nOutput:\n\n\nHello, normal user\n\n\n\n\n\n\n{{else}} and {{elseif}}\n\n\nRactive borrows a trick from Handlebars here and lets you perform:\n\n\n{{#repo}}\n  \nb\n{{name}}\n/b\n\n{{else}}\n  No repos :(\n{{/repo}}\n\n\n\n\nData:\n\n\n{\n  \nrepo\n: []\n}\n\n\n\n\nOutput:\n\n\nNo repos :(\n\n\n\n\nRactive takes it a step further and also allows you to use \n{{elseif otherCondition}}\n for alternate cases.\n\n\n{{#if foo}}\n  foo\n{{elseif bar}}\n  bar but not foo\n{{else}}\n  neither foo nor bar\n{{/if}}\n\n\n\n\nIn this case, the output would be what you would expect. If \nfoo\n is true, then the output will be \nfoo\n. If \nfoo\n is false and \nbar\n is true, the the output will be \nbar but not foo\n. If neither \nfoo\n nor \nbar\n is true, the the output will be \nneither foo nor bar\n.\n\n\nFurther, \n{{else}}\n and \n{{elseif}}\n clauses can be used with \n{{#with}}\n and \n{{#each}}\n sections too. If the context for the \n{{#with}}\n section doesn't exist, then any else clauses will be processed as if the entire section were a conditional with a false first branch. If the array for the \n{{#each}}\n (or regular iterative section) is empty or the object has no keys, then any else clauses will be processed as if the entire section were a conditional with a false first branch.\n\n\n\n\nEscaping mustaches\n\n\nIf you need to have Ractive ignore some mustaches in your template, you can escape them with a '\\'.\n\n\n{{ interpolated }} {{backslash}}{{ left alone }}\n\n\n\n\nIf you need to have a backslash before an interpolated mustache, you can escape the backslash with another '\\'. Any additional mustaches will be exported into the template.\n\n\n{{backslash}}{{backslash}}{{ interpolated }} and preceeded by a single slash.\n{{backslash}}{{backslash}}{{backslash}}{{ interpolated }} and preceeded by two slashes.\n\n\n\n\nFootnote\n\n\n*Ractive implements the Mustache specification as closely as possible. 100% compliance is impossible, because it's unlike other templating libraries - rather than turning a string into a string, Ractive turns a string into DOM, which has to be restringified so we can test compliance. Some things, like lambdas, get lost in translation - it's unavoidable, and unimportant.", 
            "title": "Mustaches"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#what-is-mustache", 
            "text": "Mustache  is one of the most popular templating languages. It's a very lightweight, readable syntax with a comprehensive specification - which means that implementations (such as Ractive) can test that they're doing things correctly.  If you've used  Handlebars  or  Angular  you'll also find mustaches familiar.   What are mustaches?  Mustache basics  Variables  Sections  Comments  Partials  Custom delimiters  Extensions  Array indices  Object iteration  Special references  Restricted references  Expressions  Handlebars-style sections  Aliasing  Static mustaches  {{else}}  and  {{elseif}}  Escaping Mustaches", 
            "title": "What is Mustache?"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#what-are-mustaches", 
            "text": "Within this documentation, and within Ractive's code, 'mustache' means two things - a snippet of a template which uses mustache delimiters, such as  {{name}} , and the object within our  parallel DOM  that is responsible for listening to data changes and updating the (real) DOM.  We say that the  {{name}}  mustache has a  reference  of  name . When it gets rendered, and we create the object whose job it is to represent  name  in the DOM, we attempt to  resolve the reference according to the current context stack . For example if we're in the  user  context, and  user  has a property of  name ,  name  will resolve to a  keypath  of  user.name .  As soon as the mustache knows what its keypath is (which may not be at render time, if data has not yet been set), it registers itself as a  dependant  of the keypath. Then, whenever data changes, Ractive scans the dependency graph to see which mustaches need to update, and notifies them accordingly.", 
            "title": "What are mustaches?"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#mustache-basics", 
            "text": "If you already know Mustache, Ractive supports all the Mustache features - basic Mustache variables like  {{name}} , as well as sections, partials, and even delimiter changes. If you're already familiar with Mustache, skip to the Extensions section below.  You can also check out the  tutorials .", 
            "title": "Mustache basics"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#variables", 
            "text": "The most basic mustache type is the variable. A  {{name}}  tag in a template will try to find the  name  key in the current context. If there is no  name  key in the current context, the parent contexts will be checked recursively. If the top context is reached and the name key is still not found, nothing will be rendered.  All variables are HTML escaped by default. If you want to return unescaped HTML, use the triple mustache:  {{{name}}} .  You can also use   to unescape a variable:  {{  name}} . This may be useful when changing delimiters (see \"Set Delimiter\" below).  Template:   * {{name}}\n * {{age}}\n * {{company}}\n * {{{company}}}  With the following data:  {\n   name :  Chris ,\n   company :  b GitHub /b \n}  Will generate the following output:   * Chris\n *\n *  lt;b gt;GitHub lt;/b gt;\n *  b GitHub /b", 
            "title": "Variables"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#sections", 
            "text": "Sections render blocks of text one or more times, depending on the value of the key in the current context.  A section begins with a pound and ends with a slash. That is,  {{#person}}  begins a \"person\" section while  {{/person}}  ends it.  The behavior of the section is determined by the value of the key.", 
            "title": "Sections"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#false-values-or-empty-lists", 
            "text": "If the person key exists and has a value of false or an empty list, the HTML between the pound and slash will not be displayed.  Template:  Shown.\n{{#person}}\n  Never shown!\n{{/person}}  Data:  {\n   person : false\n}  Output:  Shown.", 
            "title": "False Values or Empty Lists"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#non-empty-lists", 
            "text": "If the person key exists and has a non-false value, the HTML between the pound and slash will be rendered and displayed one or more times.  When the value is a non-empty list, the text in the block will be displayed once for each item in the list. The context of the block will be set to the current item for each iteration. In this way we can loop over collections.  Template:  {{#repo}}\n   b {{name}} /b \n{{/repo}}  Data:  {\n   repo : [\n    {  name :  resque  },\n    {  name :  hub  },\n    {  name :  rip  }\n  ]\n}  Output:  b resque /b  b hub /b  b rip /b", 
            "title": "Non-Empty Lists"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#non-false-values", 
            "text": "When the value is non-false but not a list, it will be used as the context for a single rendering of the block.  Template:  {{#person?}}\n  Hi {{name}}!\n{{/person?}}  Data:  {\n   person? : {  name :  Jon  }\n}  Output:  Hi Jon!", 
            "title": "Non-False Values"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#inverted-sections", 
            "text": "An inverted section begins with a caret (hat) and ends with a slash. That is   {{^person}}  begins a \"person\" inverted section while  {{/person}}  ends it.  While sections can be used to render text one or more times based on the value of the key, inverted sections may render text once based on the inverse value of the key. That is, they will be rendered if the key doesn't exist, is false, or is an empty list.  Template:  {{#repo}}\n   b {{name}} /b \n{{/repo}}\n{{^repo}}\n  No repos :(\n{{/repo}}", 
            "title": "Inverted Sections"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#attributes", 
            "text": "Sections may also be used within attribute values and around attribute values. Using a conditional section around an attribute or group of attributes will exclude those attributes from the DOM when the conditional is  false  and include them when it is  true . Using a conditional section within an attribute only affects the value of the attribute, and there may be multiple sections within an attribute value.  In the following terribly contrived example, if  big  is truthy, then the button will have a class  big  in addition to the fixed class  button . If  planetsAligned  is truthy, the button will also get an annoying  onmousemove  attribute.  Note  that ractive directives cannot currently be placed within a section, but that may change in the future.  button class= {{#big}}big {{/}}button  {{#planetsAligned}}onmousemove= alert('I am annoying...') {{/}} I sure hope the planets aren't aligned... /button", 
            "title": "Attributes"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#comments", 
            "text": "Comments begin with a bang and are ignored. The following template:  h1 Today{{! ignore me }}. /h1   Will render as follows:  h1 Today. /h1   If you'd like the comments to show up, just use html comments and set  stripComments  to  false .\nComments may contain newlines.", 
            "title": "Comments"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#partials", 
            "text": "Partials begin with a greater than sign:  {{  box}}  Recursive partials are possible. Just avoid infinite loops.  They also inherit the calling context. For example:  {{  next_more}}  In this case,  next_more.mustache  file will inherit the size and start methods from the calling context.  In this way you may want to think of partials as includes, or template expansion:  For example, this template and partial:  base.mustache:  h2 Names /h2 \n{{#names}}\n  {{  user}}\n{{/names}}  With  user.mustache  containing:  strong {{name}} /strong   Can be thought of as a single, expanded template:  h2 Names /h2 \n{{#names}}\n   strong {{name}} /strong \n{{/names}}  Partials are a very useful construct, and you can find out more about them on the  partials  page.", 
            "title": "Partials"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#custom-delimiters", 
            "text": "Custom delimiters are set with a 'Set delimiter' tag. Set delimiter tags start with an equal sign and change the tag delimiters from  {{  and  }}  to custom strings.  {{foo}}\n  {{=[[ ]]=}}\n[[bar]]  Custom delimiters may not contain whitespace or the equals sign.  You can also set custom delimiters using the  delimiters  and  tripleDelimiters  options in your Ractive instance.  var ractive = new Ractive({\n  el: whatever,\n  template: myTemplate,\n  data: {\n    greeting: 'Hello',\n    greeted: 'world',\n    triple: ' strong This is a triple-stache /strong '\n  },\n  delimiters: [ '[[', ']]' ],\n  tripleDelimiters: [ '[[[', ']]]' ]\n});", 
            "title": "Custom delimiters"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#extensions", 
            "text": "Ractive is 99% backwards-compatible with Mustache, but adds several additional features.", 
            "title": "Extensions"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#array-index-references", 
            "text": "Index references are a way of determining where we are within a list section. It's best explained with an example:  {{#items:i}}\n   !-- within here, {{i}} refers to the current index -- \n   p Item {{i}}: {{content}} /p \n{{/items}}  If you then set  items  to  [{content: 'zero'}, {content: 'one'}, {content: 'two'}] , the result would be  p Item 0: zero /p  p Item 1: one /p  p Item 2: two /p   This is particularly useful when you need to respond to user interaction. For example you could add a  data-index='{{i}}'  attribute, then easily find which item a user clicked on.", 
            "title": "Array index references"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#object-iteration", 
            "text": "Mustache can also iterate over objects, rather than array. The syntax is the same as for Array indices. Given the following ractive:  ractive = new Ractive({\n  el: container,\n  template: template,\n  data: {\n    users: {\n      'Joe': { email: 'joe@example.com' },\n      'Jane': { email: 'jane@example.com' },\n      'Mary': { email: 'mary@example.com' }\n    }\n  }\n});  We can iterate over the users object with the following:  ul \n  {{#users:name}}\n     li {{name}}: {{email}} /li \n  {{/users}} /ul   to create:  ul \n   li Joe: joe@example.com /li \n   li Jane: jane@example.com /li \n   li Mary: mary@example.com /li  /ul   In previous versions of Ractive it was required to close a section with the opening keypath. In the example above  {{#users}}  is closed by  {{/users}} . This is no longer the case, you can now simply close an iterator with  {{/}} . Ractive will attempt to warn you in the event of a mismatch,  {{#users}}  cannot be closed by  {{/comments}} . This will not effect  Expressions  as they have always been able to be closed by  {{/}} .  !--- valid markup -- \n{{#users}}\n\n{{/users}}\n\n{{#users:i}}\n\n{{/users}}\n\n{{#users}}\n\n{{/}}\n\n{{#users.topUsers}} !-- still matches the first part of the keypath, thus a valid closing tag -- \n{{/users}} !-- invalid markup -- \n{{#users}}\n\n{{/comments}}", 
            "title": "Object iteration"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#special-references", 
            "text": "There are a few implicit variables that are available anywhere within a ractive template.    @index  is a reference to the index or key name of the nearest iterative section. It is available even if an index name is not supplied for the section.  html\n{{#items}}{{@index + 1}} - {{.}}{{/}}    @key  is a reference to the current key in the nearest object iterator section.    @keypath  is the current context used to resolve references.  html\n{{#foo}}{{#bar}}{{@keypath}} - foo.bar{{/}}{{/}}\n{{#items}}{{#.condition}}{{@keypath}} - for the first item will be items.0.condition{{/}}{{/}}    @keypath  is particularly useful when aliasing is used and the current context outside of the aliasing is hidden.", 
            "title": "Special references"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#restricted-references", 
            "text": "Normally, references are resolved according to a specific algorithm, which involves  moving up the context stack  until a property matching the reference is found. In the vast majority of cases this is exactly what you want, but occasionally (for example when dealing with  recursive partials ) it is useful to be able to specify more specific directives about the context of a property being referenced.  See  References  for all available reference restrictions.", 
            "title": "Restricted references"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#expressions", 
            "text": "Expressions are a big topic, so they have a  page of their own . But this section is about explaining the difference between vanilla Mustache and Ractive Mustache, so they deserve a mention here.  Expressions look like any normal mustache. For example this expression converts  num  to a percentage:  p {{ num * 100 }}% /p   The neat part is that this expression will recognise it has a dependency on whatever keypath  num  resolves to, and will re-evaluate whenever the value of  num  changes.  Mustache fans may bristle at expressions - after all, the whole point is that mustache templates are  logic-less , right? But what that really means is that the logic is  embedded in the syntax  (what are conditionals and iterators if not forms of logic?) rather than being language dependent. Expressions just allow you to add a little more, and in so doing make complex tasks simple.", 
            "title": "Expressions"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#handlebars-style-sections", 
            "text": "In addition to Mustache-style conditional and iterative sections, Ractive adds Handlebars-style  if ,  unless ,  each , and  with  to handle branching, iteration, and context control. For  if ,  with , and  each ,  {{elseif}}  and  {{else}}  may be used to provide alternate branches for false conditions, missing contexts, or empty iterables.  button on-click= flip Flip Coin /button  p Coin flip result: {{#if heads}}heads{{else}}tails{{/if}} /p  ul \n  {{#each result}}\n     li {{.}} /li \n  {{else}}\n     li No results yet... /li \n  {{/each}} /ul  p Here is a {{#with some.nested.value}}{{.}}{{/with}} value. /p   var ractive = new Ractive({\n  el: document.body,\n  template: myTemplate,\n  data: {\n    results: [],\n    heads: true,\n    some: { nested: { value: 'nested' } }\n  }\n});\n\nractive.on('flip', function() {\n  var sadRandom = Math.floor(Math.random() * 2) === 1;\n  this.set('heads', sadRandom);\n  this.unshift('results', sadRandom ? 'heads' : 'tails');\n});  In this example, clicking the button gets a \"random\" coin flip result, sets it in an  if  conditional section, and prepends it in an  each  iterative section. There is also a  with  context section throw in for good measure.", 
            "title": "Handlebars-style sections"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#aliasing", 
            "text": "Any section (or  {{#with}}  section) provides its own context to the template that falls within it, and any references within the section will be resolved against the section context. Ambiguous references are resolved up the model hierarchy  and  the context hierarchy. Given a data structure that looks like  {\n  foo: {\n    baz: 99,\n    bar: {\n      baz: 42\n    }\n  },\n  list: [\n    baz: 198,\n    bar: {\n      baz: 84\n    }\n  ]\n}  and a template  {{#each list}}\n  explicit 1: {{.bar.baz}}\n  {{#with .bar}}\n    implicit 1: {{baz}}\n    {{#with ~/foo}}\n      explicit 2: {{.bar.baz}}\n      implicit 2: {{baz}}\n    {{/with}}\n  {{/with}}\n{{/each}}  there is no way to reference  ~/list.0.baz  from the second implicit site because the site has a different context ( ~/foo ) and using an ambiguous reference ( baz ) results in  ~/foo.baz   being used. Aliasing offers an escape hatch for similarly complex scenarios where ambiguity can cause the wrong reference to be used or performance issues to arise, because ambiguity is expensive.  Alias block use the existing  {{#with}}  mustache, but instead of setting a context, they set names for one or more keypaths. Aliases follow the form  destination as alias , where destination is any valid reference at that point in the template e.g.  {{#with .foo as myFoo, @key as someKey, 10 * @index + ~/offset as someCalculation, .baz.bat as lastOne}} . Because plain reference aliases, like the  myFoo  and  lastOne  aliases in the example, refer to exactly one non-computed keypath, they can also be used for two-way binding deeper in the template. For example,  input value=\"{{myFoo}}\" /  as a child of the alias block would bind to  .foo  in the context where the alias block is defined.  Aliasing is also extended to  {{#each}}  blocks so that the iterated item can be named rather than just referred to as  this  or  . . For instance,  {{#each list as item}}  would make  item  equivalent to  this  directly within the  each  block, but  item  would still refer to same value in further nested contexts. Index and key aliases can still be used with an aliased iteration e.g.  {{#each object as item: key, index}} .  Finally, partials can also be used with alias shorthand in much the same way that they can be passed context e.g.  {{ somePartial .foo.bar as myBar, 20 * @index + baz as myComp}} .", 
            "title": "Aliasing"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#static-mustaches", 
            "text": "Sometimes it is useful to have portions of a template render once and stay the same even if their references change. A static mustache will be updated only when its template is rendered and not when its keypath is updated. So, if a static mustache is a child of a section or partial that get re-rendered, the mustache will also be re-rendered using the current value of its keypath.  The default static mustache delimiters are  [[ ]]  for escaped values and  [[[ ]]]  for unescaped values.  [[ foo ]] {{ foo }}\n{{^flag}}\n  [[ foo ]]\n{{/}}  var ractive = new Ractive({\n  data: { foo: 'bar' },\n  ...\n});\nractive.set('foo', 'bippy');\nractive.set('flag', true);\nractive.set('flag', false);  Output:  bar bippy bippy  Static mustaches may also be used for sections that should only be updated on render.  [[# if admin ]]\nHello, admin\n[[else]]\nHello, normal user\n[[/if]]  var ractive = new Ractive({\n  data: { admin: false },\n  ...\n});\nractive.set('admin', true);  Output:  Hello, normal user", 
            "title": "Static mustaches"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#else-and-elseif", 
            "text": "Ractive borrows a trick from Handlebars here and lets you perform:  {{#repo}}\n   b {{name}} /b \n{{else}}\n  No repos :(\n{{/repo}}  Data:  {\n   repo : []\n}  Output:  No repos :(  Ractive takes it a step further and also allows you to use  {{elseif otherCondition}}  for alternate cases.  {{#if foo}}\n  foo\n{{elseif bar}}\n  bar but not foo\n{{else}}\n  neither foo nor bar\n{{/if}}  In this case, the output would be what you would expect. If  foo  is true, then the output will be  foo . If  foo  is false and  bar  is true, the the output will be  bar but not foo . If neither  foo  nor  bar  is true, the the output will be  neither foo nor bar .  Further,  {{else}}  and  {{elseif}}  clauses can be used with  {{#with}}  and  {{#each}}  sections too. If the context for the  {{#with}}  section doesn't exist, then any else clauses will be processed as if the entire section were a conditional with a false first branch. If the array for the  {{#each}}  (or regular iterative section) is empty or the object has no keys, then any else clauses will be processed as if the entire section were a conditional with a false first branch.", 
            "title": "{{else}} and {{elseif}}"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#escaping-mustaches", 
            "text": "If you need to have Ractive ignore some mustaches in your template, you can escape them with a '\\'.  {{ interpolated }} {{backslash}}{{ left alone }}  If you need to have a backslash before an interpolated mustache, you can escape the backslash with another '\\'. Any additional mustaches will be exported into the template.  {{backslash}}{{backslash}}{{ interpolated }} and preceeded by a single slash.\n{{backslash}}{{backslash}}{{backslash}}{{ interpolated }} and preceeded by two slashes.", 
            "title": "Escaping mustaches"
        }, 
        {
            "location": "/Concepts/Templates/Mustaches/#footnote", 
            "text": "*Ractive implements the Mustache specification as closely as possible. 100% compliance is impossible, because it's unlike other templating libraries - rather than turning a string into a string, Ractive turns a string into DOM, which has to be restringified so we can test compliance. Some things, like lambdas, get lost in translation - it's unavoidable, and unimportant.", 
            "title": "Footnote"
        }, 
        {
            "location": "/Concepts/Templates/Parsing/", 
            "text": "Before templates can be used, they must be parsed. Parsing involves reading in a template string and converting it to a tree-like data structure, much like a browser's parser would.\n\n\nOrdinarily, parsing happens automatically. However you can use \nRactive.parse()\n as a standalone function if, for example, you want to parse templates as part of your build process (it works in Node.js). See also \nUsing Ractive with RequireJS\n.\n\n\nThe output of \nRactive.parse()\n is an array or object (depending on whether the template contains \ninline partials\n or not). Here's an example:\n\n\nThis contains everything Ractive needs to construct its bit of the DOM and set up data-binding, proxy event handlers, and transitions.\n\n\nIt's not designed to be human-readable or -editable, but rather to use as few bytes as possible. Typically a parsed template is only about 30-40% larger than the string version. (There is some useful testing to be done to see whether the tradeoff of piping the extra few bytes to users is worth the few milliseconds of parsing that it will save!)\n\n\nWherever possible (in other words, with whichever bits of a template don't use Ractive-specific features), the template will be stored as plain HTML.", 
            "title": "Parsing"
        }, 
        {
            "location": "/Concepts/Templates/Pre-Parsing/", 
            "text": "Before Ractive can render a template, it has to \nparse\n it. Parsing consists of reading the HTML and constructing a tree-like structure that represents the structure of the HTML, but also \nmustaches\n and their \nreferences\n or \nexpressions\n, along with any other concepts that aren't represented by HTML such as \ntransitions\n and \nevent proxies\n.\n\n\nTODO...", 
            "title": "Pre-Parsing"
        }, 
        {
            "location": "/Concepts/Templates/References/", 
            "text": "Within this documentation, and within Ractive's code, a \nreference\n is a string that refers to a piece of data - in other words, within a \n{{name}}\n \nmustache\n, \nname\n is the reference.\n\n\nBy themselves, references are useless - they must \nresolve\n to a \nkeypath\n before we can do anything with them (like render their value). If the reference exists with a section mustache, it may need to be resolved \nin the context of that section\n. In fact, because sections can be nested, we have to resolve each reference within its \ncontext stack\n.\n\n\nThe resolution algorithm looks like this:\n\n\n\n\nIs the reference a special ref? If so, resolve with the appropriate special keypath.\n\n\nIf the reference is explicit or matches a path in the current context exactly, resolve with that keypath.\n\n\nGrab the current virtual node from the template hierarchy.\n\n\nIf there are any aliases, index, or key mapping defined that match, resolve with that keypath.\n\n\nIf this is a component and there are any matching mappings, resolve with that keypath.\n\n\nIf this node has context and there is a matching path, resolve with that keypath.\n\n\nOtherwise, remove the innermost context from the stack. Repeat (3-7).\n\n\nSee if \nreference\n is a valid keypath by itself. If so, resolve with that keypath.\n\n\nIf the reference is still unresolved, add it to the 'pending resolution' pile. Each time potentially matching keypaths are updated, resolution will be attempted for the unresolved reference.\n\n\n\n\nHuh?\n\n\nThat's a little bit abstract. The following example may help explain:\n\n\n{{#user}}\n  \np\nWelcome back, {{name}}!\n    {{#messages}}\n      You have {{unread}} unread of {{total}} total messages.\n      You last logged in on {{lastLogin}}.\n    {{/messages}}\n  \n/p\n\n{{/user}}\n\n\n\n\nractive = new Ractive({\n  el: container,\n  template: myTemplate,\n  data: {\n    user: {\n      name: 'Jim',\n      messages: {\n        total: 10,\n        unread: 3\n      },\n      lastLogin: 'Wednesday'\n    }\n  }\n});\n\n\n\n\nWe start with an empty context stack, so to resolve the \nuser\n in \n{{#user}}\n we skip ahead to step 6 of the algorithm. Is \nuser\n a valid keypath - i.e. does \nractive.data\n have a \nuser\n property? Why yes, it does.\n\n\nWithin the \n{{#user}}\n section, \nuser\n is a context. So we now have a non-empty context stack - \n['user']\n. So when we come to resolve the \nname\n in \n{{name}}\n, we go to step 2. The innermost (and only) context is \nuser\n, so we test the keypath \nuser.name\n. Is it valid? Why yes, it is. So the \nname\n resolves to \nuser.name\n.\n\n\nNext up, \n{{#messages}}\n. The innermost context is still \nuser\n, so we test \nuser.messages\n - bingo. Because it's a section mustache, anything inside it now has a two-level context stack (\n['user', 'user.messages']\n).\n\n\nWe take \n{{unread}}\n and \n{{total}}\n and apply the same algorithm - sure enough, they resolve to \nuser.messages.unread\n and \nuser.messages.total\n.\n\n\nWhat about \n{{lastLogin}}\n? Again, we take the innermost context from the stack - \nuser.messages\n. Is \nuser.messages.lastLogin\n a valid keypath? No, it isn't. So we take the next innermost context - \nuser\n. As it turns out, \nuser.lastLogin\n is a valid keypath, so the reference resolves.\n\n\nMost of the time you don't need to be aware that this is going on, especially if you're already familiar with \nMustache\n, but it's useful to have a background understanding.\n\n\nLists\n\n\nThis is also how list sections work. Consider the following:\n\n\n{{#items}}\n  {{content}}\n{{/items}}\n\n\n\n\nractive = new Ractive({\n  el: container,\n  template: myTemplate,\n  data: {\n    items: [{ content: 'zero' }, { content: 'one' }, { content: 'two' }]\n  }\n});\n\n\n\n\nThe contents of the \n{{#items}}\n section are rendered once for each member of \nitems\n. Each time round, the context changes - the first time it is \nitems.0\n, then it is \nitems.1\n, then it is \nitems.2\n.\n\n\nWith a context of \nitems.0\n, the \ncontent\n reference resolves to \nitems.0.content\n, and so on.\n\n\nCurrent context - \n{{.}}\n or \n{{this}}\n\n\nUsing \n{{.}}\n or \n{{this}}\n (they refer to the same thing) resolves to the current data context.\n\n\nFor example, sometimes you will have lists of primitives (i.e. strings and numbers) rather than objects. To refer to the primitives, we must use the \nimplicit iterator\n:\n\n\n{{#items}}\n  {{.}}\n{{/items}}\n\n\n\n\nractive = new Ractive({\n  el: container,\n  template: myTemplate,\n  data: {\n    items: [ 'zero', 'one', 'two' ]\n  }\n});\n\n\n\n\nWhenever Ractive sees \n{{.}}\n, it simply resolves it to the innermost context - \nitems.0\n, \nitems.1\n, \nitems.2\n.\n\n\nIn Ractive (but not Mustache), you can use \n{{this}}\n in place of \n{{.}}\n. This is because in expressions - \n{{this.toFixed(1)}}\n looks much nicer than \n{{..toFixed(1)}}\n (for example).\n\n\nRestricted references\n\n\nSometimes you may want to reference a property within the current context regardless of whether that property currently exists. For those situations you can use what's called a \nrestricted reference\n (note that this feature does not exist in vanilla Mustache):\n\n\n{{#options}}\n  \nlabel\ninput type='checkbox' checked='{{.selected}}'\n {{description}}\n/label\n\n{{/options}}\n\n\n\n\nThis feature is particularly useful with \ntwo-way binding\n as these references have to be resolved immediately.\n\n\nYou can also use the form \n{{./selected}}\n if you prefer, or \n{{this.selected}}\n, both of which are the same as \n{{.selected}}\n.\n\n\nAncestor references\n\n\nVery occasionally, you might need to refer explicitly to a property higher up in the tree to avoid naming conflicts. You can do that by prefixing references with \n../\n (or \n../../\n, or \n../../../\n...):\n\n\nh1\nBlog posts by {{name}}\n/p\n\n\n\nul class='blog-posts'\n\n  {{#posts}}\n    \nli\na href='{{ slugify(../../name) }}/{{ slugify(name) }}'\n{{name}}\n/a\n/li\n\n  {{/posts}}\n\n/ul\n\n\n\n\n\nvar ractive = new Ractive({\n  el: document.body,\n  template: myTemplate,\n  data: {\n    name: 'Rich',\n    posts: [\n      { name: 'This is a blog post' },\n      { name: 'And so is this' }\n    ],\n    slugify: function ( str ) {\n      var slug;\n      /* SOME CODE HAPPENS */\n      return slug;\n    }\n  }\n});\n\n\n\n\nIn this example, some damn fool decided it would be a good idea to give posts a 'name' property as well as authors. Which means that in the \nhref\n attribute, it wouldn't be possible to refer to the root-level \nname\n property, because it would always resolve to the \nname\n property of the current post - and that's no good, because the root-level \nname\n property is used to construct the URL.\n\n\nBy using \n../../name\n instead of \nname\n, we're saying 'go up one level (to \nposts\n), then up one more (to the root), and \nthen\n look for the \nname\n property'.\n\n\nRoot references\n\n\nYou can also navigate directly from the top of the data hierarchy with \n~/\n. Note that this is the root of the ractive instance in which the template appears, not the entire view hierarchy of nested components.\n\n\nThe above example could also use a root reference:\n\n\nh1\nBlog posts by {{name}}\n/p\n\n\n\nul class='blog-posts'\n\n  {{#posts}}\n    \nli\na href='{{ ~/name }}/{{ name }}'\n{{name}}\n/a\n/li\n\n  {{/posts}}\n\n/ul\n\n\n\n\n\nSpecial references\n\n\nThere are a few things that can be useful to reference from the template that don't really exist in your data. For instance, the current iteration index of a repeated section. These special references can be used just like any other data reference, excepting two-way binding. Here's the list of specials and their resolutions:\n\n\n\n\n@index\n - the current iteration index of the containing repeated section e.g. \n{{#each list}}{{@index}}{{/each}}\n\n\n@key\n - the current key name of the containing object iteration section e.g. \n{{#each someObj}}{{@key}}{{/each}}\n\n\n@keypath\n - the keypath to the current context e.g. \nfoo.bar.baz\n in \n{{#foo}}{{#with bar.baz}}{{@keypath}}{{/with}}{{/}}\n. If the current context happens to be a mapping in a component, the keypath will be adjusted relative to the mapping.\n\n\n@rootpath\n - the same as keypath, except not adjusted for components.\n\n\n@global\n - the current global object for this environment e.g. \nwindow\n in a browser or \nglobal\n in node. This reference can be used with two-way binding, but note that if something outside of Ractive changes a value, Ractive won't know unless you tell it to \nupdate\n.\n\n\n@this\n - the current Ractive instance e.g. the current component or the Ractive root. You can access any properties or methods available on a Ractive instance with this, and due to the way capture works, you can also use \n@this.get('...')\n in a binding and it will update with the target keypath.\n\n\n\n\nSummary of prefixes\n\n\n\n\n~/\n means at the current instance root.\n\n\n.\n means the current context. When more path follows, it follows the path from the current context.\n\n\n../\n means the parent of the current context and may also be stacked and have a following path.\n\n\n@\n means this is a special reference that has meaning specified by where it exists in the template e.g. \n@index\n means the current iteration index of the containing repeated section.", 
            "title": "References"
        }, 
        {
            "location": "/Concepts/Templates/References/#huh", 
            "text": "That's a little bit abstract. The following example may help explain:  {{#user}}\n   p Welcome back, {{name}}!\n    {{#messages}}\n      You have {{unread}} unread of {{total}} total messages.\n      You last logged in on {{lastLogin}}.\n    {{/messages}}\n   /p \n{{/user}}  ractive = new Ractive({\n  el: container,\n  template: myTemplate,\n  data: {\n    user: {\n      name: 'Jim',\n      messages: {\n        total: 10,\n        unread: 3\n      },\n      lastLogin: 'Wednesday'\n    }\n  }\n});  We start with an empty context stack, so to resolve the  user  in  {{#user}}  we skip ahead to step 6 of the algorithm. Is  user  a valid keypath - i.e. does  ractive.data  have a  user  property? Why yes, it does.  Within the  {{#user}}  section,  user  is a context. So we now have a non-empty context stack -  ['user'] . So when we come to resolve the  name  in  {{name}} , we go to step 2. The innermost (and only) context is  user , so we test the keypath  user.name . Is it valid? Why yes, it is. So the  name  resolves to  user.name .  Next up,  {{#messages}} . The innermost context is still  user , so we test  user.messages  - bingo. Because it's a section mustache, anything inside it now has a two-level context stack ( ['user', 'user.messages'] ).  We take  {{unread}}  and  {{total}}  and apply the same algorithm - sure enough, they resolve to  user.messages.unread  and  user.messages.total .  What about  {{lastLogin}} ? Again, we take the innermost context from the stack -  user.messages . Is  user.messages.lastLogin  a valid keypath? No, it isn't. So we take the next innermost context -  user . As it turns out,  user.lastLogin  is a valid keypath, so the reference resolves.  Most of the time you don't need to be aware that this is going on, especially if you're already familiar with  Mustache , but it's useful to have a background understanding.", 
            "title": "Huh?"
        }, 
        {
            "location": "/Concepts/Templates/References/#lists", 
            "text": "This is also how list sections work. Consider the following:  {{#items}}\n  {{content}}\n{{/items}}  ractive = new Ractive({\n  el: container,\n  template: myTemplate,\n  data: {\n    items: [{ content: 'zero' }, { content: 'one' }, { content: 'two' }]\n  }\n});  The contents of the  {{#items}}  section are rendered once for each member of  items . Each time round, the context changes - the first time it is  items.0 , then it is  items.1 , then it is  items.2 .  With a context of  items.0 , the  content  reference resolves to  items.0.content , and so on.", 
            "title": "Lists"
        }, 
        {
            "location": "/Concepts/Templates/References/#current-context-or-this", 
            "text": "Using  {{.}}  or  {{this}}  (they refer to the same thing) resolves to the current data context.  For example, sometimes you will have lists of primitives (i.e. strings and numbers) rather than objects. To refer to the primitives, we must use the  implicit iterator :  {{#items}}\n  {{.}}\n{{/items}}  ractive = new Ractive({\n  el: container,\n  template: myTemplate,\n  data: {\n    items: [ 'zero', 'one', 'two' ]\n  }\n});  Whenever Ractive sees  {{.}} , it simply resolves it to the innermost context -  items.0 ,  items.1 ,  items.2 .  In Ractive (but not Mustache), you can use  {{this}}  in place of  {{.}} . This is because in expressions -  {{this.toFixed(1)}}  looks much nicer than  {{..toFixed(1)}}  (for example).", 
            "title": "Current context - {{.}} or {{this}}"
        }, 
        {
            "location": "/Concepts/Templates/References/#restricted-references", 
            "text": "Sometimes you may want to reference a property within the current context regardless of whether that property currently exists. For those situations you can use what's called a  restricted reference  (note that this feature does not exist in vanilla Mustache):  {{#options}}\n   label input type='checkbox' checked='{{.selected}}'  {{description}} /label \n{{/options}}  This feature is particularly useful with  two-way binding  as these references have to be resolved immediately.  You can also use the form  {{./selected}}  if you prefer, or  {{this.selected}} , both of which are the same as  {{.selected}} .", 
            "title": "Restricted references"
        }, 
        {
            "location": "/Concepts/Templates/References/#ancestor-references", 
            "text": "Very occasionally, you might need to refer explicitly to a property higher up in the tree to avoid naming conflicts. You can do that by prefixing references with  ../  (or  ../../ , or  ../../../ ...):  h1 Blog posts by {{name}} /p  ul class='blog-posts' \n  {{#posts}}\n     li a href='{{ slugify(../../name) }}/{{ slugify(name) }}' {{name}} /a /li \n  {{/posts}} /ul   var ractive = new Ractive({\n  el: document.body,\n  template: myTemplate,\n  data: {\n    name: 'Rich',\n    posts: [\n      { name: 'This is a blog post' },\n      { name: 'And so is this' }\n    ],\n    slugify: function ( str ) {\n      var slug;\n      /* SOME CODE HAPPENS */\n      return slug;\n    }\n  }\n});  In this example, some damn fool decided it would be a good idea to give posts a 'name' property as well as authors. Which means that in the  href  attribute, it wouldn't be possible to refer to the root-level  name  property, because it would always resolve to the  name  property of the current post - and that's no good, because the root-level  name  property is used to construct the URL.  By using  ../../name  instead of  name , we're saying 'go up one level (to  posts ), then up one more (to the root), and  then  look for the  name  property'.", 
            "title": "Ancestor references"
        }, 
        {
            "location": "/Concepts/Templates/References/#root-references", 
            "text": "You can also navigate directly from the top of the data hierarchy with  ~/ . Note that this is the root of the ractive instance in which the template appears, not the entire view hierarchy of nested components.  The above example could also use a root reference:  h1 Blog posts by {{name}} /p  ul class='blog-posts' \n  {{#posts}}\n     li a href='{{ ~/name }}/{{ name }}' {{name}} /a /li \n  {{/posts}} /ul", 
            "title": "Root references"
        }, 
        {
            "location": "/Concepts/Templates/References/#special-references", 
            "text": "There are a few things that can be useful to reference from the template that don't really exist in your data. For instance, the current iteration index of a repeated section. These special references can be used just like any other data reference, excepting two-way binding. Here's the list of specials and their resolutions:   @index  - the current iteration index of the containing repeated section e.g.  {{#each list}}{{@index}}{{/each}}  @key  - the current key name of the containing object iteration section e.g.  {{#each someObj}}{{@key}}{{/each}}  @keypath  - the keypath to the current context e.g.  foo.bar.baz  in  {{#foo}}{{#with bar.baz}}{{@keypath}}{{/with}}{{/}} . If the current context happens to be a mapping in a component, the keypath will be adjusted relative to the mapping.  @rootpath  - the same as keypath, except not adjusted for components.  @global  - the current global object for this environment e.g.  window  in a browser or  global  in node. This reference can be used with two-way binding, but note that if something outside of Ractive changes a value, Ractive won't know unless you tell it to  update .  @this  - the current Ractive instance e.g. the current component or the Ractive root. You can access any properties or methods available on a Ractive instance with this, and due to the way capture works, you can also use  @this.get('...')  in a binding and it will update with the target keypath.", 
            "title": "Special references"
        }, 
        {
            "location": "/Concepts/Templates/References/#summary-of-prefixes", 
            "text": "~/  means at the current instance root.  .  means the current context. When more path follows, it follows the path from the current context.  ../  means the parent of the current context and may also be stacked and have a following path.  @  means this is a special reference that has meaning specified by where it exists in the template e.g.  @index  means the current iteration index of the containing repeated section.", 
            "title": "Summary of prefixes"
        }
    ]
}