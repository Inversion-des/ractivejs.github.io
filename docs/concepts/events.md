# Overview

Like many libraries, Ractive implements the [publish/subscribe](http://addyosmani.com/blog/understanding-the-publishsubscribe-pattern-for-greater-javascript-scalability/) mechanism to allow you to respond to, or trigger, particular events.

```js
ractive = new Ractive({
  el: 'body',
  template: '<button on-click="activate">click me!</button>'
});

ractive.on( 'activate', function ( event ) {
  alert( 'Activating!' );
});
```

There are actually two-levels of event handling in Ractive:

> The lower-level interaction with DOM events or [custom events](). These are specified using [Event directives]() that also specify how the event is to be handled using either [proxy events]() or [method calls]().

> The [publish-subscribe]() api and event system within Ractive and between components. Proxy events bridge the DOM event into a Ractive event, whereas method calls directly invoke the ractive instance and do not use the pub/sub infrastructure.

<br>
The [publish-subscribe]() event handling in Ractive allows you to consistently handle three different categories of generated events:

* [Proxy events](), mentioned above, proxy DOM and custom events defined in your template
* [Method calls]() are a more powerful alternative to proxy events that allow you to execute one or more expressions when an event fires.
* [Lifecycle events]() generated by each ractive instance - such as `init`, `render` and `teardown`
* [Custom events]() fired in code using [`ractive.fire()`](../../api/instance-properties#ractive.fire()), which can be anything you like

## Hygiene

One of the advantages of using Ractive events is that, in addition to being able to manually unsubscribe events, both DOM events and
Ractive Events will be automatically unsubscribed when the ractive instance or component is torndown.

In practice, this means adding a template directive like `on-click='select'` is all that is needed to manage the DOM event.

# Bubbling

Events that fire in components will bubble up the view hierarchy - [see this demonstration](http://jsfiddle.net/rich_harris/cdvehp1t/). Bubbling events are namespaced by the element name used for that component in the template:

```js
ractive = new Ractive({
    el: document.body,
    template: '<widget/>',
    components: {
        widget: Ractive.extend({
            template: '<button on-click="select">Select Me</button>'
        })
    },
    oninit: function () {
	    this.on( 'widget.select', function () {
	    	alert('selected!');
		});
	}
});
```
The event will continue to bubble up under the name of the originating component, not the name of each parent component.

## Cancelling

Returning `false` from an event handler will prevent that event from bubbling further:

```js
this.on( 'widget.select', function () {
    return false;
});

```

Sibling event handlers will still be called. Cancelling only applies to bubbling up to the next level of the view hierarchy.

Note that returning `false` has a dual purpose of both cancelling the view hierarchy event bubbling __and__ cancelling the DOM Event if the event was DOM-based.

Template directives for handling component events _implicitly_ cancel bubbling of the subscribed event:

```html
<widget on-foo='bar'/>
```
In this example, `widget.foo` will not bubble. Instead a new event `bar` will be fired and bubbled, assuming the above template is also contained in a component, under the name of the new component.

## The `event.component` Property

Events that bubble add a `component` property to the event object that is the component ractive instance raising the event:

```js
this.on( 'widget.select', function ( event ) {
    event.component.observe( 'foo', function ( n, o, k ) {
        console.log( 'foo changed from', o, 'to', n );
    });
});

```


# Directives

DOM events are handled with template directives that take the form of element attributes, similar to global native DOM handlers, but are prefixed with `on-` plus the name of the event:

```html
<button on-click="activate">click me!</button>
```

You can assign multiple events by separating them with a hyphen:

```html
<div on-mouseover-mousemove='@this.set( "hover", true )'>...</div>
```
The structure of the attribute content will vary depending on whether you are using [proxy events]() (the first example) or [method calls]() (the second example). See each respective section for more details.

DOM events can be any supported event on the element node. Touch events - `touchstart`, `touchmove`, `touchend`, `touchcancel`, and `touchleave` (not w3c, but supported in some browsers) - can be used as well, and will be safely ignored if not supported by the current browser.

DOM Events will be automatically unsubscribed when the ractive instance is torndown.

## Cancelling DOM Events

See [publish-subscribe]() for information on automatically stopping DOM event propagation and default action.

## Custom events

In addition to all the usual DOM events, you can use *custom events* via [event plugins](). These allow you to define what conditions on the node should generate a directive-level event.

For example, you could add gesture support to your app with [ractive-touch](https://github.com/rstacruz/ractive-touch), which integrates [Hammer.js](http://hammerjs.github.io/) with Ractive.

Once defined, the custom event can then be used like any other event directive:

```html
<div on-swipeleft="nextPage">...</div>
```
Be aware that custom event names take precedence over native DOM event names.

## Component event directives

Template component elements can also have event directives:

```html
<my-widget on-foo="bar"/>
```

However, there are some differences and limitations to component event directives:

* These only respond to component raised events and are not DOM event or custom event subscriptions.
* Arguments to proxy events are ignored
* Method calls are not currently supported
* Pattern matching __is__ supported (see [publish-subscribe]()):
```html
<my-widget on-foo.*="bar"/>
```

# Method calls

__Note:__ Unqualified event method calls are deprecated and have been replaced with event expressions that resolve the same way as every other expression in a Ractive template. This means that to call, for instance, `set('foo', 'bar')` in an event, you would now use `@this.set('foo', 'bar')`. Unfortunately, this adds a bit of boilerplate to common method calls, but it is also resolves the disparity between event directives and other template references, allows calling data methods from events, and allows executing multiple, possibly more complex, expressions when an event fires.

As an alternative to [event directive](#directives), right from your template:

```html
<p>foo is {{foo}}</p>
<button on-click='@this.toggle("foo")'>toggle foo</button>
```

In this case, because [`ractive.toggle()`](../../api/instance-properties#ractivetoggle) is a built-in method, clicking the button will toggle the value of `foo` between `true` and `false` ([demo](http://jsfiddle.net/rich_harris/xxg93vw8/)).

This also works with custom methods:

```js
var ractive = new Ractive({
  el: 'body',
  template: '<button on-click="@this.klaxon()">sound the klaxon</button>',
  audio: new Audio( 'klaxon.mp3' ),
  klaxon: function () {
    this.audio.play();
  }
});
```

You can pass as many arguments to the method as you like, including data references:

```html
{{#each items :i}}
  <button on-click='@this.select(this,i)'>select this item</button>
{{/each}}
```

Notice that mustaches are __not__ used with data reference in method calls, i.e. `{{i}}` and will cause errors if they are. String literals need to be in quotes:

```html
<button on-click='@this.set("foo", true)'>make foo true</button>
```

You can also pass the `event` object, or properties thereof (`event.original` is the original DOM event) ([demo](http://jsfiddle.net/rich_harris/9ecvjjtm/)):

```html
<div
  on-mousemove='@this.set({
    x: event.original.clientX,
    y: event.original.clientY
  })'
  on-mouseleave='@this.set({
    x: "unknown",
    y: "unknown"
  })'
>
  <p>current mouse position: {{x}} x {{y}}</p>
</div>
```

The `event` object is also available within body of the method call function as `this.event`. Note that methods on your Ractive instance that may handle your events are effectively part of your public API, and `this.event` will only be available during invocations triggered by an event.

The `event` argument is also extended with contextual helper methods. See [helpers](../api/node-info.md).

If you need to evaluate multiple expressions from an event directive, simply separate them with a `,`. For instance:

```html
{{#each someList as item}}
<div>
  {{item.display}}
  <a href="#" on-click="event.pop('../'), @this.notifyUser('item removed!'), false">
    Remove and Notify
  </a>
</div>
{{/each}}
```

Note that this is a list of independent expressions, and as long as one doesn't throw, they will all be evaluated.

## Cancelling events

As with proxy events, you can cancel a DOM event by returning `false` from your event handler. Ractive with then call `preventDefault()` and `stopPropagation()` on the original DOM event. You can also call any methods on the original event by having it passed to your handler or accessing it using `this.event.original`. With event expressions, you can force the cancellation regardless of the return from any methods you call by simply including `false` as the last expression in your list, as above in the 'Remove and Notify' example. You can also override cancellation in much the same way by using `true` instead of `false`.


# Proxy events

Ractive has a concept of *proxy events*, which translate a user *action* (e.g. a mouseclick) defined via an [event directive](#directives) into an *intention* (e.g. 'select this option'). This allows you to handle user interaction in a readable, declarative fashion, without resorting to peppering your markup with class names to use as 'hooks' (which must then be kept consistent between your markup and your JavaScript code).

As with all events in Ractive, you subscribe with [`ractive.on()`](../../api/instance-properties#ractiveon) (also see [publish-subscribe](#publish-subscribe)). Proxy events declare the handler name of the event that will be fired, along with any optional arguments:

```js
ractive = new Ractive({
  el: 'body',
  template: '<button on-click="activate">click me!</button>'
});

ractive.on( 'activate', function ( event ) {
  alert( 'Activating!' );
});
```

In this example, it is `activate` (and not `click`!) that is the name of the handler event that will be fired for any registered handlers created via [`ractive.on()`](../../api/instance-properties#ractiveon).

## Event arguments

### The `event` object

The first argument to a proxy event handler is always a Ractive `event` object. It contains various properties:

* `event.name` - the name of the event, in this case 'activate'
* `event.node` - the DOM node in question
* `event.keypath` - the [keypath](./templates.md#keypaths) of the current context
* `event.context` - the value of `this.get(event.keypath)`
* `event.index` - a map of index references
* `event.component` - the component that raised the event, only present on [bubbled events](#bubbling)
* `event.original` - the original DOM event, if available

In the example above, `event.keypath` might be `items.0` for the first item in the list, `items.1` for the second, and so on. The `event.index` map would have a property `i`, which would correspond to those indices.

The event object is also available in event handlers using `this.event`, see [publish-subscribe](#publish-subscribe) for more details.

### Custom arguments

__NOTE:__ Arguments to proxy events have been deprecated because they are too easy to break. If you need to pass arguments with your event, you can use `@this.fire('myEvent', event, arg1, arg2, etc)`.

We might want to pass arguments to our handler in addition to the `event` object. We can do that by listing them, comma-separated, after the event name:

```html
<h1>Let's shop!</h1>
<ul>
  {{#each items: i}}
    <li>
      <p>{{i+1}}: {{description}}</p>
      <label><input value='{{qty}}'> Quantity</label>

      <!-- when the user clicks this button, add {{qty}} of this item -->
      <button on-click='addToCart:{{this}},{{qty}}'>Add to cart</button>
    </li>
  {{/each}}
</ul>
```

```js
ractive.on( 'addToCart', function ( event, item, qty ) {
  /* code goes here */
});
```

## Cancelling DOM events

If you return `false` from a proxy event handler, ractive will automatically call both `preventDefault()` and `stopPropagation()` on the original DOM event.

Note that returning `false` has a dual purpose of both cancelling further bubbling up the view hierarchy [event bubbling](#bubbling) __as well as__ cancelling the DOM Event if the event was DOM-based.

If you only want to cancel the DOM event, you can call the appropriate methods directly on `event.original` or `this.event.original`, which are both references to the current DOM event object.


## Reserved event names

Note: the built-in [lifecycle events]() are **reserved**, which means you can't use their names as proxy events.


## Dynamic proxy event names

[Mustache references](./templates.md#mustaches) can be used as proxy event names:

```html
<button on-click="{{handler}}">click me!</button>
```

In practive this is of limited value, but a more important side effect is that if no handler is specified (a falsey value) the DOM event is not subscribed and will unsubscribe or resubscribe as the handler value changes. Combined with a conditional section, this allows a proxy event to be conditionally subscribed _at the DOM level_:

```html
<button on-click="{{#active}}select{{/}}">click me!</button>
```
In this example, the DOM `click` event is subscribed and unsubscribed as the value of `active` is truthy or falsey.

# Publish Subscribe

Like many libraries, Ractive implements the [publish/subscribe](http://addyosmani.com/blog/understanding-the-publishsubscribe-pattern-for-greater-javascript-scalability/) mechanism to allow you to respond to, or trigger, particular events.

## Subscribe

To subscribe to an event, use [`ractive.on()`](../../api/instance-properties#ractive.on()):

```js
ractive = new Ractive({
  el: 'body',
  template: '<button on-click="activate">click me!</button>'
});

ractive.on( 'activate', function () {
  alert( 'Activating!' );
});
```

This can be used to subscribe to any of the following type of events:

* [Proxy events]() for DOM and custom events defined in your template
* [Lifecycle events]() generated by each ractive instance - such as `init`, `render` and `teardown`
* [Custom events]() fired in code using [`ractive.fire()`](../api/instance-properties.md#ractivefire), which can be anything you like, see below.

### Multiple events to one handler

You can subscribe a handler to more than one event by separating event names with a space:

```js
ractive.on( 'activate select', function () {...} );
```
This example will fire for either an `activate` event or a `select` event.

### Object map of multiple event/handler pairs

Multiple hander/function pairs can be subscribed using an object hash:

```js
ractive.on({
	activate: function () {...},
	select: function () {...}
});
```

### Wildcard pattern handlers

Event names that use a keypath-like name can be subscribed using the pattern-matching wildcard "`*`" for any name path segment:

```js
ractive.on( 'foo.*', function () {...} );
```
This example will fire on any event name that starts with `foo.` - `foo.active`, `foo.select`, etc.

This is very useful with [event bubbling]() and auto-prefixed event names that bubble up from components.

Be aware that handlers like `widget.*` or `*` will fire for _all_ matching events, including [lifecycle events]().

### Accessing the event object

In addition to the event argument that is passed with proxy events, the event object can be accessed using `this.event` in the function body of any handler. This object is also present in non-proxy events including lifecycle events, though it includes a more limited set of properties.

Properties on all `this.event` objects:

* `this.event.name` - the name of the event
* `this.event.context` - the value of `this.get(event.keypath)` or `ractive.get()` for non-proxy events
* `this.event.component` - the component that raised the event, only present on [bubbled events]()
* `this.event.original` - the original DOM event, if available

Properties only on proxy events:
* `this.event.node` - the DOM node in question
* `this.event.keypath` - the [keypath]() of the current context
* `this.event.index` - a map of index references

One useful aspect of `this.event` is that the name of the event can be determined when wildcards are used:

```js
ractive.on( 'foo.*', function () {
	console.log( this.event.name );
});
```

### Cancelling DOM events

If you return 'false' from a proxy event handler, ractive will automatically call both `preventDefault()` and `stopPropagation()` on the original DOM event.

Note that returning `false` has a dual purpose of both cancelling the view hierarchy [event bubbling]() __as well as__ cancelling the DOM Event if the event was DOM-based.

## Unsubscribe

Event handlers are automatically removed if the instance is torn down (e.g. with [`ractive.teardown()`](../../api/instance-properties#ractive.teardown())) (which also happens as components are removed due to template/data logic).

You can also unsubscribe event handlers manually using one of two approaches:

```js
var listener = ractive.on( 'activate', function () {
  alert( 'Activating!' );
});

// later...
listener.cancel();
```

or...

```js
var handler = function () {
  alert( 'Activating!' );
};

ractive.on( 'activate', handler );

// later...
ractive.off( 'activate', handler );
```

In the second case, note that if you don't specify a handler, all 'activate' handlers will be removed. If you don't specify an event name, **all** event handlers will be removed from the instance. See [`ractive.off()`](../../api/instance-properties#ractive.off()) for more detail.

The `ractive.off()` method is chainable for easily replacing subscribtions:

```js
ractive.off( 'activate' ).on( 'activate', function () {...} );
```

## Publish

In addition to the built-in [lifecycle events]() and [proxy events](), you can fire your own events with [`ractive.fire()`](../../api/instance-properties#ractive.fire()).

This is most useful in the context of a [component]() that needs to emit custom events. Here's a (somewhat contrived) example:

```js
var Ticker = Ractive.extend({
  oninit: function () {
    var i = 1;

    this.interval = setInterval( function () {
      this.fire( 'tick', i++ );
    }.bind( this ), 1000 );
  },
  onteardown: function () {
    clearInterval( this.interval );
  }
});

var ticker = new Ticker();

ticker.on( 'tick', function ( i ) {
  console.log( i % 2 ? 'tick' : 'tock' );
});
```

