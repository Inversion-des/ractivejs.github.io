<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <meta name="author" content="RactiveJS contributors"> 
    <link rel="canonical" href="https://ractive.js.org/concepts/data-binding/"> 
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="theme-color" content="#557526">

    <title>Data Binding - Ractive.js</title>

    <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.018/css/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/cinder.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">


    <link href="../../css/index.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../..">Ractive.js</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Get Started <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../get-started/tutorials/hello-world/">Hello, world!</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/nested-properties/">Nested Properties</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/expressions/">Expressions</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/events/">Events</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/conditional-sections/">Conditional Sections</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/iterative-sections/">Iterative Sections</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/two-way-binding/">Two-way Binding</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/partials/">Partials</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/triples-embedded-html/">Triples (Embedded HTML)</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/components/">Components</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/animation/">Animations</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/svg/">SVG</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/transitions/">Transitions</a>
</li>

                        
                            
<li >
    <a href="../../get-started/tutorials/decorators/">Decorators</a>
</li>

                        
                            
<li >
    <a href="../../get-started/support/">Support</a>
</li>

                        
                            
<li >
    <a href="../../get-started/migrating/">Migrating</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">API <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../api/initialization-options/">Initialization Options</a>
</li>

                        
                            
<li >
    <a href="../../api/static-properties/">Static Properties</a>
</li>

                        
                            
<li >
    <a href="../../api/static-methods/">Static Methods</a>
</li>

                        
                            
<li >
    <a href="../../api/instance-properties/">Instance Properties</a>
</li>

                        
                            
<li >
    <a href="../../api/instance-methods/">Instance Methods</a>
</li>

                        
                            
<li >
    <a href="../../api/attributes/">Attributes</a>
</li>

                        
                            
<li >
    <a href="../../api/keypath-prefixes/">Keypath Prefixes</a>
</li>

                        
                            
<li >
    <a href="../../api/special-references/">Special References</a>
</li>

                        
                            
<li >
    <a href="../../api/context/">Context Object</a>
</li>

                        
                            
<li >
    <a href="../../api/parse/">Parse</a>
</li>

                        
                            
<li >
    <a href="../../api/transition/">Transition</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Extend <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../extend/adaptors/">Adaptors</a>
</li>

                        
                            
<li >
    <a href="../../extend/components/">Components</a>
</li>

                        
                            
<li >
    <a href="../../extend/decorators/">Decorators</a>
</li>

                        
                            
<li >
    <a href="../../extend/easings/">Easings</a>
</li>

                        
                            
<li >
    <a href="../../extend/events/">Events</a>
</li>

                        
                            
<li >
    <a href="../../extend/interpolators/">Interpolators</a>
</li>

                        
                            
<li >
    <a href="../../extend/partials/">Partials</a>
</li>

                        
                            
<li >
    <a href="../../extend/transitions/">Transitions</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Integrations <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../api/component-files/">Component Files</a>
</li>

                        
                            
<li >
    <a href="../../integrations/loaders/">Loaders</a>
</li>

                        
                            
<li >
    <a href="../../integrations/plugins/">Plugins</a>
</li>

                        
                            
<li >
    <a href="../../integrations/tools/">Tools</a>
</li>

                        
                            
<li >
    <a href="../../integrations/libraries/">Libraries</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Concepts <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../architecture/">Architecture</a>
</li>

                        
                            
<li >
    <a href="../rendering/">Rendering</a>
</li>

                        
                            
<li >
    <a href="../security/">Security</a>
</li>

                        
                            
<li class="active">
    <a href="./">Data Binding</a>
</li>

                        
                            
<li >
    <a href="../events/">Events</a>
</li>

                        
                            
<li >
    <a href="../templates/">Templates</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../security/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../events/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="https://github.com/ractivejs/ractive">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

    <div id="main">
        <div class="container">
            
            <div class="col-md-3" role="subnav"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="first-level active"><a href="#computed-properties">Computed Properties</a></li>
        
            <li class="second-level"><a href="#computed-properties-to-the-rescue">Computed properties to the rescue</a></li>
            
        
            <li class="second-level"><a href="#compact-syntax">Compact syntax</a></li>
            
        
            <li class="second-level"><a href="#setting-computed-values">Setting computed values</a></li>
            
        
            <li class="second-level"><a href="#components">Components</a></li>
            
        
            <li class="second-level"><a href="#data-context-for-computed-properties">Data context for computed properties</a></li>
            
        
    
        <li class="first-level "><a href="#dependents">Dependents</a></li>
        
            <li class="second-level"><a href="#indirect-dependencies">Indirect dependencies</a></li>
            
        
            <li class="second-level"><a href="#expressions-with-multiple-dependencies">Expressions with multiple dependencies</a></li>
            
        
    
        <li class="first-level "><a href="#observers">Observers</a></li>
        
            <li class="second-level"><a href="#like-publishsubscribe-but-different">Like publish/subscribe, but different</a></li>
            
        
            <li class="second-level"><a href="#observing-models-with-nested-properties">Observing models with nested properties</a></li>
            
        
            <li class="second-level"><a href="#pattern-observers">Pattern Observers</a></li>
            
        
            <li class="second-level"><a href="#space-delimited-observers">Space Delimited Observers</a></li>
            
        
            <li class="second-level"><a href="#a-gotcha-to-be-aware-of">A 'gotcha' to be aware of</a></li>
            
        
    
        <li class="first-level "><a href="#parallel-dom">Parallel DOM</a></li>
        
    
        <li class="first-level "><a href="#two-way-binding">Two-way binding</a></li>
        
            <li class="second-level"><a href="#input-elements">&lt;input&gt; elements</a></li>
            
        
            <li class="second-level"><a href="#checkboxes">Checkboxes</a></li>
            
        
            <li class="second-level"><a href="#radios">Radios</a></li>
            
        
            <li class="second-level"><a href="#textarea-elements">&lt;textarea&gt; elements</a></li>
            
        
            <li class="second-level"><a href="#select-elements">&lt;select&gt; elements</a></li>
            
        
            <li class="second-level"><a href="#contenteditable">contenteditable</a></li>
            
        
            <li class="second-level"><a href="#ambiguous-references">Ambiguous references</a></li>
            
        
            <li class="second-level"><a href="#lazy-updates">Lazy updates</a></li>
            
        
            <li class="second-level"><a href="#observing-changes">Observing changes</a></li>
            
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="computed-properties">Computed Properties</h1>
<p>The idea is fairly simple: you can define computed properties that update reactively based on their dependencies. In previous versions you may have done something as follows.</p>
<pre><code class="js">ractive = new Ractive({
  el: 'body',
  template: '{{width}} * {{height}} = {{ area() }}', // note the function invocation
  data: {
    width: 100,
    height: 100,
    area: function () { return this.get( 'width' ) * this.get( 'height' ); }
  }
});
</code></pre>

<p>That's nice and all - the <code>{{ area() }}</code> mustache updates reactively as <code>width</code> and <code>height</code> change - but it's limited. To get the area value programmatically you'd have to do something like...</p>
<pre><code class="js">area = ractive.get('area').call(ractive);
</code></pre>

<p>...which effectively prevents you from composing computed values together in any meaningful way. And you can't 'observe' the area outside of the template, without doing something like this:</p>
<pre><code class="js">ractive.observe( 'width height', function () {
    var area = this.get( 'width' ) * this.get( 'height' );
    doSomething( area );
});
</code></pre>

<h2 id="computed-properties-to-the-rescue">Computed properties to the rescue</h2>
<p>Now, you can do</p>
<pre><code class="js">ractive = new Ractive({
  el: 'body',
  template: '{{width}} * {{height}} = {{area}}', // `area` looks like a regular property
  data: {
    width: 100,
    height: 100
  },
  computed: {
    area: function () { return this.get( 'width' ) * this.get( 'height' ); }
  }
});
</code></pre>

<p>With this, the <code>area</code> property can be treated like any other. It will update reactively (because the calls to <code>ractive.get()</code> tell Ractive that it should be recomputed when <code>width</code> or <code>height</code> change), so you can do...</p>
<pre><code class="js">ractive.observe( 'area', doSomething );
</code></pre>

<p>...instead of manually recalculating it. And computed values can depend on other computed values, and so on (before anyone asks, we're not doing a topological sort or anything fancy like that - in real world scenarios I'd expect the overhead of doing the sort to be greater than the cost of occasionally recomputing a node in the dependency graph more times than is required).</p>
<h2 id="compact-syntax">Compact syntax</h2>
<p>The syntax used above, where each computed property is defined as a function, gives you a lot of flexibility. But there's a more compact string syntax you can use:</p>
<pre><code class="js">ractive = new Ractive({
  ...,
  computed: {
    area: '${width} * ${height}'
  }
});
</code></pre>

<p>This string is turned into a function with the <code>Function</code> constructor (which unfortunately means it isn't <a href="https://developer.mozilla.org/en-US/docs/Security/CSP">CSP compliant</a>) - any <code>${...}</code> blocks are basically turned into <code>ractive.get('...')</code>, so it works exactly the same way. Needless to say you can use any JavaScript here - <code>${foo}.toUpperCase()</code>, <code>Math.round(${num})</code>, and so on.</p>
<h2 id="setting-computed-values">Setting computed values</h2>
<p>By default, computed values are read-only, and if you try to <code>ractive.set('someComputedProperty')</code> an error will be thrown. But you can use a third syntax option which allows you to declare a <code>set()</code> method:</p>
<pre><code class="js">ractive = new Ractive({
  data: { firstname: 'Douglas', lastname: 'Crockford' },
  computed: {
    fullname: {
      get: '${firstname} + &quot; &quot; + ${lastname}', // or use the function syntax
      set: function ( fullname ) {
        var names = fullname.split( ' ' );

        this.set({
          firstname: names[0] || '',
          lastname: names[1] || ''
        });
      }
    }
  }
});

ractive.set( 'fullname', 'Rich Harris' );

ractive.get( 'firstname' ); // Rich
ractive.get( 'lastname' ); // Harris
</code></pre>

<h2 id="components">Components</h2>
<p>You can, of course, declare computed values on components:</p>
<pre><code class="js">Box = Ractive.extend({
  template: boxTemplate,
  computed: { area: '${width} * ${height}' }
});

box = new Box({
  ...,
  data: { width: 20, height: 40 }
});

box.get( 'area' ); // 800
</code></pre>

<p>Additional computed properties can be declared on the instance:</p>
<pre><code class="js">box2 = new Box({
  ...,
  data: { width: 20, height: 40, depth: 60 },
  computed: { volume: '${area} * ${depth}' }
});

box2.get( 'area' ); // 800
box2.get( 'volume' ); // 48000
</code></pre>

<h2 id="data-context-for-computed-properties">Data context for computed properties</h2>
<p>Computed properties can only be calculated for the instance context as a whole. You can't, for example, directly
compute a value for each member of an array:</p>
<pre><code class="js">new Ractive({
  template: '{{#boxes}}{{area}}{{/}}',
  data: {
    boxes: [
      { width: 20, height: 40 },
      { width: 30, height: 45 },
      { width: 20, height: 20 }
    ]
  },
  // there's no way to specify this for &quot;each&quot; box :(
  computed: { area: '${width} * ${height}' }
});
</code></pre>

<p>The solution is to either use a function that calculates the value for each member:</p>
<pre><code class="js">  template: '{{#boxes:b}}{{ getArea(b) }}{{/}}',
  data: {
    boxes: [
      { width: 20, height: 40 },
      { width: 30, height: 45 },
      { width: 20, height: 20 }
    ],
    getArea: function ( i ) {
      var box = this.get( 'boxes.' + i );
      return box.width * box.area;
    }
  }
</code></pre>

<p>Or leverage a component to "scope" the data to each item:</p>
<pre><code class="js">Box = Ractive.extend({
  template: boxTemplate,
  computed: { area: '${width} * ${height}' }
});

new Ractive({
  template: '{{#boxes}}&lt;box/&gt;{{/}}',
  data: {
    boxes: [
      { width: 20, height: 40 },
      { width: 30, height: 45 },
      { width: 20, height: 20 }
    ]
  },
  components: { box: Box }
});
</code></pre>

<h1 id="dependents">Dependents</h1>
<p>Ractive maintains a <em>dependency graph</em> in order to do the minimum amount of work necessary to keep the DOM up-to-date.</p>
<p>If you inspect a Ractive instance in your console, you'll see a property called <code>_deps</code>. This is where all dependants are listed, indexed by their dependency.</p>
<p>There is also a concept of 'priority', which exists to save us some work. If, for example, a section needs to be removed (perhaps it's a conditional section, and the condition just went from truthy to falsy), there is no point in updating all its children, so we make sure that we teardown the section first. As part of that teardown process, the children - which all have lower priority - unregister themselves as dependants before they get a chance to update.</p>
<h2 id="indirect-dependencies">Indirect dependencies</h2>
<p>If you have a mustache which depends on <code>foo.bar</code>, and <code>foo</code> changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an <em>indirect dependency</em> on <code>foo</code>, or that it has a <em>direct dependency on a downstream keypath</em> of <code>foo</code>.</p>
<p>This relationship is expressed through the <code>_depsMap</code> property of a Ractive instance - whenever <code>foo</code> changes, as well as dealing with direct <code>foo</code> dependants we check the map for those indirect dependants.</p>
<p>In the case of <a href="../templates/#expressions">expressions</a> and <a href="./#observers">observers</a>, we also need to consider dependants of <em>upstream keypaths</em>. For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:</p>
<pre><code class="html">{{#( sort( list, 'name' ) )}}
  &lt;p&gt;{{name}}&lt;/p&gt;
{{/()}}
</code></pre>

<pre><code class="js">ractive = new Ractive({
  el: myContainer,
  template: myTemplate,
  data: {
    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],
    sort: function ( list, property ) {
      return list.slice().sort( function ( a, b ) {
        return a[ property ] &lt; b[ property ] ? -1 : 1;
      });
    }
  }
});

// renders Alice, Bob, Charles

ractive.set( 'list[0].name', 'Zebediah' );

// updates to Alice, Charles, Zebediah
</code></pre>

<p>In the example, setting <code>list[0].name</code> causes dependants of <code>list</code> to be updated.</p>
<p>As well as <a href="../templates/#expressions">expressions</a>, <a href="./#observers">Observers</a> respond to both upstream and downstream changes.</p>
<h2 id="expressions-with-multiple-dependencies">Expressions with multiple dependencies</h2>
<p>The expression <code>{{ a + b }}</code> has two dependencies - <code>a</code> and <code>b</code> (or more accurately, whatever those <a href="../templates/#references">references</a> resolve to). The <code>_deps</code> graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.</p>
<p>Because the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing <code>ractive.set({ a: 1, b: 2 })</code> will only trigger one update, not two.</p>
<hr />
<h1 id="observers">Observers</h1>
<h2 id="like-publishsubscribe-but-different">Like publish/subscribe, but different</h2>
<p>A common pattern in modern JavaScript is to make models <em>observable</em>, using the traditional <a href="http://addyosmani.com/blog/understanding-the-publishsubscribe-pattern-for-greater-javascript-scalability/">publish/subscribe</a> mechanism.</p>
<p>For example, you can observe changes to attributes within a Backbone Model like so:</p>
<pre><code class="js">model = Backbone.Model({ myValue: 1 });

model.on( 'change:myValue', function ( model, value, options ) {
  alert( 'myValue changed to ' + value );
});

model.set( 'myValue', 2 ); // alerts 'myValue changed to 2'
</code></pre>

<p>This works because <code>Backbone.Model.prototype</code> inherits from <code>Backbone.Events</code>.</p>
<p>Ractive implements pub/sub with <a href="../../api/instance-methods/#ractiveon"><code>ractive.on()</code></a>, <a href="../../api/instance-methods/#ractiveoff"><code>ractive.off()</code></a> and <a href="../../api/instance-methods/#ractivefire"><code>ractive.fire()</code></a>, <a href="../../api/instance-methods/#ractiveoff"><code>ractive.off()</code></a> and <a href="../../api/instance-methods/#ractivefire"><code>ractive.fire</code></a> - see <a href="">Events</a> for more info.</p>
<h2 id="observing-models-with-nested-properties">Observing models with nested properties</h2>
<p>But the normal pub/sub mechanism won't work for monitoring data changes with Ractive, because our data can contain nested properties. It's no good subscribing to a <code>change:foo.bar</code> event, if <code>foo.bar</code> can change as a result of <code>foo</code> changing.</p>
<p>So instead, we introduce the concept of <em>observers</em>.</p>
<p>An observer observes a particular <a href="">keypath</a>, and is <em>notified</em> when the value of its keypath changes, whether directly or indirectly (because an <em>upstream</em> or <em>downstream</em> keypath changed). You create one with <code>ractive.observe()</code> (see <a href="../../api/instance-properties/#ractiveobserve"><code>ractive.observe()</code></a> for full method
API).</p>
<p>Here's an example:</p>
<pre><code class="js">ractive = new Ractive({
  el: myContainer,
  template: myTemplate,
  data: {
    foo: { bar: 1 }
  }
});

// The observer will be initialised with ( currentValue, undefined ) unless
// we pass a third `options` argument in which `init` is `false`. In other
// words this will alert 'foo.bar changed to 1'
observer = ractive.observe( 'foo.bar', function ( newValue, oldValue, keypath ) {
  alert( keypath + ' changed to ' + newValue );
});

ractive.set( 'foo.bar', 2 ); // alerts 'foo.bar changed to 2'
ractive.get( 'foo' ); // returns { bar: 2 }

ractive.set( 'foo', { bar: 3 }); // alerts 'foo.bar changed to 3'
ractive.get( 'foo.bar' ); // returns 3

observer.cancel();

ractive.set( 'foo.bar', 4 ); // alerts nothing; the observer was cancelled
</code></pre>

<p>Observers are most useful in the context of <a href="">two‐way binding</a>.</p>
<h2 id="pattern-observers">Pattern Observers</h2>
<p>It is useful to observe on specific keypaths but in the event your data contains array, or a set of dynamic data it isn't logical to bind to every potential keypath that could exist. Pattern observers use a <code>*</code> to indicate to Ractive that you would like to be notified whenever anything changes in your data at a particular depth as well as below the specified depth.</p>
<p>There are a few caveats when it comes to observing on array data, when observing on keypath <code>people.*</code> you are observing on the length of the array. This means that the <code>newValue</code> will be the index at which the new object was pushed. However when you use <code>set</code> to change an item at a particular index or a key that is on an object in the array then it will provide the object as the <code>newValue</code>.</p>
<pre><code class="js">var ractive = new Ractive({
  el: myContainer,
  template: myTemplate,
  data: {
    people: [
      {name: 'Rich Harris'},
      {name: 'Marty Nelson'}
    ]
  }
});

ractive.observe('people.*', function(newValue, oldValue, keypath) {

});

var people = ractive.get('people');
people.push({name: 'Jason Brown'});
//newValue will equal 3, and the keypath will be people.length

ractive.set('people.3', {name: 'Jack Black'});
//newValue will be {name: 'Jack Black'} and the keypath will be people.3

ractive.set('people.3.isACelebrity', true);
//newValue will be {name: 'Jack Black', isACelebrity: true} and the keypath will be people.3

ractive.set('people.0.info.isCreator', true);
//newValue will be the object for index 0 and the keypath will be people.0

</code></pre>

<p>Notice that because you are observing at the array level that <code>newValue</code> will be set as the entire object. What if you were only interested in knowing when a user became a celebrity? Simply tell Ractive you only want to observe dynamically on the array but only be notified when the <code>isACelebrity</code> key changes, <code>people.*.isACelebrity</code>.</p>
<pre><code class="js">ractive.observe('people.*.isACelebrity', function(newValue, oldValue, keypath) {

});

ractive.set('people.0.isACelebrity', true); //Rich Harris is a celebrity
//newValue will be `true` and the keypath will be people.0.isACelebrity

</code></pre>

<p>You are not limited to just one <code>*</code> for your pattern, you can use as many as you would like and in any particular order.</p>
<pre><code class="js">
ractive.observe('people.*.comments.*', function(newValue, oldValue, keypath) {

});

//even arrays of arrays

ractive.observe('people.*.*', function(newValue, oldValue, keypath) {

});

</code></pre>

<p>Furthermore it works on objects as well <code>config.*</code> will notify you when a value is changed on any key on the config object. However this differs from observing on an array in that it will provide the value set and keypath to the key that was set.</p>
<pre><code class="js">var ractive = new Ractive({
  el: myContainer,
  template: myTemplate,
  data: {
    config: {
      allowComments: true,
      allowEdit: false
    }
  }
});

ractive.observe('config.*', function(newValue, oldValue, keypath) {

});

ractive.set('config.allowEdit', true);
//newValue will be true and the keypath will be config.allowEdit

</code></pre>

<p>In addition to <code>newValue</code>, <code>oldValue</code>, and <code>keypath</code>, any widlcards that are matched in the <code>keypath</code> will be passed to the callback. Each additional wildcard will cause an extra parameter to be passed to the callback. For instance:</p>
<pre><code class="js">ractive.observe('items.*.*', function(newValue, oldValue, keypath, idx, key) {
  console.log('item', idx, key, 'is now', newValue);
});
ractive.set('items.1.foo', 'bar');
// logs 'item 1 foo is now bar'
</code></pre>

<p>Pattern observers are a simple and flexible that will allow you to observe your data any way that you want.</p>
<h2 id="space-delimited-observers">Space Delimited Observers</h2>
<p>Space delimited observers are useful when different keypaths should trigger the same function. In previous version you would have had to bind each keypath individually to the function.</p>
<p>This is a contrived example but for examples sake bare with us.</p>
<pre><code class="js">var ractive = new Ractive({
  el: myContainer,
  template: myTemplate,
  data: {
    user: {username: 'browniefed'},
    config: {isAdmin: false},
    commentCount: 0
  }
});

function updateServer() {
  //Make call to server because something in user, config, comments changed
}

ractive.observe('user.username', updateServer);
ractive.observe('config.isAdmin', updateServer);
ractive.observe('commentCount', updateServer);

</code></pre>

<p>This is unecessarily verbose, now with space delimited observers this becomes a single line.</p>
<pre><code class="js">ractive.observe('user.username config.isAdmin commentCount', updateServer);

</code></pre>

<p>This will work with patterns observers as well.</p>
<pre><code class="js">ractive.observe('user.* config.* commentCount', updateServer);

</code></pre>

<h2 id="a-gotcha-to-be-aware-of">A 'gotcha' to be aware of</h2>
<p>Observers will be notified whenever the new value is not equal to the old value - <em>sort of</em>.</p>
<p>What does 'not equal' mean? Well, with <em>primitive values</em> such as strings and numbers, that's easy - they're either identical (in the <code>===</code> sense) or they're not.</p>
<p>With objects and arrays (hereafter, just 'objects', since that's what arrays technically are), it's not so straightforward:</p>
<pre><code class="js">a = { one: 1, two: 2, three: 3 };
b = { one: 1, two: 2, three: 3 };

alert( a === b ); // alerts 'false' - they look the same, but they ain't

b = a;
b.four = 4;

alert( a === b ); // alerts 'true'. Hang on, `a` didn't have a 'four' property?
alert( a.four ); // alerts '4'. Oh. Right.
</code></pre>

<p>So one the one hand, objects which look identical aren't. On the other, you can set a property of an object and have no idea whether doing so resulted in a change.</p>
<p>There are two possible responses to this problem. First, we could do a 'deep clone' of an object whenever we do <code>ractive.set(keypath, object)</code>, using an algorithm similar to <a href="http://api.jquery.com/jQuery.extend/#jQuery-extend-deep-target-object1-objectN">jQuery extend</a>. That would mean any references you held to <code>object</code> would become irrelevant. It would also mean a whole load of extra computation, and probably some very strange behaviour with cyclical data structures. No thanks.</p>
<p>The second is to sidestep the issue, and simply state that for the purposes of determining whether to notify observers, <strong>no two objects are equal, even when they're identical</strong> (unless they're both <code>null</code>, of course - since <code>typeof null === 'object'</code> due to a <a href="http://www.2ality.com/2013/10/typeof-null.html">bug in the language</a>).</p>
<p>This is the safest, sanest behaviour, but it can lead to unexpected behaviour in one situation - accessing properties within an observer:</p>
<pre><code class="js">obj = { a: { b: { c: 1 } } };

ractive = new Ractive({
  el: myContainer,
  template: myTemplate,
  data: { obj: obj }
});

// We observe 'obj.a.b.c' indirectly, and directly
ractive.observe({
  'obj': function ( newObj, oldObj ) {
    alert( 'Indirect observer: changed from ' + oldObj.a.b.c + ' to ' + newObj.a.b.c );
  },
  'obj.a.b.c': function ( newC, oldC ) {
    alert( 'Direct observer: changed from ' + oldC + ' to ' + newC );
  }
});

obj.a.b.c = 2;

// The next line will cause two alerts:
//   'Direct observer: changed from 1 to 2'
//   'Indirect observer: changed from 2 to 2' - because oldObj === newObj
ractive.set( 'obj', obj );
</code></pre>

<p>This is definitely an edge case, but one that it's worth being aware of.</p>
<h1 id="parallel-dom">Parallel DOM</h1>
<p>Ractive works by maintaining a simplified model of the part of the DOM that it's responsible for. This model contains all the information - about data-binding, event handling and so on - that it needs to keep things up-to-date.</p>
<p>You can inspect the parallel DOM to understand what's going on under the hood, if you're into that sort of thing. Each Ractive instance, once rendered, has a <code>fragment</code> property. Each fragment has a number of properties:</p>
<ul>
<li><code>contextStack</code> - the context stack in which mustache <a href="">references</a> should be evaluated</li>
<li><code>root</code> - a reference to the Ractive instance to which it belongs</li>
<li><code>owner</code> - the <em>item</em> that owns this fragment (in the case of the root fragment, the same as <code>root</code>)</li>
<li><code>items</code> - the items belonging to this fragment</li>
</ul>
<p><em>Items</em> means elements, text nodes, and mustaches. Elements may have fragments of their own (i.e. if they have children). A partial mustache will have a fragment, and a section mustache will have zero or more fragments depending on the value of its keypath.</p>
<p>Elements may also have attributes, which have a different kind of fragment (a <em>text fragment</em> as opposed to a <em>DOM fragment</em>), containing text and mustaches.</p>
<p>Each item has a <code>descriptor</code>, which is something like DNA. This comes straight from the <a href="">parsed template</a>.</p>
<p>This is the briefest of overviews - if you want to gain a deeper understanding of what's going on under the hood, <a href="https://github.com/RactiveJS/Ractive/tree/master/src">use the source</a>.</p>
<hr />
<h1 id="two-way-binding">Two-way binding</h1>
<p>By default, a Ractive instance will update its internal model based on user input, if you have <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>&lt;select&gt;</code> elements.</p>
<p>If that's unhelpful for your app, you can disable it by passing <code>twoway: false</code> as an <a href="">initialisation option</a>.</p>
<p>Two-way vinding can also be overridden on a per-element basis using the <code>twoway</code> directive e.g. <code>&lt;input value="{{foo}}" twoway="false"&gt;</code>. If the <code>twoway</code> option is set to false, it can be overridden on a per-element bases using <code>twoway</code> as a boolean attribute e.g. <code>&lt;input value="{{foo}}" twoway&gt;</code> or <code>&lt;input value="{{foo}}" twoway="true"&gt;</code>.</p>
<h2 id="input-elements"><code>&lt;input&gt;</code> elements</h2>
<p>Two-way binding works with <code>&lt;input&gt;</code> elements of any type, including the new HTML5 types such as <code>color</code> or <code>email</code>. In most cases, you just add a mustache as the <code>value</code> attribute - this must be a single, standard <em>interpolator</em> mustache, like this:</p>
<pre><code class="html">&lt;input placeholder='Type your name' value='{{user.name}}'&gt;
</code></pre>

<p>In the example above, any changes the user makes to the input will be reflected in the <code>user.name</code> property.</p>
<h2 id="checkboxes">Checkboxes</h2>
<p>Checkboxes are used to flag a property as <code>true</code> or <code>false</code>. Rather than binding the <code>value</code> attribute, we bind the <code>checked</code> attribute:</p>
<pre><code class="html">&lt;label&gt;
    &lt;input type='checkbox' checked='{{on}}'&gt;
    The lights are {{ on ? 'on' : 'off' }}
&lt;/label&gt;
</code></pre>

<p>(True HTML nerds will recognise that <em>boolean attributes</em> such as checked don't have a value, as such - they either exist on an element or they don't. This makes life unnecessarily difficult; Ractive treats dynamic (i.e., controlled by a mustache) boolean attributes as present if the mustache is <code>true</code>, absent if <code>false</code>.)</p>
<p>Checkboxes may also be bound by the <code>name</code> attribute, which will result in the value specified in the <code>name</code> attribute containing an array of selected checkbox values.</p>
<pre><code class="html">{{#colors}}
  &lt;label&gt;
    &lt;input type='checkbox' name='{{selected}}' value='{{.}}' /&gt;{{.}}
  &lt;/label&gt;
{{/}}
</code></pre>

<p>If <code>colors</code> is an array, <code>['Red', 'Yellow', 'Green', 'Blue']</code>, then checking the first box will result in <code>selected</code> becoming <code>['Red']</code>. Checking the third box will result in <code>selected</code> becoming <code>['Red', 'Green']</code>. The array may also be updated from code using <code>set</code> or any of the array modification methods available to Ractive, and the checkboxes will be updated to reflect the contents of the array in the Ractive viewmodel.</p>
<p><strong>Note</strong> that checkboxes with both a <code>checked</code> and <code>name</code> binding will <em>only</em> bind on <code>checked</code>, not both. The <code>name</code> binding will be treated
as a normal mustache variable.</p>
<h2 id="radios">Radios</h2>
<p>Radio buttons can be controlled in the same way as checkboxes. However the chances are, if you're using radio buttons, you have a set of mutually exclusive options to choose between. In this case, if you set the <code>name</code> attribute on a radio input to e.g. <code>{{someValue}}</code>, <code>someValue</code> will reflect the <code>value</code> of the currently checked option:</p>
<pre><code class="html">&lt;label&gt;&lt;input type='radio' name='{{color}}' value='red' checked&gt; Red&lt;/label&gt;
&lt;label&gt;&lt;input type='radio' name='{{color}}' value='green'&gt; Green&lt;/label&gt;
&lt;label&gt;&lt;input type='radio' name='{{color}}' value='blue'&gt; Blue&lt;/label&gt;

&lt;p&gt;The currently selected color is &lt;span style='color: {{color}};'&gt;{{color}}&lt;/span&gt;&lt;/p&gt;
</code></pre>

<p>In the example above, the value of <code>color</code> will initially be <code>'red'</code> (because that input is checked in the template), and will update as and when the user selects another option.</p>
<h2 id="textarea-elements"><code>&lt;textarea&gt;</code> elements</h2>
<p>Textareas work exactly the same as standard text inputs - slap a dynamic <code>value</code> attribute on them, and you're done:</p>
<pre><code class="html">&lt;textarea value='{{content}}'&gt;&lt;/textarea&gt;
</code></pre>

<h2 id="select-elements"><code>&lt;select&gt;</code> elements</h2>
<p>Drop-down select menus are good when you have many options to choose from. They're straightforward to use in Ractive:</p>
<pre><code class="html">&lt;select value='{{selectedCountry}}'&gt;
    &lt;option selected disabled&gt;Select a country&lt;/option&gt;
    {{#countries}}
        &lt;option value='{{id}}'&gt;{{name}}&lt;/option&gt;
    {{/countries}}
&lt;/select&gt;
</code></pre>

<pre><code class="js">ractive = new Ractive({
    el: myContainer,
    template: myTemplate,
    data: {
        countries: [
            { id: 'AFG', name: 'Afghanistan' },
            { id: 'ALB', name: 'Albania' },
            { id: 'DZA', name: 'Algeria' },
            { id: 'ASM', name: 'American Samoa' }
            // and so on...
        ]
    }
});
</code></pre>

<p>In the example above, no country will initially be selected. If the user were to select Afghanistan from the list, the value of <code>selectedCountry</code> would change to <code>'AFG'</code>.</p>
<h2 id="contenteditable"><code>contenteditable</code></h2>
<p>Ractive can two-way data bind contenteditable elements.</p>
<pre><code class="js">var ractive = new Ractive({
    el: myContainer,
    template: myTemplate,
    data: {
        content: 'Edit me'
    }
});

ractive.observe('content', function(newValue, oldValue, keypath) {
    //newValue will contain the new content of the div
});
</code></pre>

<p><code>myTemplate</code></p>
<pre><code class="html">&lt;div contenteditable=&quot;true&quot; value=&quot;{{content}}&quot;&gt;&lt;/div&gt;
</code></pre>

<p>This will be rendered as</p>
<pre><code class="html">&lt;div contenteditable=&quot;true&quot;&gt;Edit Me&lt;/div&gt;
</code></pre>

<p>As the user edits the data the <code>content</code> will update, and observe will fire.</p>
<p>There are a few caveats that you need to know. Despite the value binding with only two curly braces <code>{{content}}</code> (double curly braces are required for two way data binding) the returned content may or may not be a string of HTML. If a user presses enter after most browsers will insert a <code>&lt;br /&gt;</code>. The <code>content</code> would be set to <code>Edit Me&lt;br/&gt;</code>. Additionally anything you set to <code>content</code> would be rendered as HTML and not escaped despite the lack of triple curly braces(<code>{{{content}}}</code>).</p>
<pre><code class="js">ractive.set('content', '&lt;ul&gt;&lt;li&gt;Edit Me&lt;/li&gt;&lt;/ul&gt;');
</code></pre>

<p>This would actually render an editable unordered list.</p>
<p>Be aware that not all browsers actually operate the same way when it comes to interacting with contenteditable. HTML generated by one browser may differ from another.</p>
<h2 id="ambiguous-references">Ambiguous references</h2>
<p>A mustache used in a two-way binding context must have an <em>unambiguous reference</em>. Consider the following:</p>
<pre><code class="html">{{#foo}}
    &lt;input value='{{bar}}'&gt;
{{/foo}}
</code></pre>

<pre><code class="js">ractive = new Ractive({
    el: myContainer,
    template: myTemplate,
    data: { foo: {} }
});
</code></pre>

<p>Ractive must decide, straight away, what <a href="">keypath</a> to bind the input's <code>value</code> attribute to. It will first see if it can <a href="">reference</a> (<code>'bar'</code>) given the current context stack (which includes a single context - <code>'foo'</code>). It can't, so it is forced to make an assumption - that the <code>'bar'</code> reference should resolve to the <code>'bar'</code> keypath.</p>
<p>But this might not be what you want - maybe you <em>did</em> want it to resolve to <code>'foo.bar'</code>.</p>
<p>You have two options - either use a <a href="">restricted reference</a>, i.e. <code>&lt;input value='{{.bar}}'&gt;</code>, or ensure that <code>foo</code> has a <code>bar</code> property (even if the initial value is <code>undefined</code>).</p>
<h2 id="lazy-updates">Lazy updates</h2>
<p>Under the hood, Ractive always binds to the <code>change</code> event (and the <code>click</code> event in IE, in the case of checkboxes, due to an IE bug). By default, it will also bind to the <code>input</code> event, which means the model is updated instantly when the user enters data (the <code>change</code> event fires when a change is <a href="https://developer.mozilla.org/en-US/docs/Web/Reference/events/change">'committed by the user'</a>). In some situations, that's not what you want - if you want to only bind to <code>change</code>, pass in <code>lazy: true</code> as an <a href="">initialisation option</a>.</p>
<p>As with <code>twoway</code>, laziness may be specified on a per-element basis. Besides <code>true</code> (or simply having the attribute preset) and <code>false</code> values, the <code>lazy</code> directive may also be a number that specifies the number of milliseconds to wait after the last <code>input</code> event fires with subsequent <code>input</code> events resetting the timeout. For instance <code>&lt;input value="{{foo}}" lazy&gt;</code> will trigger updates to <code>foo</code> on <code>change</code> and <code>&lt;input value="{{foo}}" lazy="1000"&gt;</code> will trigger updates 1 second after the last keypress.</p>
<h2 id="observing-changes">Observing changes</h2>
<p>To use user input elsewhere in your app, you'll need to observe it using <a href="../../api/instance-properties/#ractiveobserve"><code>ractive.observe()</code></a>:</p>
<pre><code class="html">&lt;input placeholder='Type your name' value='{{user.name}}'&gt;
</code></pre>

<pre><code class="js">ractive = new Ractive({
    el: myContainer,
    template: myTemplate
});

ractive.observe( 'user.name', function ( newValue ) {
    app.user.name = newValue;
    triggerSomeBehaviour();
});
</code></pre></div>
            
        </div>

        <div class="footer-nav">
            <a rel="prev" href="../security/">previous</a>
            <a rel="edit" href="https://github.com/ractivejs/ractivejs.github.io/edit/dev/docs/concepts/data-binding.md" target="_blank">edit this page
            <a rel="next" href="../events/">next</a>
        </div>

        <footer class="col-md-12 text-center">
            <hr>
            <p>
            <small>©RactiveJS contributors. Ractive.js is a free and open source project released under the MIT license.<br></small>
            
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>
        </footer>
    </div>

    <script src="../../js/jquery-1.10.2.min.js"></script>
    <script src="../../js/bootstrap-3.0.3.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
    var base_url = '../..';
    </script>
    <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
    <script src="../../js/base.js"></script>
    <script src="../../js/index.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    </body>

</html>
